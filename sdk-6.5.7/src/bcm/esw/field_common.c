/* $Id: field.c,v 1.1620 $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * Module: Field Processor APIs
 *
 * Purpose:
 *     API for Field Processor (FP) for XGS3 family and later.
 *
 *
 */
/**/
#include <shared/bsl.h>

#include <soc/drv.h>
#include <soc/scache.h>
#include <soc/cmic.h>
#include <soc/field.h>
#include <shared/pbmp.h>
#include <shared/et/bcmendian.h>
#include <bcm/field.h>
#include <bcm/error.h>
#include <bcm/mirror.h>
#include <bcm/link.h>
#include <bcm_int/esw/link.h>
#include <bcm/l3.h>
#include <bcm_int/esw/l3.h>
#ifdef BCM_TRIDENT2_SUPPORT
#include <bcm/nat.h>
#include <bcm_int/esw/nat.h>
#endif

#if defined(BCM_FIREBOLT_SUPPORT)
#include <bcm_int/esw/firebolt.h>
#endif

#if defined(BCM_RAPTOR_SUPPORT)
#include <bcm_int/esw/raptor.h>
#endif

#if defined(BCM_TRX_SUPPORT)
#include <bcm_int/esw/trx.h>
#endif

#if defined(BCM_TRIUMPH_SUPPORT)
#include <bcm_int/esw/triumph.h>
#endif

#if defined(BCM_HGPROXY_COE_SUPPORT)
#include <bcm_int/esw/xgs5.h>
#endif /* BCM_HGPROXY_COE_SUPPORT */

#include <bcm_int/esw/field.h>
#include <bcm_int/esw/range.h>
#include <bcm_int/esw/triumph2.h>
#include <bcm_int/esw/triumph3.h>
#include <bcm_int/esw/trident.h>
#include <bcm_int/esw/katana.h>
#include <bcm_int/esw/trident2.h>
#include <bcm_int/esw/tomahawk.h>
#include <bcm_int/common/multicast.h>

#if defined(BCM_ENDURO_SUPPORT)
#include <bcm_int/esw/enduro.h>
#endif

#if defined(BCM_HURRICANE_SUPPORT)
#include <bcm_int/esw/hurricane.h>
#endif

#if defined(BCM_HURRICANE2_SUPPORT)
#include <bcm_int/esw/hurricane2.h>
#endif

#if defined(BCM_KATANA2_SUPPORT)
#include <bcm_int/esw/katana2.h>
#endif /* BCM_KATANA2_SUPPORT */

#if defined(BCM_SABER2_SUPPORT)
#include <bcm_int/esw/saber2.h>
#endif /* BCM_SABER2_SUPPORT */

#include <bcm_int/esw/scorpion.h>
#include <bcm_int/esw/trunk.h>
#include <bcm_int/esw/mirror.h>
#include <bcm_int/esw/stack.h>
#include <bcm_int/esw/port.h>
#include <bcm_int/control.h>
#include <bcm_int/esw/virtual.h>
#include <bcm_int/esw_dispatch.h>
#include <bcm_int/esw/ecn.h>


#if defined(BCM_ESW_SUPPORT)
#include <bcm_int/esw/flex_ctr.h>
#include <bcm_int/esw/xgs4.h>
#endif

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
#include <bcm_int/esw/policer.h>
#endif
#ifdef BCM_GREYHOUND_SUPPORT
#include <bcm_int/esw/greyhound.h>
#endif /* BCM_GREYHOUND_SUPPORT */
#ifdef BCM_HURRICANE3_SUPPORT
#include <bcm_int/esw/hurricane3.h>
#include <bcm_int/esw/flowcnt.h>
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_GREYHOUND2_SUPPORT
#include <bcm_int/esw/greyhound2.h>
#endif /* BCM_GREYHOUND2_SUPPORT */
#if defined(INCLUDE_REGEX)
#include <bcm_int/esw/bregex.h>
#endif

#if defined(BCM_ESW_SUPPORT)
#ifdef BCM_FIELD_SUPPORT

#define SAL_ALLOC_T(t, n)  ((t *) sal_alloc((n) * sizeof(t), " ")) /* <HP/> */

#define BCM_POLICER_XGS_NOSUPPORT_FLAGS (BCM_POLICER_DROP_RED | \
                                         BCM_POLICER_MACRO    | \
                                         BCM_POLICER_EGRESS   | \
                                         BCM_POLICER_REPLACE_SHARED)

#define _FP_ENTRY_MOVE_DOWN 0x01
#define _FP_ENTRY_MOVE_UP 0x02

/* Static variables */
int prio_set_with_no_free_entries = FALSE;

int
_bcm_field_entry_copy_id(int unit,
                            bcm_field_entry_t src_entry,
                            bcm_field_entry_t dst_entry);

int
_field_tcam_policy_install(int unit, bcm_field_entry_t entry);

int
_field_entry_prio_set(int unit, bcm_field_entry_t entry, int prio);

int
_field_entry_create_id(int unit, bcm_field_group_t group,
                       bcm_field_entry_t entry);

STATIC int
_field_internal_backup_entry_delete(int unit, bcm_field_entry_t temp_entry);

STATIC
int _bcm_field_group_entry_port_update(int unit,
                                        _field_group_t *fg,
                                        bcm_pbmp_t new_pbmp);
extern soc_field_t udf_fields_f[][4];
uint8 wb_write_disable = 0;

#ifdef BCM_WARM_BOOT_SUPPORT
static const uint32 _field_sdk_warmboot_version[][2] = {
       {((6 << 16) | (4 << 8) | 7 ), BCM_FIELD_WB_VERSION_1_11},
       {((6 << 16) | (4 << 8) | 8 ), BCM_FIELD_WB_VERSION_1_14},
       {((6 << 16) | (4 << 8) | 9 ), BCM_FIELD_WB_VERSION_1_15},
       {((6 << 16) | (4 << 8) | 10 ), BCM_FIELD_WB_VERSION_1_16},
       {((6 << 16) | (4 << 8) | 11 ), BCM_FIELD_WB_VERSION_1_18},
       {((6 << 16) | (5 << 8) | 0 ), BCM_FIELD_WB_VERSION_1_11},
       {((6 << 16) | (5 << 8) | 1 ), BCM_FIELD_WB_VERSION_1_12},
       {((6 << 16) | (5 << 8) | 2 ), BCM_FIELD_WB_VERSION_1_15},
       {((6 << 16) | (5 << 8) | 3 ), BCM_FIELD_WB_VERSION_1_18},
       {((6 << 16) | (5 << 8) | 4 ), BCM_FIELD_WB_VERSION_1_19},
       {((6 << 16) | (5 << 8) | 5 ), BCM_FIELD_WB_VERSION_1_20},
       {((6 << 16) | (5 << 8) | 6 ), BCM_FIELD_WB_VERSION_1_21}
       };
#endif /* WARM_BOOT_SUPPORT*/

/*
 * Macro:
 *     FIELD_IS_INIT (internal)
 * Purpose:
 *     Check that the unit is valid and confirm that the field functions
 *     are initialized.
 * Parameters:
 *     unit - BCM device number
 * Notes:
 *     Results in return(BCM_E_UNIT), return(BCM_E_UNAVAIL), or
 *     return(BCM_E_INIT) if fails.
 */
#define FIELD_IS_INIT(unit)                                      \
    if (!soc_feature(unit, soc_feature_field)) {                 \
        return (BCM_E_UNAVAIL);                                  \
    }                                                            \
    if (_field_control[unit] == NULL) {                          \
        LOG_DEBUG(BSL_LS_BCM_FP, \
                  (BSL_META("FP(unit %d) Error: not initialized\n"), \
                   unit));   \
        return (BCM_E_INIT);                                     \
    }


/*
 * Function:
 *      _bcm_field_is_entry_stage_valid(unit, entry, stage) (internal)
 * Purpose:
 *      Checks whether the entry is in the stage provided
 * Parameters:
 *      unit        - (IN) BCM device number
 *      entry       - (IN) Entry identifier
 *      stage       - (IN) Pipeline stage id number
 * Return values:
 *      Returns BCM_E_XXX
 *      BCM_E_NONE - implies for the particular Entry, Stage is Valid
 */
int _bcm_field_is_entry_stage_valid(int unit, bcm_field_entry_t entry,
        _field_stage_id_t stage)
{
    _field_entry_t *f_ent = NULL;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       return ((_BCM_FIELD_STAGE_INGRESS == stage) ? BCM_E_NONE : BCM_E_PARAM);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                        _FP_ENTRY_PRIMARY, &f_ent));

    /* All qualifiers applicable for ingress are applicable
     * for exact match stage also. Hence allow it for exact match
     * entries when stage is Ingress. */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        stage = (stage == _BCM_FIELD_STAGE_INGRESS) ? \
                          _BCM_FIELD_STAGE_EXACTMATCH : stage;
    }

    return ((f_ent->group->stage_id == stage) ? BCM_E_NONE : BCM_E_CONFIG);
}

/*
 * Local function prototypes
 */
char *_field_qual_name(bcm_field_qualify_t qid);
char *_field_group_mode_name(uint32 group_flags);
char* _field_stage_name(_field_stage_t *stage_fc);

STATIC int _field_entry_move(int unit, _field_entry_t *f_ent, int tcam_idx_new);

/*
 * Field control data, one per device.
 */
_field_control_t         *_field_control[BCM_MAX_NUM_UNITS];

/* Sw WorkAround for EgressPortsAdd Action */
uint8                        _field_egr_ports_recovery_lock[BCM_MAX_NUM_UNITS];
_field_egr_ports_recovery_t  *_field_egr_ports_recovery[BCM_MAX_NUM_UNITS];

#ifdef BCM_WARM_BOOT_SUPPORT

/* Warmboot recovery for bcmFieldActionDscpMapNew*/
_field_dscp_map_new_eid_list_t  *dscp_map_new_eid_list[BCM_MAX_NUM_UNITS];

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)

/* Extract a field from a raw HW entry */

void
_field_extract(uint32 *buf, int offset, int width, uint32 *value)
{
    int idx, wp, bp, len;
    wp = offset / 32;
    bp = offset & (32 - 1);
    idx = 0;

    for (len = width; len > 0; len -= 32) {
        if (bp) {
            value[idx] = (buf[wp++] >> bp) & ((1 << (32 - bp)) - 1);
            value[idx] |= buf[wp] << (32 - bp);
        } else {
            value[idx] = buf[wp];
        }

        if (len < 32) {
            value[idx] &= ((1 << len) - 1);
        }

        idx++;
    }

    return;
}

#endif

int
_field_state_cleanup(int unit, _field_control_t *fc)
{
    int rv;
    _field_group_t *fg;

    /* Destroy all entries in unit. */
    rv = bcm_esw_field_entry_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Destroy all statistics entities. */
    FP_LOCK(unit);
    rv = _field_stat_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
    FP_UNLOCK(unit);

    /* Destroy all policers. */
    rv = bcm_esw_policer_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Destroy all groups in unit. */
    fg = fc->groups;
    while (fg != NULL) {

        rv = bcm_esw_field_group_destroy(unit, fg->gid);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
        fg = fc->groups;
    }
    return rv;
}

void
_bcm_field_last_alloc_eid_incr(unit)
{
    _field_control_t *fc;
    int rv = 0;

    /* Get unit FP control structure. */

    FP_LOCK(unit);
    rv = (_field_control_get(unit, &fc));
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return;
    }
    fc->last_allocated_eid++;
    FP_UNLOCK(unit);

}
int
_bcm_field_last_alloc_eid_get(unit)
{
    _field_control_t *fc;
    uint32 last_alloc_eid = -1;
    int rv = 0;

    /* Get unit FP control structure. */

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }    
    last_alloc_eid = fc->last_allocated_eid;
    FP_UNLOCK(unit);

    return last_alloc_eid;
}

/*
 * Function:
 *      _field_scache_pointer_init_wb
 * Purpose:
 *      Initialize field component scache pointers for required partitions
 *      during warm boot
 * Parameters:
 *      unit - (IN) Unit number.
 *      fc - (IN) Pointer to field control
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */

int
_field_scache_pointer_init_wb(int unit, _field_control_t  *fc)
{
    int               rv;
    uint32            alloc_get;
    soc_scache_handle_t handle;
    int               incr_size = 0;

    SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD, 1);
    SOC_SCACHE_MODULE_MAX_PARTITIONS_SET(unit, BCM_MODULE_FIELD, 1);

    /* Get the pointer for the Level 2 cache for partition 1*/
     rv = soc_scache_ptr_get(unit, handle,
                             &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                    &alloc_get);
     if (SOC_WARM_BOOT(unit) && (SOC_E_NOT_FOUND == rv)) {
          SOC_IF_ERROR_RETURN
               (soc_scache_alloc(unit, handle,
                                 fc->scache_size[_FIELD_SCACHE_PART_1] +
                                 SOC_WB_SCACHE_CONTROL_SIZE));
          rv = soc_scache_ptr_get(unit, handle,
                                  &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                  &alloc_get);
     }

     if (BCM_FAILURE(rv)) {
          return rv;
     } else if (alloc_get != fc->scache_size[_FIELD_SCACHE_PART_1] +
                SOC_WB_SCACHE_CONTROL_SIZE) {
         /* Expected size doesn't match retrieved size */
         return BCM_E_INTERNAL;
     } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_1]) {
         return BCM_E_MEMORY;
     }

     /* scache size - partition 1 is increased for TRX devices only
      * from warmboot version 1_6 and devices like Raven
      * still follows globalscache allocation method
      */
     if (SOC_IS_TRX(unit)) {
         /* Get the pointer for the Level 2 cache for partition 0 */
         SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD, 0);


         if (SOC_WARM_BOOT(unit)) {
             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_6) {
                 /* Scache size is increased by 16*1024 bytes
                  * from version BCM_FIELD_WB_VERSION_1_6 for partition 0.
                  */
                 incr_size += (16 * 1024);
             }

             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_8) {
                 /* Scache size is increased by 128*1024 bytes
                  * from version BCM_FIELD_WB_VERSION_1_8 for partition 0.
                  * with respect to version BCM_FIELD_WB_VERSION_1_6.
                  */
                 incr_size += (128 * 1024);
             }

             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_15) {
                 /*
                  * Scache size is increased by 135 * 1024 bytes
                  * from version BCM_FIELD_WB_VERSION_1_15 for partition 0.
                  * with respect to version BCM_FIELD_WB_VERSION_1_8.
                  */
                 incr_size += (135 * 1024);
             }

             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_17) {
                 /*
                  * Scache size is increased by 144 * 1024 bytes
                  * from version BCM_FIELD_WB_VERSION_1_17 for sync and recovery of
                  * policer configured rates and bursts
                  * with respect to version BCM_FIELD_WB_VERSION_1_15.
                  */
                 incr_size += (144 * 1024);
             }

             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_18) {
                 /*
                  * Scache size is increased by (18 + 3) * 1024 bytes
                  * from version BCM_FIELD_WB_VERSION_1_18 for partition 0.
                  * To add sync for SVP DVP type per entry part and
                  * ingress, src entity selcode per group part
                  * with respect to version BCM_FIELD_WB_VERSION_1_17.
                  */
                 incr_size += (21 * 1024);
             }
             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_19) {
                 /*
                  * Scache size is increased by
                  * ((16 + 1 + 1) * 4) + (16) * 12 bytes
                  * from version BCM_FIELD_WB_VERSION_1_19 for partition 0.
                  * To add sync no parm actions sync enum 4 bytes for each entry
                  * And to add PortPrioIntCosQNew Actions(Rp/Yp/Gp) CosQ Gport values
                  * 12 bytes for each entry in IFP
                  * with respect to version BCM_FIELD_WB_VERSION_1_18.
                  */
                 incr_size += (264 * 1024);
             }

             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_20) {
                 /* Allocate additional scache to sync IFP action ingress
                  * and egress mirror gport value in no parm actions sync
                  * enums per entry. IngressMirror and EgressMirror GPORT
                  * can be assigned to single entry. Have to allocate (4+4)
                  * bytes per entry.
                  * IFP = (8 bytes * 512 entries * 12 slices).
                  */
                 incr_size += (48 * 1024);
                 /*
                  * Scache size is increased by (16 * 1024) * 4 bytes
                  * (16K entries * 4 bytes) for all devices and
                  * (8 * 1024) * 4 * 2 (8K entries * 4 bytes * 2 params
                  * for KT2 devices to sync and recover the params of
                  * fabricQueue action for all entries of Ingress.
                  */
                 incr_size += (16 * 1024 * 4);
             }
             if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_21) {
                 /*
                  * Group PBMP is synced with max_groups * size of the pbmp array
                  * Sync MirrorIngress and MirrorEgress action parameters per entry
                  * Worst case 16K * 12 bytes
                  */
                  incr_size += ((512 * _SHR_PBMP_WORD_MAX * 4) + (16 * 1024 * 12));
             }
         }

         if (incr_size > 0) {
             SOC_IF_ERROR_RETURN
                 (soc_scache_realloc(unit, handle,
                                     (incr_size)));
             rv = soc_scache_ptr_get(unit, handle,
                     &(fc->scache_ptr[_FIELD_SCACHE_PART_0]),
                     &alloc_get);

             if (BCM_FAILURE(rv)) {
                 return rv;
             } else if (alloc_get != (fc->scache_size[_FIELD_SCACHE_PART_0] +
                         SOC_WB_SCACHE_CONTROL_SIZE)) {
                 /* Expected size doesn't match retrieved size */
                 return BCM_E_INTERNAL;
             } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_0]) {
                 return BCM_E_MEMORY;
             }
         }
     }
     return BCM_E_NONE;
}
/* Update the scache based on the latest field state */
int
_bcm_esw_field_scache_sync(int unit)
{
    int rv = BCM_E_NONE;
    _field_control_t *fc;
    _field_stage_t *stage_fc;
    int (* f)(int, _field_control_t *, _field_stage_t *);
    uint16 version;
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        f = _bcm_field_th_scache_sync;
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        f = _bcm_field_td2_scache_sync;
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRIUMPH(unit)
             || SOC_IS_VALKYRIE(unit)
             || SOC_IS_TRIUMPH2(unit)
             || SOC_IS_APOLLO(unit)
             || SOC_IS_VALKYRIE2(unit)
             || SOC_IS_SC_CQ(unit)
             || SOC_IS_TD_TT(unit)
             || SOC_IS_KATANAX(unit)
             || SOC_IS_HURRICANE3(unit)
             || SOC_IS_GREYHOUND2(unit)
             ) {
        f = _field_tr2_scache_sync;
    } else
#endif /* BCM_TRX_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        f = _bcm_field_tr3_scache_sync;
    } else
#endif
    {
        f = _field_scache_sync;
    }

    if (SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)) {
        return BCM_E_NONE;
    }

    /* Get unit FP control structure. */


    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Initialize scache_pos */
    fc->scache_pos = 0;
    fc->scache_pos1 = 0;

    /* Write the version number */
    version = (fc->wb_current_version);
    sal_memcpy(fc->scache_ptr[_FIELD_SCACHE_PART_0], &version, sizeof(uint16));
    fc->scache_pos += SOC_WB_SCACHE_CONTROL_SIZE;

    /* Write the version number */
    if(NULL != fc->scache_ptr[_FIELD_SCACHE_PART_1]) {
        version = (fc->wb_current_version);
        sal_memcpy(fc->scache_ptr[_FIELD_SCACHE_PART_1], &version, sizeof(uint16));
        fc->scache_pos1 += SOC_WB_SCACHE_CONTROL_SIZE;
    }


    if (SOC_IS_FIREBOLT(unit) || SOC_IS_FIREBOLT2(unit) ||
        SOC_IS_BRADLEY(unit) || SOC_IS_HUMV(unit) ||
        SOC_IS_RAVEN(unit) || SOC_IS_ENDURO(unit) ||
        SOC_IS_HAWKEYE(unit) || SOC_IS_APOLLO(unit) ||
        SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit) ||
        SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) ||
        SOC_IS_SC_CQ(unit) || SOC_IS_TD_TT(unit) ||
        SOC_IS_KATANAX(unit) || SOC_IS_HURRICANEX(unit) ||
        SOC_IS_TRIUMPH3(unit) || SOC_IS_GREYHOUND(unit) ||
        SOC_IS_GREYHOUND2(unit)) {

            rv = _field_stage_control_get
                (unit,
                 _BCM_FIELD_STAGE_INGRESS,
                 &stage_fc
                );

            if (BCM_SUCCESS(rv))
            {
                rv = (*f)(unit, fc, stage_fc);
            }
    }

#if  defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (BCM_SUCCESS(rv) &&
        (SOC_IS_FIREBOLT2(unit) || SOC_IS_ENDURO(unit) ||
         SOC_IS_APOLLO(unit) ||
         SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit) ||
         SOC_IS_TRIUMPH2(unit) || SOC_IS_VALKYRIE2(unit) ||
         SOC_IS_SC_CQ(unit) || SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)
         || SOC_IS_TRIUMPH3(unit)
         || SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit)
         || SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) &&
         (soc_feature(unit, soc_feature_field_multi_stage))) {
        rv = _field_stage_control_get
                (unit,
                 _BCM_FIELD_STAGE_EGRESS,
                 &stage_fc
                );

        if (BCM_SUCCESS(rv)) {
            rv = (*f)(unit, fc, stage_fc);

            if (BCM_SUCCESS(rv)) {
                rv = _field_stage_control_get
                        (unit,
                         _BCM_FIELD_STAGE_LOOKUP,
                         &stage_fc
                        );

                if (BCM_SUCCESS(rv)) {
                    rv = (*f)(unit, fc, stage_fc);

                    if (BCM_SUCCESS(rv) &&
                        soc_feature(unit, soc_feature_esm_support)) {
                        rv = _field_stage_control_get
                                (unit,
                                 _BCM_FIELD_STAGE_EXTERNAL,
                                 &stage_fc
                                );

                        if (BCM_SUCCESS(rv)) {
                            rv = (*f)(unit, fc, stage_fc);
                        }
                    }
                }
            }
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRIUMPH_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if (soc_feature(unit, soc_feature_field_compression)) {
            rv = _field_stage_control_get(unit,
                                          _BCM_FIELD_STAGE_CLASS,
                                          &stage_fc);
            if (BCM_SUCCESS(rv)) {
                rv = (*f)(unit, fc, stage_fc);
            }
            BCM_IF_ERROR_RETURN(rv);
        }

        if (soc_feature(unit, soc_feature_field_exact_match_support)) {

            rv = _field_stage_control_get(unit,
                                          _BCM_FIELD_STAGE_EXACTMATCH,
                                          &stage_fc);
            if (BCM_SUCCESS(rv)) {
                rv = (*f)(unit, fc, stage_fc);
            }
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    FP_UNLOCK(unit);
    return rv;
}

STATIC int
_field_group_entry_write(int unit, int slice_idx, _field_slice_t *fs,
                         _field_control_t *fc, _field_stage_t *stage_fc)
{
    int qset_count, ratio, idx, prev_prio, multigroup, master_slice;
    uint8 group_auto_expansion = 0, next_group_valid = 0;
    uint8 stat_present, pol_present, prio_ctrl;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    _field_group_t *fg;
    _field_entry_t *f_ent;
    bcm_port_t port;
    bcm_field_qualify_t q;
    bcm_pbmp_t port_cmic_pbmp;
    _field_slice_t *temp_fs = fs;
    uint8 *count = NULL;
    _field_stage_t *ingress_stage_fc = NULL;
    uint8 max_udf_count = 0;
    uint8 udf_idx;
    uint8 color_independent;
    uint8 group_flags = 0;
    int part_idx;
    int parts_cnt;


    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                _BCM_FIELD_STAGE_INGRESS, &ingress_stage_fc));

    if (ingress_stage_fc->data_ctrl) {
        max_udf_count = ingress_stage_fc->data_ctrl->num_elems * 2;
    }

    SOC_PBMP_ASSIGN(port_cmic_pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_OR(port_cmic_pbmp, PBMP_CMIC(unit));

    /* Check for multiple groups in a slice */
    if (SOC_PBMP_EQ(fs->pbmp, port_cmic_pbmp)) {
        multigroup = 0;
    } else {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync:   Multigroup.\n")));
        multigroup = 1;
    }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_scache_sync:   Writing slice %d @ byte %d...\n"),
               slice_idx, fc->scache_pos));

    buf[fc->scache_pos] = (slice_idx << 1) | multigroup;
    fc->scache_pos++;

    /* Get the master slice if expanded */
    master_slice = slice_idx;
    while (temp_fs->prev != NULL) {
        temp_fs = temp_fs->prev;
        master_slice = temp_fs->slice_number;
    }

    /* Traverse all groups and dump group data for this slice */
    fg = fc->groups;
    while (fg != NULL) {
        if (fg->stage_id != stage_fc->stage_id) {
            fg = fg->next;
            continue; /* Not in this stage */
        }
        if (fg->slices[0].slice_number != master_slice) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "_field_scache_sync:   No match on group %d.\n"),
                       fg->gid));
            fg = fg->next;
            continue; /* Not in this slice */
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync:   Match on group %d...\n"),
                   fg->gid));

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync:   Writing group %d @ byte %d...\n"),
                   fg->gid, fc->scache_pos));

        SOC_PBMP_ITER(fg->pbmp, port) {
            break; /* Pick first port found as representative */
        }


        if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
            /* Long-id format selected => Save full GID */

            buf[fc->scache_pos] = fg->gid;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 8;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 16;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 24;
            fc->scache_pos++;

            buf[fc->scache_pos] = port;
            fc->scache_pos++;
        } else {
            /* Save compact GID */

            buf[fc->scache_pos] = (fg->gid) & 0xFF; /* GID_lo */
            fc->scache_pos++;
            buf[fc->scache_pos] = ((fg->gid & 0xF00) << 4) | (port & 0xF);
            fc->scache_pos++; /* GID_hi | port_lo */
            buf[fc->scache_pos] = (port >> 4); /* port_hi */
            fc->scache_pos++;
        }

        if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) {
            int i = 0;
            for (i = 0; i < _SHR_PBMP_WORD_MAX; i++) {
                buf[fc->scache_pos] = fg->pbmp.pbits[i];
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 24;
                fc->scache_pos++;
            }
        }

        buf[fc->scache_pos] = fg->priority;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 24;
        fc->scache_pos++;

        /* Write group action res id */
        buf[fc->scache_pos] = fg->action_res_id;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 24;
        fc->scache_pos++;

        /* Obtain list of qualifiers in fg->qset */
        qset_count = 0;
        _FIELD_QSET_ITER(fg->qset, q) {
            qset_count++;
        }

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync:   Writing qset count (%d) @ byte %d...\n"),
                   qset_count, fc->scache_pos));

        buf[fc->scache_pos] = qset_count; /* qset_count */
        fc->scache_pos++;
        _FIELD_QSET_ITER(fg->qset, q) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "_field_scache_sync:     Writing qid %d @ byte %d...\n"),
                       q, fc->scache_pos));

            buf[fc->scache_pos] = q; /* QID */
            fc->scache_pos++;
            if(NULL != buf1) {
                buf1[fc->scache_pos1] = q >> 8;
                fc->scache_pos1++;
            }
        }

        count = &buf[fc->scache_pos];
        fc->scache_pos++;
        *count = 0;

        for (q = bcmFieldQualifyCount; q < ((int)_bcmFieldQualifyCount); q++) {
            if (BCM_FIELD_QSET_TEST(fg->qset, q)) {
                buf[fc->scache_pos] = q - bcmFieldQualifyCount;
                fc->scache_pos++;
                if(NULL != buf1) {
                    buf1[fc->scache_pos1] = (q - bcmFieldQualifyCount) >> 8;
                    fc->scache_pos1++;
                }
                *count = *count + 1;
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "_field_scache_sync:     Writing qid idx %d @ byte %d...\n"),
                            q, fc->scache_pos - 1));
            }
        }
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "_field_scache_sync:   Writing internal qset count (%d) @ byte %d...\n"),
                    *count, fc->scache_pos - 1 - *count));

        count = &buf[fc->scache_pos];
        fc->scache_pos++;
        *count = 0;

        for (udf_idx = 0; udf_idx < max_udf_count ; udf_idx++) {
            if (SHR_BITGET(fg->qset.udf_map, udf_idx)) {
                buf[fc->scache_pos] = udf_idx;
                fc->scache_pos++;
                *count = *count + 1;
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "_field_scache_sync:     Writing UDF idx %d @ byte %d...\n"),
                            udf_idx, fc->scache_pos - 1));
            }
        }
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "_field_scache_sync:   Writing udf count (%d) @ byte %d...\n"),
                    *count, fc->scache_pos - 1 - *count));


        if (fg->flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
            group_auto_expansion = _FIELD_GROUP_AUTO_EXPANSION;
        } else {
            group_auto_expansion = 0;
        }

        group_flags = 0;

        if (fg->flags & _FP_GROUP_LOOKUP_ENABLED) {
            group_flags |= _FIELD_GROUP_LOOKUP_ENABLED;
        }

        if (fg->flags & _FP_GROUP_WLAN) {
            group_flags |= _FIELD_GROUP_WLAN;
        }

        /* Next group not valid */
        next_group_valid = 0x0;
        fg = fg->next;
        while (fg != NULL) {
            if (multigroup
                    && (fg->stage_id == stage_fc->stage_id)
                    && (fg->slices[0].slice_number == slice_idx)) {
                /* Next group valid */
                next_group_valid = _FIELD_GROUP_NEXT_GROUP_VALID;
                break;
            }
            fg = fg->next;
        }

        /*
         * In this byte, 6 bits are used as below
         * bit 0 --  to indicate wheather next group
         *           in this slice is valid or not
         * bit 1,2 -- contains group's instance.
         * bit 5 --  to indicate group lookup enable status.
         * bit 6 --  to indicate group is WLAN.
         * bit 7 --  to indicate group auto expansion status.
         */

        buf[fc->scache_pos] = (group_auto_expansion | next_group_valid | group_flags);

        fc->scache_pos++;
    }
        /* Traverse all entries and dump entry data for this slice */
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            ratio = 2;
        } else {
            ratio = 1;
        }
        prev_prio = -1;
        for (idx = 0; idx < fs->entry_count / ratio; idx++) {
            /* Find EID that matches this HW index */
            f_ent = fs->entries[idx];
            if (f_ent == NULL) {
                continue;
            }
            if (f_ent->flags & _FP_ENTRY_INSTALLED) {
                prio_ctrl = (f_ent->prio != prev_prio) ? 1 : 0;
                stat_present = (f_ent->statistic.flags &
                                _FP_ENTRY_STAT_INSTALLED) ? 1 : 0;
                pol_present = (f_ent->policer[0].flags &
                               _FP_POLICER_INSTALLED) ? 1 : 0;
                if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                    /* Long-id format select => Save complete EID */

                    buf[fc->scache_pos] = f_ent->eid;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->eid >> 8;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->eid >> 16;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->eid >> 24;
                    fc->scache_pos++;

                    buf[fc->scache_pos] = prio_ctrl
                        | (stat_present << 1)
                        | (pol_present << 2);
                    fc->scache_pos++;
                } else {
                    /* Save compact EID */

                    buf[fc->scache_pos] = f_ent->eid & 0xFF; /* EID_lo */
                    fc->scache_pos++;
                    buf[fc->scache_pos] = ((f_ent->eid >> 8) & 0xF) | (prio_ctrl << 4) |
                        (stat_present << 5) | (pol_present << 6);
                    /* EID_hi + control bits */
                    fc->scache_pos++;
                }
                if (multigroup) {
                    /* Multiple groups in slice => Save id of group to which
                       entry belongs
                    */

                    if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                        /* Save long GID */

                        buf[fc->scache_pos] = f_ent->group->gid;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->group->gid >> 8;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->group->gid >> 16;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->group->gid >> 24;
                        fc->scache_pos++;
                    } else {
                        /* Save compact GID */

                        buf[fc->scache_pos] = f_ent->group->gid & 0xFF; /* GID_lo */
                        fc->scache_pos++;
                        buf[fc->scache_pos] = (f_ent->group->gid >> 8) & 0xF;
                        /* GID_hi */
                        fc->scache_pos++;
                    }
                }
                if (prio_ctrl) {
                    /* 32-bit priority is written */
                    buf[fc->scache_pos] = f_ent->prio & 0xFF;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = (f_ent->prio >> 8) & 0xFF;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = (f_ent->prio >> 16) & 0xFF;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = (f_ent->prio >> 24) & 0xFF;
                    fc->scache_pos++;
                    prev_prio = f_ent->prio;
                }
                /* Write policer and stat object IDs if present */
                if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                    /* Save long IDs */

                    if (pol_present) {
                        buf[fc->scache_pos] = f_ent->policer[0].pid;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->policer[0].pid >> 8;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->policer[0].pid >> 16;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->policer[0].pid >> 24;
                        fc->scache_pos++;
                    }

                    if (stat_present) {
                        buf[fc->scache_pos] = f_ent->statistic.sid;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->statistic.sid >> 8;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->statistic.sid >> 16;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = f_ent->statistic.sid >> 24;
                        fc->scache_pos++;
                    }
                } else {
                    /* Save compact IDs */
                    if (pol_present) {
                        buf[fc->scache_pos] = (f_ent->policer[0].pid) & 0xFF;
                        fc->scache_pos++;
                    }
                    if (stat_present) {
                        if (pol_present) {
                            buf[fc->scache_pos] =
                                ((f_ent->policer[0].pid >> 8 & 0xF) << 4) |
                                (f_ent->statistic.sid & 0xF);
                            fc->scache_pos++;
                        } else {
                            buf[fc->scache_pos] = f_ent->statistic.sid & 0xF;
                            fc->scache_pos++;
                        }
                        buf[fc->scache_pos] = (f_ent->statistic.sid >> 4) & 0xFF;
                        fc->scache_pos++;
                    } else if (pol_present) {
                        buf[fc->scache_pos] =
                            (f_ent->policer[0].pid >> 8 & 0xF) << 4;
                        fc->scache_pos++;
                    }
                }

                parts_cnt = 0;
                if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) ||
                        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
                    /* Sync entry part count for SVP & DVP type */
                    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                                f_ent->group->stage_id, f_ent->group->flags,
                                &parts_cnt));

                    buf[fc->scache_pos] = parts_cnt;
                    fc->scache_pos++;
                }

                /* Save Dvp Type */
                buf[fc->scache_pos] = f_ent->dvp_type;
                fc->scache_pos++;
                for (part_idx = 1; part_idx < parts_cnt; part_idx++) {
                    buf[fc->scache_pos] = f_ent[part_idx].dvp_type;
                    fc->scache_pos++;
                }

                /* Save Svp Type */
                buf[fc->scache_pos] = f_ent->svp_type;
                fc->scache_pos++;
                for (part_idx = 1; part_idx < parts_cnt; part_idx++) {
                    buf[fc->scache_pos] = f_ent[part_idx].svp_type;
                    fc->scache_pos++;
                }

                /* Save Entry Color independent flag */
                color_independent = (f_ent->flags &
                        _FP_ENTRY_COLOR_INDEPENDENT) ? 1 : 0;
                buf[fc->scache_pos] = color_independent << 7;
                fc->scache_pos++;

                BCM_IF_ERROR_RETURN(_field_entry_no_param_actions_scache_sync(
                                    unit, stage_fc, fc, f_ent, buf));
            }
        }
    return BCM_E_NONE;
}

/*
 * This function manages the Level 2 warm boot cache. The data will be stored
 * in the following format:
 * Start indicator (32 bits): Value = IFP/EFP/VFP
 *
 * Range check IDs (IFP)
 * 8-bit ID count (1 uint8)
 * ID0 (4 x uint8)
 * .
 * IDN (4 x uint8)
 *
 * Data qualifier data, as follows:
 * 8-bit data qualifier count (1 uint 8)
 * 32-bit data qualifier id (1 int)
 * 2-bit "length remainder" | 3-bit flags | 3-bit offset base (1 uint 8)
 * 16-bit data qualifier match-data offset (1 uint 16)
 * 16-bit hw_bmap field of data qualifier
 *   (Note that this field is linked to the hardware; namely, the width of this
 *   bitmap is the number of UDF n-byte chunks supported, i.e. the number of
 *   "columns" in the UDF_OFFSET table.)
 *
 * Group/entry data
 * Slice num (5 bits) | Multigroup slice indicator (1 bit): (1 uint8)
 * GID_lo (8 bits): (1 uint 8)
 * GID_hi (4 bits) | Representative_port_lo (4 bits): (1 uint 8)
 * Representative_port_hi (2 bits) | Reserved (6 bits): (1 uint 8)
 * Group priority (32 bits): (4 uint 8)
 * Qualifier count (8 bits): (1 uint 8)
 * QID 1 (8 bits): (1 uint 8)
 * .
 * QID N (8 bits): (1 uint 8)
 * Next_group_valid (1 bit) | Reserved (7 bits): (1 uint 8)
 *
 * Groups are immediately followed by entries, which can have one of the
 * following two formats depending on the multigroup slice indicator:
 * Long format:
 * 8 bit EID_lo: (1 uint 8)
 * 4 bit EID_hi | priority_ctrl (1 bit) | Policer (1 bit) | Stat (1 bit):
  (1 uint 8)
 * 8 bit GID_lo: (1 uint 8)
 * 4 bit GID_hi | 4 reserved bits: (1 uint 8)
 * priority_0: (1 uint 8)
 * priority_1: (1 uint 8) <---- The 32-bit priority is stored only if it is
 * priority_2: (1 uint 8)       different from the entry before it.
 * priority_3: (1 uint 8)
 * PID_lo (8 bits): (1 uint8)
 * PID_hi (4 bits) | SID_lo (4 bits): (1 uint8)
 * SID_hi (4 bits): (1 uint 8)
 * DVP_Type (4bits): (1 uint4)
 * SVP_Type (4 bits): (1 uint4)
 * Reserved (8 bits): (1 uint8) future purpose
 *
 * Short format:
 * 8 bit EID_lo: (1 uint 8)
 * 4 bit EID_hi | priority_ctrl (1 bit) | Policer (1 bit) | Stat (1 bit):
  (1 uint 8)
 * priority_0: (1 uint 8)
 * priority_1: (1 uint 8) <---- The 32-bit priority is stored only if it is
 * priority_2: (1 uint 8)       different from the entry before it.
 * priority_3: (1 uint 8)
 * PID_lo (8 bits): (1 uint8)
 * PID_hi (4 bits) | SID_lo (4 bits): (1 uint8)
 * SID_hi (8 bits): (1 uint 8)
 * DVP_Type (4bits): (1 uint4)
 * SVP_Type (4 bits): (1 uint4)
 * Reserved (8 bits): (1 uint8) future purpose
 *
 * End indicator (32 bits): Value = IFP/EFP/VFP
 */

void
_field_scache_stage_hdr_save(_field_control_t *fc,
                             uint32           header
                             )
{
    uint8  *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8  *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];

    /* Mark the beginning of the particular FP section */
    buf[fc->scache_pos] = header;
    fc->scache_pos++;
    buf[fc->scache_pos] = header >> 8;
    fc->scache_pos++;
    buf[fc->scache_pos] = header >> 16;
    fc->scache_pos++;
    buf[fc->scache_pos] = header >> 24;
    fc->scache_pos++;

    /* Save long-id setting */

    buf[fc->scache_pos] = fc->flags;
    fc->scache_pos++;

    if(NULL != buf1) {
        /* Mark the beginning of the particular FP section */
        buf1[fc->scache_pos1] = header;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = header >> 8;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = header >> 16;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = header >> 24;
        fc->scache_pos1++;
    }
}

int
_field_scache_stage_hdr_chk(_field_control_t *fc,
                            uint32           header
                            )
{
    uint8  *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8  *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    uint32 temp;

    /* Check header */

    temp = buf[fc->scache_pos];
    fc->scache_pos++;
    temp |= buf[fc->scache_pos] << 8;
    fc->scache_pos++;
    temp |= buf[fc->scache_pos] << 16;
    fc->scache_pos++;
    temp |= buf[fc->scache_pos] << 24;
    fc->scache_pos++;
    if (temp != header) {
        fc->l2warm = 0;

        return (BCM_E_INTERNAL);
    }

    if(NULL != buf1) {
        temp = buf1[fc->scache_pos1];
        fc->scache_pos1++;
        temp |= buf1[fc->scache_pos1] << 8;
        fc->scache_pos1++;
        temp |= buf1[fc->scache_pos1] << 16;
        fc->scache_pos1++;
        temp |= buf1[fc->scache_pos1] << 24;
        fc->scache_pos1++;
        if (temp != header) {
            fc->l2warm = 0;
            return (BCM_E_INTERNAL);
        }
    }

    if ((fc->wb_recovered_version) == BCM_FIELD_WB_VERSION_1_0) {
        /* Old scache version, always uses compact ids */

        fc->flags &= ~_FP_STABLE_SAVE_LONG_IDS;
    } else {
        /* Retrieve long-id setting */

        if (buf[fc->scache_pos] & _FP_STABLE_SAVE_LONG_IDS) {
            fc->flags |= _FP_STABLE_SAVE_LONG_IDS;
        } else {
            fc->flags &= ~_FP_STABLE_SAVE_LONG_IDS;
        }

        /* Retrieve Intra-slice device setting */
        if (buf[fc->scache_pos] & _FP_INTRASLICE_ENABLE) {
            fc->flags |= _FP_INTRASLICE_ENABLE;
        } else {
            fc->flags &= ~_FP_INTRASLICE_ENABLE;
        }

        /* Retrieve color independent device setting */
        if (buf[fc->scache_pos] & _FP_COLOR_INDEPENDENT) {
            fc->flags |= _FP_COLOR_INDEPENDENT;
        } else {
            fc->flags &= ~_FP_COLOR_INDEPENDENT;
        }

        /* Retrieve Stat sync device setting */
        if (buf[fc->scache_pos] & _FP_STAT_SYNC_ENABLE) {
            fc->flags |= _FP_STAT_SYNC_ENABLE;
        } else {
            fc->flags &= ~_FP_STAT_SYNC_ENABLE;
        }

        /* Retrieve Group Sharing sync device setting */
        if (buf[fc->scache_pos] & _FP_POLICER_GROUP_SHARE_ENABLE) {
            fc->flags |= _FP_POLICER_GROUP_SHARE_ENABLE;
        } else {
            fc->flags &= ~_FP_POLICER_GROUP_SHARE_ENABLE;
        }

        fc->scache_pos++;
    }

    return (BCM_E_NONE);
}

void
_field_scache_sync_data_quals_write(_field_control_t      *fc,
                                    _field_data_control_t *data_ctrl
                                    )
{
    uint8                   *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    unsigned                cnt;
    _field_data_qualifier_t *f_dq;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META("FP vverb: _field_scache_sync_data_quals_write...\n")));
    /* Write data qual count */

    for (cnt = 0, f_dq = data_ctrl->data_qual; f_dq; f_dq = f_dq->next, ++cnt);

    buf[fc->scache_pos] = cnt;
    fc->scache_pos++;

    /* For each data qualifier, ... */
    for (f_dq = data_ctrl->data_qual; f_dq; f_dq = f_dq->next) {
        /* Write data qual id */

        buf[fc->scache_pos] = f_dq->qid;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->qid >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->qid >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->qid >> 24;
        fc->scache_pos++;

        /* Write data qual "length remainder", flags and offset base */
        buf[fc->scache_pos] = f_dq->elem_count * data_ctrl->elem_size
                                - f_dq->length
                                - f_dq->byte_offset;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->offset_base;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->flags;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->flags >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->flags >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->flags >> 24;
        fc->scache_pos++;

        /* Write data qual match-data offset */
        buf[fc->scache_pos] = f_dq->offset;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->offset >> 8;
        fc->scache_pos++;

        /* Write data qual offset-table occupancy */
        buf[fc->scache_pos] = f_dq->hw_bmap;
        fc->scache_pos++;
        buf[fc->scache_pos] = f_dq->hw_bmap >> 8;
        fc->scache_pos++;
    }
}


int
_field_scache_sync(int unit, _field_control_t *fc,
                   _field_stage_t *stage_fc)
{
    int slice_idx, range_count = 0;
    int rv = BCM_E_NONE;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    _field_slice_t *fs;
    _field_group_t *fg;
    uint32 start_char, end_char;
    int slice_is_primary;
    int slice_mode;
    _field_range_t *fr;
    int ratio = 0;
    int idx;
    _field_entry_t *f_ent;


    switch (stage_fc->stage_id) {
    case _BCM_FIELD_STAGE_INGRESS:
        start_char = _FIELD_IFP_DATA_START;
        end_char = _FIELD_IFP_DATA_END;
        break;
    case _BCM_FIELD_STAGE_EGRESS:
        start_char = _FIELD_EFP_DATA_START;
        end_char = _FIELD_EFP_DATA_END;
        break;
    case _BCM_FIELD_STAGE_LOOKUP:
        start_char = _FIELD_VFP_DATA_START;
        end_char = _FIELD_VFP_DATA_END;
        break;
    default:
        return BCM_E_PARAM;
        break;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_scache_sync: Synching scache for FP stage %d...\n"),
               stage_fc->stage_id));

    _field_scache_stage_hdr_save(fc, start_char);

    /* Save the range check IDs */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        fr = stage_fc->ranges;
        while (fr) {
            fr = fr->next;
            range_count++;
        }
        buf[fc->scache_pos] = (uint8)range_count;
        fc->scache_pos++;
        if (range_count) {
            fr = stage_fc->ranges;
            while (fr) {
                buf[fc->scache_pos] = fr->rid & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 8) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 16) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 24) & 0xFF;
                fc->scache_pos++;
                fr = fr->next;
            }
        }
    }

    /* Save data qualifiers */

    if (stage_fc->data_ctrl != 0) {
        _field_scache_sync_data_quals_write(fc, stage_fc->data_ctrl);
    }

    _field_slice_map_write(unit, fc, stage_fc);

    /* First sync the master slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync: Checking slice %d...\n"),
                   slice_idx));

        /* Skip slices without groups */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        fg = fc->groups;
        while (fg != NULL) {
            if (fg->stage_id != stage_fc->stage_id) {
                fg = fg->next;
                continue; /* Not in this stage */
            }
            if (fg->slices[0].slice_number == slice_idx) {
                break;
            }
            fg = fg->next;
        }
        if (fg == NULL) {
            continue; /* No group found */
        }
        /* Also skip expanded slices */
        if (stage_fc->slices[_FP_DEF_INST][slice_idx].prev != NULL) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_ENDURO_SUPPORT) || defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_FIREBOLT2(unit) || SOC_IS_ENDURO(unit) ||
            SOC_IS_KATANAX(unit) || SOC_IS_HURRICANEX(unit) ||
            SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
            soc_field_t fld;
            int efp_slice_mode, paired = 0;
            uint32 val;
            fp_port_field_sel_entry_t pfs;
            soc_field_t _fb2_slice_pairing_field[8] = {
                                  SLICE1_0_PAIRINGf,   SLICE3_2_PAIRINGf,
                                  SLICE5_4_PAIRINGf,   SLICE7_6_PAIRINGf,
                                  SLICE9_8_PAIRINGf,   SLICE11_10_PAIRINGf,
                                  SLICE13_12_PAIRINGf, SLICE15_14_PAIRINGf};
            soc_field_t _efp_slice_mode[] = {SLICE_0_MODEf, SLICE_1_MODEf,
                                             SLICE_2_MODEf, SLICE_3_MODEf};
            soc_field_t _vfp_slice_pairing_field[2] = {SLICE1_0_PAIRINGf,
                                                       SLICE3_2_PAIRINGf};
            switch (stage_fc->stage_id) {
            case _BCM_FIELD_STAGE_INGRESS:
                BCM_IF_ERROR_RETURN(soc_mem_read(unit, FP_PORT_FIELD_SELm,
                                                 MEM_BLOCK_ANY, 0, &pfs));
                fld = _fb2_slice_pairing_field[slice_idx / 2];
                paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                            &pfs, fld);
                break;
            case _BCM_FIELD_STAGE_EGRESS:
                BCM_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &val));
                efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr,
                                                val,_efp_slice_mode[slice_idx]);
                if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE)) {
                    paired = 1;
                }
                break;
            case _BCM_FIELD_STAGE_LOOKUP:
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROLr(unit, &val));
                fld = _vfp_slice_pairing_field[slice_idx / 2];
                paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, val, fld);
                break;
            default:
                return BCM_E_PARAM;
                break;
            }
            if (paired && (slice_idx % 2)) {
                continue;
            }
        }
#endif /* BCM_FIREBOLT2_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
        if (SOC_IS_FIREBOLT(unit))
        {
            BCM_IF_ERROR_RETURN(_field_fb_slice_is_primary(unit, slice_idx,
                &slice_is_primary, &slice_mode));

            if (!slice_is_primary)
            {
                continue;
            }
        }
#endif /* BCM_FIREBOLT_SUPPORT */

#ifdef BCM_RAVEN_SUPPORT
        if (SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit))
        {
            BCM_IF_ERROR_RETURN(_field_fb_slice_is_primary(unit, slice_idx,
                &slice_is_primary, &slice_mode));

            if (!slice_is_primary)
            {
                continue;
            }
        }
#endif /* BCM_RAVEN_SUPPORT */
        BCM_IF_ERROR_RETURN
            (_field_group_entry_write(unit, slice_idx, fs, fc, stage_fc));
    }

    /* Now sync the expanded slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {

        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        /* Skip empty slices */
        if (fs->entry_count == fs->free_count) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "_field_scache_sync:   Slice is empty.\n")));
            continue;
        }
        /* Skip master slices */
        if (stage_fc->slices[_FP_DEF_INST][slice_idx].prev == NULL) {
            continue;
        }

        /* Ignore secondary slice in paired mode */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_ENDURO_SUPPORT) || defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_FIREBOLT2(unit) || SOC_IS_ENDURO(unit) ||
            SOC_IS_KATANAX(unit) || SOC_IS_HURRICANEX(unit) ||
            SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
            soc_field_t fld;
            int efp_slice_mode, paired = 0;
            uint32 val;
            fp_port_field_sel_entry_t pfs;
            soc_field_t _fb2_slice_pairing_field[8] = {
                                  SLICE1_0_PAIRINGf,   SLICE3_2_PAIRINGf,
                                  SLICE5_4_PAIRINGf,   SLICE7_6_PAIRINGf,
                                  SLICE9_8_PAIRINGf,   SLICE11_10_PAIRINGf,
                                  SLICE13_12_PAIRINGf, SLICE15_14_PAIRINGf};
            soc_field_t _efp_slice_mode[] = {SLICE_0_MODEf, SLICE_1_MODEf,
                                             SLICE_2_MODEf, SLICE_3_MODEf};
            soc_field_t _vfp_slice_pairing_field[2] = {SLICE1_0_PAIRINGf,
                                                       SLICE3_2_PAIRINGf};
            switch (stage_fc->stage_id) {
            case _BCM_FIELD_STAGE_INGRESS:
                BCM_IF_ERROR_RETURN(soc_mem_read(unit, FP_PORT_FIELD_SELm,
                                                 MEM_BLOCK_ANY, 0, &pfs));
                fld = _fb2_slice_pairing_field[slice_idx / 2];
                paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                            &pfs, fld);
                break;
            case _BCM_FIELD_STAGE_EGRESS:
                BCM_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &val));
                efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr,
                                                val,_efp_slice_mode[slice_idx]);
                if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE)) {
                    paired = 1;
                }
                break;
            case _BCM_FIELD_STAGE_LOOKUP:
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROLr(unit, &val));
                fld = _vfp_slice_pairing_field[slice_idx / 2];
                paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, val, fld);
                break;
            default:
                return BCM_E_PARAM;
                break;
            }
            if (paired && (slice_idx % 2)) {
                continue;
            }
        }
#endif /* BCM_FIREBOLT2_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
        if (SOC_IS_FIREBOLT(unit))
        {
            BCM_IF_ERROR_RETURN(_field_fb_slice_is_primary(unit, slice_idx,
                &slice_is_primary, &slice_mode));

            if (!slice_is_primary)
            {
                continue;
            }
        }
#endif /* BCM_FIREBOLT_SUPPORT */

#ifdef BCM_RAVEN_SUPPORT
        if (SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit))
        {
            BCM_IF_ERROR_RETURN(_field_fb_slice_is_primary(unit, slice_idx,
                &slice_is_primary, &slice_mode));

            if (!slice_is_primary)
            {
                continue;
            }
        }
#endif /* BCM_RAVEN_SUPPORT */

        /*
         * Skip expanded slices with no entries installed in Hw
         * to match recovery logic.
         */
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            ratio = 2;
        } else {
            ratio = 1;
        }

        for (idx = 0; idx < fs->entry_count / ratio; idx++) {
            /* Find EID that matches this HW index */
            f_ent = fs->entries[idx];
            if (f_ent == NULL) {
                continue;
            }
            if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
                continue;
            }
            break;
        }

        if (idx == (fs->entry_count / ratio)) {
            continue;
        }

        BCM_IF_ERROR_RETURN
            (_field_group_entry_write(unit, slice_idx, fs, fc, stage_fc));
    }

    /* Mark end of Slice Info */
    buf[fc->scache_pos] = _FP_WB_END_OF_SLICES;
    fc->scache_pos++;

    /* Group Slice Selectors */
    BCM_IF_ERROR_RETURN(_field_group_slice_selectors_sync(unit,
                        &buf[fc->scache_pos], stage_fc->stage_id));

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_scache_sync: Writing end of section @ byte %d.\n"),
               fc->scache_pos));

    /* Mark the end of the IFP section */
    buf[fc->scache_pos] = end_char & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 8) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 16) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 24) & 0xFF;
    fc->scache_pos++;
    fc->scache_usage = fc->scache_pos; /* Usage in bytes */


    if(NULL != buf1) {
        /* Mark the end of the IFP section */
        buf1[fc->scache_pos1] = end_char & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 8) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 16) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 24) & 0xFF;
        fc->scache_pos1++;
    }

    /* Check for overflow */
    if (fc->scache_pos > fc->scache_size[_FIELD_SCACHE_PART_0]) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: Current Scache Position[%u] exceeds Scache size[%u]\n"),
                 unit, fc->scache_pos, fc->scache_size[_FIELD_SCACHE_PART_0]));
        return BCM_E_INTERNAL;
    }

    if (buf1 != NULL) {
        if (fc->scache_pos1 > fc->scache_size[_FIELD_SCACHE_PART_1]) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Current Scache Position1[%u] exceeds Scache size[%u]\n"),
                     unit, fc->scache_pos1, fc->scache_size[_FIELD_SCACHE_PART_1]));
            return BCM_E_INTERNAL;
        }
    }

    return rv;
}

/* Recover FP data qualifiers */

int
_field_data_qual_recover(int              unit,
                         _field_control_t *fc,
                         _field_stage_t   *stage_fc
                         )
{
    _field_data_control_t          *data_ctrl;
    uint8                          *buf;
    unsigned                       dqcnt, n, i, len_rem;
    _field_data_qualifier_t        *f_dq = NULL;

    if ((data_ctrl = stage_fc->data_ctrl) == 0) {
        return (BCM_E_NONE);
    }

    if (fc->l2warm == 0) {
        /* No data qualifier recovery in Level 1 */
        return BCM_E_NONE;
    }

    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)

    if (soc_mem_is_valid(unit, FP_UDF_TCAMm)) {
        /* Device has UDF TCAM =>
           Recover internal information regarding TCAM entry usage
        */

        int                            rv;
        fp_udf_tcam_entry_t            fp_udf_tcam_entry;
        _field_data_tcam_entry_t       *tcam_entryp;
        bcm_field_data_packet_format_t pkt_fmt;
        int8 valid = 0;
        uint32 field = 1;
        uint32 mask = 0;
        uint32 ct;

        /* Recover TCAM entry reference counts and priorities */
        for (tcam_entryp = data_ctrl->tcam_entry_arr,
                 i = 0,
                 n = soc_mem_index_count(unit, FP_UDF_TCAMm);
             n;
             --n, ++i, ++tcam_entryp) {
            tcam_entryp->ref_count = buf[fc->scache_pos];
            fc->scache_pos++;

            BCM_IF_ERROR_RETURN(soc_mem_read(unit,
                                             FP_UDF_TCAMm,
                                             MEM_BLOCK_ANY,
                                             i,
                                             fp_udf_tcam_entry.entry_data
                                             )
                                );

            if (tcam_entryp->ref_count == 0) {
                /* TCAM entry is not in use */

                /* Consistency check: the valid bit for the TCAM entry
                   better be cleared!
                */
                if (soc_mem_field32_get(unit,
                                        FP_UDF_TCAMm,
                                        fp_udf_tcam_entry.entry_data,
                                        VALIDf
                                        )
                    != 0
                    ) {
                        /* Using new UDF module, value of ref_count always
                           equal zero, but field VALIDf of used UDF entry
                           equals to one. So need to skip this case.
                        */
                        if (soc_feature(unit, soc_feature_udf_support)) {
                            if (UDF_CTRL(unit)->udf_used_by_module
                                == UDF_USED_BY_FIELD_MODULE) {
                                return (BCM_E_INTERNAL);
                            }
                        } else {
                            return (BCM_E_INTERNAL);
                        }
                }

                continue;
            }

            /* TCAM entry is in use */

            /* Consistency check: the valid bit for the TCAM entry
               better be set!
            */
            if (soc_mem_field32_get(unit,
                                    FP_UDF_TCAMm,
                                    fp_udf_tcam_entry.entry_data,
                                    VALIDf
                                    )
                == 0
                ) {
                return (BCM_E_INTERNAL);
            }

            bcm_field_data_packet_format_t_init(&pkt_fmt);

            /* Parse l2 format.*/
            rv = _field_trx2_udf_tcam_entry_l2format_parse(
                     unit,
                     fp_udf_tcam_entry.entry_data,
                     &pkt_fmt.l2
                                                           );
            BCM_IF_ERROR_RETURN(rv);

            /* Parse vlan_tag format.*/
            rv = _field_trx2_udf_tcam_entry_vlanformat_parse(
                     unit,
                     fp_udf_tcam_entry.entry_data,
                     &pkt_fmt.vlan_tag
                                                             );
            BCM_IF_ERROR_RETURN(rv);

            /* Parse l3 fields.*/
            rv = _field_trx2_udf_tcam_entry_l3_parse(
                      unit,
                      fp_udf_tcam_entry.entry_data,
                      &pkt_fmt
                                                     );
            BCM_IF_ERROR_RETURN(rv);

            /* Parse Udf flags */
            rv = _field_trx2_udf_tcam_entry_flags_parse(
                    unit,
                    fp_udf_tcam_entry.entry_data,
                    &pkt_fmt.flags);

            BCM_IF_ERROR_RETURN(rv);

            /* Recover TCAM entry priority */
            tcam_entryp->priority = 0;
            if (pkt_fmt.l2 != BCM_FIELD_DATA_FORMAT_L2_ANY) {
                /* L2 format was specified */

                tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_L2_FORMAT;
            }

            if (pkt_fmt.vlan_tag != BCM_FIELD_DATA_FORMAT_VLAN_TAG_ANY) {
                /* Vlan tag format was specified */

                tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_VLAN_FORMAT;
            }

            if (pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_NONE
                && pkt_fmt.outer_ip == BCM_FIELD_DATA_FORMAT_IP_ANY
                && pkt_fmt.inner_ip == BCM_FIELD_DATA_FORMAT_IP_NONE
                ) {
                /* Entry corresponds to a call to
                   bcm_field_data_qualifier_ip_protocol_add() or
                   bcm_field_data_qualifier_ethertype_add()
                */

                if (soc_mem_field32_get(unit,
                                        FP_UDF_TCAMm,
                                        fp_udf_tcam_entry.entry_data,
                                        L3_FIELDS_MASKf)

                    ) {
                    if ((soc_mem_field32_get(unit,
                                             FP_UDF_TCAMm,
                                             fp_udf_tcam_entry.entry_data,
                                             L3_FIELDSf)
                                            & 0xff0000) >> 16

                        ) {
                        tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_IPPROTO;
                    }
                }
                tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MISC;
            } else {
                /* Entry corresponds to a call to
                   bcm_field_data_qualifier_packet_format_add()
                 */
                if ((pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_NONE) ||
                    (pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP) ||
                    (pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_GRE)) {

                    tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;

                } else  if (pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE
                        || pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE_INIT) {

                    tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_FCOE_FORMAT;
                    /*
                     * Entry matching on Outer + Inner FCOE extended headers has
                     * higher priority.
                     */
                    if ((BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY
                                != pkt_fmt.fibre_chan_outer)
                            && (BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY
                                != pkt_fmt.fibre_chan_inner)) {
                        tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_FCOE_FORMAT;
                    }
                } else if (pkt_fmt.tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS) {

                    tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FORMAT;

                    switch(pkt_fmt.mpls) {
                        case BCM_FIELD_DATA_FORMAT_MPLS_ONE_LABEL:
                            tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_ONE_LABEL;
                            break;
                        case BCM_FIELD_DATA_FORMAT_MPLS_TWO_LABELS:
                            tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_TWO_LABEL;
                            break;
                        case BCM_FIELD_DATA_FORMAT_MPLS_THREE_LABELS:
                            tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_THREE_LABEL;
                            break;
                        case BCM_FIELD_DATA_FORMAT_MPLS_FOUR_LABELS:
                            tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FOUR_LABEL;
                            break;
                        case BCM_FIELD_DATA_FORMAT_MPLS_FIVE_LABELS:
                            tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FIVE_LABEL;
                            break;
                        case BCM_FIELD_DATA_FORMAT_MPLS_ANY:
                            break;
                        default:
                            return (BCM_E_INTERNAL);
                    }
                }

                tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;
            }
            /* Update Priority based on UDF Flags */
            for (ct = 0; ; ct++) {
                if (udf_fields_f[ct][field] == INVALIDf) {
                    break;
                }

                valid = soc_mem_field_valid(unit, FP_UDF_TCAMm,
                        udf_fields_f[ct][field]);
                if (valid == TRUE) {
                    if (soc_mem_field32_get(unit, FP_UDF_TCAMm,
                                fp_udf_tcam_entry.entry_data, udf_fields_f[ct][mask])) {
                        tcam_entryp->priority += _FP_DATA_QUALIFIER_PRIO_FLAGS;
                    }
                }
            }
        }
    }

#endif /* defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT) */

    for (dqcnt = buf[fc->scache_pos++]; dqcnt; --dqcnt) {
        _bcm_field_data_qualifier_alloc(unit, &f_dq);

        /* Read data qual id */

        f_dq->qid = buf[fc->scache_pos];
        fc->scache_pos++;
        f_dq->qid |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        f_dq->qid |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        f_dq->qid |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;

        /* Read data qual "length remainder", flags and offset base */
        if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_10) {
            len_rem           = buf[fc->scache_pos] >> 6;
            f_dq->flags       = (buf[fc->scache_pos] >> 1)
                & _BCM_FIELD_DATA_QUALIFIER_FLAGS;
            f_dq->offset_base = buf[fc->scache_pos] & 7;
            fc->scache_pos++;
        } else {
            len_rem           = buf[fc->scache_pos];
            fc->scache_pos++;

            f_dq->offset_base = buf[fc->scache_pos];
            fc->scache_pos++;

            f_dq->flags = buf[fc->scache_pos];
            fc->scache_pos++;
            f_dq->flags |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            f_dq->flags |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            f_dq->flags |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        }

        /* Read data qual match-data offset */
        f_dq->offset = buf[fc->scache_pos];
        fc->scache_pos++;
        f_dq->offset |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;

        /* Read data qual hw_bmap */
        f_dq->hw_bmap = buf[fc->scache_pos];
        fc->scache_pos++;
        f_dq->hw_bmap |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;

        /* Find number of elements used */
        for (f_dq->elem_count = i = 0, n = (2 * stage_fc->data_ctrl->num_elems);
             n;
             --n, ++i
             ) {
            if (f_dq->hw_bmap & (1U << i)) {
                ++f_dq->elem_count;
            }
        }

        /* Consistency check: hw_bmap should not be 0! */
        if (f_dq->elem_count == 0) {
            _bcm_field_data_qualifier_free(unit, f_dq);

            return (BCM_E_INTERNAL);
        }

        _field_data_qualifier_init2(unit, stage_fc, f_dq);

        f_dq->length = f_dq->elem_count * data_ctrl->elem_size
            - f_dq->byte_offset
            - len_rem;

        /* N.B.  fq->flags is not applicable for Triumph2 => Leave as 0 */

        /* Merge qualifier's hw_bmap into overall uasge bmap */
        data_ctrl->usage_bmap |= f_dq->hw_bmap;
    }

    return (BCM_E_NONE);
}


/* Update a qset's udf_bmap to reflect actual data qualifier usage. */

void
_field_qset_udf_bmap_reinit(int              unit,
                            _field_stage_t   *stage_fc,
                            bcm_field_qset_t *qset,
                            int              qual_id
                            )
{
    _field_data_qualifier_t *f_dq;
    unsigned                elem_idx, n;
    int                     rv;
    _field_stage_t          *ingress_stage_fc = NULL;
    _field_control_t        *fc = NULL;

    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        return;
    }
    if (fc->l2warm) {
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
            return;
        }
    }

#if defined(BCM_ENDURO_SUPPORT)
    if(SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
        SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (qual_id < _bcmFieldQualifyData0 || qual_id > _bcmFieldQualifyData3) {
            return;
        }
    } else
#endif /* BCM_ENDURO_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if(soc_feature(unit, soc_feature_field_multi_pipe_support))
    {
        if (qual_id < _bcmFieldQualifyData0 || qual_id > _bcmFieldQualifyData9) {
            return;
        }
    } else
#endif /*BCM_TOMAHAWK_SUPPORT*/
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if ((SOC_IS_TD_TT(unit)
         || SOC_IS_KATANAX(unit)
         || SOC_IS_TRIUMPH3(unit))) {
        if (qual_id < _bcmFieldQualifyData0 || qual_id > _bcmFieldQualifyData3) {
            return;
        }

    } else
#endif /* BCM_TRIDENT_SUPPORT || BCM_KATANA_SUPPORT*/
    {
        if (qual_id < _bcmFieldQualifyData0 || qual_id > _bcmFieldQualifyData1) {
            return;
        }
    }

    /* UDF elements are always stored in Ingress stage control
         * irrespective of it being used in any other stage */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &ingress_stage_fc);
    if (BCM_FAILURE(rv)) {
        return;
    }

    for (f_dq = ingress_stage_fc->data_ctrl->data_qual ; f_dq; f_dq = f_dq->next) {
        for (elem_idx = 0, n = ingress_stage_fc->data_ctrl->num_elems * 2; n; --n, ++elem_idx) {
            if ((f_dq->hw_bmap & (1U << elem_idx)) == 0) {
                continue;
            }

            SHR_BITSET(qset->udf_map, elem_idx);
        }
    }

#if defined (BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_udf_support)) {
        bcmi_xgs4_udf_offset_info_t *tmp;
        UDF_LOCK(unit);
        for (tmp = UDF_CTRL(unit)->offset_info_head; tmp; tmp = tmp->next) {
            for (elem_idx = 0, n = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit); n; --n, ++elem_idx) {
                if ((tmp->hw_bmap & (1U << elem_idx)) == 0) {
                    continue;
                }

                SHR_BITSET(qset->udf_map, elem_idx);
            }
        }
        UDF_UNLOCK(unit);
    }
#endif

}


/* Recover range checkers */
int
_field_range_check_reinit(int unit, _field_stage_t *stage_fc,
                          _field_control_t *fc)
{
    int idx, index_min, index_max, count, valid_count;
    uint32 enable, type;
    soc_mem_t mem;
    uint32 tbl_entry[SOC_MAX_MEM_FIELD_WORDS];
    _field_range_t *fr, **last_fr;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];

    count = valid_count = 0;
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        mem = FP_RANGE_CHECKm;
    } else {
        mem = ESM_RANGE_CHECKm;
    }
    if (fc->l2warm) {
        count = buf[fc->scache_pos];
        fc->scache_pos++;
    }

    last_fr = &stage_fc->ranges;
    index_min = soc_mem_index_min(unit, mem);
    index_max = soc_mem_index_max(unit, mem);
    for (idx = index_min; idx <= index_max; idx ++) {
        sal_memset(tbl_entry, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        BCM_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ANY, idx, tbl_entry));
        soc_mem_field_get(unit, mem, tbl_entry, ENABLEf, &enable);
        if (enable == 0) {
            continue;
        }
        valid_count++;
        /* Create a new range entry for the list */
        if ((fr = sal_alloc(sizeof (*fr), "fp_range")) == NULL) {
            return (BCM_E_MEMORY);
        }
        sal_memset(fr, 0, sizeof(_field_range_t));
        /* Populate the structure */
        if (fc->l2warm) {
            /* Get the IDs */
            fr->rid = 0;
            fr->rid |= buf[fc->scache_pos];
            fc->scache_pos++;
            fr->rid |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            fr->rid |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            fr->rid |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        } else {
            fr->rid = idx;
        }
        fr->hw_index = idx;
        fr->style = _FP_RANGE_STYLE_FIREBOLT;
        soc_mem_field_get(unit, mem, tbl_entry, LOWER_BOUNDSf,
                          (uint32 *)&(fr->min));
        soc_mem_field_get(unit, mem, tbl_entry, UPPER_BOUNDSf,
                          (uint32 *)&(fr->max));
        if ((SOC_MEM_FIELD_VALID(unit, mem, FIELD_SELECTf))) {
            soc_mem_field_get(unit, mem, tbl_entry, FIELD_SELECTf, &type);
            switch (type) {
            case 0:
                fr->flags |= BCM_FIELD_RANGE_SRCPORT;
                break;
            case 1:
                fr->flags |= BCM_FIELD_RANGE_DSTPORT;
                break;
            case 2:
                fr->flags |= BCM_FIELD_RANGE_OUTER_VLAN;
                break;
            case 3:
                fr->flags |= BCM_FIELD_RANGE_PACKET_LENGTH;
                break;
            default:
                break; /* Should never happen */
            }
        } else {
            soc_mem_field_get(unit, mem, tbl_entry,
                              SOURCE_DESTINATION_SELECTf, &type);
            if (type == 1) {
                fr->flags |= BCM_FIELD_RANGE_SRCPORT;
            } else {
                fr->flags |= BCM_FIELD_RANGE_DSTPORT;
            }
        }

        /* Add to list of range checkers. */

        *last_fr = fr;
        last_fr = &fr->next;
    }
    if (fc->l2warm && count != valid_count) {
        return BCM_E_INTERNAL;
    }
    return BCM_E_NONE;
}

STATIC int
_field_scache_version_size_check(int unit, int former_size,
                                 uint16 former_version,
                                 int current_size,
                                 uint16 current_version)
{
    int delta_size[8] = {0};
    uint16 fversion, cversion;
    int fsize, csize, cumul_delta_size = 0;

    /* Incremental size for BCM_FIELD_WB_VERSION_1_6 */
    delta_size[0] = 16 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_8 */
    delta_size[1] = 128 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_15 */
    delta_size[2] = 135 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_17 */
    delta_size[3] = 144 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_18 */
    delta_size[4] = 21 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_19 */
    delta_size[5] = 264 * 1024;
    /* Incremental size for BCM_FIELD_WB_VERSION_1_20 */
    delta_size[6] = 48 * 1024;
    /* Incremental size for action bcmFieldActionFabricQueue
     * adding for BCM_FIELD_WB_VERSION_1_20
     */
    delta_size[6] += (16 * 1024 * 4);
    /* Incremental size for BCM_FIELD_WB_VERSION_1_21 */
    delta_size[7] = (512 * _SHR_PBMP_WORD_MAX * 4) + (16 * 1024 * 12);

    fversion = former_version;
    cversion = current_version;
    fsize    = former_size;
    csize    = current_size;

    /* This logic only handle upgrade warmboot case, don't consider downgrade case */
    if (fversion < BCM_FIELD_WB_VERSION_1_5) {
        /* skip too old version */
        return TRUE;
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_6)
            && (cversion >= BCM_FIELD_WB_VERSION_1_6)) {
        cumul_delta_size += delta_size[0];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_8)
            && (cversion >= BCM_FIELD_WB_VERSION_1_8)) {
        cumul_delta_size += delta_size[1];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_15)
            && (cversion >= BCM_FIELD_WB_VERSION_1_15)) {
        cumul_delta_size += delta_size[2];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_17)
            && (cversion >= BCM_FIELD_WB_VERSION_1_17)) {
        cumul_delta_size += delta_size[3];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_18)
            && (cversion >= BCM_FIELD_WB_VERSION_1_18)) {
        cumul_delta_size += delta_size[4];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_19)
            && (cversion >= BCM_FIELD_WB_VERSION_1_19)) {
        cumul_delta_size += delta_size[5];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_20)
            && (cversion >= BCM_FIELD_WB_VERSION_1_20)) {
        cumul_delta_size += delta_size[6];
    }

    if ((fversion < BCM_FIELD_WB_VERSION_1_21)
            && (cversion >= BCM_FIELD_WB_VERSION_1_21)) {
        cumul_delta_size += delta_size[7];
    }

    if ((fversion < cversion) &&
            ((csize - fsize) != (cumul_delta_size))) {
        return FALSE;
    }

    return TRUE;
}

/* Initialize field component scache pointers and scache sizes for
   multiple partitions */
int
_field_scache_pointer_init(int unit, _field_control_t  *fc)
{
    int               stable_size;
    int               rv;
    uint32            alloc_get;
    soc_scache_handle_t handle;

    if ((NULL == fc->scache_ptr[_FIELD_SCACHE_PART_0]) ||
        (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_1])) {

        SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
        SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD,
                              _FIELD_SCACHE_PART_0);
        if ((stable_size > 0) && !SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)) {
            if (SOC_IS_TRX(unit)) {

                fc->scache_size[_FIELD_SCACHE_PART_0] = 294 * 1024;
                /* Taking all average number into account
                 * (Note:S-Slices , P- Ports and Q - Qualifiers)
                 * IFP - 16S * 48P * 25Q
                 * VFP and EFP - 16S * 25Q
                 */
                fc->scache_size[_FIELD_SCACHE_PART_1] = 20 * 1024;

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
                    /*
                     * OAM => 70 * 1024 ((7 bytes * 8K IFP entries) + (7 bytes * 2K EFP entries))
                     * Policer L1 => 20 * 1024 (4 bytes * 20 slices * 256 entries.)
                     * No Param Actions => 40 * 1024 (4 bytes * 20 slices * 512 entries.)
                     * Slice/Secondary Selectors => 5 * 1024 (2 bytes * 128 ports/groups * 20 Slices.)
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += 135 * 1024;
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_17) {

                    /* For WB sync and recovery of configured policer rates,
                     * syncing only the delta value (diff btw configured and programmed
                     * for ckbits_sec, ckbits_burst, pkbits_sec, pkbits_burst.
                     * Taking 2 bytes for each of the delta,
                     * Required size = Maximum Number of entries * 8 bytes
                     * IFP := 16K * 8  = 128 KB
                     * EFP := 2K  * 8 = 16KB
                     * Total size = 144 KB
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += 144 * 1024;
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
                    /* Sync for SVP DVP type per entry part and
                     * ingress, src entity selcode per group part
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (21 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_19) {
                    /* Sync for Additional 4bytes to sync
                     * no parm actions sync enums per entry
                     * and 12 bytes for PortPrioIntCosQNew
                     * Actions CosQ Gport Values in IFP Stage
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (264 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_20) {
                    /* Allocate additional scache to sync IFP action ingress
                     * and egress mirror gport value in no parm actions sync
                     * enums per entry. IngressMirror and EgressMirror GPORT
                     * can be assigned to single entry. Have to allocate (4+4)
                     * bytes per entry.
                     * IFP = (8 bytes * 512 entries * 12 slices).
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (48 * 1024);
                    /*
                     * Scache size is increased by (16 * 1024) * 4 bytes
                     * (16K entries * 4 bytes) for all devices and
                     * (8 * 1024) * 4 * 2 (8K entries * 4 bytes * 2 params
                     * for KT2 devices to sync and recover the params of
                     * fabricQueue action for all entries of Ingress.
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (16 * 4 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) {
                 /*
                  * Group PBMP is synced with max_groups * size of the pbmp array
                  * Sync MirrorIngress and MirrorEgress action parameters per entry
                  * Worst case 16K * 12 bytes
                  */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += ((512 * _SHR_PBMP_WORD_MAX * 4) + (16 * 1024 * 12));
                }

            } else {
                /* Allocate a section of the Level 2 Warm Boot
                 * global cache.
                 * Assume 90% of the total stable size - just a heuristic
                 */
                fc->scache_size[_FIELD_SCACHE_PART_0] = (9 * stable_size) / 10;
                fc->scache_size[_FIELD_SCACHE_PART_1] = (1 * stable_size) / 100;
            }

            /* Get the pointer for the Level 2 cache */
            rv = soc_scache_ptr_get(unit, handle,
                                    &(fc->scache_ptr[_FIELD_SCACHE_PART_0]),
                                    &alloc_get);
            if (!SOC_WARM_BOOT(unit) && (SOC_E_NOT_FOUND == rv)) {
                /* Not yet allocated in Cold Boot */
                SOC_IF_ERROR_RETURN
                    (soc_scache_alloc(unit, handle,
                                      fc->scache_size[_FIELD_SCACHE_PART_0] +
                                      SOC_WB_SCACHE_CONTROL_SIZE));
                rv = soc_scache_ptr_get(unit, handle,
                                        &(fc->scache_ptr[_FIELD_SCACHE_PART_0]),
                                        &alloc_get);
            }
            /* Fetch WB Recovered Version */
            if (SOC_WARM_BOOT(unit)) {
                sal_memcpy(&(fc->wb_recovered_version),
                           fc->scache_ptr[_FIELD_SCACHE_PART_0],
                           sizeof(fc->wb_recovered_version));
            }


            if (BCM_FAILURE(rv)) {
                return rv;
            } else if (alloc_get != fc->scache_size[_FIELD_SCACHE_PART_0] +
                                    SOC_WB_SCACHE_CONTROL_SIZE) {
                   /* Expected size doesn't match retrieved size */
                   /* Scache size is increased by 16*1024 bytes
                    * from version BCM_FIELD_WB_VERSION_1_6.The below check is
                    * for upgrades from lower versions to BCM_FIELD_WB_VERSION_1_6
                    * and above.
                    * Scache size increased by 128 bytes from BCM_FIELD_WB_VERSION_1_8.
                    * with respect to BCM_FIELD_WB_VERSION_1_6
                    */
                    rv = _field_scache_version_size_check(unit, alloc_get,
                                                          (fc->wb_recovered_version),
                                                          fc->scache_size[_FIELD_SCACHE_PART_0] +
                                                          SOC_WB_SCACHE_CONTROL_SIZE,
                                                          (fc->wb_current_version));
                    if (rv != TRUE) {
                        return BCM_E_INTERNAL;
                    }
            } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_0]) {
                return BCM_E_MEMORY;
            }

            if (SOC_WARM_BOOT(unit)) {
                if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_3) {
                    return BCM_E_NONE;
                }
            }

            SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD, 1);
            SOC_SCACHE_MODULE_MAX_PARTITIONS_SET(unit, BCM_MODULE_FIELD, 1);

            /* Get the pointer for the Level 2 cache */
            rv = soc_scache_ptr_get(unit, handle,
                                    &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                    &alloc_get);
            if (!SOC_WARM_BOOT(unit) && (SOC_E_NOT_FOUND == rv)) {
                /* Not yet allocated in Cold Boot */
                SOC_IF_ERROR_RETURN
                    (soc_scache_alloc(unit, handle,
                                      fc->scache_size[_FIELD_SCACHE_PART_1] +
                                      SOC_WB_SCACHE_CONTROL_SIZE));
                rv = soc_scache_ptr_get(unit, handle,
                                        &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                        &alloc_get);
            }

            if (BCM_FAILURE(rv)) {
                return rv;
            } else if (alloc_get != fc->scache_size[_FIELD_SCACHE_PART_1] +
                                    SOC_WB_SCACHE_CONTROL_SIZE) {
                /* Expected size doesn't match retrieved size */
                return BCM_E_INTERNAL;
            } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_1]) {
                return BCM_E_MEMORY;
            }

        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_slice_map_write
 *
 * Purpose:
 *      Sync's slice status to scache for a stage (Expanded & master slice idx)
 *
 * Parameters:
 *             unit      - (IN) BCM device number
 *               fc      - (IN) FP control info.
 *         stage_fc      - (IN) FP stage control info.
 *
 * Returns:
 *           BCM_E_XXX
 *
 */

int
_field_slice_map_write(int unit,  _field_control_t *fc,
                           _field_stage_t *stage_fc)
{
    uint8               slice_id;        /* Slices iterator.              */
    _field_slice_t      *fs;             /* Slice pointer.                 */
    uint8               *buf;            /* Scache pointer.                */

    if ((stage_fc == NULL) || (fc == NULL)) {
        return BCM_E_PARAM;
    }

    /* No need to sync external stage */
    if (stage_fc->stage_id >= _BCM_FIELD_STAGE_EXTERNAL) {
        return BCM_E_NONE;
    }

    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];

    if (((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) && soc_mem_is_valid(unit, FP_SLICE_MAPm))
        || ((stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) && SOC_REG_IS_VALID(unit, EFP_SLICE_MAPr))
        || ((stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) && SOC_REG_IS_VALID(unit, VFP_SLICE_MAPr))) {

        for (slice_id = 0; slice_id < stage_fc->tcam_slices; slice_id++) {
            fs = stage_fc->slices[_FP_DEF_INST] + slice_id;

            buf[fc->scache_pos] = (fs->prev != NULL) ? 1 : 0;
            /* Go to master slice */
            while (fs->prev != NULL) {
                fs = fs->prev;
            }
            buf[fc->scache_pos] |= (fs->slice_number << 1);

            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "_field_slice_map_write:   Writing slice %d master slice %d expanded %d @ byte %d...\n"),
                     slice_id, (buf[fc->scache_pos] >> 1), (buf[fc->scache_pos] & 0x1), fc->scache_pos));

            fc->scache_pos++;
            fs = NULL;
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_mark_vmap_valid
 *
 * Purpose:
 *      Marks a virtual map as valid
 *
 * Parameters:
 *             unit      - (IN) BCM device number
 *         stage_fc      - (IN) FP stage control info.
 *               fg      - (IN) Select code information filled into the group.
 *     slice_number      - (IN) Slices iterator.
 *
 * Returns:
 *           BCM_E_XXX
 *
 */

STATIC int
_field_mark_vmap_valid(int unit, _field_stage_t *stage_fc,
                                  _field_group_t *fg, int s )
{
    int idx, vmap_size, map_id;
    _field_virtual_map_t *vvmap; /* Currently used virtual map. */
    _field_slice_t         *slices;

    BCM_IF_ERROR_RETURN(_bcm_field_virtual_map_size_get(unit,
                                           stage_fc, &vmap_size));

    for (map_id = 0; map_id < _FP_VMAP_CNT; map_id++) {
        slices = fg->slices;
        while (slices) {
            for (idx = 0; idx < vmap_size; idx++) {
                vvmap = stage_fc->vmap[fg->instance][map_id] + idx;

                if (vvmap->vmap_key == slices[s].slice_number) {
                    vvmap->valid = TRUE;
                    vvmap->priority = fg->priority;
                    /* update VMAP flags with group flags */
                    vvmap->flags = fg->flags;
                    if (map_id == 0) {
                        /* Update group VMAP */
                        fg->vmap_group[s] = vvmap->virtual_group;
                    }
                }
            }
            slices = slices->next;
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_group_slice_map_recovery
 *
 * Purpose:
 *      Recovers group and stage virtual map
 *
 * Parameters:
 *             unit      - (IN) BCM device number
 *               fc      - (IN) FP control info.
 *         stage_fc      - (IN) FP stage control info.
 *
 * Returns:
 *           BCM_E_XXX
 *
 */

int
_field_group_slice_vmap_recovery(int unit,  _field_control_t *fc,
                           _field_stage_t *stage_fc)
{
    _field_group_t      *fg;
    int                 idx;

    if ((stage_fc == NULL) || (fc == NULL)) {
        return BCM_E_PARAM;
    }

    /* No need to sync external stage */
    if (stage_fc->stage_id >= _BCM_FIELD_STAGE_EXTERNAL) {
        return BCM_E_NONE;
    }

    if (((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) && soc_mem_is_valid(unit, FP_SLICE_MAPm))
        || ((stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) && SOC_REG_IS_VALID(unit, EFP_SLICE_MAPr))
        || ((stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) && SOC_REG_IS_VALID(unit, VFP_SLICE_MAPr))) {

        for (fg = fc->groups; fg ; fg= fg->next) {
            /* Skip groups not belonging to stage */
            if (fg->stage_id != stage_fc->stage_id) {
                continue;
            }

            _field_mark_vmap_valid( unit, stage_fc, fg, 0 );

            if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                _field_mark_vmap_valid( unit, stage_fc, fg, 1 );
            }

            if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
                _field_mark_vmap_valid( unit, stage_fc, fg, 1 );
                _field_mark_vmap_valid( unit, stage_fc, fg, 2 );
            }

            if (fg->action_res_id != BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT) {
                for (idx = 1; idx < _FP_PAIR_MAX; idx++) {
                    fg->vmap_group[idx] = fg->vmap_group[0];
                }
            } else if (!(fc->l2warm)) {
                /* For L1 Warmboot
                *  double wide mode groups check to see if slices have same virtual group
                 * Single wide mode groups action res id will be as -1 */
                if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)
                        || (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
                    if (fg->vmap_group[0] == fg->vmap_group[1]) {
                        fg->action_res_id = fg->vmap_group[0];
                        for (idx = 2; idx < _FP_PAIR_MAX; idx++) {
                            fg->vmap_group[idx] = fg->vmap_group[0];
                        }
                    }
                }
            }
        }
    }
    return BCM_E_NONE;
}

#if defined BCM_KATANA2_SUPPORT || defined BCM_TRIDENT2_SUPPORT
/*
 * Function:
 *     _bcm_notify_qos_reinit_to_fp
 * Purpose:
 *      Notfiy Field module when qos reinit is successful,
 *      fp uses this notification to update bcmFieldActionDscpMapNew
 *      action in entry
 *
 * Parameters:
 *             unit      - (IN) BCM device number
 *               fc      - (IN) FP control info.
 *         stage_fc      - (IN) FP stage control info.
 *
 * Returns:
 *           BCM_E_XXX
 *
 */
int _bcm_notify_qos_reinit_to_fp (int unit) {
    _field_dscp_map_new_eid_list_t *dscp_map_new_eid_node = NULL;
    _field_dscp_map_new_eid_list_t *temp = NULL;
    _field_entry_t *f_ent = NULL;
    _field_action_t *fa = NULL;
    uint32 hw_value = 0;
    uint32 param1 = 0;
    int param0 = 0;

    dscp_map_new_eid_node = dscp_map_new_eid_list[unit];

    /* When DscpMapNew action is configured, after wb recovery,
     * param0 will hold the hw_value. Based on hw value, obtain the
     * mapId and update the entryId with the mapId as param0 */
    while (dscp_map_new_eid_node != NULL) {
        BCM_IF_ERROR_RETURN(bcm_esw_field_action_get(unit,
                    dscp_map_new_eid_node->eid,bcmFieldActionDscpMapNew,
                    &hw_value, &param1));
        BCM_IF_ERROR_RETURN(_bcm_tr2_qos_idx2id(unit, hw_value,
               _BCM_QOS_MAP_TYPE_DSCP_TABLE, &param0));
        BCM_IF_ERROR_RETURN(_field_entry_get(unit,
                    dscp_map_new_eid_node->eid, _FP_ENTRY_PRIMARY, &f_ent));
        for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
            if (fa->action == bcmFieldActionDscpMapNew) {
                fa->param[0] = param0;
                break;
            }
        }
        if (fa == NULL) {
            return BCM_E_INTERNAL;
        }

        temp = dscp_map_new_eid_node;
        dscp_map_new_eid_node = dscp_map_new_eid_node->next;
        sal_free (temp);
        temp = NULL;
    }
    dscp_map_new_eid_list[unit] = NULL;

    return BCM_E_NONE;
}

#endif /* BCM_KATANA2_SUPPORT, BCM_TRIDENT2_SUPPORT*/
#endif /*  BCM_WARM_BOOT_SUPPORT */

#ifdef BCM_TRIDENT2_SUPPORT
/*
 * Function:
 *      bcm_field_efp_update_alternate_key_mask
 * Purpose:
 *      As EFP has 2 types of keys, tcam.key and key_match_tcam.key
 *      using efp_key_match_type, update the alternate key meaning
 *      key which is not the current tcam installed key.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      f_ent - (IN) Pointer to field entry
 *      input_entry_type - (IN) Specifies the key type which is
 *                         currently installed in tcam
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
bcm_field_efp_update_alternate_key_mask(int unit,
                                        _field_entry_t *f_ent_1,
                                        int8 input_entry_type_1)
{
    int             parts_count = 0;    /* Number of entry parts.          */
    int             part_idx,part_id;   /* Entry parts iteration index.    */
    int             qual_idx;           /* Part qualifiers iteration index.*/
    int             rv;                 /* Operation return stauts.        */
    int             idx;
    int             idx_max;
    int             index;
    uint32          width;
    _field_group_t           *fg;       /* FP group info structure.        */
    _bcm_field_qual_offset_t *q_offset; /* Qualifier offset structure      */
    _bcm_field_group_qual_t  *q_arr;    /* Qualifiers array.               */
    _bcm_field_group_qual_t  *q_arr_1;  /* Qualifiers array.               */
    _bcm_field_qual_offset_t *q_offset_1; /* Qualifier offset structure    */
    _bcm_field_qual_data_t    q_data;
    _bcm_field_qual_data_t    q_mask;
    int8 entry_type;                    /* entry type of alternate key/mask*/
    _field_tcam_t             *tcam;    /* Tcam key/mask structure         */
    int                       dirty;    /* to check if entry is dirty      */
    _field_entry_t            *f_ent;   /* to hold the entry structure     */
    int8                      input_entry_type; /* entry type of entry     */

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, f_ent_1->eid, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;

    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* clear the data in alternate entry in all the f_ent parts*/
    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        /* when tcam.key is NULL, it might be because */
        /* group is in double mode and we are dealing here with f_ent[1] */
        /* in such cases f_ent[0] vaules can be NULL */
        if((f_ent+part_idx)->tcam.key == NULL) {
           continue;
        }
	input_entry_type = (f_ent+part_idx)->efp_key_match_type;
        /* clear the data in alternate entry */
        if (input_entry_type == _FP_ENTRY_TYPE_0) {
            tcam = &(f_ent+part_idx)->key_match_tcam;
        } else {
            tcam = &(f_ent+part_idx)->tcam;
        }
        sal_memset(tcam->key, 0, tcam->key_size);
        sal_memset(tcam->mask, 0, tcam->key_size);
    }
    /* Loop for updating the alternate key in f_ent */
    for (part_idx = 0; part_idx < parts_count; part_idx++)
    {
        if((f_ent+part_idx)->tcam.key == NULL) {
           continue;
        }
        /* get the efp_key_match_type for f_ent */
        input_entry_type = (f_ent+part_idx)->efp_key_match_type;
        /* check the entry dirty flag and keep the same value even */
        /* after the alternate entry is updated */
        dirty = 0;
        if ((f_ent+part_idx)->flags & _FP_ENTRY_DIRTY)  {
            dirty = 1;
        }
        q_arr = &(fg->qual_arr[input_entry_type][part_idx]);
        for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
            idx_max = -1;
            q_offset = q_arr->offset_arr + qual_idx;

            /* There is no value associated with zero
             * width qualifiers (Stage, Ip4 etc)
             */
             _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, width);
            if (0 == width) {
                /* if the qualifier is Ip6 or Ip4
                 * no need to update the key/mask
                 */
                continue;
            }

            _FP_QUAL_DATA_CLEAR(q_data);
            _FP_QUAL_DATA_CLEAR(q_mask);

            /* Read qualifier match value and mask. */
            rv = _bcm_field_qual_value_get(unit, q_offset, f_ent+part_idx,
                                                  q_data, q_mask);
            if (BCM_FAILURE(rv)) {
                return rv;
            }

            /* Check if qualifier was installed. */
            for (idx = 7; idx >= 0; idx--) {
                if (q_mask[idx] != 0)  {
                    idx_max = idx;
                    break;
                }
            }

            if (idx_max >= 0) {
                if (input_entry_type == 1)  {
                    entry_type = 0;
                } else {
                    entry_type = 1;
                }
                for (part_id = 0; part_id < parts_count; part_id++)
                {
                    if((f_ent+part_id)->tcam.key == NULL) {
                       continue;
                    }
                    q_arr_1 = &(fg->qual_arr[entry_type][part_id]);
                    for (index = 0; index < q_arr_1->size; index++)
                    {
                        if (q_arr->qid_arr[qual_idx] ==
                            q_arr_1->qid_arr[index])
                        {
                            q_offset_1 = q_arr_1->offset_arr + index;

                            rv = _bcm_field_qual_value_set_by_entry_type(unit,
                                                               q_offset_1,
                                                               f_ent+part_id,
                                                               q_data, q_mask, entry_type);
                            BCM_IF_ERROR_RETURN(rv);

                            /* When qualifier is found dont go for next qualifier
                             *  in q_arr
                             */
                            break;
                        }
                   }
               }
            }
        }
        /* set the entry dirty flag to the same value */
        /* as before the alternate key update  */
        if (1 == dirty) {
            (f_ent+part_idx)->flags |= _FP_ENTRY_DIRTY;
        } else {
            (f_ent+part_idx)->flags &= ~_FP_ENTRY_DIRTY;
        }
    }
    return (BCM_E_NONE);
}
#endif /* BCM_TRIDENT2_SUPPORT*/

/* Given en EID, find the group */
/* Used in various _qualify APIs */
int
_bcm_field_entry_group_find(int unit, bcm_field_entry_t eid,
                            _field_group_t **group_p)
{
    int                 idx;          /* Entry index */
    _field_control_t    *fc;          /* Unit FP control structure. */
    _field_group_t      *fg;          /* Group information.         */
    _field_entry_t      *f_ent;       /* Field entry info */

    if (NULL == group_p) {
        return (BCM_E_PARAM);
    }

    /* Get unit FP control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Iterate over the groups linked-list */
    fg = fc->groups;
    while (fg != NULL) {
        /* Now iterate over the entries in this group */
        for (idx = 0; idx < fg->group_status.entry_count; idx++) {
           f_ent = fg->entry_arr[idx];
           if (f_ent->eid == eid) {
               *group_p = fg;
               return BCM_E_NONE;
           }
        }
        fg = fg->next;
    }
    /* Group with eid not found. */
    return (BCM_E_NOT_FOUND);

}


/*
 * Function:
 *     _bcm_field_action_dest_check
 * Purpose:
 *     Verify destination prameters for fp actions
 * Parameters:
 *     unit    - (IN) BCM device number
 *     fa      - (IN) Field action structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_dest_check(int unit, _field_action_t *fa)
{
    int port_out;     /* Calculated port value.    */
    int modid_out;    /* Calculated module id.     */
    int rv;           /* Operation return value.   */

    /* Input parameters check. */
    if (NULL == fa) {
        return (BCM_E_PARAM);
    }

    /* No checks for Mirror/Mpls/Mim/Wlan gports  */
    if (BCM_GPORT_IS_SET(fa->param[1])) {
        return (BCM_E_NONE);
    }

    /* Modport/Trunk were resolved in _field_params_api_to_hw_adapt call.*/
    if (bcmFieldActionRedirectTrunk == fa->action) {
        return  _bcm_trunk_id_validate(unit, fa->param[0]);
    }

    /* Check destination module id / port. */
    rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_SET,
                                fa->param[0], fa->param[1],
                                &modid_out, &port_out);
    BCM_IF_ERROR_RETURN(rv);

    if (!SOC_MODID_ADDRESSABLE(unit, modid_out)) {
        return (BCM_E_PARAM);
    }
    if (!SOC_PORT_ADDRESSABLE(unit, port_out)) {
        return (BCM_E_PORT);
    }
    return (BCM_E_NONE);
}

#ifdef INCLUDE_L3
/*
 * Function:
 *     _bcm_field_policy_set_l3_nh_resolve
 * Purpose:
 *     Install l3 forwarding policy entry.
 * Parameters:
 *     unit      - (IN) BCM device number
 *     mem       - (IN) Policy table memory.
 *     value     - (IN) Egress object id or combined next hop information.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_policy_set_l3_nh_resolve(int unit,  int value,
                                    uint32 *flags, int *nh_ecmp_id)
{
    int rv;           /* Operation return value.    */

    /* Check if egress forwarding mode is enabled. */
    rv = bcm_xgs3_l3_egress_id_parse(unit, value, flags, nh_ecmp_id);
    if (rv == BCM_E_DISABLED) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                   (BSL_META_U(unit,
                    "Error: L3 Egress Mode must be enabled.\n")));
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_l2_actions_nh_desroy
 *
 * Purpose:
 *     Free l3 next hop and egress interface for
 *     l2 fields update action.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     nh_index - (IN) Next hop index.
 *     egr_intf_set - (IN) Egress interface allocated.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_l2_actions_nh_destroy(int unit, int nh_index, int egr_intf_set)
{
    uint32 hw_buf[SOC_MAX_MEM_FIELD_WORDS]; /* hw entry  buffer.            */
    bcm_l3_egress_t egr;                    /* Egress forwarding object.    */
    uint32 intf;                            /* Egress L3 interface id.      */

    /* Initialization. */
    bcm_l3_egress_t_init(&egr);

    /* Read next hop. */
    sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
    BCM_IF_ERROR_RETURN(soc_mem_read(unit, EGR_L3_NEXT_HOPm, SOC_BLOCK_ANY,
        nh_index, hw_buf));

    /* clear egress interface information + free interface resource */
    if ((1 == egr_intf_set) ||
        (SOC_IS_TRIUMPH2(unit) || SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
        SOC_IS_APOLLO(unit) || SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
        SOC_IS_GREYHOUND(unit) || SOC_IS_TRIUMPH3(unit) ||
        SOC_IS_GREYHOUND2(unit))) {
        /* Get interface id. */
        intf = soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm, hw_buf, INTF_NUMf);
        /* Reset interface entry in hw. */
        sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        BCM_IF_ERROR_RETURN(soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
            intf, hw_buf));
        /* Free interface id. */
       BCM_IF_ERROR_RETURN(_bcm_xgs3_egress_l3_intf_id_free(unit, intf));
    }

    /* clear egress next hop table information + free next hop index */
    sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
    BCM_IF_ERROR_RETURN(soc_mem_write(unit, EGR_L3_NEXT_HOPm,
        SOC_BLOCK_ALL, nh_index, hw_buf));

    BCM_IF_ERROR_RETURN(bcm_xgs3_nh_del(unit, 0, nh_index));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_l2_actions_nh_create
 *
 * Purpose:
 *     Free l3 next hop and egress interface for
 *     l2 fields update action.
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     da_fa   - (IN) Update destination mac action.
 *     sa_fa   - (IN) Update source mac action.
 *     vid_fa  - (IN) Update outer vid action.
 *     vn_new_fa  - (IN) Change VN tag action.
 *     vn_del_fa  - (IN) Delete VN tag action.
 *     e_new_fa  - (IN) Change E tag action.
 *     e_del_fa  - (IN) Delete E tag action.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_l2_actions_nh_create(int unit, _field_action_t *da_fa,
                                _field_action_t *sa_fa,
                                _field_action_t *vid_fa,
                                _field_action_t *vn_new_fa,
                                _field_action_t *vn_del_fa,
                                _field_action_t *e_new_fa,
                                _field_action_t *e_del_fa)
{
    uint32 hw_buf[SOC_MAX_MEM_FIELD_WORDS]; /* hw entry  buffer.     */
    bcm_l3_egress_t egr;            /* Egress forwarding object.     */
    _bcm_l3_intf_cfg_t  intf;       /* Egress L3 interface id.       */
    int nh_index;                   /* Next hop index.               */
    int nh_flags = 0;               /* Next hop flags.               */
    int rv = BCM_E_NONE;            /* Operation return status.      */

    /*validation */
    if (!BCM_XGS3_L3_INITIALIZED(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "Error: L3 module is not initialized.\n")));
        return (BCM_E_INIT);
    }
    /* Check l3 switching mode. */
    if (!(BCM_XGS3_L3_EGRESS_MODE_ISSET(unit))) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "Error: L3 Egress Mode must be enabled.\n")));
        return (BCM_E_DISABLED);
    }
    /* Initialization. */
    bcm_l3_egress_t_init(&egr);
    sal_memset(&intf, 0, sizeof(_bcm_l3_intf_cfg_t));

    /* Extract the policy info from the entry structure. */
    if (NULL != da_fa) {
        SAL_MAC_ADDR_FROM_UINT32(egr.mac_addr, da_fa->param);
    }

    if (NULL != sa_fa) {
        SAL_MAC_ADDR_FROM_UINT32(intf.l3i_mac_addr, sa_fa->param);
    }

    if (NULL != vid_fa) {
        intf.l3i_vid = vid_fa->param[0];
    }

    if (SOC_IS_TRIUMPH2(unit)
        || SOC_IS_TD_TT(unit)
        || SOC_IS_KATANAX(unit)
        || SOC_IS_APOLLO(unit)
        || SOC_IS_ENDURO(unit)
        || SOC_IS_HURRICANEX(unit)
        || SOC_IS_TRIUMPH3(unit)
        || SOC_IS_GREYHOUND(unit)
        || SOC_IS_VALKYRIE2(unit)
        || SOC_IS_GREYHOUND2(unit)
        ) {
        /* Create egress l3 interface. */
        BCM_IF_ERROR_RETURN(_bcm_xgs3_egress_l3_intf_id_alloc(unit,
            &intf));

        /* Write egress interface to the hw. */
        sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));

        /* Set mac address. */
        soc_mem_mac_addr_set(unit, EGR_L3_INTFm, hw_buf,
            MAC_ADDRESSf, intf.l3i_mac_addr);

        /* Set vlan id. */
        soc_mem_field32_set(unit, EGR_L3_INTFm, hw_buf, VIDf, intf.l3i_vid);

        /* Write interface configuration to the HW. */
        rv = soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                intf.l3i_index, hw_buf);
        if (BCM_FAILURE(rv)) {
            (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
            return rv;
        }

        /* Allocate next hop entry. */
        nh_flags = _BCM_L3_SHR_MATCH_DISABLE | _BCM_L3_SHR_WRITE_DISABLE;
        rv = bcm_xgs3_nh_add(unit, nh_flags, &egr, &nh_index);
        if (BCM_FAILURE(rv)) {
            sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
            (void)soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                        intf.l3i_index, hw_buf);
            (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
            return (rv);
        }

        /* Write egress next hop entry. */
        sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            /* Set next hop entry type to IFP_ACTIONS. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                ENTRY_TYPEf, 6);

            /* Set next hop mac address. */
            soc_mem_mac_addr_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                IFP_ACTIONS__MAC_ADDRESSf, egr.mac_addr);

            /* Set interface id. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                IFP_ACTIONS__INTF_NUMf, intf.l3i_index);

            /* Set Disable flags. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                SOC_IS_KATANA2(unit) ? IFP_ACTIONS__L3_TTL_DISABLEf :
                IFP_ACTIONS__L3_UC_TTL_DISABLEf,
                0x1);

            if (NULL == vid_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    SOC_IS_KATANA2(unit) ? IFP_ACTIONS__L3_VLAN_DISABLEf :
                    IFP_ACTIONS__L3_UC_VLAN_DISABLEf, 0x1);
            }

            if (NULL == sa_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    SOC_IS_KATANA2(unit) ? IFP_ACTIONS__L3_SA_DISABLEf :
                    IFP_ACTIONS__L3_UC_SA_DISABLEf, 0x1);
            }

            if (NULL == da_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    SOC_IS_KATANA2(unit) ? IFP_ACTIONS__L3_DA_DISABLEf :
                    IFP_ACTIONS__L3_UC_DA_DISABLEf, 0x1);
            }

            if (NULL != vn_new_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAG_ACTIONf, 0x1);
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAGf, vn_new_fa->param[0]);
            }

            if (NULL != vn_del_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAG_ACTIONf, 0x3);
            }

            if (NULL != e_new_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAG_ACTIONf, 0x2);
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAGf, e_new_fa->param[0]);
            }

            if (NULL != e_del_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    IFP_ACTIONS__VNTAG_ACTIONf, 0x3);
            }

        } else
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        {
            /* Set next hop mac address. */
            soc_mem_mac_addr_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                MAC_ADDRESSf, egr.mac_addr);

            /* Set interface id. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                INTF_NUMf, intf.l3i_index);

            /* Set Disable flags. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                L3__L3_UC_TTL_DISABLEf, 0x1);

            if (NULL == vid_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    L3__L3_UC_VLAN_DISABLEf, 0x1);
            }

            if (NULL == sa_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    L3__L3_UC_SA_DISABLEf, 0x1);
            }

            if (NULL == da_fa) {
                soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                    L3__L3_UC_DA_DISABLEf, 0x1);
            }

            if (SOC_IS_TRIUMPH3(unit)) {
                soc_mem_field32_set(unit,
                                    EGR_L3_NEXT_HOPm,
                                    hw_buf,
                                    ENTRY_TYPEf,
                                    6
                                    );
                if (NULL != e_new_fa) {
                    soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                        L2_ACTIONS__VNTAG_ACTIONf, 0x2);
                    soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                        L2_ACTIONS__VNTAGf, e_new_fa->param[0]);
                }

                if (NULL != e_del_fa) {
                    soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                        L2_ACTIONS__VNTAG_ACTIONf, 0x3);
                }

            }

        }
        /* Insert next hop information. */
        rv = soc_mem_write(unit, EGR_L3_NEXT_HOPm, SOC_BLOCK_ALL,
                nh_index, hw_buf);
        if (BCM_FAILURE(rv)) {
            sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
            (void)soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                                intf.l3i_index, hw_buf);
            (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
            return (rv);
        }
    } else {
        if (NULL != sa_fa) {
            /* Create egress l3 interface. */
            BCM_IF_ERROR_RETURN(_bcm_xgs3_egress_l3_intf_id_alloc(unit,
                &intf));

            /* Write egress interface to the hw. */
            sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));

            /* Set mac address. */
            soc_mem_mac_addr_set(unit, EGR_L3_INTFm, hw_buf,
                MAC_ADDRESSf, intf.l3i_mac_addr);

            /* Set vlan id. */
            soc_mem_field32_set(unit, EGR_L3_INTFm, hw_buf, VIDf, intf.l3i_vid);

            /* Write interface configuration to the HW. */
            rv = soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                    intf.l3i_index, hw_buf);
            if (BCM_FAILURE(rv)) {
                (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
                return rv;
            }
        }

        /* Allocate next hop entry. */
        nh_flags = _BCM_L3_SHR_MATCH_DISABLE | _BCM_L3_SHR_WRITE_DISABLE;
        rv = bcm_xgs3_nh_add(unit, nh_flags, &egr, &nh_index);
        if (BCM_FAILURE(rv)) {
            if (NULL != sa_fa) {
                sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
                (void)soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                            intf.l3i_index, hw_buf);
                (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
            }
            return (rv);
        }

        /* Write egress next hop entry. */
        sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));

        /* Set next hop mac address. */
        soc_mem_mac_addr_set(unit, EGR_L3_NEXT_HOPm, hw_buf, MAC_ADDRESSf,
            egr.mac_addr);

        /* Set Outer Vlan ID. */
        if (NULL != vid_fa) {
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                INTF_NUMf, intf.l3i_vid);
        } else if (NULL != sa_fa) {
            /* Set interface id. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                INTF_NUMf, intf.l3i_index);
        } else {
            /* Set interface id. */
            soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm, hw_buf,
                INTF_NUMf, 0);
        }

        /* Insert next hop information. */
        rv = soc_mem_write(unit, EGR_L3_NEXT_HOPm, SOC_BLOCK_ALL,
                nh_index, hw_buf);
        if (BCM_FAILURE(rv)) {
            if (NULL != sa_fa) {
                sal_memset(hw_buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
                (void)soc_mem_write(unit, EGR_L3_INTFm, SOC_BLOCK_ALL,
                            intf.l3i_index, hw_buf);
                (void)_bcm_xgs3_egress_l3_intf_id_free(unit, intf.l3i_index);
            }
            return (rv);
        }
    }

    /* Preserve next hop index in the action structure. */
    if (NULL != vid_fa) {
        vid_fa->hw_index = nh_index;
    }

    if (NULL != sa_fa) {
        sa_fa->hw_index = nh_index;
    }

    if (NULL != da_fa) {
        da_fa->hw_index = nh_index;
    }

    if (NULL != vn_new_fa) {
        vn_new_fa->hw_index = nh_index;
    }

    if (NULL != vn_del_fa) {
        vn_del_fa->hw_index = nh_index;
    }

    if (NULL != e_new_fa) {
        e_new_fa->hw_index = nh_index;
    }

    if (NULL != e_del_fa) {
        e_del_fa->hw_index = nh_index;
    }

    return (BCM_E_NONE);
}

#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
     || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
     || defined (BCM_ENDURO_SUPPORT)

/*
 * Function:
 *     _bcm_field_l3_egr_entry_type_set
 *
 * Purpose:
 *     Modify EGR_L3_NEXT_HOP entry type.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     action      - (IN) FP action.
 *     nh_index    - (IN) L3 Next Hop Index.
 *     entry_type  - (IN) Entry type to be set.
 *     disable_val - (IN) Disable value to be set for L3 fields.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_l3_egr_entry_type_set(int unit, bcm_field_action_t action,
                                     int nh_index, int entry_type,
                                     int disable_val)
{
    int rv = BCM_E_NONE;                    /* Operation return status.  */
    soc_field_t l3_vlan_disable = INVALIDf; /* L3 VLAN disable field.    */
    soc_field_t l3_ttl_disable  = INVALIDf; /* L3 TTL disable field.     */
    soc_field_t l3_sa_disable   = INVALIDf; /* L3 SrcMac disable field.  */
    soc_field_t l3_da_disable   = INVALIDf; /* L3 DstMac disable field.  */
    egr_l3_next_hop_entry_t  egr_l3_next_hop_entry; /* Egress Next Hop table
                                                     * entry info */

    if (SOC_IS_TRIUMPH3(unit)) {
       l3_vlan_disable = L2_ACTIONS__L3_UC_VLAN_DISABLEf ;
       l3_ttl_disable  = L2_ACTIONS__L3_UC_TTL_DISABLEf;
       l3_sa_disable   = L2_ACTIONS__L3_UC_SA_DISABLEf;
       l3_da_disable   = L2_ACTIONS__L3_UC_DA_DISABLEf;
    } else if (SOC_IS_KATANA2(unit)) {
       l3_vlan_disable = IFP_ACTIONS__L3_VLAN_DISABLEf ;
       l3_ttl_disable  = IFP_ACTIONS__L3_TTL_DISABLEf;
       l3_sa_disable   = IFP_ACTIONS__L3_SA_DISABLEf;
       l3_da_disable   = IFP_ACTIONS__L3_DA_DISABLEf;
    } else if (SOC_IS_TD_TT(unit) || SOC_IS_GREYHOUND(unit)
               || SOC_IS_KATANA(unit) || SOC_IS_HURRICANE3(unit)
               || SOC_IS_GREYHOUND2(unit))  {
       l3_vlan_disable = IFP_ACTIONS__L3_UC_VLAN_DISABLEf ;
       l3_ttl_disable  = IFP_ACTIONS__L3_UC_TTL_DISABLEf;
       l3_sa_disable   = IFP_ACTIONS__L3_UC_SA_DISABLEf;
       l3_da_disable   = IFP_ACTIONS__L3_UC_DA_DISABLEf;
    } else {
       return BCM_E_CONFIG;
    }

    rv = soc_mem_read(unit, EGR_L3_NEXT_HOPm,
                      MEM_BLOCK_ANY, nh_index,
                      &(egr_l3_next_hop_entry.entry_data));
    if (BCM_FAILURE(rv)) {
       return (rv);
    }

    if (SOC_MEM_FIELD_VALID(unit, EGR_L3_NEXT_HOPm,
                            ENTRY_TYPEf)) {
        soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm,
                            &(egr_l3_next_hop_entry.entry_data),
                            ENTRY_TYPEf, entry_type);
    } else {
        return BCM_E_CONFIG;
    }

    if (action == bcmFieldActionL3ChangeMacDa) {
        soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm,
                            &(egr_l3_next_hop_entry.entry_data),
                            l3_vlan_disable, disable_val);
    } else {
        soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm,
                            &(egr_l3_next_hop_entry.entry_data),
                            l3_da_disable, disable_val);
    }

    soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm,
                        &(egr_l3_next_hop_entry.entry_data),
                        l3_sa_disable, disable_val);

    soc_mem_field32_set(unit, EGR_L3_NEXT_HOPm,
                        &(egr_l3_next_hop_entry.entry_data),
                        l3_ttl_disable, disable_val);

    soc_mem_lock(unit, EGR_L3_NEXT_HOPm);
    rv = soc_mem_write(unit, EGR_L3_NEXT_HOPm, MEM_BLOCK_ANY,
                       nh_index,
                       &(egr_l3_next_hop_entry.entry_data));
    if (BCM_FAILURE(rv)) {
         soc_mem_unlock(unit, EGR_L3_NEXT_HOPm);
         return (rv);
    }

    soc_mem_unlock(unit, EGR_L3_NEXT_HOPm);
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_l3_egress_actions_set
 *
 * Purpose:
 *     Modify EGR_L3_NEXT_HOP entry type to IFP_ACTIONS (6) for FP Actions.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_l3_egress_actions_set(int unit, _field_entry_t *f_ent)
{
    _field_action_t *fa;            /* Field action descriptor. */
    int nh_index = 0;               /* Next hop index. */
    uint32 ref_count = 0;           /* L3 Reference count  */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) {
        return (BCM_E_NONE);
    }

    /* The following chips do not support entry type IFP_ACTIONS (6) */
    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE2(unit)) {
        return (BCM_E_NONE);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions;
         ((fa != NULL) && (_FP_ACTION_VALID & fa->flags));
         fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionL3ChangeVlan:
               break;

          case bcmFieldActionL3ChangeMacDa:
               break;

          default:
               continue;
        }

        /* Validate the Egress object Id */
        /* Make sure the object is only for Next hop entries
           and not for Multipath and DVP*/
        if (BCM_XGS3_L3_EGRESS_IDX_VALID(unit, fa->param[0])) {
            nh_index = fa->param[0] - BCM_XGS3_EGRESS_IDX_MIN;
        } else {
            return BCM_E_PARAM;
        }

        ref_count = BCM_XGS3_L3_ENT_REF_CNT(BCM_XGS3_L3_TBL_PTR(unit, next_hop),
                                            nh_index);

        /* Check to handle Entry reinstall */
        if ((_FP_INVALID_INDEX == fa->hw_index) ||
                (nh_index != fa->hw_index)) {

        /* Make sure entry is valid and not inuse by other modules */
        if (ref_count < 1) {
            return BCM_E_NOT_FOUND;
        } else if (ref_count > 1) {
            return BCM_E_BUSY;
        }

        /* Configure ENTRY_TYPE to 6 (IFP_ACTIONS) */
        BCM_IF_ERROR_RETURN(_bcm_field_l3_egr_entry_type_set(unit, fa->action,
                                                             nh_index, 6, 1));
        if (_FP_INVALID_INDEX != fa->hw_index) {
            fa->old_index = fa->hw_index;
        }
        /* Preserve next hop index in the action structure. */
        fa->hw_index = nh_index;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_l3_egress_actions_reset
 *
 * Purpose:
 *     Reset EGR_L3_NEXT_HOP entry type to 0 for FP actions
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 *     flags     - (IN) Flags.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_l3_egress_actions_reset(int unit, _field_entry_t *f_ent, int flags)
{
    _field_action_t *fa;          /* Field action descriptor. */
    int nh_index = 0;             /* Next hop id. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) {
        return (BCM_E_NONE);
    }

    /* The following chips do not support entry type IFP_ACTIONS (6) */
    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE2(unit)) {
        return (BCM_E_NONE);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionL3ChangeVlan:
               break;

          case bcmFieldActionL3ChangeMacDa:
               break;

          default:
               continue;
        }
        if ((flags & _FP_ACTION_RESOURCE_FREE) &&
            (_FP_INVALID_INDEX != fa->hw_index)) {
             nh_index = fa->hw_index;
             fa->hw_index = _FP_INVALID_INDEX;
             BCM_IF_ERROR_RETURN
                   (_bcm_field_l3_egr_entry_type_set(unit, fa->action,
                                                     nh_index, 0, 0));
        }

        if ((flags & _FP_ACTION_OLD_RESOURCE_FREE) &&
            (_FP_INVALID_INDEX != fa->old_index)) {
             nh_index = fa->old_index;
             fa->old_index = _FP_INVALID_INDEX;
             BCM_IF_ERROR_RETURN
                   (_bcm_field_l3_egr_entry_type_set(unit, fa->action,
                                                     nh_index, 0, 0));
        }
    }
    return (BCM_E_NONE);
}

#endif /* (BCM_KATANA_SUPPORT) || (BCM_TRIDENT_SUPPORT) ||
          (BCM_TRIUMPH3_SUPPORT) || (BCM_GREYHOUND_SUPPORT) */


/*
 * Function:
 *     _bcm_field_l2_actions_hw_alloc
 *
 * Purpose:
 *     Allocate l3 next hop and egress interface for
 *     l2 fields update action.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_l2_actions_hw_alloc(int unit, _field_entry_t *f_ent)
{
    _field_action_t *vid_fa;        /* Update outer vid action.      */
    _field_action_t *sa_fa;         /* Update source mac action.     */
    _field_action_t *da_fa;         /* Update destination mac action.*/
    _field_action_t *vn_new_fa;     /* Change VN tag.                */
    _field_action_t *vn_del_fa;     /* Delete VN tag action.         */
    _field_action_t *e_new_fa;      /* Change E tag.                */
    _field_action_t *e_del_fa;      /* Delete E tag action.         */
    _field_action_t *fa;            /* Field action descriptor.      */

    /*
     * Applicable to stage ingress on devices which support
     * soc_feature_field_action_l2_change feature.
     */
    if ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
        (_BCM_FIELD_STAGE_EXACTMATCH != f_ent->group->stage_id)) {
        return (BCM_E_NONE);
    }

    /* Initialization. */
    sa_fa = da_fa = vid_fa = vn_new_fa = vn_del_fa = e_new_fa = e_del_fa = NULL;

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; ((fa != NULL) && (_FP_ACTION_VALID & fa->flags)); fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionSrcMacNew:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              sa_fa = fa;
              break;
          case bcmFieldActionDstMacNew:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              da_fa = fa;
              break;
          case bcmFieldActionOuterVlanNew:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              vid_fa = fa;
              break;
          case bcmFieldActionVnTagNew:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              vn_new_fa = fa;
              break;
          case bcmFieldActionVnTagDelete:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              vn_del_fa = fa;
              break;
          case bcmFieldActionEtagNew:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              e_new_fa = fa;
              break;
          case bcmFieldActionEtagDelete:
              if (_FP_INVALID_INDEX != fa->hw_index) {
                  fa->old_index = fa->hw_index;
              }
              e_del_fa = fa;
              break;
          default:
              continue;
        }
    }

    /* Create nh entry. */
    if ((NULL != vid_fa) || (NULL != da_fa) || (NULL != sa_fa) ||
        (NULL != vn_new_fa) || (NULL != vn_del_fa) ||
         (NULL != e_new_fa) || (NULL != e_del_fa)) {
        BCM_IF_ERROR_RETURN(_bcm_field_l2_actions_nh_create(unit, da_fa, sa_fa,
            vid_fa, vn_new_fa, vn_del_fa, e_new_fa, e_del_fa));
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_l2_actions_hw_free
 *
 * Purpose:
 *     Free l3 next hop and egress interface for
 *     l2 fields update action.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 *     flags     - (IN) Free flags (old/new/both).
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_l2_actions_hw_free(int unit, _field_entry_t *f_ent,
                                  uint32 flags)
{
    _field_action_t *fa;            /* Field action descriptor.      */
    int nh_index;                   /* Next hop index.               */
    int old_nh_index;               /* Old next hop index.           */
    int egr_intf_set = 0;            /* Egress interface allocated    */
    int rv = BCM_E_NONE;            /* Operation return status.      */

    /* Applicable to stage ingress on TRX and FB family of devices only. */
    if ((0 == SOC_IS_TRX(unit))
        && (0 == SOC_IS_FB(unit))
        && (0 == SOC_IS_BRADLEY(unit))) {
        return (BCM_E_NONE);
    }

    if ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
        (_BCM_FIELD_STAGE_EXACTMATCH != f_ent->group->stage_id)) {
        return BCM_E_NONE;
    }

    /* Initialization. */
    nh_index = old_nh_index = _FP_INVALID_INDEX;

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionSrcMacNew:
              egr_intf_set = TRUE;
              /* passthru */
              /* coverity[MISSING_BREAK: FALSE] */
          case bcmFieldActionOuterVlanNew:
          case bcmFieldActionDstMacNew:
          case bcmFieldActionVnTagNew:
          case bcmFieldActionVnTagDelete:
          case bcmFieldActionEtagNew:
          case bcmFieldActionEtagDelete:
              if ((flags & _FP_ACTION_RESOURCE_FREE) &&
                  (_FP_INVALID_INDEX != fa->hw_index)) {
                  nh_index = fa->hw_index;
                  fa->hw_index = _FP_INVALID_INDEX;
              }
              if ((flags & _FP_ACTION_OLD_RESOURCE_FREE) &&
                  (_FP_INVALID_INDEX != fa->old_index)) {
                  old_nh_index = fa->old_index;
                  fa->old_index = _FP_INVALID_INDEX;
              }
              break;
          default:
              break;
        }
    }

    /* Destroy old next hop if any. */
    if (_FP_INVALID_INDEX != old_nh_index) {
        rv = _bcm_field_l2_actions_nh_destroy(unit, old_nh_index, egr_intf_set);
        BCM_IF_ERROR_RETURN(rv);
    }
    if (_FP_INVALID_INDEX != nh_index) {
        rv = _bcm_field_l2_actions_nh_destroy(unit, nh_index, egr_intf_set);
        BCM_IF_ERROR_RETURN(rv);
    }
    return (BCM_E_NONE);
}
#endif /* INCLUDE_L3 */

/*
 * Function:
 *     _field_dest_type_clear
 * Purpose:
 *     Clear Destination Type value in qualifier data.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     entry    - (IN) entry identifier.
 *     qual     - (IN) field qualifier.
 *     data     - (IN) qualifier data.
 *     mask     - (IN) qualifier mask.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_dest_type_clear(int unit, bcm_field_entry_t entry,
        bcm_field_qualify_t qual, uint32 *data, uint32 *mask)
{
#ifdef BCM_TRIUMPH2_SUPPORT
    _field_group_t *fg;         /* Field group structure              */
    int entry_width;            /* Forward Entity Select status       */
    int dst_fwd_entity_status;  /* dst_fwd_entity_sel selector status */

    /* Check if this device supports per-slice control fields */
    if (0 == soc_feature(unit, soc_feature_field_slice_dest_entity_select)) {
        return (BCM_E_NONE);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Return for multi-pipe supported devices */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        return (BCM_E_NONE);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /*
     * Check if dst_fwd_entity_sel secondary selector is used.
     */
    for (entry_width = 0; entry_width < _FP_MAX_ENTRY_WIDTH; entry_width++) {
        switch (fg->sel_codes[entry_width].dst_fwd_entity_sel) {
            case _bcmFieldFwdEntityGlp:
                if (qual == bcmFieldQualifyDstPort
                    || qual == bcmFieldQualifyDstTrunk) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMplsGport:
                if ((qual == bcmFieldQualifyDstMplsGport) ||
                        (qual == bcmFieldQualifyDstMplsGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityNivGport:
                if ((qual == bcmFieldQualifyDstNivGport) ||
                        (qual == bcmFieldQualifyDstNivGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMimGport:
                if ((qual == bcmFieldQualifyDstMimGport) ||
                        (qual == bcmFieldQualifyDstMimGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityWlanGport:
                if ((qual == bcmFieldQualifyDstWlanGport) ||
                        (qual == bcmFieldQualifyDstWlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityVxlanGport:
                if ((qual == bcmFieldQualifyDstVxlanGport) ||
                        (qual == bcmFieldQualifyDstVxlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityVlanGport:
                if ((qual == bcmFieldQualifyDstVlanGport) ||
                        (qual == bcmFieldQualifyDstVlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityCommonGport:
                if ((qual == bcmFieldQualifyDstGport) ||
                        (qual == bcmFieldQualifyDstGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityL3Egress:
                dst_fwd_entity_status
                    = (qual == bcmFieldQualifyDstL3Egress)
                        ? TRUE : (qual == bcmFieldQualifyDstL3EgressNextHops)
                        ? TRUE : FALSE;
                break;
            case _bcmFieldFwdEntityMulticastGroup:
                if ((qual == bcmFieldQualifyDstMulticastGroup) ||
                        (qual == bcmFieldQualifyDstMulticastGroups)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMultipath:
                dst_fwd_entity_status =
                    (qual == bcmFieldQualifyDstMultipath) ? TRUE: FALSE;
                break;
            default:
                dst_fwd_entity_status = FALSE;
        }
        if (TRUE == dst_fwd_entity_status) {
            break;
        }
    }

    if (FALSE == dst_fwd_entity_status) {
        return BCM_E_NONE;
    } else {
        _FIELD_D_TYPE_RESET(*data);
        _FIELD_D_TYPE_RESET(*mask);
    }
#endif /* !BCM_TRIUMPH2_SUPPORT */
    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_dest_type_qualify
 * Purpose:
 *     Set Destination Type value in qualifier data.
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     entry            - (IN) entry identifier.
 *     qual             - (IN) field qualifier.
 *     data             - (IN) qualifier data.
 *     mask             - (IN) qualifier mask.
 *     flags            - (IN) Flags to set d_type.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_dest_type_qualify(int unit, bcm_field_entry_t entry,
        bcm_field_qualify_t qual, uint32 *data, uint32 *mask,
        uint32 flags)
{
#ifdef BCM_TRIUMPH2_SUPPORT
    _field_group_t *fg;         /* Field group structure              */
    int entry_width;            /* Forward Entity Select status       */
    int dst_fwd_entity_status;  /* dst_fwd_entity_sel selector status */

    /* Check if this device supports per-slice control fields */
    if (0 == soc_feature(unit, soc_feature_field_slice_dest_entity_select)) {
        return (BCM_E_NONE);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Return for multi-pipe supported devices */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        return (BCM_E_NONE);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /*
     * Check if dst_fwd_entity_sel secondary selector is used.
     */
    for (entry_width = 0; entry_width < _FP_MAX_ENTRY_WIDTH; entry_width++) {
        switch (fg->sel_codes[entry_width].dst_fwd_entity_sel) {
            case _bcmFieldFwdEntityGlp:
                if (qual == bcmFieldQualifyDstPort
                    || qual == bcmFieldQualifyDstTrunk) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMplsGport:
                if ((qual == bcmFieldQualifyDstMplsGport) ||
                        (qual == bcmFieldQualifyDstMplsGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityNivGport:
                if ((qual == bcmFieldQualifyDstNivGport) ||
                        (qual == bcmFieldQualifyDstNivGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMimGport:
                if ((qual == bcmFieldQualifyDstMimGport) ||
                        (qual == bcmFieldQualifyDstMimGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityWlanGport:
                if ((qual == bcmFieldQualifyDstWlanGport) ||
                        (qual == bcmFieldQualifyDstWlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityVxlanGport:
                if ((qual == bcmFieldQualifyDstVxlanGport) ||
                        (qual == bcmFieldQualifyDstVxlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityVlanGport:
                if ((qual == bcmFieldQualifyDstVlanGport) ||
                        (qual == bcmFieldQualifyDstVlanGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityCommonGport:
                if ((qual == bcmFieldQualifyDstGport) ||
                        (qual == bcmFieldQualifyDstGports)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityL3Egress:
                dst_fwd_entity_status
                    = (qual == bcmFieldQualifyDstL3Egress)
                        ? TRUE : (qual == bcmFieldQualifyDstL3EgressNextHops)
                        ? TRUE : FALSE;
                break;
            case _bcmFieldFwdEntityMulticastGroup:
                if ((qual == bcmFieldQualifyDstMulticastGroup) ||
                        (qual == bcmFieldQualifyDstMulticastGroups)) {
                    dst_fwd_entity_status = TRUE;
                } else {
                    dst_fwd_entity_status = FALSE;
                }
                break;
            case _bcmFieldFwdEntityMultipath:
                dst_fwd_entity_status =
                    (qual == bcmFieldQualifyDstMultipath) ? TRUE: FALSE;
                break;
            default:
                dst_fwd_entity_status = FALSE;
        }
        if (TRUE == dst_fwd_entity_status) {
            break;
        }
    }

    if (FALSE == dst_fwd_entity_status) {
        return BCM_E_NONE;
    } else {
        switch (qual) {
            case bcmFieldQualifyDstMplsGport:
            case bcmFieldQualifyDstNivGport:
            case bcmFieldQualifyDstMimGport:
            case bcmFieldQualifyDstWlanGport:
            case bcmFieldQualifyDstVxlanGport:
            case bcmFieldQualifyDstVlanGport:
            case bcmFieldQualifyDstMplsGports:
            case bcmFieldQualifyDstNivGports:
            case bcmFieldQualifyDstMimGports:
            case bcmFieldQualifyDstWlanGports:
            case bcmFieldQualifyDstVxlanGports:
            case bcmFieldQualifyDstVlanGports:
                _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeDvp);
                break;
            case bcmFieldQualifyDstL3Egress:
            case bcmFieldQualifyDstL3EgressNextHops:
                _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeNhi);
                break;
            case bcmFieldQualifyDstMultipath:
                _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeEcmp);
                break;
            case bcmFieldQualifyDstMulticastGroup:
            case bcmFieldQualifyDstMulticastGroups:
                if (flags & _bcmFieldDestTypeL3mc) {
                    _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeL3mc);
                } else if (flags & _bcmFieldDestTypeL2mc) {
                    _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeL2mc);
                } else {
                    return BCM_E_INTERNAL;
                }
                break;
            case bcmFieldQualifyDstGport:
            case bcmFieldQualifyDstGports:
                if (flags & _bcmFieldDestTypeDglp) {
                    _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeDglp);
                } else if (flags & _bcmFieldDestTypeDvp) {
                    _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeDvp);
                } else {
                    return BCM_E_INTERNAL;
                }
                break;
            default:
                _FIELD_D_TYPE_INSERT(*data, _bcmFieldDestTypeDglp);
        }
    }

    if ((bcmFieldQualifyDstL3EgressNextHops == qual)
        || (bcmFieldQualifyDstTrunk == qual)
        || (bcmFieldQualifyDstMulticastGroups == qual)
        || (bcmFieldQualifyDstPort == qual)) {
        _FIELD_D_TYPE_MASK_INSERT(*mask);
    } else if ((qual != bcmFieldQualifyDstGports) &&
            (qual != bcmFieldQualifyDstWlanGports) &&
            (qual != bcmFieldQualifyDstVlanGports) &&
            (qual != bcmFieldQualifyDstVxlanGports) &&
            (qual != bcmFieldQualifyDstMimGports) &&
            (qual != bcmFieldQualifyDstNivGports) &&
            (qual != bcmFieldQualifyDstMulticastGroups) &&
            (qual != bcmFieldQualifyDstMplsGports)) {
        *mask = (BCM_FIELD_EXACT_MATCH_MASK);
    }
#endif /* !BCM_TRIUMPH2_SUPPORT */
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_qual_conf_t_init
 * Purpose:
 *     Initialize qualifier configuration structure.
 * Parameters:
 *     ptr  - (OUT) Pointer to field qualifier configuration strucutre.
 *
 * Returns:
 *     Void.
 */
void
_bcm_field_qual_conf_t_init(_bcm_field_qual_conf_t *ptr)
{
    _bcm_field_selector_t  *selector;

    if (NULL == ptr) {
        return;
    }

    /* Reset qualifier configuration structure. */
    sal_memset(ptr, 0, sizeof(_bcm_field_qual_conf_t));

    /* Set Selectors to Don't care. */
    selector           = &ptr->selector;
    selector->dev_sel  = _bcmFieldDevSelDisable;
    selector->pri_sel  = _bcmFieldSliceSelDisable;
    selector->sec_sel  = _bcmFieldSliceSelDisable;

    return;
}

/*
 * Function:
 *     _bcm_field_qual_info_t_init
 * Purpose:
 *     Initialize qualifier info structure.
 * Parameters:
 *     ptr  - (OUT) Pointer to field qualifier info strucutre.
 *
 * Returns:
 *     Void.
 */
void
_bcm_field_qual_info_t_init(_bcm_field_qual_info_t *ptr)
{
    /* Input parameters check. */
    if (NULL == ptr) {
        return;
    }

    /* Reset qualifier configuration structure. */
    sal_memset(ptr, 0, sizeof(_bcm_field_qual_info_t));

    return;
}

/*
 * Function:
 *     _bcm_field_qual_insert
 * Purpose:
 *     Add qualifier to stage qualifers list.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control strucutre.
 *     qual_type - (IN) Type of Qualifier.
 *     qual_id   - (IN) Qualifier Id.
 *     ptr       - (IN) Reference to qual configuration structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_insert (int unit, _field_stage_t *stage_fc, int qual_type,
                        int qual_id, _bcm_field_qual_conf_t *ptr)
{
    _bcm_field_qual_info_t *f_qual = NULL;        /* Field qualifier info.    */
    _bcm_field_qual_conf_t *f_qual_conf = NULL;   /* Qualifier configuration. */
    int alloc_size;                               /* Memory allocation size.  */

    /* Input parameters check. */
    if ((NULL == ptr) || (NULL == stage_fc) ||
        (qual_id < 0) || (qual_id > _bcmFieldQualifyCount)) {
        return BCM_E_PARAM;
    }

    /* Check qualifier support based on flag. */
    if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) &&
           (ptr->offset.flags & _BCM_FIELD_QUAL_OFFSET_NO_IFP_SUPPORT)) {
        return BCM_E_NONE;
    }
    if ((_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id) &&
            (ptr->offset.flags & _BCM_FIELD_QUAL_OFFSET_NO_EM_SUPPORT)) {
        return BCM_E_NONE;
    }

    /* Assign the stage qual_arr based on the qualifier type */
    if (qual_type == _bcmFieldQualifierTypePresel) {
       if (!soc_feature(unit, soc_feature_field_preselector_support)) {
          return BCM_E_INTERNAL;
       }
       f_qual = stage_fc->f_presel_qual_arr[qual_id];
    } else {
       f_qual = stage_fc->f_qual_arr[qual_id];
    }

    /* Allocate qualifier descriptor. */
    if (NULL == f_qual) {
        alloc_size = sizeof(_bcm_field_qual_info_t);
        _FP_XGS3_ALLOC(f_qual, alloc_size, "FP qualifier info");
        if (NULL == f_qual) {
            return (BCM_E_MEMORY);
        }
        _bcm_field_qual_info_t_init(f_qual);
        f_qual->qid = qual_id;
    }

    /* Allocate qualifier configurations array. */
    /* Re-alloc configuration array if qualifier has multiple configurations. */
    alloc_size = (f_qual->conf_sz + 1) * sizeof (_bcm_field_qual_conf_t);

    /* Allocated qualifier descriptor. */
    _FP_XGS3_ALLOC(f_qual_conf, alloc_size, "FP qualifier config");
    if (NULL == f_qual_conf) {
        if (NULL != f_qual->conf_arr) {
           sal_free(f_qual->conf_arr);
        }
        sal_free(f_qual);
        if (qual_type == _bcmFieldQualifierTypePresel) {
           stage_fc->f_presel_qual_arr[qual_id] = NULL;
        } else {
           stage_fc->f_qual_arr[qual_id] = NULL;
        }
        return (BCM_E_MEMORY);
    }

    /* Copy previous configurations if any.  */
    if (NULL != f_qual->conf_arr) {
        alloc_size -= sizeof(_bcm_field_qual_conf_t);
        sal_memcpy (f_qual_conf, f_qual->conf_arr, alloc_size);
        sal_free(f_qual->conf_arr);
    }

    /* Set configuration array pointer to a new array. */
    f_qual->conf_arr = f_qual_conf;

    /* Copy new configuration to configuration array. */
    f_qual->conf_arr[f_qual->conf_sz] = *ptr;

    /* Increment number of active configurations. */
    f_qual->conf_sz++;

    /* Install qualifier into stage qualifiers array. */
    if (qual_type == _bcmFieldQualifierTypePresel) {
       stage_fc->f_presel_qual_arr[qual_id] = f_qual;
    } else {
       stage_fc->f_qual_arr[qual_id] = f_qual;
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *      _field_selector_update_cmp
 * Purpose:
 *      Compare number of update required in order to use
 *      a qualifier select code.
 * Parameters:
 *      b - (IN) first compared selector.
 *      a - (IN) second compared selector.
 * Returns:
 *      a<=>b
 */
STATIC INLINE int
_field_selector_update_cmp(void *a, void *b)
{
    _bcm_field_qual_conf_t *first;     /* First compared selector.  */
    _bcm_field_qual_conf_t *second;    /* Second compared selector. */

    first = (_bcm_field_qual_conf_t *)a;
    second = (_bcm_field_qual_conf_t *)b;

    if (first->selector.update_count <
        second->selector.update_count) {
        return (-1);
    } else if (first->selector.update_count >
               second->selector.update_count) {
        return (1);
    }
    return (0);
}

/*
 * Function:
 *      _field_qual_info_cmp
 * Purpose:
 *      Compare frequency of two qualifiers appearance.
 * Parameters:
 *      b - (IN) first compared qualifier.
 *      a - (IN) second compared qualifier.
 * Returns:
 *      a<=>b
 */
STATIC INLINE int
_field_qual_info_cmp (void *a, void *b)
{
    _bcm_field_qual_info_t **first;     /* First compared qualifier.  */
    _bcm_field_qual_info_t **second;    /* Second compared qualifier. */

    first = (_bcm_field_qual_info_t **)a;
    second = (_bcm_field_qual_info_t **)b;

    if ((*first)->conf_sz < (*second)->conf_sz) {
        return (-1);
    } else if ((*first)->conf_sz > (*second)->conf_sz) {
        return (1);
    }
    return (0);
}

/*
 * Function:
 *     _field_selector_insert
 * Purpose:
 *     Insert selector into a specific tcam part of the entry.
 * Parameters:
 *     sel_arr     - (IN) Current entry select codes.
 *     part_idx    - (IN) Tcam part index.
 *     selector     - (IN) Inserted selector.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_selector_insert (_field_sel_t *sel_arr, int part_idx,
                        _bcm_field_selector_t *selector)
{
    _field_sel_t *tcam_part;   /* Tcam part selectors. */

    /* Input parameters check. */
    if ((NULL == sel_arr) || (NULL == selector)) {
        return (BCM_E_PARAM);
    }

    tcam_part = sel_arr + part_idx;

    /* Per device selector. */
    switch (selector->dev_sel) {
      case _bcmFieldDevSelDisable:
          break;
      case _bcmFieldDevSelInnerVlanOverlay:
          sel_arr[0].inner_vlan_overlay = selector->dev_sel_val;
          break;
      case _bcmFieldDevSelIntrasliceVfpKey:
          sel_arr[0].intraslice_vfp_sel = selector->dev_sel_val;
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    /* Primary slice selector. */
    switch (selector->pri_sel) {
      case _bcmFieldSliceSelDisable:
          break;
      case _bcmFieldSliceSelFpf1:
          tcam_part->fpf1 = selector->pri_sel_val;
          break;
      case _bcmFieldSliceSelFpf2:
          tcam_part->fpf2 = selector->pri_sel_val;
          break;
      case _bcmFieldSliceSelFpf3:
          tcam_part->fpf3 = selector->pri_sel_val;
          break;
      case _bcmFieldSliceSelFpf4:
          tcam_part->fpf4 = selector->pri_sel_val;
          break;
      case _bcmFieldSliceSelExternal:
          tcam_part->extn = selector->pri_sel_val;
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    /* Per slice selectors are inserted into primary slice only. */
    if ((selector->intraslice) && (0 != part_idx)) {
        tcam_part = sel_arr + (part_idx - 1);
    }

    /* Secondary slice selector. */
    switch (selector->sec_sel) {
    case _bcmFieldSliceSelDisable:
        break;
    case _bcmFieldSliceSrcClassSelect:
        tcam_part->src_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceDstClassSelect:
        tcam_part->dst_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceIntfClassSelect:
        tcam_part->intf_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceLoopbackTypeSelect:
        tcam_part->loopback_type_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceIngressEntitySelect:
        tcam_part->ingress_entity_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSrcEntitySelect:
        tcam_part->src_entity_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceDstFwdEntitySelect:
        tcam_part->dst_fwd_entity_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceFwdFieldSelect:
        tcam_part->fwd_field_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceIpHeaderSelect:
        tcam_part->ip_header_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSrcTypeSelect:
        tcam_part->src_type_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceIp6AddrSelect:
        tcam_part->ip6_addr_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceAuxTag1Select:
        tcam_part->aux_tag_1_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceAuxTag2Select:
        tcam_part->aux_tag_2_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceOamOverLayEnable:
        tcam_part->oam_overlay_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceTtlClassSelect:
        tcam_part->ttl_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceTcpClassSelect:
        tcam_part->tcp_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceTosClassSelect:
        tcam_part->tos_class_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF1:
        tcam_part->egr_class_f1_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF2:
        tcam_part->egr_class_f2_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF3:
        tcam_part->egr_class_f3_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF4:
        tcam_part->egr_class_f4_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF6:
        tcam_part->egr_class_f6_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF7:
        tcam_part->egr_class_f7_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF8:
        tcam_part->egr_class_f8_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrDvpKey4:
        tcam_part->egr_key4_dvp_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrDvpKey8:
        tcam_part->egr_key8_dvp_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrMdlKey4:
        tcam_part->egr_key4_mdl_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrOamOverlayKey4:
        tcam_part->egr_oam_overlay_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrDestPortF1:
        tcam_part->egr_dest_port_f1_sel = selector->sec_sel_val;
        break;
    case _bcmFieldSliceSelEgrDestPortF5:
        tcam_part->egr_dest_port_f5_sel = selector->sec_sel_val;
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    /* Tertiary slice selector */
    switch (selector->ter_sel) {
    case _bcmFieldSliceSelDisable:
        break;
    case _bcmFieldSliceFpf1SrcDstClassSelect:
        tcam_part->src_dest_class_f1_sel = selector->ter_sel_val;
        break;
    case _bcmFieldSliceFpf3SrcDstClassSelect:
        tcam_part->src_dest_class_f3_sel = selector->ter_sel_val;
        break;
    case _bcmFieldSliceOamInterfaceClassSelect:
        tcam_part->oam_intf_class_sel = selector->ter_sel_val;
        break;
    case _bcmFieldSliceSelEgrClassF6:
        tcam_part->egr_class_f6_sel = selector->ter_sel_val;
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_selector_diff
 * Purpose:
 *     Compare selector configuration with current selectors
 *     status of field group entry.
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     sel_arr     - (IN) Current entry select codes.
 *     part_idx    - (IN) Tcam part index.
 *     selector    - (IN) Compared selector.
 *     diff_count  - (OUT) Number of different elements.
 * Returns:
 *     BCM_E_XXX
 * NOTE:
 *     Function returns BCM_E_RESOURCE if configurations are conflicting.
 */
int
_field_selector_diff(int unit, _field_sel_t *sel_arr, int part_idx,
                     _bcm_field_selector_t *selector,
                     uint8 *diff_count)
{
    uint8 count;                   /* Required updates count. */
    _field_sel_t *tcam_part;       /* Tcam part selectors.    */
#if defined(BCM_FIREBOLT_SUPPORT)
    int temp;                      /* Temporary test variable.*/
    int rv;                        /* Operation return status.*/
#endif /* BCM_FIREBOLT_SUPPORT */

    /* Input parameters check. */
    if ((NULL == sel_arr) || (NULL == selector) || (NULL == diff_count)) {
        return (BCM_E_PARAM);
    }

    count = 0;
    tcam_part = sel_arr + part_idx;

    /* Qualifier is available in the second part of intraslice entry */
    if (selector->intraslice) {
        if (_FP_SELCODE_DONT_USE == tcam_part->intraslice) {
            return (BCM_E_RESOURCE);
        }
    } else {
        if (_FP_SELCODE_DONT_USE != tcam_part->intraslice) {
            return (BCM_E_RESOURCE);
        }
    }

    /* Qualifier is available only in the primary part of a paired
       entry */

    if (selector->primary) {
        if (part_idx % 2) {
            return (BCM_E_RESOURCE);
        }
    }

    /* Qualifier is available only in the secondary part of a paired
       entry */

    if (selector->secondary) {
        if (_FP_SELCODE_DONT_USE == tcam_part->secondary) {
            return (BCM_E_RESOURCE);
        }
    }

    /* Per device selectors. */
    switch (selector->dev_sel) {
      case _bcmFieldDevSelDisable:
          break;
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_RAVEN_SUPPORT)
      case _bcmFieldDevSelInnerVlanOverlay:
          rv = _bcm_field_fb_group_inner_vlan_overlay_get(unit, &temp);
          BCM_IF_ERROR_RETURN(rv);
          if (((_FP_SELCODE_DONT_CARE != temp)  &&
               (temp != selector->dev_sel_val)) ||
              ((_FP_SELCODE_DONT_CARE != sel_arr[0].inner_vlan_overlay) &&
               (sel_arr[0].inner_vlan_overlay != selector->dev_sel_val))) {
              return (BCM_E_RESOURCE);
          }
          break;
#endif /* BCM_FIREBOLT_SUPPORT */
#if defined(BCM_FIREBOLT2_SUPPORT)
      case _bcmFieldDevSelIntrasliceVfpKey:
          rv = _bcm_field_vfp_doublewide_key_select_get(unit, &temp);
          BCM_IF_ERROR_RETURN(rv);
          if (((_FP_SELCODE_DONT_CARE != temp)  &&
               (temp != selector->dev_sel_val)) ||
              ((_FP_SELCODE_DONT_CARE != sel_arr[0].intraslice_vfp_sel) &&
               (sel_arr[0].intraslice_vfp_sel != selector->dev_sel_val))) {
              return (BCM_E_RESOURCE);
          }
          break;
#endif /* BCM_FIREBOLT2_SUPPORT */
      default:
          return (BCM_E_INTERNAL);
    }


    /* Primary slice selector. */
    switch (selector->pri_sel) {
      case _bcmFieldSliceSelDisable:
          break;
      case _bcmFieldSliceSelFpf1:
          if (tcam_part->fpf1 == _FP_SELCODE_DONT_CARE) {
              count++;
          } else if (tcam_part->fpf1 != selector->pri_sel_val) {
              return (BCM_E_RESOURCE);
          }
          break;
      case _bcmFieldSliceSelFpf2:
          if (tcam_part->fpf2 == _FP_SELCODE_DONT_CARE) {
              count++;
          } else if (tcam_part->fpf2 != selector->pri_sel_val) {
              return (BCM_E_RESOURCE);
          }
          break;
      case _bcmFieldSliceSelFpf3:
          if (tcam_part->fpf3 == _FP_SELCODE_DONT_CARE) {
              count++;
          } else if (tcam_part->fpf3 != selector->pri_sel_val) {
              return (BCM_E_RESOURCE);
          }
          break;
      case _bcmFieldSliceSelFpf4:
          if (tcam_part->fpf4 == _FP_SELCODE_DONT_CARE) {
              count++;
          } else if (tcam_part->fpf4 != selector->pri_sel_val) {
              return (BCM_E_RESOURCE);
          }
          break;
      case _bcmFieldSliceSelExternal:
          if (tcam_part->extn == _FP_SELCODE_DONT_CARE) {
              count++;
          } else if (tcam_part->extn != selector->pri_sel_val) {
              return (BCM_E_RESOURCE);
          }
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    /* Secondary slice selector. */
    /* Per slice selectors are inserted into primary slice only. */
    if ((selector->intraslice) && (0 != part_idx)) {
        tcam_part = sel_arr + (part_idx - 1);
    }

    switch (selector->sec_sel) {
    case _bcmFieldSliceSelDisable:
        break;
    case _bcmFieldSliceSrcClassSelect:
        if (tcam_part->src_class_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->src_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceDstClassSelect:
        if (tcam_part->dst_class_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->dst_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceIntfClassSelect:
        if (tcam_part->intf_class_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->intf_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceLoopbackTypeSelect:
        if (tcam_part->loopback_type_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->loopback_type_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceIngressEntitySelect:
        if (tcam_part->ingress_entity_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->ingress_entity_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSrcEntitySelect:
        if (tcam_part->src_entity_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->src_entity_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceDstFwdEntitySelect:
        if (tcam_part->dst_fwd_entity_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->dst_fwd_entity_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceFwdFieldSelect:
        if (tcam_part->fwd_field_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->fwd_field_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceIpHeaderSelect:
        if (tcam_part->ip_header_sel== _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->ip_header_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSrcTypeSelect:
        if (tcam_part->src_type_sel== _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->src_type_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceIp6AddrSelect:
        if (tcam_part->ip6_addr_sel == _FP_SELCODE_DONT_CARE) {
            count++;
        } else if (tcam_part->ip6_addr_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceAuxTag1Select:
        if (tcam_part->aux_tag_1_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->aux_tag_1_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceAuxTag2Select:
        if (tcam_part->aux_tag_2_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->aux_tag_2_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceOamOverLayEnable:
        if (tcam_part->oam_overlay_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->oam_overlay_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF1:
        if (tcam_part->egr_class_f1_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f1_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF2:
        if (tcam_part->egr_class_f2_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f2_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF3:
        if (tcam_part->egr_class_f3_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f3_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF4:
        if (tcam_part->egr_class_f4_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f4_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF6:
        if (tcam_part->egr_class_f6_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f6_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF7:
        if (tcam_part->egr_class_f7_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f7_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF8:
        if (tcam_part->egr_class_f8_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f8_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrDvpKey4:
        if (tcam_part->egr_key4_dvp_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_key4_dvp_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrDvpKey8:
        if (tcam_part->egr_key8_dvp_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_key8_dvp_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrMdlKey4:
        if (tcam_part->egr_key4_mdl_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_key4_mdl_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrOamOverlayKey4:
        if (tcam_part->egr_oam_overlay_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_oam_overlay_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrDestPortF1:
        if (tcam_part->egr_dest_port_f1_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_dest_port_f1_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrDestPortF5:
        if (tcam_part->egr_dest_port_f5_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_dest_port_f5_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceTtlClassSelect:
        if (tcam_part->ttl_class_sel== _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->ttl_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceTcpClassSelect:
        if (tcam_part->tcp_class_sel== _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->tcp_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceTosClassSelect:
        if (tcam_part->tos_class_sel== _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->tos_class_sel != selector->sec_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    /* Tertiary slice selector */
    switch (selector->ter_sel) {
    case _bcmFieldSliceSelDisable:
        break;
    case _bcmFieldSliceFpf1SrcDstClassSelect:
        if (tcam_part->src_dest_class_f1_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->src_dest_class_f1_sel != selector->ter_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceFpf3SrcDstClassSelect:
        if (tcam_part->src_dest_class_f3_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->src_dest_class_f3_sel != selector->ter_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceOamInterfaceClassSelect:
        if (tcam_part->oam_intf_class_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->oam_intf_class_sel != selector->ter_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    case _bcmFieldSliceSelEgrClassF6:
        if (tcam_part->egr_class_f6_sel == _FP_SELCODE_DONT_CARE) {
            ++count;
        } else if (tcam_part->egr_class_f6_sel != selector->ter_sel_val) {
            return (BCM_E_RESOURCE);
        }
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    *diff_count = count;

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_slice_is_empty
 *
 * Purpose:
 *     Report if a slice has any entries.
 *
 * Parameters:
 *     fc     - (IN) Field control structure.
 *     fs     - (IN) Slice control structure.
 *     empty - (OUT) True - slice is empty/False otherwise.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_is_empty(int unit, _field_slice_t *fs, uint8 *empty)
{
    int ratio = 1;                  /* Free to Total entry ratio.     */

    /* Input parameters check. */
    if (NULL == fs) {
        return (BCM_E_PARAM);
    }

    if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
        ratio = 2;
    }

    if (fs->entry_count == ratio * fs->free_count) {
        *empty = TRUE;
    } else {
        *empty = FALSE;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_group_status_init
 * Purpose:
 *     Initialize bcm_field_group_status_t structure.
 * Parameters:
 *     unit  -  (IN)BCM unit number.
 *     entry -  (OUT)Initialized field group status structure.
 * Retruns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_status_init(int unit, bcm_field_group_status_t *entry)
{
    /* Input parameters check. */
    if (NULL == entry) {
        return (BCM_E_PARAM);
    }

    sal_memset(entry, 0,  sizeof(bcm_field_group_status_t));

    entry->prio_min = BCM_FIELD_GROUP_PRIO_ANY;
    entry->prio_max = BCM_FIELD_ENTRY_PRIO_HIGHEST;
    entry->entries_total = -1;
    entry->entries_free = -1;
    entry->counters_total = -1;
    entry->counters_free = -1;
    entry->meters_total = -1;
    entry->meters_free = -1;
    entry->entry_count = 0;
    entry->counter_count = 0;
    entry->meter_count = 0;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_stage_entries_free
 * Purpose:
 *     Free entries array for all stage slices.
 * Parameters:
 *     unit     -  (IN)BCM unit number.
 *     stage_fc -  (IN)Stage field control
 * Retruns:
 *     BCM_E_XXX
 */
int
_bcm_field_stage_entries_free(int unit, _field_stage_t *stage_fc)
{
    _field_slice_t *fs;   /* Field slice pointer.   */
    int idx;              /* Slice iteration index. */

    /* Input parameters check */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }
    /* Deallocate the entry pointers */
    for (idx = 0; idx < stage_fc->tcam_slices; idx++) {
        fs = stage_fc->slices[_FP_DEF_INST] + idx;
        if (NULL != fs->entries) {
            sal_free(fs->entries);
            fs->entries = NULL;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_control_get
 * Purpose:
 *     Lookup a FP control config from a bcm device id.
 * Parameters:
 *     unit -  (IN)BCM unit number.
 *     fc   -  (OUT) Field control structure.
 * Retruns:
 *     BCM_E_XXX
 */
int
_field_control_get(int unit, _field_control_t **fc)
{
    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    /* Make sure system was initialized. */
    FIELD_IS_INIT(unit);

    /* Fill field control structure. */
    *fc = _field_control[unit];

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_egr_ports_recovery_control_get
 * Purpose:
 *     Lookup a FP EGR_PORTS_RECOVERY config
 *     from a bcm device id.
 * Parameters:
 *     unit           -  (IN) BCM unit number.
 *     f_egr_recovery - (OUT) Field Egr_ports_recovery
 *                            structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_egr_ports_recovery_control_get(int unit,
         _field_egr_ports_recovery_t **f_egr_recovery)
{
    /* Input parameters check. */
    if (NULL == f_egr_recovery) {
        return (BCM_E_PARAM);
    }

    /* Fill field control structure. */
    *f_egr_recovery = _field_egr_ports_recovery[unit];

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stage_control_get
 * Purpose:
 *     Lookup stage FP control config from bcm device id and
 *     pipeline stage number.
 * Parameters:
 *     unit      -  (IN)BCM unit number.
 *     stage_id  -  (IN)Pipeline stage id number.
 *     stage_fc  -  (OUT) Stage Field control structure.
 * Retruns:
 *     BCM_E_XXX
 */
int
_field_stage_control_get(int unit, _field_stage_id_t stage_id,
                          _field_stage_t **stage_fc)
{
    _field_stage_t *stage_p;  /* Stages iteration pointer. */

    FIELD_IS_INIT(unit);                                      \

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Check that module was initialized. */
    if (NULL == (_field_control[unit])->stages) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Stage (%d) is not initialized.\n"),
                   unit, stage_id));
        return (BCM_E_INIT);
    }

    /* Find a stage with stage_id equals to stage. */
    stage_p = (_field_control[unit])->stages;
    while (stage_p) {
        if (stage_p->stage_id == stage_id) {
            break;
        }
        stage_p = stage_p->next;
    }

    if (NULL == stage_p) {
        if(((_field_control[unit])->flags & _FP_EXTERNAL_PRESENT) ||
            (_BCM_FIELD_STAGE_EXTERNAL != stage_id))
        {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Unknown pipeline stage (%d).\n"),
                     unit, stage_id));
        }
        if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
            return (BCM_E_UNAVAIL);
        } else if (_BCM_FIELD_STAGE_EXACTMATCH == stage_id) {
            return (BCM_E_UNAVAIL);
        } else if (_BCM_FIELD_STAGE_CLASS == stage_id) {
            return (BCM_E_UNAVAIL);
        } else if (((stage_id == _BCM_FIELD_STAGE_EGRESS) ||
            (stage_id == _BCM_FIELD_STAGE_LOOKUP)) &&
            (!soc_feature(unit, soc_feature_field_multi_stage))) {
            return (BCM_E_UNAVAIL);
        } else {
            return (BCM_E_NOT_FOUND);
        }
    }

    /* Fill stage field control structure. */
    *stage_fc = stage_p;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_get
 * Purpose:
 *     Lookup a group information on specified bcm device.
 * Parameters:
 *     unit - (IN)BCM device number.
 *     gid  - (IN)Group ID.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_get(int unit, bcm_field_group_t gid, _field_group_t **group_p)
{
    _field_control_t    *fc;          /* Unit FP control structure. */
    _field_group_t      *fg;          /* Group information.         */

    if (NULL == group_p) {
        return (BCM_E_PARAM);
    }

    /* Get unit FP control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Iterate over the groups linked-list looking for a matching Group ID */
    fg = fc->groups;
    while (fg != NULL) {
        if (fg->gid == gid) {
            *group_p = fg;
            return (BCM_E_NONE);
        }
        fg = fg->next;
    }
    /* Group with id == gid not found. */
    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *     _bcm_field_group_id_generate
 *
 * Purpose:
 *     Find an unused Group ID.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - (OUT) new Group ID
 *
 * Returns:
 *     BCM_E_NONE  - Success
 *     BCM_E_PARAM - null pointer to group
 */
int
_bcm_field_group_id_generate(int unit, bcm_field_group_t *group)
{
    _field_group_t *group_p;  /* Group info. */

    /* Input parameters check. */
    if (NULL == group) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group == NULL\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    *group = _FP_ID_BASE;

    while (!BCM_FAILURE(_field_group_get(unit, *group, &group_p))) {
        (*group)++;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_entry_tcam_parts_count
 * Purpose:
 *     Get number of tcam entries needed to accomodate an entry.
 * Parameters:
 *     unit        - (IN)  BCM device number.
 *     group_flags - (IN)  Entry group flags.
 *     count       - (OUT) Entry parts count.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_entry_tcam_parts_count (int unit, _field_stage_id_t stage_id,
                                   uint32 group_flags, int *part_count)
{
    /* Input parameters check. */
    if (NULL == part_count) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == stage_id))) {
       return _bcm_field_th_entry_tcam_parts_count(unit, group_flags,
                                                   part_count);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (group_flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        if (group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            *part_count = 2;
        } else {
            *part_count = 1;
        }
    } else if (group_flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        if (group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            *part_count = 4;
        } else {
            *part_count = 2;
        }
    } else if (group_flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        *part_count = 3;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_entry_action_dirty
 * Purpose:
 *     Check if only action was modified for the entry after last installation
 * Parameters:
 *     unit        - (IN)  BCM device number.
 *     f_ent       - (IN)  Primary entry pointer.
 *     dirty       - (OUT) Entry dirty flag.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_action_dirty(int unit, _field_entry_t *f_ent, int *dirty)
{
    int parts_count = 0;               /* Entry tcam parts count.       */
    int idx;                           /* Entry parts iterator.         */
    int rv;                            /* Operation return status.      */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == dirty)) {
        return (BCM_E_PARAM);
    }

    /* Get number of tcam parts based on group flags. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                            f_ent->group->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Check entry dirty and action only dirty for all parts of the entry */
    for (idx = 0; idx < parts_count; idx++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: _field_entry_action_dirty() Part:%x EntryDirty:%x ActionOnlyDirty:%x\n"),
                   unit, idx, (f_ent[idx].flags & (_FP_ENTRY_DIRTY)),
                   (f_ent[idx].flags & (_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY))));
        /*
         * If entry dirty is set and action only dirty is not set,
         * it is likely a qualifier change, return FALSE.
         */
        if ((f_ent[idx].flags & _FP_ENTRY_DIRTY) &&
            (0 == (f_ent[idx].flags & _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY))) {
            *dirty = FALSE;
            return (BCM_E_NONE);
        }

        if ((f_ent[idx].flags & _FP_ENTRY_DIRTY) &&
            (f_ent[idx].flags & _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY)) {
            *dirty = TRUE;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_dirty
 * Purpose:
 *     Check if entry was modified after last installation
 * Parameters:
 *     unit        - (IN)  BCM device number.
 *     f_ent       - (IN)  Primary entry pointer.
 *     dirty       - (OUT) Entry dirty flag.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_dirty(int unit, _field_entry_t *f_ent, int *dirty)
{
    _field_entry_policer_t *f_ent_pl;  /* Field entry policer structure.*/
    _field_policer_t *f_pl;            /* Field policer descriptor.     */
    int parts_count = 0;               /* Entry tcam parts count.       */
    int idx;                           /* Entry parts iterator.         */
    int rv;                            /* Operation return status.      */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == dirty)) {
        return (BCM_E_PARAM);
    }

    /* Get number of tcam parts based on group flags. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                            f_ent->group->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* If any entry part was changed - reinstall is required. */
    for (idx = 0; idx < parts_count; idx++) {
         if (f_ent[idx].flags & _FP_ENTRY_DIRTY) {
            break;
        }
    }
    *dirty = (idx < parts_count) ? TRUE : FALSE;

    if (0 == (*dirty)) {
        /* Policer configuration updates check. */
        for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
            f_ent_pl = f_ent->policer + idx;
            /* Skip invalid policers. */
            if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
                continue;
            }
            /* Read policer configuration.*/
            rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
            BCM_IF_ERROR_RETURN(rv);

            /* Check if policer was modified. */
            if (f_pl->hw_flags & _FP_POLICER_DIRTY) {
                *dirty = TRUE;
                break;
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_entry_flags_to_tcam_part
 * Purpose:
 *     Each field entry contains up to 4 TCAM
 *     entries. This routine maps sw entry flags
 *     to tcam entry (0-3).
 *     Note this is not a physical address in tcam.
 *     Single: 0
 *     Single & Intraslice Double: 0, 1
 *     Paired: 0, 1
 *     Paired & Intraslice Double: 0, 1, 2, 3
 *     Triple: 0, 1, 2
 * Parameters:
 *     unit        - (IN)  Device number.
 *     entry_flags - (IN)  Entry flags.
 *     fg          - (IN)  Entry group structure.
 *     entry_part  - (OUT) Entry part (0-3)
 * Returns:
 *     BCM_E_NONE  - Success
 *     BCM_E_INTERNAL - Error
 */
int
_bcm_field_entry_flags_to_tcam_part (int unit, uint32 entry_flags,
                                     _field_group_t *fg,
                                     uint8 *entry_part)
{
    /* Input parameters check. */
    if (NULL == entry_part || NULL == fg) {
        return (BCM_E_PARAM);
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == fg->stage_id)) {
       return _bcm_field_th_entry_flags_to_tcam_part(unit, entry_flags,
                                                     fg->flags,
                                                     entry_part);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    if (entry_flags & _FP_ENTRY_PRIMARY) {
        if (entry_flags & _FP_ENTRY_SECOND_HALF) {
            *entry_part = 1;
        } else {
            *entry_part = 0;
        }
    } else if (entry_flags & _FP_ENTRY_SECONDARY) {
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            if (entry_flags & _FP_ENTRY_SECOND_HALF) {
                *entry_part = 3;
            } else {
                *entry_part = 2;
            }
        } else {
            *entry_part= 1;
        }
    } else if (entry_flags & _FP_ENTRY_TERTIARY) {
        *entry_part = 2;
    } else {
        return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_tcam_part_to_entry_flags
 * Purpose:
 *     Each field entry contains up to 4 TCAM
 *     entries. This routine maps tcam entry (0-3)
 *     to SW entry flags.
 *     Single: 0
 *     Single & Intraslice Double: 0, 1
 *     Paired: 0, 1
 *     Paired & Intraslice Double: 0, 1, 2, 3
 *     Triple: 0, 1, 2
 *     Retrieve the part of the group entry resides in.
 * Parameters:
 *     unit        - (IN)  Device number.
 *     entry_part  - (IN)  Entry Part number.
 *     fg          - (IN)  Group Structure.
 *     entry_flags - (OUT) Entry Flags.
 * Returns:
 *     BCM_E_NONE  - Success
 *     BCM_E_INTERNAL - Error
 */
int
_bcm_field_tcam_part_to_entry_flags(int unit, int entry_part,
                                    _field_group_t *fg,
                                    uint32 *entry_flags)
{
    /* Input parameters check. */
    if (NULL == entry_flags || NULL == fg) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
       return _bcm_field_th_tcam_part_to_entry_flags(unit, entry_part,
                                                     fg->flags,
                                                     entry_flags);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    switch (entry_part) {
      case 0:
          *entry_flags = _FP_ENTRY_PRIMARY;
          break;
      case 1:
          if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
              *entry_flags = _FP_ENTRY_PRIMARY | _FP_ENTRY_SECOND_HALF;
          } else {
              *entry_flags = _FP_ENTRY_SECONDARY;
          }
          break;
      case 2:
          if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
              *entry_flags = _FP_ENTRY_SECONDARY;
          } else {
              *entry_flags = _FP_ENTRY_TERTIARY;
          }
          break;
      case 3:
          *entry_flags = _FP_ENTRY_SECONDARY | _FP_ENTRY_SECOND_HALF;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_tcam_part_to_slice_number
 * Purpose:
 *     Each field entry contains up to 4 TCAM
 *     entries. This routine maps tcam entry (0-3)
 *     to a slice number
 * Parameters:
 *     unit         - (IN)  Unit
 *     entry_part   - (IN)  Entry Part number.
 *     fg           - (IN)  Field Group Structure.
 *     slice_number - (OUT) Slice number (0-2)
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_tcam_part_to_slice_number(int unit,
                                     int entry_part,
                                     _field_group_t *fg,
                                     uint8 *slice_number)
{
    /* Input parameters check. */
    if (NULL == slice_number || NULL == fg) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == fg->stage_id)) {
       return _bcm_field_th_tcam_part_to_slice_number(entry_part, fg->flags,
                                                      slice_number);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    switch (entry_part) {
      case 0:
          *slice_number = 0;
          break;
      case 1:
          if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
              *slice_number = 0;
          } else {
              *slice_number = 1;
          }
          break;
      case 2:
          if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
              *slice_number = 1;
          } else {
              *slice_number = 2;
          }
          break;
      case 3:
          *slice_number = 1;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_slice_idx_change
 * Purpose:
 *     Move the software entry to a new slice index.
 * Parmeters:
 *     unit    - (IN) BCM device number.
 *     f_ent   - (IN/OUT) Field entry to be moved.
 *     amount  - (IN) Number of indexes to move + or -.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entry_slice_idx_change(int unit, _field_entry_t *f_ent,
                              int parts_count, int *tcam_idx_new)
{
    _field_slice_t *fs;          /* Field slice control structure. */
    _field_stage_t *stage_fc;    /* Stage field control structure. */
    int new_slice_numb = 0;      /* Entry new slice number.        */
    int new_slice_idx = 0;       /* Entry new offset in the slice  */
    int instance;                /* Pipe Instance.                 */
    int idx;                     /* Iteration index.               */
    int rv;                      /* Operation return status.       */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->group) || (NULL == f_ent->fs)) {
        return (BCM_E_PARAM);
    }

    /*  Get stage control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Retrieve instance */
    instance = f_ent->group->instance;

    for (idx = 0; idx < parts_count; idx++) {
        /* Get slice control structure. */
        fs = f_ent[idx].fs;

        /* Move the software entry to the new index. */
        if (prio_set_with_no_free_entries == FALSE) {
            fs->entries[f_ent[idx].slice_idx] = NULL;
        }

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                 (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
            rv = _bcm_field_th_tcam_idx_to_slice_offset(unit, stage_fc,
                                                        f_ent,
                                                        tcam_idx_new[idx],
                                                        &new_slice_numb,
                                                        &new_slice_idx);
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
           /* Calculate entry new slice & offset in the slice. */
           rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc,
                                                  instance,
                                                  tcam_idx_new[idx],
                                                  &new_slice_numb,
                                                  &new_slice_idx);
        }
        BCM_IF_ERROR_RETURN(rv);

        /* If entry moves across the slices update free/used counters. */
        if ((f_ent[idx].fs->slice_number != new_slice_numb) &&
            (0 == (f_ent[idx].flags & _FP_ENTRY_SECOND_HALF))) {
            fs->free_count++;
            stage_fc->slices[instance][new_slice_numb].free_count--;
        }

        /* Update entry structure. */
        stage_fc->slices[instance][new_slice_numb].entries[new_slice_idx]
            = f_ent + idx;
        f_ent[idx].fs = &stage_fc->slices[instance][new_slice_numb];
        f_ent[idx].slice_idx = new_slice_idx;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_entry_t_compare
 * Purpose:
 *      Compare entry id in _field_entry_t structure.
 * Parameters:
 *      b - (IN) first compared qualifier.
 *      a - (IN) second compared qualifier.
 * Returns:
 *      a<=>b
 */
STATIC INLINE int
_field_entry_t_compare(void *a, void *b)
{
    _field_entry_t **first;     /* First compared entry.  */
    _field_entry_t **second;    /* Second compared entry. */

    first = (_field_entry_t **)a;
    second = (_field_entry_t **)b;

    if ((*first)->eid < (*second)->eid) {
        return (-1);
    } else if ((*first)->eid > (*second)->eid) {
        return (1);
    }
    return (0);
}

/*
 * Function:
 *     _field_entry_get
 * Purpose:
 *     Lookup a FP rule(entry) from a unit ID and slice & rule id choice.
 * Parmeters:
 *     unit    - (IN)BCM device number.
 *     eid     - (IN)Entry id.
 *     flags   - (IN)Entry flags to match.
 *     entry_p - (OUT) Entry lookup result.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_get(int unit, bcm_field_entry_t eid, uint32 flags,
                  _field_entry_t **entry_p)
{
    _field_entry_t   target;  /* Entry lookup pointer.    */
    _field_entry_t   *f_ent;  /* Entry lookup pointer.    */
    _field_control_t *fc;     /* Field control structure. */
    _field_group_t   *fg;     /* Field group iterator.    */
    uint8  entry_part = 0;    /* Wide entry part number.  */
    int    idx;               /* Entry index.             */

    /* Input parameters check. */
    if (NULL == entry_p) {
        return (BCM_E_PARAM);
    }

    /* Reset target entry */
    target.eid = eid;
    f_ent = &target;

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    fg = fc->groups;
    while (NULL != fg)  {
        /* Skip empty groups. */
        if (NULL == fg->entry_arr) {
            fg = fg->next;
            continue;
        }
        idx = _shr_bsearch(fg->entry_arr, fg->group_status.entry_count,
                           sizeof(_field_entry_t *), (void *)&f_ent,
                           _field_entry_t_compare);
        if (idx >= 0) {
            (void)_bcm_field_entry_flags_to_tcam_part(unit, flags,
                                                      fg,
                                                      &entry_part);
            *entry_p = fg->entry_arr[idx] + entry_part;
            return (BCM_E_NONE);
        }
        fg = fg->next;
    }
    /* Rule with id == eid not found. */
    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *     _field_group_entry_add
 * Purpose:
 *     Insert an entry to field group entry array.
 * Parmeters:
 *     unit    - (IN)BCM device number.
 *     fg      - (IN)Field group structure.
 *     f_ent   - (IN)Inserted entry structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_entry_add (int unit, _field_group_t *fg,
                        _field_entry_t *f_ent)
{
    _field_entry_t **f_ent_arr;   /* Field group entry array.*/
    int mem_sz;                   /* Memory size.            */
    int idx;                      /* Entry insertion index.  */
    int tmp;                      /* Temporary iterator.     */

    /* Input parameters check */
    if ((NULL == fg) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Verify if entry already present in the group . */
    if (NULL != fg->entry_arr) {
        idx = _shr_bsearch(fg->entry_arr, fg->group_status.entry_count,
                           sizeof (_field_entry_t *), &f_ent,
                           _field_entry_t_compare);
        /* Entry already IN. */
        if (idx >= 0) {
            return (BCM_E_NONE);
        }
    } else {
        idx = -1;  /* Insert into 0 location. */
    }

    /* Check if group has enough room for new entry */
    if (fg->group_status.entry_count + 1 >
        fg->ent_block_count * _FP_GROUP_ENTRY_ARR_BLOCK) {

        mem_sz = _FP_GROUP_ENTRY_ARR_BLOCK * (fg->ent_block_count + 1) *
            sizeof(_field_entry_t *);

        f_ent_arr = NULL;

        _FP_XGS3_ALLOC(f_ent_arr, mem_sz, "field group entries array");
        if (NULL == f_ent_arr) {
            return (BCM_E_MEMORY);
        }
        /* Copy original array to newly allocated one. */
        if (NULL != fg->entry_arr) {
            mem_sz = _FP_GROUP_ENTRY_ARR_BLOCK * (fg->ent_block_count) *
                sizeof(_field_entry_t *);
            sal_memcpy(f_ent_arr, fg->entry_arr, mem_sz);

            sal_free (fg->entry_arr);
        }
        fg->entry_arr = f_ent_arr;
        fg->ent_block_count++;
    }
    /* Make room for inserted entry */
    idx = (((-1) * idx) - 1);
    tmp = fg->group_status.entry_count - 1;
    while (tmp >= idx) {
    /*    coverity[var_deref_op : FALSE]    */
        fg->entry_arr[tmp + 1] = fg->entry_arr[tmp];
        tmp--;
    }
    fg->entry_arr[idx] = f_ent;
    fg->group_status.entry_count++;
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_group_entry_delete
 * Purpose:
 *     Remove an entry from field group entry array.
 * Parmeters:
 *     unit    - (IN)BCM device number.
 *     fg      - (IN)Field group structure.
 *     f_ent   - (IN)Removed entry structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_entry_delete(int unit, _field_group_t *fg,
                        _field_entry_t *f_ent)
{
    int idx;                      /* Entry insertion index.  */
    int tmp;                      /* Temporary iterator.     */

    /* Input parameters check */
    if ((NULL == fg) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Make sure group entry array was not deallocated. */
    if (NULL == fg->entry_arr) {
        return (BCM_E_INTERNAL);
    }

    /* Verify if entry already present in the group . */
    idx = _shr_bsearch(fg->entry_arr, fg->group_status.entry_count,
                       sizeof (_field_entry_t *), &f_ent,
                       _field_entry_t_compare);
    if (idx < 0) {
        return (BCM_E_NOT_FOUND);
    }

    /* Make room for inserted entry */
    tmp = idx;
    while (tmp < fg->group_status.entry_count - 1) {
        fg->entry_arr[tmp] = fg->entry_arr[tmp + 1];
        tmp++;
    }
    fg->group_status.entry_count--;
    fg->entry_arr[fg->group_status.entry_count] = NULL;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_entry_get_by_id
 * Purpose:
 *     Lookup a complete FP rule(entry) from a unit & rule id choice.
 * Parmeters:
 *     unit      - (IN)BCM device number.
 *     eid       - (IN)Entry id.
 *     entry_arr - (OUT) Entry lookup result array. (Array of pointers to
 *                       primary/secondary/teriary ... parts of entry.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_entry_get_by_id(int unit, bcm_field_entry_t eid,
                       _field_entry_t **entry_arr)
{
    int    rv;     /* Operation return status. */

    /* Input parameters check. */
    if (NULL == entry_arr) {
        return (BCM_E_PARAM);
    }

    /* Initialize entry array. */
    *entry_arr = NULL;

    /* Extract primary entry. */
    rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, entry_arr);

    return (rv);
}

/*
 * Function:
 *     _bcm_field_entry_qual_get
 *
 * Purpose:
 *     Lookup a _field_entry_t from a unit ID taking into account mode. Since
 *     double and triple-wide modes can have multiple physical entries with the
 *     same Entry ID,
 *
 * Parmeters:
 *     unit    - (IN)BCM device number.
 *     eid     - (IN)Entry id.
 *     qual    - (IN)Qualifier used to select the correct slice
 *     entry_p - (OUT)Lookup result entry.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_entry_qual_get(int unit, bcm_field_entry_t entry,
                          int qual, _field_entry_t **entry_p)
{
    _bcm_field_group_qual_t *q_arr;  /* Qualifiers array.               */
    int             parts_count = 0; /* Number of entry parts.          */
    uint8                     entry_type;  /* Index to tcam entries of
                                              multiple types            */
    int             part_idx;        /* Entry parts iteration index.    */
    int             qual_idx;        /* Part qualifiers iteration index.*/
    uint8           found;           /* Entry lookup flags.             */
    _field_group_t  *fg;             /* FP group info structure.        */
    int             rv;              /* Operation return status.        */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_bcm_field_entry_qual_get\n")));

    /* Input parameters check. */
    if (NULL == entry_p) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    found = FALSE;

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, entry_p);
    BCM_IF_ERROR_RETURN(rv);

    fg = (*entry_p)->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    /* If it's an external slice, then the qualifier has to be in the primary
     * entry, since that's the only entry it has. */
    if (fg->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        return (BCM_E_NONE);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
        return (BCM_E_NONE);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    entry_type = _FP_ENTRY_TYPE_DEFAULT;

    /* Iterate over all entry parts. */
    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        /* Get part qualifiers array. */
        q_arr = &(fg->qual_arr[entry_type][part_idx]);
        /* Search array by qualifier id. */
        for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
            if ((uint16)qual == q_arr->qid_arr[qual_idx]) {
                found = TRUE;
                break;
            }
        }
        if (found) {
            break;
        }
    }

    /* Check lookup status. */
    if (FALSE == found) {
        return (BCM_E_NOT_FOUND);
    }

    *entry_p += part_idx;
    return (BCM_E_NONE);
}

#if defined(BCM_TRIDENT2_SUPPORT)
/*
 * Function:
 *     _bcm_field_efp_entry_qual_get
 *
 * Purpose:
 *     Lookup a _field_entry_t from a unit ID taking into account mode. Since
 *     double and triple-wide modes can have multiple physical entries with the
 *     same Entry ID,
 *
 * Parmeters:
 *     unit    - (IN)BCM device number.
 *     eid     - (IN)Entry id.
 *     qual    - (IN)Qualifier used to select the correct slice
 *     entry_p - (OUT)Lookup result entry.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_efp_entry_qual_get(int unit, bcm_field_entry_t entry,
                          int qual, _field_entry_t **entry_p)
{
    _bcm_field_group_qual_t *q_arr;  /* Qualifiers array.               */
    int             parts_count = 0; /* Number of entry parts.          */
    uint8                     entry_type;  /* Index to tcam entries of
                                              multiple types            */
    int             part_idx;        /* Entry parts iteration index.    */
    int             qual_idx;        /* Part qualifiers iteration index.*/
    uint8           found;           /* Entry lookup flags.             */
    _field_group_t  *fg;             /* FP group info structure.        */
    int             rv;              /* Operation return status.        */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_bcm_field_efp_entry_qual_get\n")));

    /* Input parameters check. */
    if (NULL == entry_p) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    found = FALSE;

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, entry_p);
    BCM_IF_ERROR_RETURN(rv);

    fg = (*entry_p)->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    if (!(SOC_IS_TD2_TT2(unit) &&
            (_BCM_FIELD_STAGE_EGRESS == fg->stage_id))) {
        return (BCM_E_INTERNAL);
    }

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    if ((*entry_p)->efp_key_match_type) {
        entry_type = _FP_ENTRY_TYPE_1;
    } else {
        entry_type = _FP_ENTRY_TYPE_0;
    }

    /* Iterate over all entry parts. */
    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        /* Get part qualifiers array. */
        q_arr = &(fg->qual_arr[entry_type][part_idx]);
        /* Search array by qualifier id. */
        for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
            if ((uint16)qual == q_arr->qid_arr[qual_idx]) {
                found = TRUE;
                break;
            }
        }
        if (found) {
            break;
        }
    }

    /* Check lookup status. */
    if (FALSE == found) {
        return (BCM_E_NOT_FOUND);
    }

    *entry_p += part_idx;
    return (BCM_E_NONE);
}
#endif

/*
 * Function:
 *     _bcm_field_policer_get
 * Purpose:
 *     Lookup a Policer description structure by policer id.
 * Parmeters:
 *     unit      - (IN)BCM device number.
 *     pid       - (IN)Policer id.
 *     policer_p - (OUT) Policer lookup result.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_policer_get(int unit, bcm_policer_t pid,
                       _field_policer_t **policer_p)
{
    _field_policer_t *f_pl; /* Policer lookup pointer.  */
    _field_control_t *fc;   /* Field control structure. */
    uint32 hash_index;      /* Entry hash.              */

    /* Input parameters check. */
    if (NULL == policer_p) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    hash_index = pid & _FP_HASH_INDEX_MASK(fc);
    f_pl  =  fc->policer_hash[hash_index];
    while (NULL != f_pl) {
        /* Match entry id. */
        if (f_pl->pid == pid) {
            *policer_p = f_pl;
            return (BCM_E_NONE);
        }
        f_pl = f_pl->next;
    }

    /* Policer with pid == pid was not found. */
    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *      _field_policer_destroy2
 * Purpose:
 *      Deinitialize a policer entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      fc      - (IN) Field control structure.
 *      f_pl    - (IN) Internal policer descriptor.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_policer_destroy2(int unit, _field_control_t *fc,
                        _field_policer_t *f_pl)
{
    /* Input parameters check. */
    if ((NULL == fc) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    /* Reject destroy if policer is in use. */
    if (f_pl->sw_ref_count > 1) {
        return (BCM_E_BUSY);
    }

    /* Remove policer for lookup hash. */
    _FP_HASH_REMOVE(fc->policer_hash, _field_policer_t, f_pl,
                    (f_pl->pid & _FP_HASH_INDEX_MASK(fc)));


    /* De-allocate policer descriptor. */
    sal_free(f_pl);

    /* Decrement number of active policers. */
    if (fc->policer_count > 0) {
        fc->policer_count--;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_policer_destroy
 * Purpose:
 *      Deinitialize a policer entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      pid     - (IN) Policer id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_policer_destroy(int unit, bcm_policer_t pid)
{
    _field_control_t    *fc;               /* Field control structure.     */
    _field_policer_t    *f_pl;             /* Internal policer descriptor. */
    int                 rv;                /* Operation return status.     */

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Find policer info. */
    rv = _bcm_field_policer_get(unit, pid, &f_pl);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    return _field_policer_destroy2(unit, fc, f_pl);
}

/*
 * Function:
 *      _field_policer_hw_flags_set
 * Purpose:
 *      Update policer installation is required flag.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      f_pl    - (IN/OUT) Internal policer descriptor.
 *      flags   - (IN) Internal flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_policer_hw_flags_set(int unit, _field_policer_t *f_pl, uint32 flags)
{
    /* Input parameters check. */
    if (NULL == f_pl) {
        return (BCM_E_PARAM);
    }

    f_pl->hw_flags |= flags;

    switch (f_pl->cfg.mode) {
        case bcmPolicerModeSrTcm:
        case bcmPolicerModeTrTcm:
        case bcmPolicerModeTrTcmDs:
        case bcmPolicerModeCoupledTrTcmDs:
        case bcmPolicerModeSrTcmModified:
        case bcmPolicerModeSrTcmTsn:
        case bcmPolicerModeCommitted:
            f_pl->hw_flags |= _FP_POLICER_DIRTY;
            break;
        default:
            return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_policer_id_alloc
 * Purpose:
 *      Allocate a policer id.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      pid     - (OUT) Policer id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_policer_id_alloc(int unit, bcm_policer_t *pid)
{
    int               max_count;           /* Maximum number of pid to try.*/
    _field_policer_t  *f_pl;               /* Field policer descriptor.    */
    int               rv;                  /* Operation return status.     */
    static uint32  last_allocated_pid = 0; /* Policer id alloc tracker.    */

    /* Input parameters check. */
    if (NULL == pid) {
        return (BCM_E_PARAM);
    }

    max_count = _FP_ID_MAX;
    while (max_count--) {
        last_allocated_pid++;
        if (_FP_ID_MAX == last_allocated_pid) {
            last_allocated_pid = _FP_ID_BASE;
        }
        rv = _bcm_field_policer_get(unit, last_allocated_pid, &f_pl);
        if (BCM_E_NOT_FOUND == rv) {
            *pid = last_allocated_pid;
            return (BCM_E_NONE);
        }
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }
    return (BCM_E_RESOURCE);
}


/*
 * Function:
 *      _field_policer_mode_support
 * Purpose:
 *      Validate policer mode support.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      f_ent   - (IN) Field entry policer attached.
 *      level   - (IN) Level policer attached.
 *      f_pl    - (IN) Policer descriptor.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_policer_mode_support(int unit, _field_entry_t *f_ent,
                                int level, _field_policer_t *f_pl)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status.     */

    if ((0 == level) && (bcmPolicerModePeak == f_pl->cfg.mode)) {
        /* bcmPolicerModePeak not supported. */
        return (BCM_E_UNAVAIL);
    }

    if (1 == level) {
#ifdef BCM_TRIDENT_SUPPORT
        if (SOC_IS_TD_TT(unit)) {
            /* Trident device does not support Level1 policers. */
            return (rv);
        }
#endif
        if ((SOC_IS_TRX(unit)
            && (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id))
            || ((_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id)
                && (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)))) {
            /* Level 1 flow mode policer must be bcmPolicerModeCommitted. */
            rv = (_FP_POLICER_IS_FLOW_MODE(f_pl))
                    ? (BCM_E_NONE) : (BCM_E_PARAM);
        }
        return (rv);
    }

    switch (f_pl->cfg.mode) {
        case bcmPolicerModeTrTcm:
        case bcmPolicerModeSrTcm:
        case bcmPolicerModeCommitted:
        case bcmPolicerModeGreen:
            rv = BCM_E_NONE;
            break;
        case bcmPolicerModePassThrough:
            if (SOC_IS_TRX(unit)) {
                rv = BCM_E_NONE;
            } else if ((SOC_IS_FIREBOLT2(unit))
                        && (_BCM_FIELD_STAGE_EGRESS
                            == f_ent->group->stage_id)) {
                rv = BCM_E_NONE;
            }
            break;
        case bcmPolicerModeTrTcmDs:
            if (SOC_IS_TRX(unit)) {
                rv = BCM_E_NONE;
            }
            break;
        case bcmPolicerModeSrTcmModified:
            if ((soc_feature(unit, soc_feature_field_virtual_queue))
                && ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)
                || ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                     && ((SOC_IS_TRIDENT2X(unit)
                            || SOC_IS_TITAN2PLUS(unit)))))) {
                rv = BCM_E_NONE;
            }
            break;
        case bcmPolicerModeCoupledTrTcmDs:
            if ((soc_feature(unit, soc_feature_field_virtual_queue)) &&
                (((!SOC_IS_TD_TT(unit)) &&
                  (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) ||
                 ((SOC_IS_APACHE(unit) &&
                  (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id))))) {
                rv = BCM_E_NONE;
            }
            break;
        case bcmPolicerModeSrTcmTsn:
            if (SOC_IS_GREYHOUND2(unit)) {
                if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
                    (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
                    rv = BCM_E_NONE;
                }
            }
            break;
        default:
            rv = BCM_E_PARAM;
            break;
    }

#if defined(BCM_ENDURO_SUPPORT)
    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE2(unit) ||
        SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        /* Egress stage does not support packet based metering */
        if ((f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS)
            && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            rv = BCM_E_PARAM;
        }
    }
#endif
    return (rv);
}

int
_field_policer_mode_support(int unit, _field_entry_t *f_ent,
                            int level, _field_policer_t *f_pl)
{
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_policer_mode_support(unit, f_ent, level, f_pl));
    }
#endif

    return (_bcm_field_policer_mode_support(unit, f_ent, level, f_pl));
}


/*
 * Function:
 *      _field_policer_create
 * Purpose:
 *      Initialize a policer entry.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      pol_cfg - (IN) Policer configuration.
 *      flags   - (IN) HW/API specific flags.
 *      pid     - (OUT) Policer id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_policer_create(int unit, bcm_policer_config_t *pol_cfg,
                      uint32 flags, bcm_policer_t *pid)
{
    _field_control_t    *fc;          /* Field control structure.     */
    int                 rv;           /* Operation return status.     */
    _field_policer_t    *f_pl = NULL; /* Internal policer descriptor. */

    /* Input parameters check. */
    if (NULL == pol_cfg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Generate policer id. */
    if (0 == (pol_cfg->flags & BCM_POLICER_WITH_ID)) {
        BCM_IF_ERROR_RETURN(_field_policer_id_alloc(unit, pid));
    } else {
        /* Check if policer id is already in use. */
        rv = _bcm_field_policer_get(unit, *pid, &f_pl);
        if (BCM_SUCCESS(rv)) {

            /* Verify that replace flag is set. */
            if(0 == (pol_cfg->flags & BCM_POLICER_REPLACE)) {
                return (BCM_E_EXISTS);
            }

            /* Make sure police is not attached to any entry. */
            if (1 != f_pl->sw_ref_count) {
                return (BCM_E_BUSY);
            }
            /* Copy new configuration. */
            sal_memcpy(&f_pl->cfg, pol_cfg, sizeof(bcm_policer_config_t));

            /* Set policer "dirty" flag and return. */
            rv = _field_policer_hw_flags_set(unit, f_pl, flags);
            return (rv);
        }
    }

    /* Allocate policer descriptor. */
    _FP_XGS3_ALLOC(f_pl, sizeof (_field_policer_t), "Field policer");
    if (NULL == f_pl) {
        return (BCM_E_MEMORY);
    }

    /* Copy policer configuration. */
    sal_memcpy(&f_pl->cfg, pol_cfg, sizeof(bcm_policer_config_t));

    /* Set policer "dirty" flags. */
    rv = _field_policer_hw_flags_set(unit, f_pl, flags);
    if (BCM_FAILURE(rv)) {
        sal_free(f_pl);
        return (rv);
    }

    /* Initialize reference count to 1. */
    f_pl->sw_ref_count = 1;

    /* Set hw index to - no hw resources allocated. */
    f_pl->pool_index = _FP_INVALID_INDEX;
#ifdef BCM_TRIUMPH3_SUPPORT
    f_pl->logical_pool_index = _FP_INVALID_INDEX;
#endif
    f_pl->hw_index = _FP_INVALID_INDEX;

    /* Initialize policer id. */
    f_pl->pid = *pid;

    /* Insert policer into policers hash. */
    _FP_HASH_INSERT(fc->policer_hash, f_pl, (*pid & _FP_HASH_INDEX_MASK(fc)));

    /* Increment number of active policers. */
    fc->policer_count++;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_meter_mem_get
 * Purpose:
 *     Get meter memory name.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control.
 *     mem       - (OUT) Meter memory.
 * Returns:
 *     BCM_E_XXX   -
 */
STATIC int
_field_meter_mem_get(int unit, _field_stage_t *stage_fc, soc_mem_t *mem)
{
    /* Input parameters check. */
    if ((NULL == stage_fc)  || (NULL == mem)) {
        return (BCM_E_PARAM);
    }

    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            *mem = FP_METER_TABLEm;
            break;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        case _BCM_FIELD_STAGE_EGRESS:
            *mem = EFP_METER_TABLEm;
            break;
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        default:
            return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}
/*
 * Function: _field_counter_mem_get
 *
 * Description:
 *      Service routine used to extract unit field counters memories
 *
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      fc              - (IN) Field control structure.
 *      stage_fc        - (IN) Stage field control structure.
 *      counter_x_mem   - (OUT)First counters memory.
 *      counter_y_mem   - (OUT)Second counters memory.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_counter_mem_get(int            unit,
                           _field_stage_t *stage_fc,
                           soc_mem_t      *counter_x_mem,
                           soc_mem_t      *counter_y_mem
                           )
{
    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
#ifdef BCM_FIREBOLT_SUPPORT
        if (SOC_IS_FBX(unit)) {
#ifdef BCM_BRADLEY_SUPPORT
            if (soc_feature(unit, soc_feature_two_ingress_pipes)) {
                *counter_x_mem = FP_COUNTER_TABLE_Xm;
                *counter_y_mem = FP_COUNTER_TABLE_Ym;
            } else
#endif /* BCM_BRADLEY_SUPPORT */
            {
                *counter_x_mem = FP_COUNTER_TABLEm;
            }
        } else
#endif /* BCM_FIREBOLT_SUPPORT */
        {
           return (BCM_E_UNAVAIL);
        }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (_BCM_FIELD_STAGE_LOOKUP== stage_fc->stage_id) {
        return (BCM_E_NONE);
    } else if (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id) {
        if (soc_feature(unit, soc_feature_two_ingress_pipes)) {
            *counter_x_mem = EFP_COUNTER_TABLE_Xm;
            *counter_y_mem = EFP_COUNTER_TABLE_Ym;
        } else {
            *counter_x_mem = EFP_COUNTER_TABLEm;
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    } else if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
        *counter_x_mem = EXT_FP_CNTRm;
    } else {
        return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}


int
_field_counter_mem_get(int            unit,
                       _field_stage_t *stage_fc,
                       soc_mem_t      *counter_x_mem,
                       soc_mem_t      *counter_y_mem
                       )
{
    if (NULL == stage_fc || NULL == counter_x_mem || NULL == counter_y_mem) {
        return (BCM_E_PARAM);
    }

    *counter_x_mem = INVALIDm;
    *counter_y_mem = INVALIDm;

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_counter_mem_get(unit,
                                               stage_fc,
                                               counter_x_mem,
                                               counter_y_mem
                                               )
                );
    }
#endif

    return (_bcm_field_counter_mem_get(unit,
                                       stage_fc,
                                       counter_x_mem,
                                       counter_y_mem
                                       )
            );
}


/*
 * Function:
 *     _field_entry_counter_move
 * Purpose:
 *     Move the counter for an entry moving across a slice
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN) Stage field control.
 *     old_slice    - (IN) Old counter slice number.
 *     old_hw_index - (IN) Old counter hw index.
 *     f_st         - (IN) New statistics entity descriptor.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_entry_counter_move(int unit, _field_stage_t *stage_fc,
                              uint8 old_slice, int old_hw_index,
                              _field_stat_t *f_st_old,
                              _field_stat_t *f_st)
{
    soc_mem_t counter_x_mem, counter_y_mem; /* Counter memories         */
    _field_control_t *fc;                   /* FP control information   */
    uint32 flags = 0;                       /* Bytes/Packets Stats type */
    uint64 value;                           /* Hardware Stats value     */
    int new_idx1 = _FP_INVALID_INDEX;       /* Primary Hw stats index   */
    int new_idx2 = _FP_INVALID_INDEX;       /* Secondary Hw stats index */
    int new_idx3 = _FP_INVALID_INDEX;       /* Third Hw stats index */
    int nstat;                              /* Number of stats          */
    int rv = BCM_E_INTERNAL;                /* Operation return status  */

    /* Get field control structure. */
    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get the counter memories */
    rv = _field_counter_mem_get(unit, stage_fc, &counter_x_mem, &counter_y_mem);
    BCM_IF_ERROR_RETURN(rv);

    for (nstat = 0; nstat < f_st_old->nstat; nstat++) {
        /* Get Stat value from old hardware index */
        rv = _field_stat_value_get(unit, 0, f_st_old, f_st_old->stat_arr[nstat],
                &value);
        BCM_IF_ERROR_RETURN(rv);

        if (_BCM_FIELD_STAGE_EXTERNAL != stage_fc->stage_id) {
            /* Get Stat New hardware index values */
            rv = fc->functions.fp_stat_index_get(unit, f_st,
                f_st->stat_arr[nstat], &new_idx1, &new_idx2, &new_idx3, &flags);
            BCM_IF_ERROR_RETURN(rv);
        } else if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
            new_idx1 = f_st->hw_index;
        }

        /* Check if new hardware index is valid */
        if (_FP_INVALID_INDEX == new_idx1) {
            return (BCM_E_INTERNAL);
        }

        if ((flags & _FP_STAT_BYTES)
            && (stage_fc->flags & _FP_STAGE_SEPARATE_PACKET_BYTE_COUNTERS))  {
            /*
             * For devices that do not support separate packet and byte counters
             * only _field_x32_counters is used.
             */

#if defined(BCM_TRX_SUPPORT)
            /* Zero the accumulated part at new_idx1 */
            COMPILER_64_ZERO(stage_fc->_field_x64_counters[new_idx1].
                accumulated_counter);

            /* Copy the accumulated part value */
            COMPILER_64_OR(stage_fc->_field_x64_counters[new_idx1].
                accumulated_counter, value);

            /* Zero the last_hw_value at new_idx1 */
            COMPILER_64_ZERO(stage_fc->_field_x64_counters[new_idx1].
                last_hw_value);

            /* Zero Y-Pipeline counter values */
            if (INVALIDm != counter_y_mem) {
                COMPILER_64_ZERO(stage_fc->_field_y64_counters[new_idx1].
                    accumulated_counter);
                COMPILER_64_ZERO(stage_fc->_field_y64_counters[new_idx1].
                    last_hw_value);
            }

            /* Zero counters at secondary index */
            if (_FP_INVALID_INDEX != new_idx2) {
                COMPILER_64_ZERO(stage_fc->_field_x64_counters[new_idx2].
                    accumulated_counter);
                COMPILER_64_ZERO(stage_fc->_field_x64_counters[new_idx2].
                    last_hw_value);

                /* Zero Y-Pipeline counter values at secondary index */
                if (INVALIDm != counter_y_mem) {
                    COMPILER_64_ZERO(stage_fc->_field_y64_counters[new_idx2].
                        accumulated_counter);
                    COMPILER_64_ZERO(stage_fc->_field_y64_counters[new_idx2].
                        last_hw_value);
                }
            }
#endif
        } else {

            /* Zero the accumulated part at new_idx1 */
            COMPILER_64_ZERO(stage_fc->_field_x32_counters[new_idx1].
                accumulated_counter);

            /* Copy the accumulated part */
            COMPILER_64_OR(stage_fc->_field_x32_counters[new_idx1].
                accumulated_counter, value);

            /* Zero the last_hw_value at new_idx1 */
            stage_fc->_field_x32_counters[new_idx1].last_hw_value = 0;

            /* Zero Y-Pipeline packet counter values */
            if (INVALIDm != counter_y_mem) {
#if defined(BCM_SCORPION_SUPPORT)
                COMPILER_64_ZERO(stage_fc->_field_y32_counters[new_idx1].
                    accumulated_counter);

                /* Zero the last_hw_value at new_idx1 */
                stage_fc->_field_y32_counters[new_idx1].last_hw_value = 0;
#endif
            }

            /* Zero counters at secondary index */
            if (_FP_INVALID_INDEX != new_idx2) {
                /* Zero the accumulated part at new_idx2 */
                COMPILER_64_ZERO(stage_fc->_field_x32_counters[new_idx2].
                    accumulated_counter);

                /* Zero the last_hw_value at new_idx2 */
                stage_fc->_field_x32_counters[new_idx2].last_hw_value = 0;

                /* Zero Y-Pipeline packet counter values at secondary index */
                if (INVALIDm != counter_y_mem) {
#if defined(BCM_SCORPION_SUPPORT)
                    COMPILER_64_ZERO(stage_fc->_field_y32_counters[new_idx2].
                        accumulated_counter);

                    /* Zero the last_hw_value at new_idx2 */
                    stage_fc->_field_y32_counters[new_idx2].last_hw_value = 0;
#endif
                }
            }
        }

        COMPILER_64_ZERO(value);
        rv = _field_stat_value_set(unit, f_st_old, f_st_old->stat_arr[nstat],
                  value);
        BCM_IF_ERROR_RETURN(rv);
    }
    return rv;
}

/*
 * Function:
 *     _field_entry_meter_move
 * Purpose:
 *     Move the meters for an entry moving across a slice
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN) Stage field control.
 *     instance     - {IN) Pipe Instance the entry belongs to.
 *     old_slice    - (IN) Old meter slice number.
 *     old_hw_index - (IN) Old meter hw index.
 *     f_pl         - (IN) New meter descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entry_meter_move(int unit, _field_stage_t *stage_fc,
                        int instance, uint8 old_slice, int old_hw_index,
                        _field_policer_t *f_pl)
{
    uint32 buf[SOC_MAX_MEM_FIELD_WORDS];  /* Meter memory entry buffer. */
    soc_mem_t mem_x = INVALIDm;           /* Meter memory.              */
    soc_mem_t mem_y = INVALIDm;           /* Meter memory.              */
    int old_index;                        /* Old meter index in memory. */
    int new_index;                        /* New meter index in memory. */

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_SC_CQ(unit) || SOC_IS_TD_TT(unit)) {
        BCM_IF_ERROR_RETURN(_field_trx_meter_table_get(unit, stage_fc->stage_id, &mem_x, &mem_y));
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(_field_meter_mem_get(unit, stage_fc, &mem_x));
    }

    old_index =  stage_fc->slices[instance][old_slice].start_tcam_idx
                    + (2 * old_hw_index);

    new_index =  stage_fc->slices[instance][f_pl->pool_index].start_tcam_idx
                    + (2 * f_pl->hw_index);

    if ((old_index < soc_mem_index_min(unit, mem_x)) ||
        ((old_index + 1) > soc_mem_index_max(unit, mem_x)) ||
        (new_index < soc_mem_index_min(unit, mem_x)) ||
        ((new_index + 1) > soc_mem_index_max(unit, mem_x))) {
        return (BCM_E_PARAM);
    }

    /* Clear entry buffer. */
    sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));

    /* Copy meter from old location to a new one. */
    if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
        BCM_IF_ERROR_RETURN
            (soc_mem_read(unit, mem_x, MEM_BLOCK_ANY, old_index, buf));
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, mem_x, MEM_BLOCK_ALL, new_index, buf));
        sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        if (INVALIDm != mem_y) {
            BCM_IF_ERROR_RETURN
                (soc_mem_read(unit, mem_y, MEM_BLOCK_ANY, old_index, buf));
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, mem_y, MEM_BLOCK_ALL, new_index, buf));
        }

        sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        BCM_IF_ERROR_RETURN
            (soc_mem_read(unit, mem_x, MEM_BLOCK_ANY, old_index + 1, buf));
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, mem_x, MEM_BLOCK_ALL, new_index + 1, buf));
        sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        if (INVALIDm != mem_y) {
            BCM_IF_ERROR_RETURN
                (soc_mem_read(unit, mem_y, MEM_BLOCK_ANY, old_index + 1, buf));
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, mem_y, MEM_BLOCK_ALL, new_index + 1, buf));
        }
    } else {
        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            BCM_IF_ERROR_RETURN
                (soc_mem_read(unit, mem_x, MEM_BLOCK_ANY, old_index, buf));
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, mem_x, MEM_BLOCK_ALL, new_index, buf));
            sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
            if (INVALIDm != mem_y) {
                BCM_IF_ERROR_RETURN
                    (soc_mem_read(unit, mem_y, MEM_BLOCK_ANY, old_index, buf));
                BCM_IF_ERROR_RETURN
                    (soc_mem_write(unit, mem_y, MEM_BLOCK_ALL, new_index, buf));
            }

            /* Clear peak dirty bit. */
            f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;
        } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            BCM_IF_ERROR_RETURN
                (soc_mem_read(unit, mem_x, MEM_BLOCK_ANY, old_index + 1, buf));
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, mem_x, MEM_BLOCK_ALL, new_index + 1, buf));
            sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
            if (INVALIDm != mem_y) {
                BCM_IF_ERROR_RETURN
                    (soc_mem_read(unit, mem_y, MEM_BLOCK_ANY, old_index + 1, buf));
                BCM_IF_ERROR_RETURN
                    (soc_mem_write(unit, mem_y, MEM_BLOCK_ALL, new_index + 1, buf));
            }

            /* Clear committed dirty bit. */
            f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_meter_pool_alloc
 *
 * Purpose:
 *     Allocate/Find meter pool with free meters
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Stage field control structure.
 *     instance - (IN) Pipe Instance.
 *     f_pl     - (IN) Field policer descriptor
 *     slice_id - (IN) Slice base index.
 *     pool_idx - (OUT) Meter pool index.
 * Returns:
 *     BCM_E_XXX
 *
 */
STATIC int
_field_meter_pool_alloc(int unit, _field_stage_t *stage_fc, int instance,
                        _field_policer_t *f_pl, uint8 slice_id, uint8 *pool_idx)
{
    _field_meter_pool_t  *f_mp;          /* Meter pool descriptor. */
    int                  idx;            /* Pool iteration index.  */
    int                  free_pool;      /* Free meter pool.       */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == pool_idx)) {
        return (BCM_E_PARAM);
    }

    free_pool = _FP_INVALID_INDEX;

   	/* Create policer in an existing pool */
    if ((f_pl->level == 1) && (f_pl->cfg.pool_id != -1)
        && (f_pl->cfg.flags & BCM_POLICER_WITH_POOL_ID)) {

        /* Check if pool_id passed is a valid pool */
        f_mp = stage_fc->meter_pool[instance][f_pl->cfg.pool_id];
        if ((NULL == f_mp) || (f_mp->slice_id == _FP_INVALID_INDEX)
            || (f_mp->level != 1)) {
            return (BCM_E_INTERNAL);
        }

        /* If free meters are available then allocate pool */
		if ((_FP_POLICER_IS_FLOW_MODE(f_pl) && f_mp->free_meters > 0)
             || (!_FP_POLICER_IS_FLOW_MODE(f_pl) && f_mp->free_meters >= 2)) {
            *pool_idx = f_pl->cfg.pool_id;
            return (BCM_E_NONE);
        }
    }

    for (idx = 0 ; idx < stage_fc->num_meter_pools; idx++) {
        f_mp = stage_fc->meter_pool[instance][idx];
        if (NULL == f_mp) {
            return (BCM_E_INTERNAL);
        }

        /* If we have a matching pool with free entries - just use it. */
        if ((f_mp->slice_id == slice_id)
            && (f_mp->level == f_pl->level)
            && ((_FP_POLICER_IS_FLOW_MODE(f_pl) && f_mp->free_meters > 0)
                || (!_FP_POLICER_IS_FLOW_MODE(f_pl) && f_mp->free_meters >= 2)
                )) {
            *pool_idx = idx;
            f_pl->cfg.pool_id = *pool_idx;
            return (BCM_E_NONE);
        }

        /* Preserve first free pool */
        if ((_FP_INVALID_INDEX  == free_pool) &&
            (_FP_INVALID_INDEX  == f_mp->slice_id)) {
            free_pool = idx;
        }
    }


    /* We have to use free pool at this point. */
    if (_FP_INVALID_INDEX == free_pool) {
        return (BCM_E_RESOURCE);
    }

    f_mp = stage_fc->meter_pool[instance][free_pool];
    f_mp->slice_id = slice_id;
    f_mp->level = f_pl->level;
    *pool_idx = free_pool;
    f_pl->cfg.pool_id = *pool_idx;
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_meter_pool_free
 *
 * Purpose:
 *     Unreserve a meter pool.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Stage field control structure.
 *     instance - (IN) Pipe Instance.
 *     pool_idx - (IN) Meter pool index.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_meter_pool_free(int unit, _field_stage_t *stage_fc,
                       int instance, uint8 pool_idx)
{
    _field_meter_pool_t *f_mp;          /* Meter pool descriptor. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    f_mp = stage_fc->meter_pool[instance][pool_idx];
    if (NULL == f_mp) {
        return (BCM_E_INTERNAL);
    }

    /* Make sure pool entries are not in use. */
    if (f_mp->free_meters != f_mp->size) {
        return (BCM_E_BUSY);
    }

    f_mp->slice_id = _FP_INVALID_INDEX;
    f_mp->level = -1;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_meter_pool_entry_free
 *
 * Purpose:
 *     Free meter pool entry.
 *     if necessary free the pool itself.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control structure.
 *     instance  - (IN) Pipe Instance.
 *     f_pl      - (IN) Policer descriptor.
 * Returns:
 *     BCM_E_XXX
 *
 */
STATIC int
_field_meter_pool_entry_free(int unit, _field_stage_t *stage_fc,
                             int instance, _field_policer_t *f_pl)
{
    _field_control_t   *fc;
    _field_meter_pool_t *f_mp;  /* Meter pool descriptor. */
    int idx;                    /* Meter index.           */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    /* Meter pool index sanity check. */
    if (stage_fc->num_meter_pools <= f_pl->pool_index) {
        return (BCM_E_PARAM);
    }

    /* Get field control information. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {

        /* When ingress physical policer pools is split into logical pools
         * Allocate pool id and index using the logical meter pool entry
         * allocator
         */
        if (fc->ingress_logical_policer_pools_mode !=
                    bcmFieldIngressLogicalPolicerPools8x1024) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Policer Pools is in non default mode."
                                   " Logical Meter alloc called.\r\n"), unit));
            return _field_tr3_logical_meter_pool_entry_free (unit, stage_fc, f_pl);
        }
    }
#endif

    f_mp = stage_fc->meter_pool[instance][f_pl->pool_index];

    /* Mark meter as free in the slice. */
    idx = f_pl->hw_index * 2;

    /* Meter index in the pool sanity check. */
    if ((f_mp->size <= idx)
        || (f_mp->size <= (idx + 1))) {
        return (BCM_E_PARAM);
    }

    if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
        _FP_METER_BMP_REMOVE(f_mp->meter_bmp, idx);
        _FP_METER_BMP_REMOVE(f_mp->meter_bmp, idx + 1);
        f_mp->free_meters += 2;
    } else {

        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            _FP_METER_BMP_REMOVE(f_mp->meter_bmp, idx);

            /* Clear excess meter flag bit. */
            _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
        } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            _FP_METER_BMP_REMOVE(f_mp->meter_bmp, idx + 1);
        }
        f_mp->free_meters++;
    }

    /* Free empty pool. */
    if (f_mp->free_meters == f_mp->size) {
        BCM_IF_ERROR_RETURN
           (_field_meter_pool_free(unit, stage_fc, instance, f_pl->pool_index));
    }

    /* Reset pool and hw index information in policer structure. */
    f_pl->pool_index = _FP_INVALID_INDEX;
    f_pl->hw_index = _FP_INVALID_INDEX;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_meter_pool_entry_alloc
 *
 * Purpose:
 *     Allocate meter pool entry.
 *
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     stage_fc         - (IN) Stage field control structure.
 *     instance         - (IN) Pipe Instance.
 *     pool_slice_id    - (IN) Meter pool index.
 *     f_pl             - (IN) Field policer descriptor
 * Returns:
 *     BCM_E_XXX
 *
 */
STATIC int
_field_meter_pool_entry_alloc(int unit, _field_stage_t *stage_fc, int instance,
                              uint8 pool_slice_id, _field_policer_t *f_pl)
{
    uint8                   pool_idx;       /* Meter pool index.        */
    int                     idx;            /* Pool iteration index.    */
    _field_meter_pool_t    *f_mp;           /* Meter pool descriptor.   */
    _field_control_t       *fc;             /* Field control structure. */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    if (f_pl->level >= _FP_POLICER_LEVEL_COUNT) {
        return (BCM_E_PARAM);
    }
    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {

        /* When ingress physical policer pools is split into logical pools
         * Allocate pool id and index using the logical meter pool entry
         * allocator
         */
        if (fc->ingress_logical_policer_pools_mode !=
                    bcmFieldIngressLogicalPolicerPools8x1024) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Policer Pools is in non default mode."
                                   " Logical Meter alloc called.\r\n"), unit));
            return _field_tr3_logical_meter_pool_entry_alloc (unit,
                                                              stage_fc,
                                                              pool_slice_id,
                                                              f_pl);
        }
    }
#endif

    /* Allocate meter pool with free meters. */
    BCM_IF_ERROR_RETURN(_field_meter_pool_alloc(unit, stage_fc, instance, f_pl,
                                                 pool_slice_id, &pool_idx));
    f_mp = stage_fc->meter_pool[instance][pool_idx];

    /* Reserve unused meter. */
    for (idx = 0; idx < f_mp->size; idx++) {

        /* Allocate meter indices for non-flow mode meters. */
        if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {

            if (0 != (idx % 2)) {
                /* skip odd meter indices */
                continue;
            }

            if ((0 == _FP_METER_BMP_TEST(f_mp->meter_bmp, idx))
                && (0 == _FP_METER_BMP_TEST(f_mp->meter_bmp, idx + 1))) {
                _FP_METER_BMP_ADD(f_mp->meter_bmp, idx);
                _FP_METER_BMP_ADD(f_mp->meter_bmp, (idx + 1));
                /* Decrement free meters count in meter pool. */
                f_mp->free_meters -= 2;
                f_pl->pool_index = pool_idx ;
                f_pl->hw_index   = (idx / 2);
                return (BCM_E_NONE);
            }
        }

        /* Allocate hardware resources for flow mode meters. */
        if (_FP_POLICER_IS_FLOW_MODE(f_pl)
            && (0 == _FP_METER_BMP_TEST(f_mp->meter_bmp, idx))) {

            if (f_pl->hw_flags & _FP_POLICER_DIRTY) {
                f_pl->hw_flags &= (idx % 2)
                                    ? ~_FP_POLICER_PEAK_DIRTY
                                    : ~_FP_POLICER_COMMITTED_DIRTY;
            } else {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "FP(unit %d) Error: Meter alloc called with invalid"
                                       " hw_flags=%x\n"), unit, f_pl->hw_flags));
                return (BCM_E_INTERNAL);
            }

            if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {
                _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
            } else {
                _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
            }

            _FP_METER_BMP_ADD(f_mp->meter_bmp, idx);

            /* Decrement free meter count in meter pool. */
            f_mp->free_meters--;
            f_pl->pool_index =  pool_idx;
            f_pl->hw_index   =  (idx / 2);
            return (BCM_E_NONE);
        }
    }

    /* Never reached - pool alloc makes sure at least one meter is available. */
    if (f_mp->free_meters == f_mp->size) {
        BCM_IF_ERROR_RETURN(_field_meter_pool_free(unit, stage_fc, instance, pool_idx));
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function:
 *     _field_meterpool_hw_entry_alloc
 *
 * Purpose:
 *     Allocate field entry meter from a meter pool.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     f_ent - (IN) Field entry structure.
 *     f_pl  - (IN) Field policer descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_meterpool_hw_entry_alloc (int unit, _field_entry_t *f_ent,
                                 _field_policer_t *f_pl)
{
    _field_stage_id_t      stage_id;  /* Stage id used for metering.          */
    _field_stage_t         *stage_fc; /* Field stage control structure.       */
    _field_group_t         *fg;       /* Field group structure.               */
    uint8                  pool_sid;  /* Key to ensure single update per hit. */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    fg = f_ent->group;
    stage_id = ((_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) || \
                (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) ? \
               _BCM_FIELD_STAGE_INGRESS : fg->stage_id;

    /* Get meter pool stage control. */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, stage_id, &stage_fc));

    /* Generate unique pool id.  */
    if ((_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) {
        pool_sid = stage_fc->tcam_slices;
    } else {
        pool_sid = fg->slices->slice_number;
    }

    /* Allocate an entry within the pool. */
    BCM_IF_ERROR_RETURN
        (_field_meter_pool_entry_alloc(unit, stage_fc, f_ent->group->instance,
                                       pool_sid, f_pl));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slice_meter_free
 *
 * Purpose:
 *     Free slice meter.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     f_ent - (IN) Field entry structure.
 *     f_pl  - (IN) Field policer descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_meter_free(int unit, _field_entry_t *f_ent,
                          _field_policer_t *f_pl)
{
    _field_stage_t         *stage_fc; /* Field stage control structure. */
    _field_slice_t         *fs;       /* Field slice structure.         */
    int                     idx;

    if ((NULL == f_ent) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    /* Get field stage control structure. */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_ent->group->stage_id,
                                                 &stage_fc));

    /* Get slice policer installed in. */
    fs =  stage_fc->slices[f_ent->group->instance] + (f_pl->pool_index);

    /* Must be a valid meter index. */
    if (f_pl->hw_index == _FP_INVALID_INDEX) {
        return (BCM_E_INTERNAL);
    }

    /* Determine even meter's index from meter pair index. */
    idx = f_pl->hw_index * 2;

    /* Validate input hardware index. */
    if ((idx >= fs->meters_count) || ((idx + 1) >= fs->meters_count)) {
        return (BCM_E_INTERNAL);
    }

    /* Mark meter as free in the slice. */
    if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
        _FP_METER_BMP_REMOVE(fs->meter_bmp, idx);
        _FP_METER_BMP_REMOVE(fs->meter_bmp, idx + 1);
    } else {

        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            _FP_METER_BMP_REMOVE(fs->meter_bmp, idx);

            /* Clear excess meter flag bit. */
            _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
        } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            _FP_METER_BMP_REMOVE(fs->meter_bmp, idx + 1);
        }
    }

    f_pl->hw_index   = _FP_INVALID_INDEX;
    f_pl->pool_index = _FP_INVALID_INDEX;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slice_meter_alloc
 *
 * Purpose:
 *     Allocate a policer for an entry from a slice.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     fs        - (IN) Slice policer will be installed in.
 *     f_pl      - (IN) Policer descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_meter_alloc(int unit, _field_slice_t *fs, _field_policer_t *f_pl)
{
    int              idx;          /* Policer iteration index. */

    /* Input parameters check. */
    if ((NULL == f_pl) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    /* Find unused meter in the slice. */
    for (idx = 0; idx < fs->meters_count; idx++) {

        /* Allocate a meter pair for non-flow mode policer. */
        if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {

            if (0 != (idx % 2)) {
                /* skip odd meter indices. */
                continue;
            }

            if ((0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx))
                && (0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx + 1))) {
                _FP_METER_BMP_ADD(fs->meter_bmp, idx);
                _FP_METER_BMP_ADD(fs->meter_bmp, (idx + 1));
                f_pl->pool_index =  fs->slice_number;
                f_pl->hw_index   =  (idx / 2) ;
                break;
            }
        }

        /* Allocate a meter from meter pair for flow mode meters. */
        if (_FP_POLICER_IS_FLOW_MODE(f_pl)
            && (0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx))) {

            if (f_pl->hw_flags & _FP_POLICER_DIRTY) {
                f_pl->hw_flags &= (idx % 2)
                                    ? ~_FP_POLICER_PEAK_DIRTY
                                    : ~_FP_POLICER_COMMITTED_DIRTY;
            } else {
                /* Meter move operation, flag is set here. */
                f_pl->hw_flags |= (idx % 2)
                                    ? _FP_POLICER_COMMITTED_DIRTY
                                    : _FP_POLICER_PEAK_DIRTY;
            }

            if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {
                _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
            } else {
                _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
            }

            _FP_METER_BMP_ADD(fs->meter_bmp, idx);
            f_pl->pool_index =  fs->slice_number;
            f_pl->hw_index   =  (idx / 2);
            break;
        }
    }

    if (idx == fs->meters_count) {
        return (BCM_E_RESOURCE);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_meter_hw_free
 *
 * Purpose:
 *     Deallocate a policer from an entry slice.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN/OUT) Entry policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_meter_hw_free(int unit, _field_entry_t *f_ent)
{
    _field_stage_t         *stage_fc;    /* Field stage control.            */
    _field_entry_policer_t *f_ent_pl;    /* Field entry policer structure.  */
    uint8                  entry_part;   /* Secondary entry part.           */
    _field_policer_t       *f_pl;        /* Policer descriptor.             */
    _field_group_t         *fg;          /* Field group structure.          */
    int                     rv;          /* Operation return status.        */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    f_ent_pl = f_ent->policer;
    fg = f_ent->group;

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Read policer configuration.*/
    BCM_IF_ERROR_RETURN(_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /* Policer slice index sanity check. */
    if ((f_pl->pool_index >= stage_fc->tcam_slices)
        || (f_pl->pool_index == _FP_INVALID_INDEX)) {
        return (BCM_E_INTERNAL);
    }

    /* Free policer id. */
    rv = _field_slice_meter_free(unit, f_ent, f_pl);

    /* Reset entry policer related flags. */
    if (f_ent->flags & _FP_ENTRY_POLICER_IN_SECONDARY_SLICE) {
        /* Get primary entry from the second slice. */
        rv = _bcm_field_entry_flags_to_tcam_part(unit, _FP_ENTRY_SECONDARY,
                                                  fg, &entry_part);
        BCM_IF_ERROR_RETURN(rv);
        sal_memset(f_ent[entry_part].policer, 0, sizeof(_field_entry_policer_t));
        f_ent->flags &=  ~_FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
    }
    return (rv);
}

/*
 * Function:
 *     _field_meter_hw_alloc
 *
 * Purpose:
 *     Allocate a policer/s for an entry from a slice.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN/OUT) Entry array policer belongs to.
 *     fs        - (IN) Desired slice for the policer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_meter_hw_alloc(int unit, _field_entry_t *f_ent, _field_slice_t *fs)
{
    _field_entry_policer_t *f_ent_pl;           /* Field entry policer .     */
    _field_policer_t       *f_pl;               /* Policer descriptor.       */
    _field_group_t         *fg;                 /* Field group structure.    */
    uint8                  entry_part;          /* Field entry tcam part .   */
    int                    rv = BCM_E_RESOURCE; /* Operation return status.  */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    f_ent_pl = f_ent->policer;

    /* Reject unused policers. */
    if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
        return (BCM_E_PARAM);
    }

    /* Read policer configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /*
     *  Allocate meter from a primary slice unless color dependent counter
     *  is only availabe in secondary slice
     */
    if (0 == (f_ent->flags & _FP_ENTRY_ALLOC_FROM_SECONDARY_SLICE)) {
        rv = _field_slice_meter_alloc(unit, fs, f_pl);
    }
    if (BCM_E_RESOURCE == rv)  {
        fg = f_ent->group;

        /* Double/Triple wide groups might allocate from secondary slice. */
        if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)
            || (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {

            rv = _field_slice_meter_alloc(unit, fs + 1, f_pl);
            if (BCM_SUCCESS(rv)) {

                /* Get primary entry from the second slice. */
                rv = _bcm_field_entry_flags_to_tcam_part (unit,
                                                         _FP_ENTRY_SECONDARY,
                                                        fg, &entry_part);
                BCM_IF_ERROR_RETURN(rv);

                f_ent->flags |= _FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
                sal_memcpy(f_ent[entry_part].policer, f_ent->policer,
                           sizeof(_field_entry_policer_t));
                f_ent[entry_part].policer->flags |= _FP_POLICER_INSTALLED;
            }
        }
    }
    return (rv);
}


/*
 * Function:
 *     _field_policer_meter_hw_free
 *
 * Purpose:
 *     Clear the meter entries from the h/w associated with the policer
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     level     - (IN) Policer level.
 *     f_ent     - (IN) Entry policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_policer_meter_hw_free(int unit, _field_entry_t *f_ent,
                             _field_entry_policer_t *f_ent_pl)
{
    _field_stage_t    *stage_fc;        /* Stage field control structure */
    _field_policer_t  *f_pl;            /* Policer descriptor            */
    soc_mem_t          meter_table_x;   /* Meter table name              */
    soc_mem_t          meter_table_y;   /* Meter table name              */
    soc_mem_t          meter_table;     /* Meter table name              */
    int                meter_idx;       /* Meter hw index                */
    int                idx;             /* Meter hw index                */
    int                rv = BCM_E_NONE; /* Return value                  */
    int                iter = 0;        /* Iteration count               */


    meter_table_x = INVALIDm;
    meter_table_y = INVALIDm;

    /* Get field stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, f_ent->group->stage_id,
                                  &stage_fc));

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        return _bcm_field_th_policer_meter_hw_free(unit, f_ent, f_ent_pl);
    }
#endif

    /* Resolve meter table name. */
#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        BCM_IF_ERROR_RETURN
            (_field_trx_meter_table_get(unit, f_ent->fs->stage_id,
                                        &meter_table_x, &meter_table_y));
    } else
#endif
    {
#if defined(BCM_FIREBOLT_SUPPORT) ||defined(BCM_RAPTOR_SUPPORT)
        BCM_IF_ERROR_RETURN
            (_field_fb_policer_mem_get (unit, f_ent, &meter_table_x));
#endif
    }

    /* Read policer configuration.*/
    BCM_IF_ERROR_RETURN
        (_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /* Must be a valid meter index. */
    if (f_pl->hw_index == _FP_INVALID_INDEX) {
        return (BCM_E_INTERNAL);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /* Get slice policer installed in. */
        idx =  (f_pl->pool_index *
                stage_fc->meter_pool[f_ent->group->instance]
                                    [f_pl->pool_index]->pool_size)
                + (2 * f_pl->hw_index);

    } else {
        idx = stage_fc->slices[f_ent->group->instance]
                              [f_pl->pool_index].start_tcam_idx
                              + (2 * f_pl->hw_index);
    }

    meter_idx = idx;
    for (iter = 0; iter < 2; iter++) {
        idx = meter_idx;

        if (0 == iter) {
            meter_table = meter_table_x;
        } else {
            meter_table = meter_table_y;
        }

        if (meter_table == INVALIDm) {
            continue;
        }

        if (idx < soc_mem_index_min(unit, meter_table) ||
            idx > soc_mem_index_max(unit, meter_table)) {
            return (BCM_E_INTERNAL);
        }

        if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
            rv = soc_mem_write(unit, meter_table, MEM_BLOCK_ALL,
                    idx, soc_mem_entry_null(unit,meter_table));
            BCM_IF_ERROR_RETURN(rv);

            idx++;
            rv = soc_mem_write(unit, meter_table, MEM_BLOCK_ALL,
                    idx, soc_mem_entry_null(unit,meter_table));
        } else {
            if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
                idx ++;
            }

            rv = soc_mem_write(unit, meter_table, MEM_BLOCK_ALL,
                    idx, soc_mem_entry_null(unit,meter_table));
        }
    }

    return (BCM_E_NONE);
}

STATIC int
_field_policer_hw_free(int unit, uint8 level, _field_entry_t *f_ent)
{
    _field_entry_policer_t *f_ent_pl;  /* Field entry policer structure. */
    _field_stage_t         *stage_fc;  /* Stage field contol.            */
    _field_policer_t       *f_pl;      /* Policer descriptor.            */
    _field_stage_id_t      stage_id;  /* Stage id used for metering.          */

    /* Input parameters check. */
    if ((NULL == f_ent) || (level >= _FP_POLICER_LEVEL_COUNT)) {
        return (BCM_E_PARAM);
    }

    f_ent_pl = f_ent->policer + level;

    if (f_ent_pl->flags & _FP_POLICER_INSTALLED) {
        f_ent_pl->flags = _FP_POLICER_DETACH;
        return (BCM_E_NONE);
    } else {
        if (0 == (f_ent_pl->flags & _FP_POLICER_DETACH)) {
            /* Read policer configuration.*/
            BCM_IF_ERROR_RETURN
                (_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

            /* Decrement policer reference counter. */
            f_pl->sw_ref_count--;

            f_ent_pl->pid   = _FP_INVALID_INDEX;
            f_ent_pl->flags = 0;

            return (BCM_E_NONE);
        }
    }

    /* Read policer configuration.*/
    BCM_IF_ERROR_RETURN(_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /* Decrement hw reference count. */
    if (f_pl->hw_ref_count > 0) {
        f_pl->hw_ref_count--;
    }

    /* Policer not used by any other entry. */
    if (f_pl->hw_ref_count == 0) {

        stage_id = (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ? \
                   _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

        /* Deinstall policer from hw. */
        BCM_IF_ERROR_RETURN
            (_field_stage_control_get(unit, stage_id, &stage_fc));

        _field_policer_meter_hw_free(unit, f_ent, f_ent_pl);
        /* Mark hw resource as unused in sw. */
        if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
            BCM_IF_ERROR_RETURN
                (_field_meter_pool_entry_free(unit, stage_fc,
                                              f_ent->group->instance, f_pl));
        } else {
            BCM_IF_ERROR_RETURN(_field_meter_hw_free(unit, f_ent));
        }
        /* decrement group meter count when the hw_ref_count
           becomes 0 */
        f_ent->group->group_status.meter_count--;
        /* for flow mode, 1 meter is associated to group
           and for all other modes, 2 meters are associated */
        if(!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
            f_ent->group->group_status.meter_count--;
        }
        /* Mark policer for reinstallation. */
        BCM_IF_ERROR_RETURN (_field_policer_hw_flags_set(unit, f_pl, 0));
    }

    /* Decrement policer reference counter. */
    f_pl->sw_ref_count--;

    f_ent_pl->pid   = _FP_INVALID_INDEX;
    f_ent_pl->flags = 0;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_policers_hw_alloc
 *
 * Purpose:
 *     Allocate policers required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry array.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_policers_hw_alloc(int unit, _field_entry_t *f_ent)
{
    _field_entry_policer_t *f_ent_pl;  /* Field entry policer structure.*/
    _field_stage_t         *stage_fc;  /* Stage field control.          */
    _field_policer_t       *f_pl;      /* Field policer descriptor.     */
    _field_control_t       *fc;        /* Field control structure.      */
    int                    idx;        /* Policer levels iterator.      */
    int                    rv;         /* Operation return status.      */
    _field_meter_pool_t    *f_mp;      /* Meter pool descriptor.        */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get field stage control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate policers if necessary. */
    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;
        /* Skip invalid policers. */
        if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
            continue;
        }

        /* Read policer configuration.*/
        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);

        /*
         * Check if entry's primary slice_number matches
         * Policer meter pool slice_id for Level0 policer.
         */
        if ((!(_FP_POLICER_GROUP_SHARE_ENABLE & fc->flags)) &&
             (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {

            if ((0 == idx) && (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)
                && (_FP_INVALID_INDEX != f_pl->pool_index)) {

                f_mp = stage_fc->meter_pool[f_ent->group->instance]
                                           [f_pl->pool_index];
                if (f_ent->group->slices->slice_number != f_mp->slice_id) {
                    return (BCM_E_PARAM);
                }

            }
        }

        /*
         * Check policer mode support - double check in case
         * attached policer was modified by bcm_policer_set API.
         */
        rv = _field_policer_mode_support(unit, f_ent, idx, f_pl);
        BCM_IF_ERROR_RETURN(rv);

        /* Allocate policer hw index. */
        if (_FP_INVALID_INDEX == f_pl->hw_index) {
            if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
                rv = _field_meterpool_hw_entry_alloc(unit, f_ent, f_pl);
            } else {
                rv = _field_meter_hw_alloc(unit, f_ent, f_ent->fs);
            }
            BCM_IF_ERROR_RETURN(rv);
        }

        /* Increment hw reference count. */
        if (0 == (f_ent_pl->flags & _FP_POLICER_INSTALLED)) {
            f_ent_pl->flags |=  _FP_POLICER_INSTALLED;
            f_pl->hw_ref_count++;
            /* Increment group meter count when hw_ref_count
               becomes 1 (policer can be shared). */
            f_ent->group->group_status.meter_count++;
            /* for flow mode, 1 meter is associated to group
               and for all other modes, 2 meters are associated */
            if(!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
                f_ent->group->group_status.meter_count++;
            }
        }

        if (f_pl->hw_flags & _FP_POLICER_DIRTY) {
            BCM_IF_ERROR_RETURN(fc->functions.fp_policer_install(unit, f_ent, f_pl));
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_policers_hw_free
 *
 * Purpose:
 *     Free entry policers.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 *     flags     - (IN) Flags to free old/all resources
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_policers_hw_free(int unit, _field_entry_t *f_ent, uint32 flags)
{
    _field_entry_policer_t *f_ent_pl;       /* Field entry policer structure.*/
    int                    idx;             /* Policer levels iterator.      */
    bcm_policer_t          policer_id = -1; /* Policer Id.                   */
    uint8                  isPolicerDetach = 0;

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Allocate policers if necessary. */
    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;
        policer_id = f_ent_pl->pid;
        isPolicerDetach = (f_ent_pl->flags & _FP_POLICER_DETACH);

        if ((_FP_ACTION_OLD_RESOURCE_FREE & flags) &&
            (0 == (f_ent_pl->flags & _FP_POLICER_DETACH))) {
            /* Old resourse should have the detach flag set */
            continue;
        }

        if (0 == (f_ent_pl->flags & _FP_POLICER_DETACH)) {
            /* Skip invalid policers. */
            if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
                continue;
            }
            /* Skip installed policers. */
            if (0 == (f_ent_pl->flags & _FP_POLICER_INSTALLED)) {
                continue;
            }
        }

        if ((_FP_ACTION_RESOURCE_FREE & flags) &&
            (0 == (f_ent_pl->flags & _FP_POLICER_DETACH))) {
            /* Forced released if h/w resources
             * When this comes to this place, then the policer
             * is not detached but it is valid and installed
             * Mark the policy as detached and release the resource
             */
            f_ent_pl->flags = _FP_POLICER_DETACH;
        }

        BCM_IF_ERROR_RETURN(_field_policer_hw_free(unit, idx, f_ent));

        if ((flags & _FP_ACTION_POLICER_SW_UPDATE) && (!isPolicerDetach)) {
            BCM_IF_ERROR_RETURN (bcm_esw_field_entry_policer_attach
                                                     (unit,f_ent->eid,
                                                      idx,policer_id));
        }
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *      _field_entry_policer_detach
 * Purpose:
 *      Detach a policer from a field entry.
 * Parameters:
 *      unit     - (IN) Unit number.
 *      entry_id - (IN) Field entry ID.
 *      level    - (IN) Policer level.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_entry_policer_detach(int unit, _field_entry_t *f_ent, int level)
{
    _field_entry_policer_t *f_ent_pl;/* Field entry policer structure.*/
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
     int rv=0;
     vfp_policy_table_entry_t vfp_entry;
#endif
    /* Input parameters check. */
    if ((level >= _FP_POLICER_LEVEL_COUNT) || (level < 0)) {
        return (BCM_E_PARAM);
    }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    if ((SOC_IS_KATANAX(unit)) || (SOC_IS_TRIUMPH3(unit))
            || (SOC_IS_APACHE(unit))) {
        if ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) ||
            (SOC_IS_TRIUMPH3(unit) &&
            (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id))) {
            rv = _bcm_esw_delete_policer_from_table(unit,
                   f_ent->global_meter_policer.pid, VFP_POLICY_TABLEm,0,&vfp_entry);
            if (BCM_FAILURE(rv)) {
                return (rv);
            }
            f_ent->global_meter_policer.pid = 0;
            f_ent->global_meter_policer.flags = 0;
            /* Entry must be reinstalled for policer to take effect. */
            f_ent->flags  |= _FP_ENTRY_DIRTY;
            return (BCM_E_NONE);
        }
    }
#endif
    /* Make sure policer attached to the entry. */
    f_ent_pl = f_ent->policer + level;
    if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
        return (BCM_E_EMPTY);
    }

    /* If entry was installed decrement hw reference counter. */
    BCM_IF_ERROR_RETURN(_field_policer_hw_free (unit, level, f_ent));

    /*
     * If qualifiers have not been modified for this entry,
     * set Policy table only dirty flag.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }
    /* Mark entry for reinstall. */
    f_ent->flags |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_stat_get
 * Purpose:
 *     Lookup a statistics entity description structure by stat id.
 * Parmeters:
 *     unit      - (IN)  BCM device number.
 *     sid       - (IN)  Statistics entity id.
 *     stat_p    - (OUT) Lookup result.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_stat_get(int unit, int sid, _field_stat_t **stat_p)
{
    _field_stat_t    *f_st; /* Policer lookup pointer.  */
    _field_control_t *fc;   /* Field control structure. */
    uint32 hash_index;      /* Entry hash.              */

    /* Input parameters check. */
    if (NULL == stat_p) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    hash_index = sid & _FP_HASH_INDEX_MASK(fc);
    f_st  =  fc->stat_hash[hash_index];
    while (NULL != f_st) {
        /* Match entry id. */
        if (f_st->sid == sid) {
            *stat_p = f_st;
            return (BCM_E_NONE);
        }
        f_st = f_st->next;
    }

    /* Statistics entity with sid == sid was not found. */
    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *      _bcm_field_stat_id_alloc
 * Purpose:
 *      Allocate a statistics entity id.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      sid     - (OUT) Stat id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_stat_id_alloc(int unit, int *sid)
{
    int               max_count;           /* Maximum number of sids to try.*/
    _field_stat_t     *f_st;               /* Field stat descriptor.        */
    int               rv;                  /* Operation return status.      */
    static uint32  last_allocated_sid = 0; /* Policer id alloc tracker.     */

    /* Input parameters check. */
    if (NULL == sid) {
        return (BCM_E_PARAM);
    }

    max_count = _FP_ID_MAX;
    while (max_count--) {
        last_allocated_sid++;
        if (_FP_ID_MAX == last_allocated_sid) {
            last_allocated_sid = _FP_ID_BASE;
        }
        rv = _bcm_field_stat_get(unit, last_allocated_sid, &f_st);
        if (BCM_E_NOT_FOUND == rv) {
            *sid = last_allocated_sid;
            return (BCM_E_NONE);
        }
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }
    return (BCM_E_RESOURCE);
}


/*
 * Function:
 *    _field_stat_array_to_bmap
 *
 * Description:
 *      API caller statistics array bit map
 * Parameters:
 *      unit  - (IN) BCM device number.
 *      f_st  - (IN) Field statistics entity.
 *      bmap  - (OUT) Field group id.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_field_stat_array_to_bmap(int unit, _field_stat_t *f_st, uint32 *bmap)
{
    int idx;

    /* Input parameters check */
    if ((NULL == f_st) || (NULL == bmap)) {
        return (BCM_E_PARAM);
    }

    *bmap = 0;
    for (idx = 0; idx < f_st->nstat; idx++) {
        if (NULL == (f_st->stat_arr + idx)) {
       /*
        * COVERITY
        *
        * This conditin may not hit.
        * It is kept intentionally as a defensive check.
        */
        /* coverity[dead_error_line] */
            return (BCM_E_PARAM);
        }

        /* coverity[mixed_enums] */
        if ((int)f_st->stat_arr[idx] >= _bcmFieldStatCount) {
            return (BCM_E_PARAM);
        }

        *bmap |= (1 << (int)f_st->stat_arr[idx]);
    }
    return (BCM_E_NONE);
}
/*
 * Function:
 *    _bcm_field_stat_array_to_bmap
 *
 * Description:
 *      API caller statistics array bit map
 * Parameters:
 *      unit  - (IN) BCM device number.
 *      f_st  - (IN) Field statistics entity.
 *      bmap  - (OUT) Field group id.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_stat_array_to_bmap(int unit, _field_stat_t *f_st, uint32 *bmap)
{
    return _field_stat_array_to_bmap(unit, f_st, bmap);
}
/*
 * Function:
 *   _field_stat_hw_mode_to_bmap
 *
 * Description:
 *      HW counter mode to statistics bitmap.
 * Parameters:
 *      unit           - (IN) BCM device number.
 *      mode           - (IN) HW counter mode.
 *      stage_id       - (IN) Stage id.
 *      hw_bmap        - (OUT) Statistics bitmap.
 *      hw_entry_count - (OUT) Number of counters required.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_field_stat_hw_mode_to_bmap(int unit, uint16 mode,
                            _field_stage_id_t stage_id,
                            uint32 *hw_bmap, uint8 *hw_entry_count)
{
    int rv;

    /* Input parameters check. */
    if ((NULL == hw_bmap) || (NULL == hw_entry_count)) {
        return (BCM_E_PARAM);
    }

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        rv = _bcm_field_tr3_stat_hw_mode_to_bmap(unit,
                                                 mode,
                                                 stage_id,
                                                 hw_bmap,
                                                 hw_entry_count
                                                 );
    } else
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
        (stage_id == _BCM_FIELD_STAGE_INGRESS)) {
        rv = _bcm_field_trident_stat_hw_mode_to_bmap(unit, mode, stage_id,
                                                 hw_bmap, hw_entry_count);
    } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT)
    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)
        || SOC_IS_VALKYRIE2(unit)) {
        rv = _bcm_field_tr2_stat_hw_mode_to_bmap(unit, mode, stage_id,
                                                 hw_bmap, hw_entry_count);
    } else
#endif /* !BCM_TRIUMPH2_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        rv = _bcm_field_trx_stat_hw_mode_to_bmap(unit, mode, stage_id,
                                                 hw_bmap, hw_entry_count);
    } else
#endif /* BCM_TRX_SUPPORT */
    {
        rv = _bcm_field_fb_stat_hw_mode_to_bmap(unit, mode, stage_id,
                                                hw_bmap, hw_entry_count);
    }
    return (rv);
}

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *    _field_flowcnt_mode_get
 * Purpose:
 *    Get flowcnt stat hardware counter mode information
 * Parameters:
 *     unit  - (IN) BCM device number
 *     f_st  - (IN) Pointer to field stat structure
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_flowcnt_mode_get(int unit,
                         _field_stat_t *f_st)
{
    uint32 req_bmap;    /* Requested statistics bitmap.    */

    /* Input parameter check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        f_st->hw_mode = 0;
        f_st->hw_stat = 0;
        f_st->hw_flags |= _FP_STAT_FLOWCNT_CNTR;
        f_st->flex_mode = 0;
        f_st->hw_entry_count = 0;
        return (BCM_E_NONE);
    }

    /* VFP stages support only Pkt or Byte STATs */
    if ((req_bmap != (1 << (int)bcmFieldStatBytes)) &&
        (req_bmap != (1 << (int)bcmFieldStatPackets))) {
        return (BCM_E_UNAVAIL);
    }

    /* Initialize stat structure with flowcnt stat parameter info. */
    f_st->hw_mode = (int) bcmStatGroupModeSingle;
    f_st->hw_stat = req_bmap;
    f_st->hw_flags |= _FP_STAT_FLOWCNT_CNTR;
    f_st->flex_mode = 0;
    /* No. of hw entries is known only after Flow Count STAT alloc. */
    /* f_st->hw_entry_count = 1; */

    return (BCM_E_NONE);
}
#endif

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *    _field_flex_mode_get
 * Purpose:
 *    Get flex stat hardware counter mode information
 * Parameters:
 *     unit  - (IN) BCM device number
 *     f_st  - (IN) Pointer to field stat structure
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_flex_mode_get(int unit,
                         _field_stat_t *f_st)
{
    uint32 req_bmap;    /* Requested statistics bitmap.    */
    uint32 valid_bmap;  /* Bitmap of valid flex STAT types. */

    /* Input parameter check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        f_st->hw_mode = 0;
        f_st->hw_stat = 0;
        f_st->hw_flags |= _FP_STAT_FLEX_CNTR;
        f_st->flex_mode = 0;
        f_st->hw_entry_count = 0;
        return (BCM_E_NONE);
    }

    /* VFP stages support only Pkt and Byte STATs */
    valid_bmap = ((1 << (int) bcmFieldStatBytes) |
                    (1 << (int) bcmFieldStatPackets));

    /* Validate requested STAT types. */
    if (req_bmap & ~(valid_bmap)) {
        return (BCM_E_UNAVAIL);
    }

    /* Initialize stat structure with flex stat parameter info. */
    f_st->hw_mode = (int) bcmStatGroupModeSingle;
    f_st->hw_stat = req_bmap;
    f_st->hw_flags |= _FP_STAT_FLEX_CNTR;
    f_st->flex_mode = 0;
    /* No. of hw entries is known only after Flex Hw STAT alloc. */
    /* f_st->hw_entry_count = 1; */

    return (BCM_E_NONE);
}
#endif

/*
 * Function:
 *    _bcm_field_stat_hw_mode_get
 *
 * Description:
 *      Get hw counter mode which will satisfy requested statistics set.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      f_st     - (IN) Field statistics entity.
 *      stage_id - (IN) Field stage id.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_stat_hw_mode_get(int unit, _field_stat_t *f_st,
                            _field_stage_id_t stage_id)
{
    uint32            req_bmap;       /* Requested statistics bitmap.    */
    uint32            hw_bmap;        /* HW supported statistics bitmap. */
    uint8             hw_entry_count; /* Number of counter table entries.*/
    uint16            idx;            /* HW counter modes iterator.      */
    int               rv;             /* Operation return status.        */
    int               fp_stat_hw_mode_max;

    /* Input parameters check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    /*
     * If device supports advanced flex counters
     * and stage is lookup stage, then get
     * flex stat mode for this Stat.
     */
    if (soc_feature(unit, soc_feature_advanced_flex_counter)
        && ((_BCM_FIELD_STAGE_LOOKUP == stage_id)
        || (_BCM_FIELD_STAGE_EXTERNAL == stage_id))) {
        return (_field_flex_mode_get(unit, f_st));
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    /*
     * If device supports vlan flow counters
     * and stage is lookup stage, then get
     * flow count stat mode for this Stat.
     */
    if (soc_feature(unit, soc_feature_flowcnt)
        && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {
        return (_field_flowcnt_mode_get(unit, f_st));
    }
#endif


#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_tr3_stat_hw_mode_max(stage_id,
                                             &fp_stat_hw_mode_max
                                             )
            );
    } else
#endif
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
        (stage_id == _BCM_FIELD_STAGE_INGRESS)) {
        fp_stat_hw_mode_max = _FP_TRIDENT_STAT_HW_MODE_MAX;
    } else {
        fp_stat_hw_mode_max = _FP_STAT_HW_MODE_MAX;
    }

    /* Get application requested bitmap. */
    rv = _field_stat_array_to_bmap (unit, f_st, &req_bmap);
    BCM_IF_ERROR_RETURN(rv);

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        f_st->hw_stat = 0;
        f_st->hw_entry_count = 0;
        f_st->hw_mode = 0;
        return (BCM_E_NONE);
    }

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
    if ((soc_feature(unit, soc_feature_field_vfp_flex_counter) ||
        soc_feature(unit, soc_feature_flowcnt))
        && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {

        hw_bmap = (1 << (int)bcmFieldStatBytes)
                    | (1 << (int)bcmFieldStatPackets);

        if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
            f_st->hw_mode = 1;
            f_st->hw_stat = hw_bmap;
            f_st->hw_entry_count = 1;
            return (BCM_E_NONE);
        }

        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Check if any hw supported mode will produce requested statistics. */
#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        /* The f_st->hw_mode has already been read from the HW */
        rv = _field_stat_hw_mode_to_bmap (unit, f_st->hw_mode, stage_id,
                                          &hw_bmap, &hw_entry_count);
    } else
#endif
    {
        for (idx = 1; idx <= fp_stat_hw_mode_max; idx++) {
            rv = _field_stat_hw_mode_to_bmap(unit, idx, stage_id,
                                             &hw_bmap, &hw_entry_count);
            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                      "MODE:0x%x (l:%d u:%d) req_bmap:[0x%x] hw_bmap:[0x%x]"
                      " hw_entry_count:%d :: [0x%x]\n\r"), idx, (idx & 0x7),
                      ((idx >> 3) & 0x7), req_bmap, hw_bmap, hw_entry_count,
                      ((req_bmap | hw_bmap) & ~(hw_bmap))));

            if (rv == BCM_E_CONFIG) {
               /* Returns BCM_E_CONFIG, if the given mode is not supported */
               continue;
            }

            if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
                /* <HP>

                   For maximizing utilization of hardware counters, this should
                   select the hw_mode both supports the requested stats
                   AND minimizes the number of required hardware counters.

                   </HP> */

                break;
            }
        }
        if  (idx > fp_stat_hw_mode_max) {
            return (BCM_E_RESOURCE);
        }
        f_st->hw_mode = idx;
    }

    f_st->hw_stat = hw_bmap;
    f_st->hw_entry_count = hw_entry_count;

    return (BCM_E_NONE);
}


/*
 * Function:
 *      _field_stat_destroy2
 * Purpose:
 *      Deinitialize a statistics collection entity
 * Parameters:
 *      unit    - (IN) Unit number.
 *      fc      - (IN) Internal stat entity descriptor.
 *      f_st    - (IN) Field stat s
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_stat_destroy2(int unit, _field_control_t *fc, _field_stat_t *f_st)
{
    /* Input parameters check. */
    if ((NULL == fc) || (NULL == f_st)) {
        return (BCM_E_PARAM);
    }

    /* Reject destroy if policer is in use. */
    if (f_st->sw_ref_count > 1) {
        return (BCM_E_BUSY);
    }

    /* Remove policer for lookup hash. */
    _FP_HASH_REMOVE(fc->stat_hash, _field_stat_t, f_st,
                    (f_st->sid & _FP_HASH_INDEX_MASK(fc)));

    /* De-allocate statistics entity descriptor. */
    if (NULL != f_st->stat_arr) {
        sal_free(f_st->stat_arr);
    }
    if (NULL != f_st->stat_values) {
        sal_free(f_st->stat_values);
    }

    sal_free(f_st);

    /* Decrement number of active policers. */
    if (fc->stat_count > 0) {
        fc->stat_count--;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_stat_destroy
 * Purpose:
 *      Deinitialize a statistics collection entity
 * Parameters:
 *      unit    - (IN) Unit number.
 *      sid     - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_stat_destroy(int unit, int sid)
{
    _field_control_t  *fc;         /* Field control structure.     */
    _field_stat_t     *f_st;       /* Internal policer descriptor. */
    int               rv;          /* Operation return status.     */

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Find policer info. */
    rv = _bcm_field_stat_get(unit, sid, &f_st);
    BCM_IF_ERROR_RETURN(rv);

    return _field_stat_destroy2(unit, fc, f_st);
}
/*
 * Function:
 *      _bcm_field_stat_destroy
 * Purpose:
 *      Deinitialize a statistics collection entity
 * Parameters:
 *      unit    - (IN) Unit number.
 *      sid     - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_stat_destroy(int unit, int sid)
{
    return _field_stat_destroy(unit, sid);
}
/*
 * Function:
 *      _field_stat_destroy_all
 * Purpose:
 *      Destroy all statistics collection entities
 * Parameters:
 *      unit    - (IN) Unit number.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_stat_destroy_all(int unit)
{
    _field_control_t *fc;   /* Field control structure. */
    int idx;                /* Entry hash iterator.     */
    int idx_max;            /* Index max.               */
    int rv;                 /* Operation return status. */

    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    idx_max = _FP_HASH_SZ(fc);
    for (idx= 0; idx < idx_max; idx ++) {
        while (NULL != fc->stat_hash[idx]) {
            rv = _field_stat_destroy2(unit, fc, fc->stat_hash[idx]);
            if (BCM_FAILURE(rv)) {
                break;
            }
        }
    }
    return (rv);
}

/*
 * Function:
 *      _bcm_field_group_stat_destroy
 * Purpose:
 *      Destroy all statistics collection entities
 *      associated to a field group.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      group   - (IN) field group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_group_stat_destroy(int unit, bcm_field_group_t group)
{
    _field_control_t *fc;   /* Field control structure. */
    int idx;                /* Entry hash iterator.     */
    int idx_max;            /* Index max.               */
    int rv;                 /* Operation return status. */
    _field_stat_t *f_st;    /* Reference to Field stat structure. */
    _field_stat_t *f_st_free, *f_st_prev;

    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    idx_max = _FP_HASH_SZ(fc);
    for (idx= 0; idx < idx_max; idx ++) {
        f_st = fc->stat_hash[idx];
        f_st_prev = NULL;
        while (NULL != f_st) {
            if (group == f_st->gid) {
                if (f_st_prev != NULL) {
                   f_st_prev->next = f_st->next;
                   f_st_free = f_st;
                   f_st = f_st_prev->next;
                } else {
                   f_st_free = f_st;
                   f_st = f_st->next;
                   rv = _field_stat_destroy2(unit, fc, f_st_free);
                   if (BCM_FAILURE(rv)) {
                      break;
                   }
                   continue;
                }

                /* De-allocate statistics entity descriptor. */
                if (NULL != f_st_free->stat_arr) {
                   sal_free(f_st_free->stat_arr);
                }
                if (NULL != f_st_free->stat_values) {
                   sal_free(f_st_free->stat_values);
                }

                sal_free(f_st_free);
                f_st_free = NULL;

                /* Decrement number of active policers. */
                if (fc->stat_count > 0) {
                   fc->stat_count--;
                }
            } else {
                f_st_prev = f_st;
                f_st = f_st->next;
            }
        }
    }
    return (rv);
}

/*
 * Function:
 *    _field_stat_array_init
 *
 * Description:
 *      Preserve API requested statistics array.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      f_st     - (IN) Field statistics entity.
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (IN) Collected statistics descriptors array.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_stat_array_init(int unit, _field_control_t *fc, _field_stat_t *f_st,
                       int nstat, bcm_field_stat_t *stat_arr)
{
    int rv;

    /* Input parameters check. */
    if ((NULL == f_st) || (0 == nstat) || (NULL == stat_arr) || (NULL == fc)) {
        return (BCM_E_PARAM);
    }

    /* Free currently allocated  stat array if any. */
    if (NULL != f_st->stat_arr) {
        sal_free(f_st->stat_arr);
        f_st->stat_arr = NULL;
        f_st->nstat = 0;
    }

    /* Free currently allocated  values array if any. */
    if (NULL != f_st->stat_values) {
        sal_free(f_st->stat_values);
        f_st->stat_values = NULL;
    }

    _FP_XGS3_ALLOC(f_st->stat_arr, (nstat * sizeof (bcm_field_stat_t)),
                   "Field stat array");
    if (NULL == f_st->stat_arr) {
        return (BCM_E_MEMORY);
    }

    _FP_XGS3_ALLOC(f_st->stat_values, (nstat * sizeof (uint64)),
                   "Field stat values array");
    if (NULL == f_st->stat_values) {
        sal_free(f_st->stat_arr);
        f_st->stat_arr = NULL;
        return (BCM_E_MEMORY);
    }

    /* Copy stats array. */
    sal_memcpy(f_st->stat_arr, stat_arr, (nstat * sizeof(bcm_field_stat_t)));
    f_st->nstat = nstat;

    /* Map stats array to hw mode. */
    rv = fc->functions.fp_stat_hw_mode_get(unit, f_st, f_st->stage_id);
    if (BCM_FAILURE(rv)) {
        if (!(f_st->hw_flags & _FP_STAT_INTERNAL)) {
            sal_free(f_st->stat_arr);
            sal_free(f_st->stat_values);
            f_st->stat_arr = NULL;
            f_st->stat_values = NULL;
        }
        return (rv);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _bcm_field_stat_array_init
 *
 * Description:
 *      Preserve API requested statistics array.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      f_st     - (IN) Field statistics entity.
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (IN) Collected statistics descriptors array.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_stat_array_init(int unit, _field_control_t *fc,
                           _field_stat_t *f_st, int nstat,
                           bcm_field_stat_t *stat_arr)
{
    /* Input parameters check. */
    if ((NULL == f_st) || (0 == nstat) || (NULL == stat_arr) || (NULL == fc)) {
        return (BCM_E_PARAM);
    }

    return _field_stat_array_init(unit, fc, f_st, nstat, stat_arr);
}
/*
 * Function:
 *    _field_stat_create
 *
 * Description:
 *       Create statistics collection entity.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      group    - (IN) Field group id.
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (IN) Collected statistics descriptors array.
 *      flags    - (IN) HW/API specific flags.
 *      stat_id  - (OUT) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_stat_create(int unit, bcm_field_group_t group, int nstat,
                   bcm_field_stat_t *stat_arr, uint32 flags, int *stat_id)
{
    _field_control_t    *fc;          /* Field control structure.     */
    _field_group_t      *fg;          /* Field group pointer.         */
    int                 rv;           /* Operation return status.     */
    _field_stat_t       *f_st = NULL; /* Internal stat descriptor.    */
    int                 idx;

    /* Input parameters check. */
    if ((nstat <= 0) ||
        (NULL == stat_id) ||
        (nstat > (_bcmFieldStatCount + 1))) {
            return (BCM_E_PARAM);
    }

    if ((0 != nstat) && (NULL == stat_arr)) {
        return (BCM_E_PARAM);
    }

    for (idx = 0; idx < nstat; idx++) {
        if ((stat_arr[idx] < bcmFieldStatBytes) ||
                (stat_arr[idx] >= bcmFieldStatCount)) {
            return (BCM_E_PARAM);
        }
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));

    /* Get group descriptor. */
    rv = _field_group_get (unit, group, &fg);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if(_BCM_FIELD_STAGE_CLASS == fg->stage_id) {
            return (BCM_E_UNAVAIL);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
   if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
       if ((0 == soc_feature(unit, soc_feature_field_vfp_flex_counter)) &&
           (0 == soc_feature(unit, soc_feature_flowcnt))
           && (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id)) {
           return (BCM_E_UNAVAIL);
        }
   }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    if (flags & _FP_STAT_CREATE_ID) {
        /* Check if statistics entity id already exists. */
        rv = _bcm_field_stat_get(unit, *stat_id, &f_st);
        if (BCM_SUCCESS(rv)) {
            /* Stat ID already exists return */
            return (BCM_E_EXISTS);
        }
        flags = 0;
    } else {
        /* Generate statistics entity id. */
        BCM_IF_ERROR_RETURN (_bcm_field_stat_id_alloc(unit, stat_id));
    }

    /* Allocate statistics descriptor. */
    _FP_XGS3_ALLOC(f_st, sizeof (_field_stat_t), "Field stat entity");
    if (NULL == f_st) {
        return (BCM_E_MEMORY);
    }

    /* Initialize reference count to 1. */
    f_st->sw_ref_count = 1;

    /* Set hw index to - no hw resources allocated. */
    f_st->pool_index = _FP_INVALID_INDEX;
    f_st->hw_index = _FP_INVALID_INDEX;

    /* Initialize stat id. */
    f_st->sid = *stat_id;

    /* Store caller internal flags. */
    f_st->hw_flags = flags;
    f_st->stage_id = fg->stage_id;
    f_st->gid      = fg->gid;

    /* Allocate counters array. */
    if (0 != nstat) {
        rv = _field_stat_array_init(unit, fc, f_st, nstat, stat_arr);
        if (BCM_FAILURE(rv)) {
            sal_free(f_st);
            return (rv);
        }
    }


    /* Insert policer into statistics hash. */
    _FP_HASH_INSERT(fc->stat_hash, f_st, (*stat_id & _FP_HASH_INDEX_MASK(fc)));

    /* Increment number of active policers. */
    fc->stat_count++;
    f_st->flex_mode = 0;
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_entry_stat_attach
 *
 * Description:
 *       Attach statistics entity to Field Processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      entry     - (IN) Field entry id.
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_entry_stat_attach(int unit, _field_entry_t *f_ent, int stat_id)
{
    _field_entry_stat_t    *f_ent_st; /* Field entry statistics structure.*/
    _field_stat_t          *f_st;     /* Internal statisics descriptor.   */
    _field_stage_id_t      stage_id;  /* Pipeline stage id.               */
    int                    rv;        /* Operation return status.         */
    _field_stage_t         *stage_fc; /* Field stage control structure.*/

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get entry pipeline stage id. */
    stage_id = f_ent->group->stage_id;

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
   if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
       if (!soc_feature(unit, soc_feature_field_vfp_flex_counter) &&
           !soc_feature(unit, soc_feature_flowcnt)
           && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {
           return (BCM_E_UNAVAIL);
        }
   }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
   if (_BCM_FIELD_STAGE_EXACTMATCH == stage_id) {
       if (!(f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT)) {
           if (!(BCM_FIELD_ASET_TEST(f_ent->group->aset,
                                          bcmFieldActionStatGroup))) {
               LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "FP(unit %d) - Exact Match Group %d created"
                   " without action bcmFieldActionStatGroup.\n"),
                    unit, f_ent->group->gid));
               return (BCM_E_CONFIG);
           }
       }
   }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if another  statistics entity is already attached. */
    f_ent_st = &f_ent->statistic;
    if (f_ent_st->flags & _FP_ENTRY_STAT_VALID) {
        return (BCM_E_EXISTS);
    }

    /* Check if statistics action conflicts with other actions */
    if (f_ent_st->flags & _FP_ENTRY_STAT_NOT_ALLOWED) {
        return (BCM_E_CONFIG);
    }

    /* Get statistics entity  description structure. */
    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    BCM_IF_ERROR_RETURN(rv);

    if ((f_st->stage_id != stage_id) ||
        (f_st->gid !=  f_ent->group->gid)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_advanced_flex_counter) &&
            !soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Can't attach flex stat to normal field stat */
        if (((f_st->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                    (f_st->stage_id == _BCM_FIELD_STAGE_EGRESS)) &&
                (f_st->hw_flags & \
                 (_FP_STAT_FLEX_CNTR | _FP_STAT_INTERNAL_FLEX_COUNTER))) {
            return (BCM_E_CONFIG);
        }
    }
#endif

    /* Get stage control information. */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, stage_id, &stage_fc));

    /* Validate STAT pool_index */
    if (_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id
        && !(stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS)
        && !(stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS)
        && (_FP_INVALID_INDEX != f_st->hw_index)) {
        if ((!(f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE)
                && f_ent->fs->slice_number != f_st->pool_index)
            || ((f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE)
                && f_ent->fs->slice_number + 1 != f_st->pool_index)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) - Counters cannot be shared between slices.\n"),
                       unit));
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "             Create a new stat and attach to EID=%d.\n"),
                       f_ent->eid));
            return (BCM_E_CONFIG);
        }
    }

    /* Check if statistics entity can be shared. */
    if (f_st->sw_ref_count > 1) {
        /* Statistics sharing is restricted to a single stage. */
        if (stage_id != f_st->stage_id) {
            return (BCM_E_PARAM);
        }
    }

    /* Increment statistics entity reference counter. */
    f_st->sw_ref_count++;

    /* Attach statistics entity to an entry. */
    f_ent_st->flags |= _FP_ENTRY_STAT_VALID;
    f_ent_st->sid    = stat_id;

    /*
     * If qualifiers have not been modified for this entry,
     * set Policy table only dirty flag.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }

    /* Entry must be reinstalled for statistics to take effect. */
    f_ent->flags  |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}

#if defined(BCM_TRIUMPH2_SUPPORT)
/*
 * Function:
 *     _bcm_esw_fp_flex_stat_index_set
 *
 * Purpose:
 *     Allocation callback from flex stat module used to notify fp module
 *     allocated flex stat index.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control structure.
 *     f_ent     - (IN/OUT) Entry array policer belongs to.
 *     fs        - (IN) Desired slice for the counter.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_esw_fp_flex_stat_index_set(int unit, _bcm_flex_stat_handle_t handle,
                                int fs_idx, void *cookie)
{
    _field_stat_t *f_st = (_field_stat_t *)cookie;
    f_st->hw_index = fs_idx;
    return (BCM_E_NONE);
}
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *     _field_flex_counter_free
 *
 * Purpose:
 *     Free flex counter resources used by field entry/entries.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Entry array policer belongs to.
 *     f_st     - (IN) Statistics entity.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_flex_counter_free(int unit, _field_entry_t *f_ent, _field_stat_t *f_st)
{
    _field_stage_t   *stage_fc;
    int              entry_idx=0;
    int              rv;
    soc_mem_t        tcam_mem;          /* TCAM memory id.         */
    soc_mem_t        policy_mem;        /* Policy table memory id. */
    _field_stage_id_t      stage_id;    /* Pipeline stage id.      */

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );

    stage_id = f_ent->group->stage_id;

    /* Detach flex stat only if it has been created. */
    if (f_st->flex_mode != 0) {
        /*
         * Get entry index at which flex STAT information
         * has been programmed in policy table.
         */
        BCM_IF_ERROR_RETURN
            (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                 stage_fc,
                                                 f_ent->group->instance,
                                                 f_ent->fs->slice_number,
                                                 f_ent->slice_idx,
                                                 &entry_idx
                                                 )
            );

        rv = _field_fb_tcam_policy_mem_get(unit, f_ent->group->stage_id,
                &tcam_mem, &policy_mem);
        BCM_IF_ERROR_RETURN(rv);

        if (stage_id == _BCM_FIELD_STAGE_EGRESS) {
            rv = _bcm_esw_stat_flex_detach_egress_table_counters
                (unit, 0,
                 policy_mem,
                 entry_idx
                );
        } else {
            rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                (unit,
                 policy_mem,
                 entry_idx
                );
        }

        /*
         * Flex STATs module initialized before field module, ignore
         * error during bcm_field_detach().
         */
        if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
            return (rv);
        }

        /*
         * Destroy Flex STAT when created not attached
         * through bcm_field_stat_attach API.
         */
        if (!(f_st->hw_flags & _FP_STAT_CREATED_BY_FLEX_MODULE)) {
            rv = bcm_esw_stat_group_destroy(unit, f_st->flex_mode);

            /*
             * Flex STATs module initialized before field module, ignore
             * error during bcm_field_detach().
             * Ignore:BCM_E_INTERNAL (as multiple stat entries use same SingleMode
             */
            if (rv == BCM_E_INTERNAL) { /* Doesn't look appropriate error code but*/
                rv = BCM_E_NONE;
            }
            if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
                return (rv);
            }
        }
        /* decrement the group's counter count equal to
           the hw counters used for this stat */
        f_ent->group->group_status.counter_count =
        f_ent->group->group_status.counter_count - f_st->hw_entry_count;

        f_st->hw_index   = _FP_INVALID_INDEX;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_entry_count = 0;
        f_st->flex_mode = 0;
    }

    return (BCM_E_NONE);
}
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *     _field_flowcnt_counter_free
 *
 * Purpose:
 *     Free flow count counter resources used by field entry/entries.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Entry array policer belongs to.
 *     f_st     - (IN) Statistics entity.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_flowcnt_counter_free(int unit, _field_entry_t *f_ent, _field_stat_t *f_st)
{
    _field_stage_t   *stage_fc;
    int              entry_idx=0;
    int              rv;
    soc_mem_t        tcam_mem;          /* TCAM memory id.         */
    soc_mem_t        policy_mem;        /* Policy table memory id. */

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );

    /* Detach flex stat only if it has been created. */
    if (f_st->flex_mode != 0) {
        /*
         * Get entry index at which flowcnt STAT information
         * has been programmed in policy table.
         */
        BCM_IF_ERROR_RETURN
            (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                 stage_fc,
                                                 f_ent->group->instance,
                                                 f_ent->fs->slice_number,
                                                 f_ent->slice_idx,
                                                 &entry_idx
                                                 )
            );

        rv = _field_fb_tcam_policy_mem_get(unit, f_ent->group->stage_id,
                &tcam_mem, &policy_mem);
        BCM_IF_ERROR_RETURN(rv);

        rv = _bcm_esw_flowcnt_object_table_detach(unit,
                                policy_mem, entry_idx);

        /*
         * Flex STATs module initialized before field module, ignore
         * error during bcm_field_detach().
         */
        if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
            return (rv);
        }

        /*
         * Destroy Flow count STAT.
         */
        rv = bcm_esw_stat_group_destroy(unit, f_st->flex_mode);

        /*
         *  STATs module initialized before field module, ignore
         * error during bcm_field_detach().
         * Ignore:BCM_E_INTERNAL (as multiple stat entries use same SingleMode
         */
        if (rv == BCM_E_INTERNAL) { /* Doesn't look appropriate error code but*/
            rv = BCM_E_NONE;
        }
        if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
            return (rv);
        }

        f_st->hw_index   = _FP_INVALID_INDEX;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_entry_count = 0;
        f_st->flex_mode = 0;
    }

    return (BCM_E_NONE);
}
#endif


/*
 * Function:
 *     _field_slice_counter_free
 *
 * Purpose:
 *     Free a counter from a slice.
 *
 * Parameters:
 *     unit  - (IN) Bcm device number.
 *     f_ent - (IN) Field entry.
 *     f_st  - (IN) Statistics entity.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_counter_free(int unit, _field_entry_t *f_ent, _field_stat_t *f_st)
{
    uint8          entry_part;   /* Secondary slice entry part.    */
    _field_group_t *fg;          /* Field group structure.         */
    _field_slice_t *fs;          /* Field slice structure.         */
    int            idx;          /* SW counter index.              */
    int            rv = BCM_E_NONE; /* Operation return status.    */

    if ((NULL == f_ent) || (NULL == f_st)) {
        return (BCM_E_PARAM);
    }

    fg = f_ent->group;
    fs = (f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE) ? \
         f_ent->fs + 1: f_ent->fs;

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if ((soc_feature(unit, soc_feature_advanced_flex_counter)
        && (f_st->hw_flags & _FP_STAT_FLEX_CNTR))) {
        return (_field_flex_counter_free(unit, f_ent, f_st));
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    if ((soc_feature(unit, soc_feature_flowcnt)
        && (f_st->hw_flags & _FP_STAT_FLOWCNT_CNTR))) {
        return (_field_flowcnt_counter_free(unit, f_ent, f_st));
    }
#endif


#if defined (BCM_TRIUMPH2_SUPPORT)
    /* Free is  external for vfp counters. */
    if (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) {
        if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
            /* During Disable - Pass valid counter index for new STAT API mode
            * or zero as counter index for old STAT API mode
            */
            if (f_st->flex_mode) {
                _bcm_flex_stat_type_t fs_type;
                uint32 fs_inx;

                fs_type = _BCM_FLEX_STAT_TYPE(f_st->flex_mode);
                fs_inx  = _BCM_FLEX_STAT_COUNT_INX(f_st->flex_mode);
                rv = _bcm_esw_flex_stat_enable_set(unit,
                                                   fs_type,
                                                   _bcm_esw_fp_flex_stat_index_set,
                                                   (void *)f_st,
                                                   f_st->sid,
                                                   FALSE,
                                                   fs_inx);
            } else {
                rv = _bcm_esw_flex_stat_enable_set(unit,
                                                   _bcmFlexStatTypeFp,
                                                   _bcm_esw_fp_flex_stat_index_set,
                                                   (void *)f_st,
                                                   f_st->sid,
                                                   FALSE,
                                                   0
                                                   );
           }
       }

       f_st->hw_index   = _FP_INVALID_INDEX;
       f_st->pool_index = _FP_INVALID_INDEX;

       /* During system restart flex stat module
        * might be reinitialized before fp reinit. Hence
        * calls to the flex stat module will result in BCM_E_NOT_FOUND
        * error code.
        */
        if ((_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id) &&
            (BCM_E_NOT_FOUND == rv)) {
            rv = BCM_E_NONE;
        }
        return (rv);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined (BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) && (_BCM_FIELD_STAGE_EGRESS == f_st->stage_id)) {
        /* FB2 - doesn't have counter pairs in stage egress. */
        idx = f_st->hw_index;
    } else
#endif /* BCM_FIREBOLT2_SUPPORT */
    {
        idx = 2 * f_st->hw_index;
    }

    /* Clear counter is used bit. */
    if (2 == f_st->hw_entry_count) {
        _FP_COUNTER_BMP_REMOVE(fs->counter_bmp, idx);
        _FP_COUNTER_BMP_REMOVE(fs->counter_bmp, idx + 1);
    } else {
        /*
         * hw_mode refers to COUNTER_MODEf in FP_POLICY_TABLEm
         * On TD_TT and KTX, this is a 6-bit field:-
         * 0,1,2 bit positions represent lower or even counters
         * 3,4,5 bit positions represent upper or odd counters
         *
         * On rest of the TRX devices, COUNTER_MODEf in FP_POLICY_TABLEm
         * and EFP_POLICY_TABLEm are 3-bit fields, where
         * value 1 - means lower counter is used
         * value 2 - means upper counter is used.
         * values [3 - 7] - mean both counters are used
         *
         * On older devices, COUNTER_MODEf in FP_POLICY_TABLEM
         * is a 4 bit field with the upper bit indicating
         * byte/packet mode and rest of the 3 bits representing
         * the COUNTER_MODE as above.Egress has only one counter,
         * no mode selection
         */
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
                f_st->stage_id == _BCM_FIELD_STAGE_INGRESS) {
            if (f_st->hw_mode > 7)  {
                idx++;
            }
        } else if (SOC_IS_TRX(unit)) {
            if (f_st->hw_mode > 1) {
                idx++;
            }
        } else {
            if ((f_st->hw_mode & 0x7) > 1) {
                idx++;
            }
        }

        _FP_COUNTER_BMP_REMOVE(fs->counter_bmp, idx);
    }

    /* Reset entry policer related flags. */
    if (f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE) {
        /* Get primary entry from the second slice. */
        rv = _bcm_field_entry_flags_to_tcam_part (unit, _FP_ENTRY_SECONDARY,
                                                  fg, &entry_part);
        BCM_IF_ERROR_RETURN(rv);
        sal_memset(&f_ent[entry_part].statistic, 0, sizeof(_field_entry_stat_t));
        f_ent->flags &=  ~_FP_ENTRY_STAT_IN_SECONDARY_SLICE;
    }

    /* decrement the group's counter count equal to
       the hw counters used for this stat */
    f_ent->group->group_status.counter_count =
        f_ent->group->group_status.counter_count - f_st->hw_entry_count;

    f_st->hw_index   = _FP_INVALID_INDEX;
    f_st->pool_index = _FP_INVALID_INDEX;
    return BCM_E_NONE;
}
/*
 * Function:
 *     _field_counter32_collect_alloc
 * Purpose:
 *     Initialize software field for collection of 32 (or less) bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_counter32_collect_alloc(int unit, soc_mem_t mem, char *descr,
                               _field_counter32_collect_t **ptr)
{
    int mem_size;

    /* Input parameters check. */
    if ((NULL == ptr) || (NULL == descr) || (INVALIDm == mem)) {
        return (BCM_E_PARAM);
    }

    /* Allocate a buffer to track counters. */
    mem_size = (soc_mem_index_count(unit, mem) *
                                         sizeof(_field_counter32_collect_t));
    *ptr  = sal_alloc(mem_size, descr);
    if (NULL == *ptr) {
        return (BCM_E_MEMORY);
    }
    sal_memset(*ptr, 0, mem_size);
    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_counter32_collect_alloc
 * Purpose:
 *     Initialize software field for collection of 32 (or less) bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_counter32_collect_alloc(int unit, soc_mem_t mem, char *descr,
                                   _field_counter32_collect_t **ptr)
{
    return _field_counter32_collect_alloc(unit, mem, descr, ptr);
}
#if defined(BCM_TRX_SUPPORT) || defined(BCM_BRADLEY_SUPPORT)
/*
 * Function:
 *     _field_counter64_collect_alloc
 * Purpose:
 *     Initialize software field for collection > 32 bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_counter64_collect_alloc(int unit, soc_mem_t mem, char *descr,
                               _field_counter64_collect_t **ptr)
{
    int mem_size;

    /* Input parameters check. */
    if ((NULL == ptr) || (NULL == descr) || (INVALIDm == mem)) {
        return (BCM_E_PARAM);
    }

    /* Allocate a buffer to track counters. */
    mem_size = (soc_mem_index_count(unit, mem) *
                                         sizeof(_field_counter64_collect_t));
    *ptr  = sal_alloc(mem_size, descr);
    if (NULL == *ptr) {
        return (BCM_E_MEMORY);
    }
    sal_memset(*ptr, 0, mem_size);
    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_counter64_collect_alloc
 * Purpose:
 *     Initialize software field for collection > 32 bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_counter64_collect_alloc(int unit, soc_mem_t mem, char *descr,
                               _field_counter64_collect_t **ptr)
{
    return _field_counter64_collect_alloc(unit, mem, descr, ptr);
}
#endif /* BCM_TRX_SUPPORT || BCM_BRADLEY_SUPPORT */
/*
 * Function:
 *     _field_counter_collect_deinit
 * Purpose:
 *     Denitialize software field counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 * NOTE:
 *    FC must be locked & callback deregistred before calling this
 *    function..
 */
STATIC int
_field_counter_collect_deinit(int unit, _field_stage_t *stage_fc)
{
    _field_control_t *fc;
    int rv = 0;
#if defined(BCM_TOMAHAWK_SUPPORT)
    int                       pipe;      /* XGS pipeline to operate on. */
    int                       max_pipes; /* Maximum pipeline per stage. */
#endif

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Field control get. */


    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }


    if (NULL !=  stage_fc->_field_x32_counters) {
        sal_free(stage_fc->_field_x32_counters);
        stage_fc->_field_x32_counters = NULL;
    }

#if defined(BCM_TRIUMPH_SUPPORT)
    if (NULL !=  stage_fc->_field_ext_counters)  {
        sal_free(stage_fc->_field_ext_counters);
        stage_fc->_field_ext_counters = NULL;
    }
#endif /* !BCM_TRIUMPH_SUPPORT */


#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (NULL !=  stage_fc->_field_x64_counters) {
        sal_free(stage_fc->_field_x64_counters);
        stage_fc->_field_x64_counters = NULL;
    }

    if (NULL !=  stage_fc->_field_y64_counters) {
        sal_free(stage_fc->_field_y64_counters);
        stage_fc->_field_y64_counters = NULL;
    }
#endif /* BCM_BRADLEY_SUPPORT || BCM_TRX_SUPPORT */

#if defined(BCM_SCORPION_SUPPORT)
    if (NULL !=  stage_fc->_field_y32_counters)  {
        sal_free(stage_fc->_field_y32_counters);
        stage_fc->_field_y32_counters = NULL;
    }
#endif /* BCM_SCORPION_SUPPORT */

    if (NULL !=  stage_fc->_field_memacc_counters)  {
        sal_free(stage_fc->_field_memacc_counters);
        stage_fc->_field_memacc_counters = NULL;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    max_pipes = stage_fc->num_pipes;
    if (stage_fc->flags & _FP_STAGE_MULTI_PIPE_COUNTERS) {
        for (pipe = 0; pipe < max_pipes; pipe++ ) {
            if (NULL !=  stage_fc->_field_32_counters[pipe]) {
                sal_free(stage_fc->_field_32_counters[pipe]);
                stage_fc->_field_32_counters[pipe] = NULL;
            }
        }

        for (pipe = 0; pipe < max_pipes; pipe++ ) {
            if (NULL !=  stage_fc->_field_64_counters[pipe]) {
                sal_free(stage_fc->_field_64_counters[pipe]);
                stage_fc->_field_32_counters[pipe] = NULL;
            }
        }
    }
#endif

    FP_UNLOCK(unit);

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_counter_collect_deinit
 * Purpose:
 *     Denitialize software field counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 * NOTE:
 *    FC must be locked & callback deregistred before calling this
 *    function..
 */
int
_bcm_field_counter_collect_deinit(int unit, _field_stage_t *stage_fc)
{
    return _field_counter_collect_deinit(unit, stage_fc);
}

/*
 * Function:
 *    _field_sw_counter_set
 *
 * Description:
 *   Service routine used to set 64-bit software accumulated counters.
 * Parameters:
 *   unit         - (IN) BCM device number.
 *   stage_fc     - (IN) Stage field control structure.
 *   idx          - (IN) Counter hw index.
 *   packet_count - (OUT) Packet Counter value
 *   byte_count   - (OUT) Byte Counter value
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_sw_counter_set(int unit, _field_stage_t *stage_fc,
                      int idx, uint64 *packet_count,
                      uint64 *byte_count)
{
    _field_control_t          *fc;           /* Field control structure. */
    soc_mem_t                 counter_x_mem; /* Counter table on X pipe  */
    soc_mem_t                 counter_y_mem; /* Counter table on Y pipe  */
    uint32                    *hw_buf_x;     /* X memory HW buffer.      */
    uint32                    *hw_buf_y;     /* Y memory HW buffer.      */
    int                       rv;            /* Operation return status. */

    hw_buf_x = hw_buf_y = NULL;

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get counter memory. */
    rv = _field_counter_mem_get(unit, stage_fc, &counter_x_mem, &counter_y_mem);
    BCM_IF_ERROR_RETURN(rv);

    /* HW index sanity check. */
    if (idx < soc_mem_index_min(unit, counter_x_mem) ||
        idx > soc_mem_index_max(unit, counter_x_mem)) {
        return (BCM_E_INTERNAL);
    }

    /* Allocate buffer for counter values in HW.  */
    _FP_XGS3_ALLOC(hw_buf_x, 2 * WORDS2BYTES(SOC_MAX_MEM_FIELD_WORDS),
                   "Counter buffers");
    if (NULL == hw_buf_x) {
        return (BCM_E_MEMORY);
    }

    /* Read X pipeline counter memory. */
    rv = soc_mem_read(unit, counter_x_mem, MEM_BLOCK_ANY, idx, hw_buf_x);
    if (BCM_FAILURE(rv)) {
        sal_free(hw_buf_x);
        return (BCM_E_MEMORY);
    }

    /* Read Y pipeline counter memory. */
    if (INVALIDm != counter_y_mem) {
        hw_buf_y = hw_buf_x + SOC_MAX_MEM_FIELD_WORDS;
        rv = soc_mem_read(unit, counter_y_mem, MEM_BLOCK_ANY, idx, hw_buf_y);
        if (BCM_FAILURE(rv)) {
            sal_free(hw_buf_x);
            return (BCM_E_MEMORY);
        }
    }

    /* Process accumulated counter value. */
    rv = fc->functions.fp_counter_set(unit, stage_fc, counter_x_mem,
                                      hw_buf_x, counter_y_mem, hw_buf_y,
                                      idx, packet_count, byte_count);
    sal_free(hw_buf_x);
    return (rv);
}

/*
 * Function:
 *    _field_sw_counter_get
 *
 * Description:
 *       Service routine used to retrieve 64-bit software accumulated counters.
 * Parameters:
 *   unit         - (IN) BCM device number.
 *   stage_fc     - (IN) Stage field control structure.
 *   idx          - (IN) Counter hw index.
 *   packet_count - (OUT) Packet Counter value
 *   byte_count   - (OUT) Byte Counter value
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_sw_counter_get(int unit, _field_stage_t *stage_fc,
                      int idx, uint64 *packet_count,
                      uint64 *byte_count)
{
    _field_control_t          *fc;           /* Field control structure. */
    soc_mem_t                 counter_x_mem; /* Counter table on X pipe  */
    soc_mem_t                 counter_y_mem; /* Counter table on Y pipe  */
    uint32                    *hw_buf_x;     /* X memory HW buffer.      */
    uint32                    *hw_buf_y;     /* Y memory HW buffer.      */
    int                       rv;            /* Operation return status. */
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
#if defined(BCM_SCORPION_SUPPORT)
    _field_counter32_collect_t *cntrs32_buf;  /* Sw packet counter value    */
#endif
    _field_counter64_collect_t *cntrs64_buf;  /* Sw byte counter value      */
#endif

    COMPILER_64_ZERO(*packet_count);
    COMPILER_64_ZERO(*byte_count);
    hw_buf_x = hw_buf_y = NULL;

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get counter memory. */
    rv = _field_counter_mem_get(unit, stage_fc, &counter_x_mem, &counter_y_mem);
    BCM_IF_ERROR_RETURN(rv);

    /* HW index sanity check. */
    if (idx < soc_mem_index_min(unit, counter_x_mem) ||
        idx > soc_mem_index_max(unit, counter_x_mem)) {
        return (BCM_E_INTERNAL);
    }

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if ((0 == (fc->flags & _FP_STAT_SYNC_ENABLE)) &&
        (SOC_IS_TRX(unit) || SOC_IS_BRADLEY(unit))) {
        /* Read X pipeline counter memory. */
        if (INVALIDm != counter_x_mem) {
            cntrs64_buf = &stage_fc->_field_x64_counters[idx];
            COMPILER_64_ADD_64(*byte_count,
                cntrs64_buf->accumulated_counter);
#if defined(BCM_SCORPION_SUPPORT)
            cntrs32_buf = &stage_fc->_field_x32_counters[idx];
            COMPILER_64_ADD_64(*packet_count,
                cntrs32_buf->accumulated_counter);
#endif
        }

        /* Read Y pipeline counter memory. */
        if (INVALIDm != counter_y_mem) {
            cntrs64_buf = &stage_fc->_field_y64_counters[idx];
            COMPILER_64_ADD_64(*byte_count,
                cntrs64_buf->accumulated_counter);

#if defined(BCM_SCORPION_SUPPORT)
            cntrs32_buf = &stage_fc->_field_y32_counters[idx];
            COMPILER_64_ADD_64(*packet_count,
                cntrs32_buf->accumulated_counter);
#endif
        }
    } else
#endif
    {
        /* Allocate buffer for counter values in HW.  */
        _FP_XGS3_ALLOC(hw_buf_x, 2 * WORDS2BYTES(SOC_MAX_MEM_FIELD_WORDS),
                       "Counter buffers");
        if (NULL == hw_buf_x) {
            return (BCM_E_MEMORY);
        }

        /* Read X pipeline counter memory. */
        if (INVALIDm != counter_x_mem) {
            rv = soc_mem_read(unit, counter_x_mem, MEM_BLOCK_ANY, idx, hw_buf_x);
            if (BCM_FAILURE(rv)) {
                sal_free(hw_buf_x);
                return (BCM_E_MEMORY);
            }
        }

        /* Read Y pipeline counter memory. */
        if (INVALIDm != counter_y_mem) {
            hw_buf_y = hw_buf_x + SOC_MAX_MEM_FIELD_WORDS;
            rv = soc_mem_read(unit, counter_y_mem, MEM_BLOCK_ANY, idx, hw_buf_y);
            if (BCM_FAILURE(rv)) {
                sal_free(hw_buf_x);
                return (BCM_E_MEMORY);
            }
        }

        /* Process accumulated counter value. */
        rv = fc->functions.fp_counter_get(unit, stage_fc, counter_x_mem,
                                          hw_buf_x, counter_y_mem, hw_buf_y,
                                          idx, packet_count, byte_count);
        sal_free(hw_buf_x);
    }
    return (rv);
}

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *      _field_flex_stat_value_set
 *
 * Description:
 *      Set 64 bit flex counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (IN) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_field_flex_stat_value_set(int unit,
                           _field_stat_t *f_st,
                           bcm_field_stat_t stat,
                           uint64 value)
{
    _field_stage_t      *stage_fc;  /* Stage field control.         */
    int                 idx;        /* Stat array index.            */
    bcm_stat_value_t    stat_val;   /* Flex counter statistics.     */

    /* Get field control. */


    /* Stage field control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_st->stage_id,
                                  &stage_fc
                                  )
        );

    /* Check that stat was requested during statistics entity creation. */
    for (idx = 0; idx < f_st->nstat; idx++) {
        if (stat == f_st->stat_arr[idx]) {
            break;
        }
    }

    if (idx == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    if (_FP_INVALID_INDEX != f_st->hw_index) {

        if (stat == bcmFieldStatPackets) {
            COMPILER_64_TO_32_LO(stat_val.packets, value);
        } else {
            COMPILER_64_SET(stat_val.bytes,
                            COMPILER_64_HI(value),
                            COMPILER_64_LO(value));
        }

	/* coverity[uninit_use_in_call : FALSE] */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_stat_counter_raw_set(unit,
                                           f_st->flex_mode,
                                           (stat == bcmFieldStatBytes) ? 1 : 0,
                                           (f_st->hw_entry_count - 1),
                                           &stat_val
                                           )
                );

    }

    return (BCM_E_NONE);
}
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *      _field_flowcnt_stat_value_set
 *
 * Description:
 *      Set 64 bit flowcnt counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (IN) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_field_flowcnt_stat_value_set(int unit,
                           _field_stat_t *f_st,
                           bcm_field_stat_t stat,
                           uint64 value)
{
    int                 idx;        /* Stat array index.            */
    bcm_stat_value_t    stat_val;   /* Flowcnt counter statistics.     */
    uint32              byte_flag;  /* Byte or packet */

    /* Check that stat was requested during statistics entity creation. */
    for (idx = 0; idx < f_st->nstat; idx++) {
        if (stat == f_st->stat_arr[idx]) {
            break;
        }
    }

    if (idx == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    if (_FP_INVALID_INDEX != f_st->hw_index) {

        if (stat == bcmFieldStatBytes) {
            byte_flag = 1;
            COMPILER_64_SET(stat_val.bytes,
                            COMPILER_64_HI(value),
                            COMPILER_64_LO(value));
        } else if (stat == bcmFieldStatPackets) {
            byte_flag = 0;
            COMPILER_64_TO_32_LO(stat_val.packets, value);
        } else {
            return BCM_E_CONFIG;
        }

        BCM_IF_ERROR_RETURN
            (_bcm_esw_flowcnt_counter_raw_set(unit, f_st->flex_mode,
                                               byte_flag,
                                               0,
                                               &stat_val
                                           )
                );

    }

    return (BCM_E_NONE);
}
#endif

/*
 * Function:
 *      _field_stat_value_set
 *
 * Description:
 *      Set 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (IN) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_stat_value_set(int unit, _field_stat_t *f_st, bcm_field_stat_t stat,
                       uint64 value)
{
    _field_stage_t      *stage_fc;      /* Stage field control.         */
    _field_control_t    *fc;            /* Field control structure.     */
#if defined (BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t    flex_stat;      /* Flex stat type.              */
#endif /* BCM_TRIUMPH2_SUPPORT */
    int                 idx1;           /* First counter index to read. */
    int                 idx2;           /* Second counter index to read.*/
    int                 idx3;           /* Third counter index to read.*/
    uint32              flags;          /* _FP_STAT_XXX.                */
    int                 rv;             /* Operation return status.     */

    /* Input parameters check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /* Stage field control structure. */
    rv = _field_stage_control_get(unit, f_st->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (stage_fc->flags & _FP_STAGE_MULTI_PIPE_COUNTERS) {
        return (fc->functions.fp_stat_value_set(unit, f_st, stat, value));
    }
#endif

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
        if (f_st->hw_flags & _FP_STAT_FLEX_CNTR) {
            return (_field_flex_stat_value_set(unit,
                                               f_st,
                                               stat,
                                               value
                                               )
            );
        }
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    if ((_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id)
        && soc_feature(unit, soc_feature_flowcnt)) {

        if (f_st->hw_flags & _FP_STAT_FLOWCNT_CNTR) {
            return (_field_flowcnt_stat_value_set(unit,
                                               f_st,
                                               stat,
                                               value
                                               )
            );
        }
    }
#endif

#if defined (BCM_TRIUMPH2_SUPPORT)
    /* Flexible stat counters handling. */
    if (_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id) {
        flex_stat = (stat == bcmFieldStatBytes) ? _bcmFlexStatIngressBytes :
            _bcmFlexStatIngressPackets;
        return _bcm_esw_flex_stat_set(unit, _bcmFlexStatTypeFp,
                                      f_st->sid, flex_stat, value);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Check that stat was requested during statistics entity creation. */
    for (idx1 = 0; idx1 < f_st->nstat; idx1++) {
        if (stat == f_st->stat_arr[idx1]) {
            break;
        }
    }
    if (idx1 == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    /* Get hw indexes and flags needed to compose requested statistic.*/
    rv = fc->functions.fp_stat_index_get(unit, f_st, stat, &idx1,
                                         &idx2, &idx3, &flags);
    BCM_IF_ERROR_RETURN(rv);

    /* Set accumulated counter value at primary index. */
    if (_FP_INVALID_INDEX == idx1) {
        return (BCM_E_INTERNAL);
    }

    if (flags & _FP_STAT_BYTES) {
        rv = _field_sw_counter_set(unit, stage_fc, idx1, NULL, &value);
    } else {
        rv = _field_sw_counter_set(unit, stage_fc, idx1, &value, NULL);
    }
    BCM_IF_ERROR_RETURN(rv);

    /* Reset accumulated counter value at secondary index. */
    if (_FP_INVALID_INDEX != idx2) {
        /* <HP>

           Should this behaviour be looked at?  What this means is that setting
           the value for an "implied" stat (i.e. one not directly represented by
           a hardware counter, but calculated from hardware counters) affects
           values for non-implied stats.

           Example:
           stat = { red, yellow, not-green }

           which is represented in the hardware by 2 counters, one for r and one
           for y, and not-green is returned as the sum of r and y hardware
           counters.

           But, setting the not-green stat to X will set one of the hardware
           counters to X and the other to 0.  Thus, the r and y counts will be
           lost, and one of them will be set to X, and the other to 0 -- rather
           bizarre behaviour from an outside point-of-view.

           </HP> */

        COMPILER_64_ZERO (value);
        if (flags & _FP_STAT_BYTES) {
            rv = _field_sw_counter_set(unit, stage_fc, idx2, NULL, &value);
        } else {
            rv = _field_sw_counter_set(unit, stage_fc, idx2, &value, NULL);
        }
    }

    BCM_IF_ERROR_RETURN(rv);

    if (_FP_INVALID_INDEX != idx3) {
        COMPILER_64_ZERO (value);
        if (flags & _FP_STAT_BYTES) {
            rv = _field_sw_counter_set(unit, stage_fc, idx3, NULL, &value);
        } else {
            rv = _field_sw_counter_set(unit, stage_fc, idx3, &value, NULL);
        }
    }

    return (rv);
}

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *    _field_flex_stat_get
 * Purpose:
 *    Get flex stat counter value
 * Parameters:
 *    unit  - (IN) BCM device number
 *    f_st  - (IN) Pointer to field stat structure
 *    stat  - (IN) Stat type value to get
 *    value - (OUT) Stat value
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_flex_stat_get(int unit,
                     int sync_mode,
                     _field_stat_t *f_st,
                     bcm_field_stat_t stat,
                     uint64 *value)
{
    int idx;
    bcm_stat_value_t stat_val;
    int rv;

    /* Stat Type Check. */
    if ((bcmFieldStatPackets != stat)
        && (bcmFieldStatBytes != stat)) {
        return (BCM_E_PARAM);
    }

    /* Check that stat was requested during statistics entity creation. */
    for (idx = 0 ; idx < f_st->nstat; idx++) {
        if (stat == f_st->stat_arr[idx]) {
            break;
        }
    }

    /* Invalid Stat. */
    if (idx == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    COMPILER_64_ZERO(*value);

    if (_FP_INVALID_INDEX != f_st->hw_index) {
        /* Read stat value using flex stat routine.*/
        rv = _bcm_esw_stat_counter_raw_get(unit,
                                           sync_mode,
                                           f_st->flex_mode,
                                           (stat == bcmFieldStatBytes) ? 1 : 0,
                                           (f_st->hw_entry_count - 1),
                                           &stat_val
                                           );
        /*
         * Flex STAT module is initalized before field module during reset.
         * Attempt to read flex stats by field module would result in
         * error. Ignore these errors.
         */
        if (BCM_FAILURE(rv)) {
            if (TRUE == _field_control[unit]->init) {
                return (rv);
            } else {
                return (BCM_E_NOT_FOUND);
            }
        } else {
            /* Store retrieved stat value in return variable. */
            if (bcmFieldStatPackets == stat) {
                COMPILER_64_ADD_32(*value, stat_val.packets);
            } else {
                COMPILER_64_OR(*value, stat_val.bytes);
            }
        }
    }

    return (BCM_E_NONE);
}
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *    _field_flowcnt_stat_get
 * Purpose:
 *    Get vlan flow stat counter value
 * Parameters:
 *    unit  - (IN) BCM device number
 *    f_st  - (IN) Pointer to field stat structure
 *    stat  - (IN) Stat type value to get
 *    value - (OUT) Stat value
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_flowcnt_stat_get(int unit,
                     int sync_mode,
                     _field_stat_t *f_st,
                     bcm_field_stat_t stat,
                     uint64 *value)
{
    int idx;
    bcm_stat_value_t stat_val;
    int rv;

    /* Stat Type Check. */
    if ((bcmFieldStatPackets != stat)
        && (bcmFieldStatBytes != stat)) {
        return (BCM_E_PARAM);
    }

    /* Check that stat was requested during statistics entity creation. */
    for (idx = 0 ; idx < f_st->nstat; idx++) {
        if (stat == f_st->stat_arr[idx]) {
            break;
        }
    }

    /* Invalid Stat. */
    if (idx == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    COMPILER_64_ZERO(*value);

    if (_FP_INVALID_INDEX != f_st->hw_index) {
        /* Read stat value using flowcnt stat routine.*/
        rv = _bcm_esw_flowcnt_counter_raw_get(
                             unit, sync_mode, f_st->flex_mode,
                             (stat == bcmFieldStatBytes) ? 1 : 0,
                             0,
                             &stat_val);
        /*
         * STAT module is initalized before field module during reset.
         * Attempt to read flex stats by field module would result in
         * error. Ignore these errors.
         */
        if (BCM_FAILURE(rv)) {
            if (TRUE == _field_control[unit]->init) {
                return (rv);
            } else {
                return (BCM_E_NOT_FOUND);
            }
        } else {
            /* Store retrieved stat value in return variable. */
            if (bcmFieldStatPackets == stat) {
                COMPILER_64_ADD_32(*value, stat_val.packets);
            } else {
                COMPILER_64_OR(*value, stat_val.bytes);
            }
        }
    }

    return (BCM_E_NONE);
}


#endif /* BCM_HURRICANE3_SUPPORT */

/*
 * Function:
 *      _field_stat_value_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_stat_value_get(int unit, int sync_mode, _field_stat_t *f_st, bcm_field_stat_t stat,
                       uint64 *value)
{
    uint64              packet_count_1; /* Primary index packet count.  */
    uint64              byte_count_1;   /* Primary index byte count.    */
    uint64              packet_count_2; /* Secondary index packet count.*/
    uint64              byte_count_2;   /* Secondary index byte count.  */
    uint64              packet_count_3; /* Third counter index packet count. */
    uint64              byte_count_3;   /* Third counterindex byte count.    */
    _field_stage_t      *stage_fc;      /* Stage field control.         */
#if defined (BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t    flex_stat;      /* Flex stat type.              */
#endif /* BCM_TRIUMPH2_SUPPORT */
    _field_control_t    *fc;            /* Field control structure.     */
    int                 idx1;           /* First counter index to read. */
    int                 idx2;           /* Second counter index to read.*/
    int                 idx3;           /* Third counter index to read. */
    uint32              flags;          /* _FP_STAT_XXX.                */
    int                 rv;             /* Operation return status.     */

    /* Input parameters check. */
    if ((NULL == value) || (NULL == f_st)) {
        return (BCM_E_PARAM);
    }


    /* Get field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Stage field control structure. */
    rv = _field_stage_control_get(unit, f_st->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (stage_fc->flags & _FP_STAGE_MULTI_PIPE_COUNTERS) {
        return (fc->functions.fp_stat_value_get(unit, sync_mode,
                                                f_st, stat, value));
    }
#endif

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    /* Get flex stat counter value. */
    if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
        if (f_st->hw_flags & _FP_STAT_FLEX_CNTR) {
            return (_field_flex_stat_get(unit, sync_mode, f_st, stat, value));
        }
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    if ((_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id)
        && (soc_feature(unit, soc_feature_flowcnt))) {

        return (_field_flowcnt_stat_get(unit, sync_mode, f_st, stat, value));
    }
#endif


#if defined (BCM_TRIUMPH2_SUPPORT)
    /* Flexible stat counters handling. */
    if (_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id) {
        flex_stat = (stat == bcmFieldStatBytes) ? _bcmFlexStatIngressBytes :
            _bcmFlexStatIngressPackets;
        return _bcm_esw_flex_stat_get(unit, sync_mode,_bcmFlexStatTypeFp,
                                      f_st->sid, flex_stat, value);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Initialization. */
    COMPILER_64_ZERO(packet_count_1);
    COMPILER_64_ZERO(packet_count_2);
    COMPILER_64_ZERO(packet_count_3);
    COMPILER_64_ZERO(byte_count_1);
    COMPILER_64_ZERO(byte_count_2);
    COMPILER_64_ZERO(byte_count_3);
    idx1 = idx2 = idx3 = _FP_INVALID_INDEX;
    flags = 0;


    /* Check that stat was requested during statistics entity creation. */
    for (idx1 = 0; idx1 < f_st->nstat; idx1++) {
        if (stat == f_st->stat_arr[idx1]) {
            break;
        }
    }
    if (idx1 == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    /* Get hw indexes and flags needed to compose requested statistic.*/
    rv = fc->functions.fp_stat_index_get(unit, f_st, stat, &idx1,
                                         &idx2, &idx3, &flags);
    BCM_IF_ERROR_RETURN(rv);

    /* Get accumulated counter value at primary index. */
    if (_FP_INVALID_INDEX != idx1) {
        rv = _field_sw_counter_get(unit, stage_fc, idx1, &packet_count_1,
                                   &byte_count_1);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get accumulated counter value at secondary index. */
    if (_FP_INVALID_INDEX != idx2) {
        rv = _field_sw_counter_get(unit, stage_fc, idx2, &packet_count_2,
                                   &byte_count_2);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get accumulated counter value at secondary index. */
    if (_FP_INVALID_INDEX != idx3) {
        rv = _field_sw_counter_get(unit, stage_fc, idx3, &packet_count_3,
                                   &byte_count_3);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get final counter value. */
    COMPILER_64_ZERO(*value);
    if (flags & _FP_STAT_BYTES) {
        if (flags & _FP_STAT_ADD) {
            COMPILER_64_ADD_64(byte_count_1, byte_count_2);
            COMPILER_64_ADD_64(byte_count_1, byte_count_3);
        } else if (flags & _FP_STAT_SUBSTRACT) {
            COMPILER_64_SUB_64(byte_count_1, byte_count_2);
        }
        COMPILER_64_OR(*value, byte_count_1);
    } else {
        if (flags & _FP_STAT_ADD) {
            COMPILER_64_ADD_64(packet_count_1, packet_count_2);
            COMPILER_64_ADD_64(packet_count_1, packet_count_3);
        } else if (flags & _FP_STAT_SUBSTRACT) {
            COMPILER_64_SUB_64(packet_count_1, packet_count_2);
        }
        COMPILER_64_OR(*value, packet_count_1);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stat_hw_free
 *
 * Purpose:
 *     Deallocate hw counter from an entry.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry statistics belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_stat_hw_free (int unit, _field_entry_t *f_ent)
{
    _field_entry_stat_t  *f_ent_st;  /* Field entry statistics structure. */
    _field_stat_t        *f_st;      /* Statistics entity descriptor.     */
    uint64               value;      /* 64 bit zero to reset hw value.    */
    int                  idx;        /* Statistics iteration index.       */
    int                  rv;         /* Operation return status.          */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    _field_stage_t       *stage_fc;  /* pipeline stage                    */
    int                  entry_idx = 0; /* Entry index at policy table    */
#endif
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }
    f_ent_st = &f_ent->statistic;

    /* Skip uninstalled statistics entity. */
    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        return (BCM_E_NONE);
    }

    /* No de-allocation is required for external FP. */
    if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->fs->stage_id) {
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit)) {
            /* Update Ingress accounting table's statistics */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_tr3_ext_stat_flex_detach_ingress_table_counters(
                           unit, f_ent));
        }
#endif
        f_ent_st->flags &=  ~_FP_ENTRY_STAT_INSTALLED;
        return (BCM_E_NONE);
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );
#endif

    /* Read stat entity configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

    /* Decrement hw reference count. */
    if (f_st->hw_ref_count > 0) {
        f_st->hw_ref_count--;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
            if (f_st->flex_mode != 0 && f_st->hw_ref_count > 0) {
                /*
                 * Get entry index at which flex STAT information
                 * has been programmed in policy table.
                 */
                BCM_IF_ERROR_RETURN
                    (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                         stage_fc,
                                                         f_ent->group->instance,
                                                         f_ent->fs->slice_number,
                                                         f_ent->slice_idx,
                                                         &entry_idx
                                                        )
                    );

                rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                    (unit,
                     VFP_POLICY_TABLEm,
                     entry_idx
                    );
                /*
                 * Flex STAT module detached before field module, ignore
                 * error during bcm_field_detach().
                 */
                if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
                    return (rv);
                }
            }
        }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
        if (soc_feature(unit, soc_feature_flowcnt) &&
                (_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id)) {
            if (f_st->flex_mode != 0 && f_st->hw_ref_count > 0) {

                /*
                 * Get entry index at which STAT information
                 * has been programmed in policy table.
                 */
                BCM_IF_ERROR_RETURN
                    (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                        stage_fc,
                                                        f_ent->group->instance,
                                                        f_ent->fs->slice_number,
                                                        f_ent->slice_idx,
                                                        &entry_idx
                                                        ));

                rv = _bcm_esw_flowcnt_object_table_detach(unit,
                                VFP_POLICY_TABLEm, entry_idx);
                /*
                 * STAT module detached before field module, ignore
                 * error during bcm_field_detach().
                 */
                if (BCM_FAILURE(rv) && (TRUE == _field_control[unit]->init)) {
                    return (rv);
                }
            }
        }
#endif

    }

    /* Statistics is not used by any other entry. */
    if (f_st->hw_ref_count == 0) {
        COMPILER_64_ZERO(value);
        /* Read & Reset  individual statistics. */
        for (idx = 0; idx < f_st->nstat; idx++) {
            rv = _field_stat_value_get(unit, 0, f_st, f_st->stat_arr[idx],
                                       f_st->stat_values + idx);
            if (BCM_FAILURE(rv)) {
                /* During system restart flex stat module
                 * might be reinitialized before fp reinit. Hence
                 * calls to the flex stat module will result in
                 * BCM_E_NOT_FOUND * error code.
                 */
                if (soc_feature(unit, soc_feature_field_multi_pipe_support)
                        && (_BCM_FIELD_STAGE_EGRESS == f_st->stage_id)) {
                    if (TRUE == _field_control[unit]->init) {
                        return rv;
                    }
                } else if (0 == ((_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id)
                    && (BCM_E_NOT_FOUND == rv))) {
                    return rv;
                }
            } else {
                rv = _field_stat_value_set(unit, f_st,
                                           f_st->stat_arr[idx], value);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
        /* Mark hw resource as unused in sw. */
        BCM_IF_ERROR_RETURN(_field_slice_counter_free(unit, f_ent, f_st));
    }

    /*
     * If qualifiers have not been modified for this entry,
     * set Action only dirty flag.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }

    f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;

    /* Mark entry for reinstall. */
    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_stat_hw_free
 *
 * Purpose:
 *     Free counter resources used by field entry/entries.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Entry array policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_stat_hw_free (int unit, _field_entry_t *f_ent)
{
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) &&
       (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
        return (_bcm_field_tr3_stat_hw_free(unit, f_ent));
    }
#endif

    return (_field_stat_hw_free(unit, f_ent));
}


/*
 * Function:
 *    _field_entry_stat_detach
 *
 * Description:
 *       Detach statistics entity from Field processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_ent     - (IN) Field entry structure.
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_field_entry_stat_detach(int unit, _field_entry_t *f_ent, int stat_id)
{
    _field_stat_t       *f_st;     /* Internal statistics entity.  */
    _field_entry_stat_t *f_ent_st; /* Field entry stat structure.  */
    _field_control_t    *fc;
    int                 rv;        /* Operation return status.     */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Make sure statistics entity attached to the entry. */
    f_ent_st = &f_ent->statistic;

    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID)) {
        return (BCM_E_EMPTY);
    }

    /* Compare statistics entity id with attached entity id. */
    if (stat_id  != f_ent_st->sid) {
        return (BCM_E_PARAM);
    }

    /* Get statics entity descriptor structure. */
    rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));

    /* If entry was installed decrement hw reference counter. */
    rv = fc->functions.fp_stat_hw_free(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Decrement statistics entity reference counter. */
    f_st->sw_ref_count--;

    /* If no one else is using the entity and it is internal destroy it. */
    if ((1 == f_st->sw_ref_count) && (f_st->hw_flags & _FP_STAT_INTERNAL)) {
        rv = _field_stat_destroy(unit, f_ent_st->sid);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Detach policer from an entry. */
    f_ent_st->sid   = _FP_INVALID_INDEX;
    f_ent_st->flags = 0;

    /*
     * If qualifiers have not been modified for this entry,
     * set Policy table only dirty flag.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }
    /* Mark entry for reinstall. */
    f_ent->flags |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}
/*
 * Function:
 *    _bcm_field_entry_stat_detach
 *
 * Description:
 *       Detach statistics entity from Field processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_ent     - (IN) Field entry structure.
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_entry_stat_detach(int unit, _field_entry_t *f_ent, int stat_id)
{
    return _field_entry_stat_detach(unit, f_ent, stat_id);
}
/*
 * Function:
 *     _field_stat_color_dependent
 *
 * Purpose:
 *    Check if statistics entity is color dependent.
 *
 * Parameters:
 *     unit            - (IN) BCM device number.
 *     f_st            - (IN) Field statistics entity..
 *     color_dependent - (IN) Field statistics entity..
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stat_color_dependent(int unit, _field_stat_t *f_st,
                            uint8 *color_dependent)
{
   /* Input parameters check. */
    if ((NULL == f_st) || (NULL == color_dependent)) {
        return (BCM_E_PARAM);
    }
#if defined(BCM_TRIDENT_SUPPORT)
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
        (f_st->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
        switch (f_st->hw_mode & 0x7) {
            case (0x0):
            /* Fall thru */
            case (0x7):
                *color_dependent = FALSE;
                break;
            default:
                *color_dependent = TRUE;
                break;
        }
        switch ((f_st->hw_mode >> 3) & 0x7) {
            case (0x0):
            /* Fall thru */
            case (0x7):
                break;
            default:
                *color_dependent = TRUE;
                break;
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT */
    {
        switch (f_st->hw_mode) {
          case (0x0):
          case (0x1):
          case (0x2):
          case (0x9):
          case (0xa):
              *color_dependent = FALSE;
              break;
          default:
              *color_dependent = TRUE;
              break;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stat_hw_mode_adjust
 *
 * Purpose:
 *     Ajust statistics entity mode based on
 *     allocated counter index.
 *
 * Parameters:
 *     unit  - (IN)     Bcm device number.
 *     f_st  - (IN/OUT) Statistics entity.
 *     idx   - (IN)     Allocated hw index.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stat_hw_mode_adjust(int unit, _field_stat_t *f_st, int idx)
{
    /* Input parameters check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIDENT_SUPPORT)
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
        (f_st->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
        /* Adjust statistics hw mode  */
        if (0x1 == (idx & 0x1)) {
            if (f_st->hw_mode & 0x7) {
                f_st->hw_mode <<= 3;
            }
        } else {
            if (((f_st->hw_mode >> 3) & 0x7)) {
                f_st->hw_mode >>= 3;
            }
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT */
    {
        /* Adjust statistics hw mode  */
        if (0 == (idx & 0x1)) {
            if ((0xa == f_st->hw_mode) || (0x2 == f_st->hw_mode)) {
                f_st->hw_mode--;
            }
        } else {
            if ((0x9 == f_st->hw_mode) || (0x1 == f_st->hw_mode)) {
                f_st->hw_mode++;
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slice_counter_alloc
 *
 * Purpose:
 *     Allocate a counter from a slice.
 *
 * Parameters:
 *     unit  - (IN)     Bcm device number.
 *     fs    - (IN)     Slice where counter resides.
 *     f_st  - (IN/OUT) Statistics entity.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_counter_alloc(int unit, _field_slice_t *fs, _field_stat_t *f_st)
{
    int  idx;        /* Bitmap iteration index.     */
    int  idx_max;    /* Total number of counters.   */

    if ((NULL == fs) || (NULL == f_st)) {
        return (BCM_E_PARAM);
    }

    idx_max = fs->counters_count;

    /* If counter is disabled  skip allocation. */
    if (0 == f_st->hw_mode) {
        return (BCM_E_NONE);
    }

    for (idx = 0; idx < idx_max; idx++) {
        /* Double entry counters. (e.g Red + Green) */
        if (0x2 == f_st->hw_entry_count) {
            if (0 != (idx % 2)) {
                /* Skip odd indexes. */
                continue;
            }
            if ((0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, idx)) &&
                (0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, (idx + 1)))) {
                /* Mark counter as used. */
                _FP_COUNTER_BMP_ADD(fs->counter_bmp, idx);
                _FP_COUNTER_BMP_ADD(fs->counter_bmp, idx + 1);
                /* Save counter information in statistics entity structure. */
                f_st->pool_index = fs->slice_number;
                f_st->hw_index = idx/2;
                /* Set counter dirty flag. */
                break;
            } else {
                continue;
            }
        }

        /* Single entry counters. (e.g Bytes) */
        if ((0x1 == f_st->hw_entry_count)
            && (0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, idx))) {
            /* Mark counter as used. */
            _FP_COUNTER_BMP_ADD(fs->counter_bmp, idx);
            /* Save counter information in statistics entity structure. */
            f_st->pool_index = fs->slice_number;
#if defined (BCM_FIREBOLT2_SUPPORT)
            if (SOC_IS_FIREBOLT2(unit) && (_BCM_FIELD_STAGE_EGRESS == f_st->stage_id)) {
                /* FB2 - doesn't have counter pairs in stage egress. */
                f_st->hw_index = idx;
            } else
#endif /* BCM_FIREBOLT2_SUPPORT */
            {
                f_st->hw_index = (idx/2);
                /* Adjust statistics hw mode */
                BCM_IF_ERROR_RETURN(_field_stat_hw_mode_adjust(unit, f_st, idx));
            }
            break;
        }
    }
    if (idx == idx_max) {
        return (BCM_E_RESOURCE);
    }
    return (BCM_E_NONE);
}

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *     _field_flex_counter_hw_alloc
 *
 * Purpose:
 *     Allocate flex stat hardware resource
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_flex_counter_hw_alloc(int unit,
                             _field_entry_t *f_ent)
{
    bcm_stat_flex_mode_t    offset_mode;  /* Counter mode.                  */
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    _field_entry_stat_t     *f_ent_st;    /* Field entry stat collector.    */
    _field_stat_t           *f_st;        /* Field statistics descriptor.   */
    uint32                  flex_sid;     /* Flex Stat ID.                  */
    uint32                  num_hw_cntrs; /* Number of counters allocated.  */
    uint32                  pool_num;     /* Flex Stat Hw Pool No.          */
    uint32                  base_index;   /* Flex Stat counter base index.  */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field entry STAT structure. */
    f_ent_st = &f_ent->statistic;

    /* Read STAT configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

    /* If counter is disabled skip allocation. */
    if (0 == f_st->hw_stat) {
        return (BCM_E_NONE);
    }

    if (_FP_INVALID_INDEX == f_st->hw_index) {
        switch (f_st->stage_id) {
            case _BCM_FIELD_STAGE_LOOKUP:
                stat_obj = bcmStatObjectIngPolicy;
                break;
            case _BCM_FIELD_STAGE_EXTERNAL:
                stat_obj = bcmStatObjectIngEXTPolicy;
                break;
            default:
                /* IFP and EFP stages does not use Flex STAT. */
                return (BCM_E_INTERNAL);
        }

        /* Create a flex stat group. */
        BCM_IF_ERROR_RETURN
            (bcm_esw_stat_group_create(unit,
                                       stat_obj,
                                       (bcm_stat_group_mode_t) f_st->hw_mode,
                                       &flex_sid,
                                       &num_hw_cntrs
                                       )
            );

        /* Get flex counter hardware details stored in flex stat ID.*/
        _bcm_esw_stat_get_counter_id_info(unit, flex_sid,
                                          &stat_mode,
                                          &stat_obj,
                                          &offset_mode,
                                          &pool_num,
                                          &base_index
                                          );
        /* Store flex stat hardware details in stat data structure. */
        f_st->flex_mode = flex_sid;
        f_st->pool_index = pool_num;
        f_st->hw_index = base_index;
        f_st->hw_mode = offset_mode;
        f_st->hw_entry_count = num_hw_cntrs;
    }

    /* For VFP, this flag is set in _field_trx_flex_stat_action_set */
    if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->fs->stage_id) {
       f_ent->statistic.flags |= _FP_ENTRY_STAT_INSTALLED;
    }
    return (BCM_E_NONE);
}
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *     _field_flowcnt_counter_hw_alloc
 *
 * Purpose:
 *     Allocate flow count stat hardware resource
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_flowcnt_counter_hw_alloc(int unit,
                             _field_entry_t *f_ent)
{
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    _field_entry_stat_t     *f_ent_st;    /* Field entry stat collector.    */
    _field_stat_t           *f_st;        /* Field statistics descriptor.   */
    bcm_stat_group_mode_t   group;
    uint32                  profile_group, pool_idx, base_idx;
    uint32                  flowcnt_sid; /* Flowcnt Stat ID.                  */
    uint32                  num_hw_cntrs; /* Number of counters allocated.  */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field entry STAT structure. */
    f_ent_st = &f_ent->statistic;

    /* Read STAT configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

    /* If counter is disabled skip allocation. */
    if (0 == f_st->hw_stat) {
        return (BCM_E_NONE);
    }

    if (_FP_INVALID_INDEX == f_st->hw_index) {
        switch (f_st->stage_id) {
            case _BCM_FIELD_STAGE_LOOKUP:
                stat_obj = bcmStatObjectIngFieldStageLookup;
                break;
            default:
                /* IFP and EFP stages does not use flow count STAT. */
                return (BCM_E_INTERNAL);
        }

        /* Create a flowcnt stat group. */
        BCM_IF_ERROR_RETURN
            (bcm_esw_stat_group_create(unit,
                                       stat_obj,
                                       (bcm_stat_group_mode_t) f_st->hw_mode,
                                       &flowcnt_sid,
                                       &num_hw_cntrs
                                       )
            );

        /* Get flowcnt counter hardware details stored in flowcnt stat ID.*/
        _bcm_esw_flowcnt_counter_id_get(flowcnt_sid,
                &group, &stat_obj, &profile_group, &pool_idx, &base_idx);

        /* Store flex stat hardware details in stat data structure. */
        f_st->flex_mode = flowcnt_sid;
        f_st->pool_index = pool_idx;
        f_st->hw_index = base_idx;
        f_st->hw_entry_count = num_hw_cntrs;
    }

    return (BCM_E_NONE);
}
#endif /* BCM_HURRICANE3_SUPPORT */


/*
 * Function:
 *     _bcm_field_counter_hw_alloc
 *
 * Purpose:
 *     Allocate a counter/s for an entry from a slice.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control structure.
 *     f_ent     - (IN/OUT) Entry array policer belongs to.
 *     fs        - (IN) Desired slice for the counter.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_counter_hw_alloc(int unit, _field_entry_t *f_ent, _field_slice_t *fs)
{
    uint8                  color_dependent;/* Statistics is color based.*/
    uint8                  entry_part; /* Field entry tcam part.        */
    _field_entry_stat_t    *f_ent_st;  /* Field entry stat structure.   */
    _field_entry_policer_t *f_ent_pl;  /* Field entry policer structure.*/
    _field_stage_t         *stage_fc;  /* Stage field control.          */
    _field_group_t         *fg;        /* Field group structure.        */
    _field_stat_t          *f_st;      /* Field statistics descriptor.  */
    int                    rv;         /* Operation return status.      */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    fg       = f_ent->group;
    f_ent_pl = f_ent->policer;
    f_ent_st = &f_ent->statistic;

    /* Reject unused counters. */
    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID)) {
        return (BCM_E_PARAM);
    }

    /* Read STAT configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

#if defined(BCM_TRIUMPH2_SUPPORT)
    /* Allocation is external for vfp counters. */
    if (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id
        && !soc_feature(unit, soc_feature_advanced_flex_counter)
        && !soc_feature(unit, soc_feature_flowcnt)) {
       if ((f_st->hw_flags & _FP_STAT_INTERNAL) && 0 == f_st->hw_mode) {
        /*
         * Invalid counter mode used for bcmFieldActionUpdateCounter action.
         * BCM_FIELD_COUNTER_MODE_DEFAULT or BCM_FIELD_COUNTER_MODE_NO_YES
         * are the valid counter modes for lookup stage.
         */
            return (BCM_E_CONFIG);
        }
        /* During Enable - Pass valid counter index for new STAT API mode
         * or zero as counter index for old STAT API mode
         */
        if (f_st->flex_mode) {
            _bcm_flex_stat_type_t fs_type;
            uint32 fs_inx;

            fs_type = _BCM_FLEX_STAT_TYPE(f_st->flex_mode);
            fs_inx  = _BCM_FLEX_STAT_COUNT_INX(f_st->flex_mode);
            rv = _bcm_esw_flex_stat_enable_set(unit, fs_type,
                                                _bcm_esw_fp_flex_stat_index_set,
                                                (void *)f_st, f_st->sid,
                                                TRUE,fs_inx);
        } else {
            rv = _bcm_esw_flex_stat_enable_set(unit, _bcmFlexStatTypeFp,
                                                _bcm_esw_fp_flex_stat_index_set,
                                                (void *)f_st, f_st->sid,
                                                TRUE,0);
        }
        if (BCM_SUCCESS(rv)) {
           /* Increment the group counters count equal to
           the hw entries count .*/
           f_ent->group->group_status.counter_count =
                 f_ent->group->group_status.counter_count + f_st->hw_entry_count;
        }
        return rv;
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Get entry stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN (rv);


    /* Verify if statistics entity is color dependent. */
    rv = _field_stat_color_dependent(unit, f_st, &color_dependent);
    BCM_IF_ERROR_RETURN (rv);

    if ((0 == (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) &&
        (f_ent_pl->flags & _FP_POLICER_INSTALLED) &&
        (color_dependent)) {
        /* If meter is present, counter must reside in the same slice. */
        if (f_ent->flags & _FP_ENTRY_POLICER_IN_SECONDARY_SLICE) {
            rv = _field_slice_counter_alloc(unit, fs + 1, f_st);
            if (BCM_SUCCESS(rv)) {
                /* Get primary entry from the second slice. */
                rv = _bcm_field_entry_flags_to_tcam_part (unit,
                                                      _FP_ENTRY_SECONDARY,
                                                      fg, &entry_part);
                BCM_IF_ERROR_RETURN(rv);
                f_ent->flags |= _FP_ENTRY_STAT_IN_SECONDARY_SLICE;
                sal_memcpy(&f_ent[entry_part].statistic, &f_ent->statistic,
                           sizeof(_field_entry_stat_t));
                f_ent[entry_part].statistic.flags |= _FP_ENTRY_STAT_INSTALLED;
            }
        } else {
            rv = _field_slice_counter_alloc(unit, fs, f_st);
        }
    } else {
        rv = _field_slice_counter_alloc(unit, fs, f_st);
        if((BCM_FAILURE(rv)) &&
           ((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE))) {
            rv = _field_slice_counter_alloc(unit, fs + 1, f_st);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_field_entry_flags_to_tcam_part (unit,
                                                    _FP_ENTRY_SECONDARY,
                                                    fg, &entry_part);
                BCM_IF_ERROR_RETURN(rv);
                f_ent->flags |= _FP_ENTRY_STAT_IN_SECONDARY_SLICE;
                sal_memcpy(&f_ent[entry_part].statistic, &f_ent->statistic,
                           sizeof(_field_entry_stat_t));
                f_ent[entry_part].statistic.flags |=  _FP_ENTRY_STAT_INSTALLED;
            }
        }
    }
    /* Increment the group counters count equal to
           the hw entries count .*/
    f_ent->group->group_status.counter_count =
          f_ent->group->group_status.counter_count + f_st->hw_entry_count;
    return (rv);
}


STATIC int
_field_counter_hw_alloc(int unit, _field_entry_t *f_ent, _field_slice_t *fs)
{
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_counter_hw_alloc(unit, f_ent));
    }
#endif

    return (_bcm_field_counter_hw_alloc(unit, f_ent, fs));
}


/*
 * Function:
 *     _field_stat_hw_alloc
 *
 * Purpose:
 *     Allocate counters required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry array.
 *     fs        - (IN) Slice to allocate a counter.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_stat_hw_alloc(int unit, _field_entry_t *f_ent)
{
    _field_entry_stat_t    *f_ent_st;  /* Field entry stat structure.   */
    _field_stat_t          *f_st;      /* Field statistics descriptor.  */
    int                    rv;         /* Operation return status.      */
    _field_stage_t         *stage_fc; /* Field stage control structure.*/

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    f_ent_st = &f_ent->statistic;

    /* Skip entries without countres attached. */
    if ((0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID)) ||
        (f_ent_st->flags & _FP_ENTRY_STAT_EMPTY)) {
        return (BCM_E_NONE);
    }

    /* No allocation is required for external FP, because:
       - for TR/TR2, each entry has it's own dedicated counter, and
       - for TR3, EXTFP supports only flex counters (as does VFP)
     */
    if ((_BCM_FIELD_STAGE_EXTERNAL == f_ent->fs->stage_id) &&
        !soc_feature(unit, soc_feature_advanced_flex_counter)) {
        f_ent_st->flags |=  _FP_ENTRY_STAT_INSTALLED;
        return (BCM_E_NONE);
    }

    /* Read statistics entity configuration. */
    rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
    BCM_IF_ERROR_RETURN (rv);

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
        /* Allocate flex STAT entity hw index. */
        if (f_st->hw_flags & _FP_STAT_FLEX_CNTR) {
            return (_field_flex_counter_hw_alloc(unit, f_ent));
        }
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
        if (soc_feature(unit, soc_feature_flowcnt)) {
            /* Allocate flowcnt STAT entity hw index. */
            if (f_st->hw_flags & _FP_STAT_FLOWCNT_CNTR) {
                return (_field_flowcnt_counter_hw_alloc(unit, f_ent));
            }
        }
#endif

    /* Allocate statistics entity hw index. */
    if (_FP_INVALID_INDEX == f_st->hw_index) {
        rv = _field_counter_hw_alloc(unit, f_ent, f_ent->fs);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get stage control information. */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                 f_ent->fs->stage_id,
                                                 &stage_fc
                                                 )
                        );

    /* Validate STAT pool_index */
    if (_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id
        && !(stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS)
        && !(stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS)
        && (_FP_INVALID_INDEX != f_st->hw_index)) {
        if ((!(f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE)
                && f_ent->fs->slice_number != f_st->pool_index)
            || ((f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE)
                && f_ent->fs->slice_number + 1 != f_st->pool_index)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) - Counters cannot be shared between slices.\n"),
                       unit));
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "             Create a new stat and attach to EID=%d.\n"),
                       f_ent->eid));
            BCM_IF_ERROR_RETURN(_field_slice_counter_free(unit, f_ent, f_st));
            return (BCM_E_CONFIG);
        }
    }

    /* Increment statistics hw reference count. */
    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        f_ent_st->flags |=  _FP_ENTRY_STAT_INSTALLED;
        f_st->hw_ref_count++;
        if (1 == f_st->hw_ref_count) {
            int idx;

            /* Write individual statistics privious value. */
            for (idx = 0; idx < f_st->nstat; idx++) {
                rv = _field_stat_value_set(unit, f_st, f_st->stat_arr[idx],
                                           f_st->stat_values[idx]);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_stat_hw_alloc
 *
 * Purpose:
 *     Allocate counters required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry array.
 *     fs        - (IN) Slice to allocate a counter.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_bcm_field_stat_hw_alloc(int unit, _field_entry_t *f_ent)
{
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    return _field_stat_hw_alloc(unit, f_ent);
}
/*
 * Function:
 *     _field_mirror_dest_delete
 * Purpose:
 *     Unset mirroring destination & disable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     fa       - (IN) Field action descriptor.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_mirror_dest_delete(int unit, _field_entry_t  *f_ent, _field_action_t *fa, uint32 flags)
{
    uint32 mirror_flags;      /* Mirror module flags.     */
    int rv;
    uint32 mirror_slot_flags;

    /* Input parameters check */
    if ((NULL == fa) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Set mirror flags. */
    if (bcmFieldActionMirrorIngress == fa->action) {
        mirror_flags = BCM_MIRROR_PORT_INGRESS;
    }  else if (bcmFieldActionMirrorEgress == fa->action) {
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            mirror_flags = BCM_MIRROR_PORT_EGRESS_TRUE;
        } else {
            /* Stage Ingress */
            mirror_flags = BCM_MIRROR_PORT_EGRESS;
        }
    } else {
        return (BCM_E_PARAM);
    }

    if ((flags & _FP_ACTION_RESOURCE_FREE) &&
        (_FP_INVALID_INDEX != fa->hw_index)) {
           rv = _bcm_esw_mirror_fp_dest_delete(unit, fa->hw_index, mirror_flags);
           BCM_IF_ERROR_RETURN(rv);
           fa->hw_index = _FP_INVALID_INDEX;

           /* Delete Ref to any mirror slot container if any */
           if (mirror_flags & BCM_MIRROR_PORT_INGRESS) {
                mirror_slot_flags =
                            _BCM_MIRROR_SLOT_INGRESS | _BCM_MIRROR_SLOT_FP;
                BCM_IF_ERROR_RETURN
                 (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                  mirror_slot_flags,
                                                  f_ent->ing_mtp_slot_map));
                f_ent->ing_mtp_slot_map = 0;
            }
            if (mirror_flags & BCM_MIRROR_PORT_EGRESS) {
                mirror_slot_flags =
                            _BCM_MIRROR_SLOT_EGRESS | _BCM_MIRROR_SLOT_FP;
                BCM_IF_ERROR_RETURN
                 (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                  mirror_slot_flags,
                                                  f_ent->egr_mtp_slot_map));
                f_ent->egr_mtp_slot_map = 0;
            }
    }

    if ((flags & _FP_ACTION_OLD_RESOURCE_FREE) &&
        (_FP_INVALID_INDEX != fa->old_index)) {
          rv = _bcm_esw_mirror_fp_dest_delete(unit, fa->old_index, mirror_flags);
          BCM_IF_ERROR_RETURN(rv);
          fa->old_index = _FP_INVALID_INDEX;

          /* Delete Referece to Mirror Slot Container if any */
          if (mirror_flags & BCM_MIRROR_PORT_INGRESS) {
              mirror_slot_flags =
                            _BCM_MIRROR_SLOT_INGRESS | _BCM_MIRROR_SLOT_FP;
              BCM_IF_ERROR_RETURN
                 (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                  mirror_slot_flags,
                                                  f_ent->ing_mtp_slot_map));
              f_ent->ing_mtp_slot_map = 0;
          }
          if (mirror_flags & BCM_MIRROR_PORT_EGRESS) {
              mirror_slot_flags =
                            _BCM_MIRROR_SLOT_EGRESS | _BCM_MIRROR_SLOT_FP;
              BCM_IF_ERROR_RETURN
                 (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                  mirror_slot_flags,
                                                  f_ent->egr_mtp_slot_map));
              f_ent->egr_mtp_slot_map = 0;
          }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_mirror_dest_add
 * Purpose:
 *     Set mirroring destination & enable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     fa       - (IN) field action
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_mirror_dest_add (int unit, _field_entry_t *f_ent, _field_action_t *fa)
{
    uint32 mirror_flags;      /* Mirror module flags.     */

    /* Input parameters check. */
    if ((NULL == fa) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Set mirror flags. */
    if (bcmFieldActionMirrorIngress == fa->action) {
        mirror_flags = BCM_MIRROR_PORT_INGRESS;
    }  else if (bcmFieldActionMirrorEgress == fa->action) {
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            mirror_flags = BCM_MIRROR_PORT_EGRESS_TRUE;
        } else {
            /* Stage Ingress */
            mirror_flags = BCM_MIRROR_PORT_EGRESS;
        }
    } else {
        return (BCM_E_PARAM);
    }

    return _bcm_esw_mirror_fp_dest_add(unit,  fa->param[0], fa->param[1],
                                       mirror_flags, &fa->hw_index);
}


/*
 * Function:
 *      _field_slice_counter_available
 * Purpose:
 *      Checks if counter might be installed in a slice.
 * Parameters:
 *   unit       - (IN) BCM device number.
 *   f_st       - (IN) Field statistics entity.
 *   fs         - (IN) Destination slice.
 * Returs:
 *   BCM_E_XXX
 */
int
_field_slice_counter_available(int unit, _field_stat_t *f_st, _field_slice_t *fs)
{
    int  idx;            /* Counters iteration index.        */

    /* Input parameters check. */
    if ((NULL == f_st) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    /* Check if target slice has a free counters */
    for (idx = 0; idx < fs->counters_count; idx++) {
        if (0x2 == f_st->hw_entry_count) {
            if (0 != (idx % 2)) {
                /* Skip odd indexes. */
                continue;
            }
            if ((0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, idx)) &&
                (0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, (idx+ 1)))) {
                    break;
            }
        } else if (0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, idx)) {
            break;
        }
    }

    if (idx == fs->counters_count) {
        return (BCM_E_RESOURCE);
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_slice_meter_available
 * Purpose:
 *      Checks if policer might be installed in a slice.
 * Parameters:
 *   unit       - (IN) BCM device number.
 *   f_pl       - (IN) Policer descriptor.
 *   fs         - (IN) Destination slice.
 * Returs:
 *   BCM_E_XXX
 */
STATIC int
_field_slice_meter_available(int unit, _field_policer_t *f_pl, _field_slice_t *fs)
{
    int   idx;            /* Meters iteration index.       */

    /* Input parameters check. */
    if ((NULL == f_pl) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    /* Check if target slice has a free meter */
    for (idx = 0; idx < fs->meters_count; idx++) {
        if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
            if (0 != (idx % 2)) {
                /* skip odd */
                continue;
            }

            if ((0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx))
                && (0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx + 1))) {
                break;
            }
        }

        if (_FP_POLICER_IS_FLOW_MODE(f_pl)
            && 0 == _FP_METER_BMP_TEST(fs->meter_bmp, idx)) {
            break;
        }
    }

    if (idx == fs->meters_count) {
        return (BCM_E_RESOURCE);
    }
    return (BCM_E_NONE);
}


/*
 * Function: _field_entry_install_slice_fit
 *
 * Purpose: Checks if slice has HW resource required for entry installation.
 * Parameters:
 *   unit        - (IN) BCM device number.
 *   stage_fc    - (IN) Stage field control.
 *   f_ent       - (IN) Entry to be inserted.
 *   fs          - (IN) Destination slice.
 * Returs:
 *   BCM_E_NONE - Entry fits the slice.
 *   BCM_E_XXX  - Otherwise.
 */
STATIC int
_field_entry_install_slice_fit(int unit, _field_stage_t *stage_fc,
                       _field_entry_t *f_ent, _field_slice_t *fs)
{
    _field_entry_policer_t *f_ent_pl;      /* Field entry policers.    */
    _field_entry_stat_t    *f_ent_st;      /* Field entry statistics.  */
    _field_stat_t          *f_st;          /* Field statistics entity. */
    _field_policer_t       *f_pl;          /* Field policer.           */
    _field_group_t         *fg;            /* Field group structure.   */
    uint8                  color_dependent;/* Stat is color dependend. */
    int                    rv;             /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == f_ent) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }
    fg = f_ent->group;

    /* Reset allocation flags. */
    f_ent->flags &= ~_FP_ENTRY_ALLOC_FROM_SECONDARY_SLICE;

    /* If device supports global meter pools or no meter installed -> no issue. */
    f_ent_pl = f_ent->policer;
    if ((stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) ||
        (0 == (f_ent_pl->flags & _FP_POLICER_VALID))) {
        f_pl = NULL;
    }  else {
        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);
        if (_FP_INVALID_INDEX != f_pl->hw_index) {
            f_pl = NULL; /* NO allocation required. */
        }
    }

    /* If device supports global counters or no counter installed -> no issue. */
    f_ent_st = &f_ent->statistic;
    if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
        /* Nothing to do for external FP, because:
           - for TR/TR2, each entry has it's own dedicated counter, and
           - for TR3, EXTFP supports only flex counters (as does VFP)
        */
        f_st = NULL;
    } else if ((stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS) ||
               (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS) ||
        (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID))) {
        f_st = NULL;
    }  else {
        rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
        BCM_IF_ERROR_RETURN(rv);
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
            if (f_st->flex_mode != 0) {
                return BCM_E_NONE; /* NO allocation required. */
            }
            if (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
                return BCM_E_NONE;
            }
        }
#endif
        if (_FP_INVALID_INDEX != f_st->hw_index) {
            f_st = NULL; /* NO allocation required. */
        }
    }

    /* Check if counter & meter are available in primary slice. */
    rv = BCM_E_NONE;
    /*    coverity[new_values : FALSE]    */
    if (f_pl != NULL) {
        rv =  _field_slice_meter_available(unit, f_pl, fs);
    }
    if ((f_st != NULL) && (BCM_SUCCESS (rv))) {
        rv = _field_slice_counter_available(unit, f_st, fs);
    }
    if (BCM_SUCCESS (rv)) {
        return (BCM_E_NONE);
    }

    if ((fg->flags  & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
        /* No counters -> policer can be allocated from any slice. */
        /* No policers -> counter can be allocated from any slice. */
        if ((f_st == NULL) || (f_pl == NULL)) {
            return (BCM_E_NONE);
        }

        /*
         * Only if counter is color blind it might be allocated
         * in a slice a different s policer.
         */

        /* Check if statistics entity is color dependent. */
        rv = _field_stat_color_dependent(unit, f_st, &color_dependent);
        BCM_IF_ERROR_RETURN(rv);
        if (FALSE == color_dependent) {
            return (BCM_E_NONE);
        }

        /* Check if counter & meter are available in secondary slice. */
        rv =  _field_slice_meter_available(unit, f_pl, fs + 1);
        if (BCM_SUCCESS (rv)) {
            rv =  _field_slice_counter_available(unit, f_st, fs + 1);
        }

        /* Policer must be allocated from secondary slice */
        if (BCM_SUCCESS (rv)) {
            f_ent->flags |= _FP_ENTRY_ALLOC_FROM_SECONDARY_SLICE;
            return (BCM_E_NONE);
        }
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function: _field_entry_move_slice_fit
 *
 * Purpose: Checks if slice has HW resource required for entry movement.
 * Parameters:
 *   unit        - (IN) BCM device number.
 *   stage_fc    - (IN) Stage field control.
 *   f_ent       - (IN) Entry to be inserted.
 *   fs          - (IN) Destination slice.
 *   freed_counters - (INOUT) Number of counters to be freed by a planned move
 * Returs:
 *   BCM_E_NONE - Entry fits the slice.
 *   BCM_E_XXX  - Otherwise.
 */
STATIC int
_field_entry_move_slice_fit(int unit, _field_stage_t *stage_fc,
    _field_entry_t *f_ent, _field_slice_t *fs, int *freed_meters,
    int *freed_counters)
{
    _field_entry_policer_t *f_ent_pl;      /* Field entry policers.    */
    _field_entry_stat_t    *f_ent_st;      /* Field entry statistics.  */
    _field_stat_t          *f_st;          /* Field statistics entity. */
    _field_policer_t       *f_pl;          /* Field policer.           */
    _field_group_t         *fg;            /* Field group structure.   */
    uint8                  color_dependent;/* Stat is color dependend. */
    int                    rv = BCM_E_NONE;/* Operation return status. */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == f_ent) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    fg = f_ent->group;

    /* Reset allocation flags. */
    f_ent->flags &= ~_FP_ENTRY_ALLOC_FROM_SECONDARY_SLICE;

    /* If device supports global meter pools or no meter installed -> no issue. */
    f_ent_pl = f_ent->policer;
    if ((stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) ||
        (0 == (f_ent_pl->flags & _FP_POLICER_VALID))) {
        f_pl = NULL;
    }  else {
        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);

        /* Reject policers shared by multiple entries. */
        if (2 != f_pl->sw_ref_count) {
            return (BCM_E_RESOURCE);
        }
    }

    /* If device supports global counters or no counter installed -> no issue. */
    f_ent_st = &f_ent->statistic;
    if ((stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS) ||
        (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS) ||
        (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID))) {
        f_st = NULL;
    }  else {
        rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
        BCM_IF_ERROR_RETURN(rv);

        /* Reject counters shared by multiple entries. */
        if (2 != f_st->sw_ref_count) {
            return (BCM_E_RESOURCE);
        }
    }

    /* Check if counter & meter are available in primary slice. */

    rv = BCM_E_NONE;

    /* coverity[new_values : FALSE]    */
    if (f_pl != NULL && *freed_meters == 0)
    {
        rv =  _field_slice_meter_available(unit, f_pl, fs);
    }

    if ((f_st != NULL) && (BCM_SUCCESS (rv)))
    {
        if (f_st->hw_entry_count > *freed_counters)
        {
            f_st->hw_entry_count -= *freed_counters;
            rv = _field_slice_counter_available(unit, f_st, fs);
            f_st->hw_entry_count += *freed_counters;
        }
    }

    if (BCM_SUCCESS (rv))
    {
        *freed_meters = (f_pl != NULL) ? 1 : 0;
        *freed_counters = (f_st != NULL) ? f_st->hw_entry_count : 0;

        return (BCM_E_NONE);
    }

    if ((fg->flags  & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
        /* No counters -> policer can be allocated from any slice. */
        /* No policers -> counter can be allocated from any slice. */
        if ((NULL == f_st) || (NULL == f_pl)) {
            return (BCM_E_NONE);
        }

        /*
         * Only if counter is color blind it might be allocated
         * in a slice a different s policer.
         */

        /* Check if statistics entity is color dependent. */
        rv = _field_stat_color_dependent(unit, f_st, &color_dependent);
        BCM_IF_ERROR_RETURN(rv);
        if (FALSE == color_dependent) {
            return (BCM_E_NONE);
        }

        /* Check if counter & meter are available in secondary slice. */
        rv =  _field_slice_meter_available(unit, f_pl, fs + 1);
        if (BCM_SUCCESS (rv)) {
            rv =  _field_slice_counter_available(unit, f_st, fs + 1);
        }

        /* Policer must be allocated from secondary slice */
        if (BCM_SUCCESS (rv)) {
            f_ent->flags |= _FP_ENTRY_ALLOC_FROM_SECONDARY_SLICE;
            return (BCM_E_NONE);
        }
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function:
 *      _field_action_hw_resources_free
 * Purpose:
 *      Free hw resources allocated for field action installation.
 * Parameters:
 *      unit     - (IN) BCM device number
 *      f_ent    - (IN) Field entry structure.
 *      fa       - (IN) Field action structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_action_hw_resources_free(int unit, _field_entry_t  *f_ent,
                                _field_action_t *fa,uint32 flags)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    int rv; /* Operational Status */
    _field_control_t *fc; /* Field Control Structure */
#endif
#if defined(INCLUDE_L3)
#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
         || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
         || defined (BCM_ENDURO_SUPPORT)
    uint32 flags_action;         /* L3 forwarding flags.    */
    int nh_ecmp_id;              /* Next hop/Ecmp group id. */
#endif
#endif /* INCLUDE_L3 */

#if defined(BCM_TRIDENT2_SUPPORT)
    soc_mem_t mem;
#endif

#if defined(INCLUDE_L3)
#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
         || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT)
    flags_action = 0;
    nh_ecmp_id = 0;
#endif
#endif
    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == fa)) {
        return (BCM_E_PARAM);
    }


    switch (fa->action) {
      case bcmFieldActionMirrorIngress:
      case bcmFieldActionMirrorEgress:
          return _field_mirror_dest_delete(unit, f_ent, fa,flags);
          break;
      case bcmFieldActionRedirectMcast:
#if defined(INCLUDE_L3)
      case bcmFieldActionRedirectIpmc:
#endif /* INCLUDE_L3 */
          if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)){
              break;
          }
      case bcmFieldActionRedirectPbmp:
      case bcmFieldActionEgressMask:
      case bcmFieldActionEgressPortsAdd:
          /* Applicable to stage ingress on TRX devices only. */
          if ((0 == SOC_IS_TRX(unit)) ||
              ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
               (_BCM_FIELD_STAGE_EXACTMATCH !=  f_ent->group->stage_id))) {
              break;
          }
#if defined(BCM_TRX_SUPPORT)
          BCM_IF_ERROR_RETURN
              (_bcm_field_trx_redirect_profile_delete(unit, fa->hw_index));
#endif /* BCM_TRX_SUPPORT */
          break;
#if defined(INCLUDE_L3)
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_TRX_SUPPORT)
      case bcmFieldActionSrcMacNew:
      case bcmFieldActionDstMacNew:
      case bcmFieldActionOuterVlanNew:
          if (soc_feature(unit, soc_feature_field_action_l2_change)) {
              BCM_IF_ERROR_RETURN(_bcm_field_l2_actions_hw_free(unit, f_ent,
                        _FP_ACTION_HW_FREE));

          }
          break;
#endif /* BCM_TRX_SUPPORT || BCM_FIREBOLT2_SUPPORT */

#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
         || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
         || defined (BCM_ENDURO_SUPPORT)
      case bcmFieldActionL3ChangeMacDa:
      case bcmFieldActionL3ChangeVlan:
          if (SOC_IS_KATANAX(unit) || SOC_IS_TD_TT(unit)
              || SOC_IS_TRIUMPH3(unit) || SOC_IS_GREYHOUND(unit) ||
              SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
              BCM_IF_ERROR_RETURN(_bcm_field_l3_egress_actions_reset(unit,
                                                  f_ent, _FP_ACTION_HW_FREE));
          }
          break;
      case bcmFieldActionL3Switch:
      case bcmFieldActionRedirectEgrNextHop:
          if (SOC_IS_KATANAX(unit) || SOC_IS_TD_TT(unit)
                  || SOC_IS_TRIUMPH3(unit) || SOC_IS_GREYHOUND(unit)
                  || SOC_IS_HURRICANEX(unit) || SOC_IS_ENDURO(unit)
                  || SOC_IS_GREYHOUND2(unit)) {
              BCM_IF_ERROR_RETURN(_bcm_field_policy_set_l3_nh_resolve (unit,
                          fa->param[0], &flags_action, &nh_ecmp_id));

              BCM_IF_ERROR_RETURN(bcmi_esw_l3_egress_ref_count_update (unit,
                          fa->param[0], flags_action, nh_ecmp_id,0));
              fa->hw_index = _FP_INVALID_INDEX;
          }
          break;
#endif /* BCM_KATANA_SUPPORT || BCM_TRIDENT_SUPPORT || BCM_TRIUMPH3_SUPPORT \
          || BCM_GREYHOUND_SUPPORT || BCM_ENDURO_SUPPORT */

#if defined(BCM_TRIDENT2_SUPPORT) /* BCM_TRIDENT2_SUPPORT */
      case bcmFieldActionNatEgressOverride:
          BCM_IF_ERROR_RETURN(_bcm_esw_nat_egress_ref_count_update
                  (unit, fa->param[0], 0));
          fa->hw_index = _FP_INVALID_INDEX;
          break;
#endif /* BCM_TRIDENT2_SUPPORT */

#endif /* INCLUDE_L3 */

#if defined(BCM_TRIDENT2_SUPPORT)
      case bcmFieldActionHashSelect0:
      case bcmFieldActionHashSelect1:
          /* Applicable to stage lookup on TRIDENT2 device only. */
          if ((0 == (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) ||
              (_BCM_FIELD_STAGE_LOOKUP != f_ent->group->stage_id)) {
              break;
          }
          mem = ((fa->action == bcmFieldActionHashSelect0)?
                  VFP_HASH_FIELD_BMAP_TABLE_Am:
                  VFP_HASH_FIELD_BMAP_TABLE_Bm);
         BCM_IF_ERROR_RETURN(_bcm_field_td2_hash_select_profile_delete(unit,
                                                         mem,
                                                         fa->hw_index));
          break;
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
      case bcmFieldActionFabricEHAddOrUpdate:

          BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
          if(NULL != fc->functions.fp_eh_mask_profile_hw_free) {
              rv = fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent, flags);
              BCM_IF_ERROR_RETURN(rv);
          }
          break;
#endif
      default:
          break;
    }
    fa->hw_index = _FP_INVALID_INDEX;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_mtp_hw_free
 *
 * Purpose:
 *     Free mtp indexes used in field entry
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_mtp_hw_free (int unit, _field_entry_t *f_ent, uint32 flags)
{
    _field_action_t *fa;        /* Field action descriptor. */
    int rv;                     /* Operation return status. */

    /* Extract action info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        /* Allocate mtp destination only for mirroring actions */
        if ((bcmFieldActionMirrorIngress != fa->action) &&
            (bcmFieldActionMirrorEgress != fa->action)) {
            continue;
        }

        if ((_FP_INVALID_INDEX == fa->hw_index) && (_FP_INVALID_INDEX == fa->old_index) ) {
            continue;
        }

        rv = _field_action_hw_resources_free(unit, f_ent, fa,flags);
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *      _field_invalid_actions_remove
 * Purpose:
 *      Remove deleted actions from entry actions
 *      linked list.
 * Parameters:
 *      unit  - (IN) BCM device number
 *      f_ent - (IN) Field entry structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_invalid_actions_remove(int unit, _field_entry_t  *f_ent)
{
    _field_action_t     *fa;
    _field_action_t     *fa_prev = NULL;
    _field_action_t     *fa_next = NULL;
    _field_action_t     *fa_iter;        /* Field entry actions iterator.*/
    int                 rv;
#if defined(BCM_TRIDENT_SUPPORT)
    uint8               idx;             /* Entry array action dest index. */
    uint32              entry_flags;     /* Entry flags                    */
#endif
#ifdef BCM_KATANA_SUPPORT
    uint32 param0 = 0, param1 = 0, in_flags = 0;
    int queue_id = 0;
    ing_queue_map_entry_t ing_queue_entry;
    int referenceCount = 0;
#endif

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Find the action in the entry */
    fa = f_ent->actions; /* start at head */
    while (fa != NULL) {
        fa_next = fa->next;
        if (fa->flags & _FP_ACTION_VALID) {
            fa_prev = fa;
            fa      = fa_next;
            continue;
        }
#if defined (BCM_TRIUMPH3_SUPPORT)
        if ( SOC_IS_TRIUMPH3(unit) && (_FP_INVALID_INDEX != fa->hw_index) &&
             ((fa->action == bcmFieldActionReplaceSrcMac) ||
              (fa->action == bcmFieldActionReplaceDstMac) ||
              (fa->action == bcmFieldActionReplaceInnerVlan) ||
              (fa->action == bcmFieldActionReplaceOuterVlan) ||
              (fa->action == bcmFieldActionReplaceInnerVlanPriority)  ||
              (fa->action == bcmFieldActionReplaceOuterVlanPriority) )) {
            rv = _bcm__field_tr3_action_replaceL2Fields_remove_HWEntries(unit, f_ent, fa);
            BCM_IF_ERROR_RETURN(rv);
        }
#endif

        if (_FP_INVALID_INDEX != fa->hw_index) {
            /*
             * Check if a valid instance of this action exists in
             * the entry actions linked list.
             * If TRUE, hardware index must be freed only
             * after updating policy table with new information.
             */
            if ((bcmFieldActionEgressMask == fa->action)
                || (bcmFieldActionRedirectBcastPbmp == fa->action)
                || (bcmFieldActionRedirectPbmp == fa->action)
                || (bcmFieldActionEgressPortsAdd == fa->action)
                || (bcmFieldActionRedirectMcast == fa->action)
                || (bcmFieldActionRedirectIpmc == fa->action)
                || (bcmFieldActionMirrorIngress == fa->action)
                || (bcmFieldActionMirrorEgress == fa->action)
                || (bcmFieldActionHashSelect0 == fa->action)
                || (bcmFieldActionHashSelect1 == fa->action)
                || (bcmFieldActionFabricEHAddOrUpdate == fa->action)) {

               if(_FP_ACTION_MODIFY & fa->flags) {


                fa->flags &= ~_FP_ACTION_MODIFY;

                fa_iter = f_ent->actions;

                while (fa_iter != NULL) {
                    if ((1 == (fa_iter->flags & _FP_ACTION_VALID))
                        && (fa_iter->action == fa->action)
                        && (_FP_INVALID_INDEX == fa_iter->hw_index)) {
                            /* Do not free here. Release the hardware
                             * index after policy install operation.
                             */
                            fa_iter->hw_index = fa->hw_index;
                            fa_iter->flags |= _FP_ACTION_MODIFY;
                            fa->hw_index = _FP_INVALID_INDEX;
                            break;
                    }
                    fa_iter = fa_iter->next;
                }

                /* Here _FP_ACTION_MODIFY flag cleared means , no duplicate
                   actions are found i.e an action is removed from the entry.
                   Those invalid but not modified entries will be removed in
                   the second pass to this function,so just return BCM_E_NONE
                   on first pass */
                if(!(_FP_ACTION_MODIFY & fa->flags)) {
                   fa_prev = fa;
                   fa      = fa_next;
                   continue;
                }
              }
            }


            /*
             * Action not set for this entry, free the hardware index.
             */
            if (_FP_INVALID_INDEX != fa->hw_index) {
                rv = _field_action_hw_resources_free(unit, f_ent, fa,
                                                     _FP_ACTION_RESOURCE_FREE);
                BCM_IF_ERROR_RETURN(rv);
            }
        }

        if (fa_prev != NULL) {
            fa_prev->next = fa->next;
        } else { /* matched head of list */
            f_ent->actions = fa_next;
        }
#if defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_KATANAX(unit)) {
        if (fa != NULL) {
            if ((fa->action == bcmFieldActionFabricQueue) &&
                (f_ent->fs->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
                sal_memset(&ing_queue_entry, 0, sizeof(ing_queue_map_entry_t));
                param0 = fa->param[0];
                param1 = fa->param[1];
                /* For Katana if param1 BCM_FABRIC_QUEUE_xxx
                 * flags are set then param0 is
                 * ucast/ucast_subscriber group cosq gport */
                if ((param1 & BCM_FABRIC_QUEUE_DEST_OFFSET) ||
                    (param1 & BCM_FABRIC_QUEUE_CUSTOMER)) {
                   if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(param0) ||
                        BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(param0) ||
                        BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(param0)) {
#if defined(BCM_KATANA2_SUPPORT)
                        if (SOC_IS_KATANA2(unit)) {
                            queue_id = -1;
                            rv = _bcm_kt2_cosq_index_resolve(
                                  unit, param0, 0,
                                 _BCM_KT_COSQ_INDEX_STYLE_BUCKET,
                                  NULL, &queue_id, NULL);
                            if (BCM_FAILURE(rv) &&
                                 (rv != BCM_E_NOT_FOUND)) {
                                 return rv;
                             }
                        } else
#endif
                        {
                            if (SOC_IS_KATANA(unit)) {
                                BCM_IF_ERROR_RETURN(_bcm_kt_cosq_index_resolve(
                                    unit, param0, 0,
                                    _BCM_KT_COSQ_INDEX_STYLE_BUCKET,
                                    NULL, &queue_id, NULL));
                            }
                        }
                    } else {
                        queue_id = param0 & 0xffff;
                    }
                    in_flags = param1;
                } else {
                    queue_id = param0 & 0xffff;
                    in_flags = param0;
                }

                if (in_flags & BCM_FABRIC_QUEUE_DEST_OFFSET) {
                   if (queue_id != -1) {
                       BCM_IF_ERROR_RETURN(
                          _bcm_field_fabricQueue_action_node_delete (unit,
                              queue_id, param1, &referenceCount));
                       if(referenceCount == 0) {
                           BCM_IF_ERROR_RETURN(BCM_XGS3_MEM_WRITE(unit,
                                        ING_QUEUE_MAPm,
                                        queue_id, &ing_queue_entry));
                       }
                    }
               }
            }
        }
    }
#endif
        /* okay to free action */
        sal_free(fa);
        fa = fa_next;
    }

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT (unit) &&
        !(soc_feature(unit, soc_feature_field_multi_pipe_support))) {
        if ((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {

            if (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                entry_flags = (_FP_ENTRY_PRIMARY | _FP_ENTRY_SECOND_HALF);
            } else {
                entry_flags = _FP_ENTRY_SECONDARY;
            }

            rv = _bcm_field_entry_flags_to_tcam_part(unit, entry_flags,
                                                     f_ent->group,
                                                     &idx);

            BCM_IF_ERROR_RETURN(rv);
            /* Find the action in the entry */
            fa = f_ent[idx].actions; /* start at head */
            fa_prev = NULL;
            fa_next = NULL;
            while (fa != NULL) {
                fa_next = fa->next;
                if (fa->flags & _FP_ACTION_VALID) {
                    fa_prev = fa;
                    fa = fa_next;
                    continue;
                }
                if (fa_prev != NULL) {
                    fa_prev->next = fa->next;
                } else { /* matched head of list */
                    f_ent[idx].actions = fa_next;
                }

                /* okay to free action */
                sal_free(fa);
                fa = fa_next;
            }
        }
    }
#endif

    /* Remove Invalid Oam Actions */
#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_invalid_actions_remove (unit, f_ent);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_mtp_hw_alloc
 *
 * Purpose:
 *     Allocate mtp indexes required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_mtp_hw_alloc (int unit, _field_entry_t *f_ent)
{
    _field_action_t *fa;  /* Field action descriptor. */
    int rv;               /* Operation return status. */
    int mirror_flags = 0;

    /* Extract action info from the entry structure. */
    for (fa = f_ent->actions; ((fa != NULL) && (_FP_ACTION_VALID & fa->flags)); fa = fa->next) {
        /* Allocate mtp destination only for mirroring actions */
        if ((bcmFieldActionMirrorIngress != fa->action) &&
            (bcmFieldActionMirrorEgress != fa->action)) {
            continue;
        }
        if(_FP_ACTION_MODIFY & fa->flags) {
            fa->old_index = fa->hw_index;
            fa->hw_index = _FP_INVALID_INDEX;
        }
        if (_FP_INVALID_INDEX == fa->hw_index) {
        /* Allocate mirror destination. */
          if(BCM_E_RESOURCE == (rv = _field_mirror_dest_add(unit, f_ent, fa))) {
            if(_FP_ACTION_MODIFY & fa->flags) {
                fa->hw_index = fa->old_index;
                fa->old_index = _FP_INVALID_INDEX;
            }
            for (fa = f_ent->actions;
                 ((fa != NULL) &&
                 (_FP_ACTION_VALID & fa->flags)); fa = fa->next) {
                if ((bcmFieldActionMirrorIngress != fa->action)
                     && (bcmFieldActionMirrorEgress != fa->action)) {
                    continue;
                }
                if (fa->flags & _FP_ACTION_DIRTY) {
                    /* Free the alloted resources */
                    _field_mirror_dest_delete(unit, f_ent, fa,
                                              _FP_ACTION_RESOURCE_FREE);
                }
            }
          }
          BCM_IF_ERROR_RETURN(rv);
        } else {
            if (bcmFieldActionMirrorIngress == fa->action) {
                mirror_flags =
                    _BCM_MIRROR_SLOT_INGRESS | _BCM_MIRROR_SLOT_FP;
                BCM_IF_ERROR_RETURN
                    (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                     mirror_flags,
                                                     f_ent->ing_mtp_slot_map));
                f_ent->ing_mtp_slot_map = 0;
            }
            if (bcmFieldActionMirrorEgress == fa->action) {
                if (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id) {
                    mirror_flags =
                        _BCM_MIRROR_SLOT_EGRESS | _BCM_MIRROR_SLOT_FP;
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_mirror_fp_slot_del_ref(unit,
                                                         mirror_flags,
                                                         f_ent->egr_mtp_slot_map));
                    f_ent->egr_mtp_slot_map = 0;
                }
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_redirect_profile_hw_free
 *
 * Purpose:
 *     Free redirect profile indexes required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 *     flags     - (IN) Free flags (old/new/both).
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_redirect_profile_hw_free(int unit, _field_entry_t *f_ent, uint32 flags)
{
    _field_action_t *fa;  /* Field action descriptor. */
    int rv = BCM_E_NONE;  /* Operation return status. */

    /* Applicable to stage ingress on TRX devices only. */
    if ((0 == SOC_IS_TRX(unit)) ||
        ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
         (_BCM_FIELD_STAGE_EXTERNAL != f_ent->group->stage_id) &&
         (_BCM_FIELD_STAGE_EXACTMATCH != f_ent->group->stage_id))) {
        return (BCM_E_NONE);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionRedirectMcast:
#if defined(INCLUDE_L3)
          case bcmFieldActionRedirectIpmc:
#endif /* INCLUDE_L3 */
              if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)){
                  break;
              }
          case bcmFieldActionRedirectPbmp:
          case bcmFieldActionRedirectBcastPbmp:
          case bcmFieldActionEgressMask:
          case bcmFieldActionEgressPortsAdd:
#if defined(BCM_TRX_SUPPORT)
              if ((flags & _FP_ACTION_RESOURCE_FREE) &&
                  (_FP_INVALID_INDEX != fa->hw_index)) {
                  rv = _bcm_field_trx_redirect_profile_delete(unit,
                                                              fa->hw_index);
                  BCM_IF_ERROR_RETURN(rv);
                  fa->hw_index = _FP_INVALID_INDEX;
              }

              if ((flags & _FP_ACTION_OLD_RESOURCE_FREE) &&
                  (_FP_INVALID_INDEX != fa->old_index)) {
                  rv = _bcm_field_trx_redirect_profile_delete(unit,
                                                              fa->old_index);
                  BCM_IF_ERROR_RETURN(rv);
                  fa->old_index = _FP_INVALID_INDEX;
              }
              break;
#endif /* BCM_TRX_SUPPORT */
          default:
              break;
        }
    }
    return (rv);
}


/*
 * Function:
 *     _field_redirect_profile_hw_alloc
 *
 * Purpose:
 *     Allocate redirect profile index required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry descriptor.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_redirect_profile_hw_alloc (int unit, _field_entry_t *f_ent)
{
    int rv = BCM_E_NONE;  /* Operation return status.     */
#if defined (BCM_TRX_SUPPORT)
    _field_action_t *fa;  /* Field action descriptor.     */

    int ref_count;        /* Profile use reference count. */

    /* Applicable to stage ingress on TRX devices only. */
    if ((0 == SOC_IS_TRX(unit)) ||
        ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
         (_BCM_FIELD_STAGE_EXTERNAL != f_ent->group->stage_id) &&
         (_BCM_FIELD_STAGE_EXACTMATCH != f_ent->group->stage_id))) {
        return (BCM_E_NONE);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; ((fa != NULL) && (_FP_ACTION_VALID & fa->flags)); fa = fa->next) {
        switch (fa->action) {
          case bcmFieldActionRedirectMcast:
#if defined(INCLUDE_L3)
          case bcmFieldActionRedirectIpmc:
#endif /* INCLUDE_L3 */
              if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)){
                  break;
              }
          case bcmFieldActionRedirectPbmp:
          case bcmFieldActionRedirectBcastPbmp:
          case bcmFieldActionEgressMask:
          case bcmFieldActionEgressPortsAdd:
              /*
               * Store previous hardware index value in old_index.
               */
              fa->old_index = fa->hw_index;

              rv = _bcm_field_trx_redirect_profile_alloc(unit, f_ent, fa);
              if ((BCM_E_RESOURCE == rv) &&
                  (_FP_INVALID_INDEX != fa->old_index)) {
                  /* Destroy old profile ONLY
                   * if it is not used by other entries.
                   */
                  rv = _bcm_field_trx_redirect_profile_ref_count_get(unit,
                                                                     fa->old_index,
                                                                     &ref_count);
                  BCM_IF_ERROR_RETURN(rv);
                  if (ref_count > 1) {
                      return (BCM_E_RESOURCE);
                  }
                  rv = _bcm_field_trx_redirect_profile_delete(unit, fa->old_index);
                  BCM_IF_ERROR_RETURN(rv);

                  /* Destroy old profile is no longer required. */
                  fa->old_index = _FP_INVALID_INDEX;

                  /* Reallocate profile for new action. */
                  rv = _bcm_field_trx_redirect_profile_alloc(unit, f_ent, fa);
              }
              break;
          default:
              break;
        }
        if (BCM_FAILURE(rv)) {
            _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            break;
        }
    }
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *     _field_port_filter_enable_set
 *
 * Purpose:
 *     Set the filter enable state in the Port Tables.
 *
 * Parameters:
 *     unit   - (IN)BCM device number.
 *     fc     - (IN)Field control structure.
 *     state  - (IN) TRUE = to enable
 *                   FALSE = disable filtering.
 *
 * Returns:
 *     BCM_E_NONE  - Success
 *     BCM_E_XXX   - From table read/write
 */
int
_field_port_filter_enable_set(int unit, _field_control_t *fc, uint32 state)
{
    int port;                      /* Port iterator.               */
    int ret_val = BCM_E_NONE;      /* Operation return value.      */
    bcm_port_config_t  port_config;/* Device port config structure.*/
    bcm_pbmp_t port_pbmp, all_pbmp;

    /* Input parameters check. */
    if (NULL == fc || ((state != TRUE) && (state != FALSE))) {
        return (BCM_E_PARAM);
    }

    state = (state) ? 1 : 0;

    /* Read device port configuration. */
    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
    BCM_PBMP_CLEAR(port_pbmp);
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(port_pbmp, port_config.port);
    BCM_PBMP_ASSIGN(all_pbmp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &port_pbmp));
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &port_pbmp);
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)){
        int oamp_enable;
        (void)bcm_sb2_sat_oamp_enable_get(unit, &oamp_enable);
        /* Skip OAMP port for saber2 device */
        if(oamp_enable) {
            SOC_PBMP_PORT_REMOVE(port_pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
            SOC_PBMP_PORT_REMOVE(all_pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
        }
    }
#endif

    FP_LOCK(unit);

    /* Iterate over all the ports but CPU set Lookup filtering. */
    BCM_PBMP_ITER(port_pbmp, port) {
        /* Set field  enable to the hw. */
        ret_val =  bcm_esw_port_control_set(unit, port,
                                            bcmPortControlFilterLookup, state);

        if (BCM_E_UNAVAIL == ret_val) {
            /* Device doesn't support lookup filtering. */
            break;
        }

        if (BCM_FAILURE(ret_val)) {
            FP_UNLOCK(unit);
            return (ret_val);
        }
    }

    /* Iterate over all the ports but CPU set ingress filtering. */
    BCM_PBMP_ITER(port_pbmp, port) {
        /* Set field  enable to the hw. */
        ret_val =  bcm_esw_port_control_set(unit, port,
                                            bcmPortControlFilterIngress, state);
        if (BCM_FAILURE(ret_val)) {
            FP_UNLOCK(unit);
            return (ret_val);
        }
    }

    /* Iterate over all the ports set egress filtering. */
    BCM_PBMP_ITER(all_pbmp, port) {
        /* Set field  enable to the hw. */
        ret_val =  bcm_esw_port_control_set(unit, port,
                                            bcmPortControlFilterEgress, state);

        if (BCM_E_UNAVAIL == ret_val) {
            /* Device doesn't support egress filtering. */
            break;
        }

        if (BCM_FAILURE(ret_val)) {
            FP_UNLOCK(unit);
            return (ret_val);
        }
    }
    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: _field_qualifier_gport_resolve
 *
 * Purpose:
 *     Resolves gport as parameter of qualifier.
 *
 * Parameters:
 *     unit     - (IN) BCM device number
 *     gport    - (IN) GPORT to resolve
 *     mask     - (IN) qualifier mask, in case of gport must be -1
 *     out_p    - (OUT) port encoded into gport.
 *     out_m    - (OUT) module encoded into gport.
 *     out_t    - (OUT) trunk encoded into gport.
 *
 * Returns:
 *     BCM_E_NONE      - No errors.
 *     BCM_E_XXX       - Otherwise.
 */

int
_field_qualifier_gport_resolve(int unit, bcm_gport_t gport, int mask,
                               int *out_p, int *out_m, int *out_t)
{
    bcm_port_t      port;
    bcm_module_t    modid;
    bcm_trunk_t     tgid = BCM_TRUNK_INVALID;
    int             id;

    /* In case of gport mask must be exact match */
    if (BCM_FIELD_EXACT_MATCH_MASK != mask) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(
        _bcm_esw_gport_resolve(unit, gport, &modid, &port, &tgid, &id));

#if defined(BCM_HGPROXY_COE_SUPPORT)
    if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        /* For this case gport_resolve returns non-negative id */
    } else
#endif
#if defined(BCM_KATANA2_SUPPORT)
    if (BCM_GPORT_IS_SET(gport) &&
        _BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, gport)) {
        /* For this case gport_resolve returns non-negative id */
    } else
#endif
    {
        if (-1 != id) {
            return BCM_E_PORT;
        }
    }

    if (BCM_TRUNK_INVALID != tgid && NULL == out_t) {
        return BCM_E_PORT;
    }
    if (NULL != out_t) {
        *out_t = tgid;
    }
    if (NULL != out_m) {
        *out_m = modid;
    }
    if (NULL != out_p) {
        *out_p = port;
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_params_hw_to_api_adapt
 *
 * Purpose:
 *     Adapts action parameters from HW to API space.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     action - (IN)Action to adapt parameters for (bcmFieldActionXXX)
 *     param0 - (IN/OUT)Action parameter
 *     param1 - (IN/OUT)Action parameter
 *
 * Returns:
 *     BCM_E_NONE      - No errors.
 *     BCM_E_XXX       - Otherwise.
 */

int
_field_params_hw_to_api_adapt(int unit, bcm_field_action_t action,
                              uint32 *param0, uint32 *param1)
{
    int                 isGport;
    _bcm_gport_dest_t   dest;

    _bcm_gport_dest_t_init(&dest);
    BCM_IF_ERROR_RETURN(
        bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport));

    switch (action) {
        case bcmFieldActionRedirect:
            if (isGport) {
                dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                dest.modid = *param0;
                dest.port = *param1;
                BCM_IF_ERROR_RETURN(
                   _bcm_esw_gport_construct(unit, &dest, (bcm_gport_t*)param1));
               *param0 = -1;   /* If gport requested param0 should be ignored */
            }
            break;
        case bcmFieldActionRedirectTrunk:
            if (isGport) {
                dest.gport_type = _SHR_GPORT_TYPE_TRUNK;
                dest.tgid = *param0;
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_gport_construct(unit, &dest, (bcm_gport_t*)param0));
                *param1 = -1;   /* If gport requested param1 should be ignored */
            }
            break;
        default:
            break;
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_params_api_to_hw_adapt
 *
 * Purpose:
 *     Adapts action parameters from API to HW space.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     action - (IN)Action to adapt parameters for (bcmFieldActionXXX)
 *     param0 - (IN/OUT)Action parameter
 *     param1 - (IN/OUT)Action parameter
 *
 * Returns:
 *     BCM_E_NONE      - No errors.
 *     BCM_E_XXX       - Otherwise.
 */

int
_field_params_api_to_hw_adapt(int unit, bcm_field_action_t action,
                              uint32 *param0, uint32 *param1)
{
    bcm_module_t        l_modid;
    bcm_trunk_t         l_tgid;
    bcm_port_t          l_port;
    int                 id;


    switch (action) {
        case bcmFieldActionRedirect:
            if (BCM_GPORT_IS_SET(*param1)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_gport_resolve(unit, *param1, &l_modid, &l_port, &l_tgid, &id));

#if defined(BCM_HGPROXY_COE_SUPPORT)
                /* modify param0 and param1 for
                 * SubportPktTag subport gport.
                 * For this case gport_resolve function returns
                 * non-negative id */
            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) &&
                _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, *param1)) {
                    if (BCM_TRUNK_INVALID != l_tgid) {
                        return BCM_E_PARAM;
                    }
                    *param1 = l_port;
                    *param0 = l_modid;
            } else
#endif

#if defined(BCM_KATANA2_SUPPORT)
                /* modify param0 and param1 for
                 * LinkPHy/SubportPktTag subport gport.
                 * For this case gport_resolve function returns
                 * non-negative id */
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    *param1)) {
                    if (BCM_TRUNK_INVALID != l_tgid) {
                        return BCM_E_PARAM;
                    }
                    *param1 = l_port;
                    *param0 = l_modid;
                } else
#endif
                {
                    /* Do not modify param0 and param1 if id != -1 */
                    if (-1 == id) {
                        if (BCM_TRUNK_INVALID != l_tgid) {
                            return BCM_E_PARAM;
                        }
                        *param1 = l_port;
                        *param0 = l_modid;
                    }
                }
            }
            break;
        case bcmFieldActionRedirectTrunk:
            if (BCM_GPORT_IS_SET(*param0)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_gport_resolve(unit, *param0, &l_modid, &l_port, &l_tgid, &id));

#if defined(BCM_HGPROXY_COE_SUPPORT)
            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) &&
                _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, *param0)) {
                    /* For this case gport_resolve function returns
                     * non-negative id */
                    if ((BCM_TRUNK_INVALID == l_tgid) ){
                        return BCM_E_PARAM;
                    }
                    *param0 = l_tgid;
                    *param1 = -1;   /* if param0 is trunk, param1 ignored */
                } else
#endif
#if defined(BCM_KATANA2_SUPPORT)
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    *param0)) {
                    /* For this case gport_resolve function returns
                     * non-negative id */
                    if ((BCM_TRUNK_INVALID == l_tgid) ){
                        return BCM_E_PARAM;
                    }
                    *param0 = l_tgid;
                    *param1 = -1;   /* if param0 is trunk, param1 ignored */
                } else
#endif
                {
                    if ((-1 != id) || (BCM_TRUNK_INVALID == l_tgid) ){
                        return BCM_E_PARAM;
                    }
                    *param0 = l_tgid;
                    *param1 = -1;   /* if param0 is trunk, param1 ignored */
                }
            }
            break;
        default:
            break;
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_meter_refresh_enable_set
 *
 * Purpose:
 *     Enable meters refresh cycle.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     fc     - (IN) Field control structure.
 *     state  - (IN) On/Off boolean.
 *
 * Returns:
 *     BCM_E_NONE      - No errors.
 *     BCM_E_XXX       - Otherwise.
 */
int
_field_meter_refresh_enable_set(int unit, _field_control_t *fc, uint32 state)
{

    int rv = BCM_E_NONE;    /* Operation return status. */
#ifdef BCM_TRIUMPH_SUPPORT
    soc_reg_t  reg;
#endif /* BCM_TRIUMPH_SUPPORT */

    /* Input parameters check. */
    if (NULL == fc || ((state != TRUE) && (state != FALSE))) {
        return (BCM_E_PARAM);
    }

    state = (state) ? 1 : 0;

#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TR_VL(unit)) {
        reg = (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
            SOC_IS_GREYHOUND(unit)|| SOC_IS_GREYHOUND2(unit)) ?
            IESMIF_CONTROLr : IESMIF_CONTROL2r;
        if (SOC_REG_IS_VALID (unit, reg)) {
            if (SOC_REG_FIELD_VALID(unit, reg, FP_REFRESH_ENABLEf)) {
                rv = soc_reg_field32_modify(unit, reg, REG_PORT_ANY,
                                        FP_REFRESH_ENABLEf, state);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
        if(!SOC_IS_HURRICANE(unit)) {
            if (SOC_REG_IS_VALID (unit, EFP_METER_CONTROLr)) {
                if (SOC_REG_FIELD_VALID(unit,  EFP_METER_CONTROLr, EFP_REFRESH_ENABLEf)) {
                    rv = soc_reg_field32_modify(unit, EFP_METER_CONTROLr, REG_PORT_ANY,
                                    EFP_REFRESH_ENABLEf, state);
                }
            }
            BCM_IF_ERROR_RETURN(rv);
        }
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROLr,
                                        REG_PORT_ANY,
                                        FP_REFRESH_ENABLEf, state);
            BCM_IF_ERROR_RETURN(rv);

        } else
#endif
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2_64r,
                                        REG_PORT_ANY,
                                        FP_REFRESH_ENABLEf, state);
            BCM_IF_ERROR_RETURN(rv);

        } else
#endif
        if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit) || SOC_IS_HURRICANE2(unit) ||
            SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2r,
                                        REG_PORT_ANY,
                                        FP_REFRESH_ENABLEf, state);
            BCM_IF_ERROR_RETURN(rv);
        }
        return rv;
    }
#endif /* BCM_TRIUMPH_SUPPORT */

#ifdef BCM_SCORPION_SUPPORT
    if (SOC_IS_SC_CQ(unit)) {

        rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2r, REG_PORT_ANY,
                                    FP_REFRESH_ENABLEf, state);
        BCM_IF_ERROR_RETURN(rv);
        if (SOC_SWITCH_BYPASS_MODE_L3_ONLY != SOC_SWITCH_BYPASS_MODE(unit)) {
            rv = soc_reg_field32_modify(unit, EFP_METER_CONTROLr,
                                        REG_PORT_ANY,
                                        EFP_REFRESH_ENABLEf, state);
            BCM_IF_ERROR_RETURN(rv);
        }
        return BCM_E_NONE;
    }
#endif /* BCM_SCORPION_SUPPORT */

#ifdef BCM_BRADLEY_SUPPORT
    if (SOC_IS_HBX(unit)) {
        uint32 sbs_ctrl;
        uint32 pipe_sel;
        BCM_IF_ERROR_RETURN(READ_SBS_CONTROLr(unit, &sbs_ctrl));
        pipe_sel = soc_reg_field_get(unit, SBS_CONTROLr, sbs_ctrl,
                                     PIPE_SELECTf);

        rv =soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2r, REG_PORT_ANY,
                                   FP_REFRESH_ENABLEf, state);
        BCM_IF_ERROR_RETURN(rv);

        /* Flip between X and Y pipe */
        pipe_sel = (pipe_sel == 0) ? 1 : 0;
        soc_reg_field_set(unit, SBS_CONTROLr, &sbs_ctrl, PIPE_SELECTf,
                          pipe_sel);
        BCM_IF_ERROR_RETURN(WRITE_SBS_CONTROLr(unit, sbs_ctrl));

        rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2r, REG_PORT_ANY,
                                    FP_REFRESH_ENABLEf, state);
        BCM_IF_ERROR_RETURN(rv);
        /* Restore original pipeline selection */
        pipe_sel = (pipe_sel == 0) ? 1 : 0;
        soc_reg_field_set(unit, SBS_CONTROLr, &sbs_ctrl, PIPE_SELECTf,
                          pipe_sel);
        return WRITE_SBS_CONTROLr(unit, sbs_ctrl);
    }
#endif /* BCM_BRADLEY_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_stage)) {
        rv = soc_reg_field32_modify(unit, EFP_METER_CONTROLr, REG_PORT_ANY,
                                    EFP_REFRESH_ENABLEf, state);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif /* BCM_FIREBOLT2_SUPPORT */

    rv = soc_reg_field32_modify(unit, AUX_ARB_CONTROLr, REG_PORT_ANY,
                                FP_REFRESH_ENABLEf, state);

    return (rv);
}


/*
 * Function:
 *     _bcm_field_stage_qualifiers_free
 * Purpose:
 *     De-initialize stage qaualifiers descriptors.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 *
 * Returns:
 *     BCM_E_NONE
 */
int
_bcm_field_stage_qualifiers_free(int unit, _field_stage_t *stage_fc)
{
    _bcm_field_qual_info_t  *f_qual; /* Qualifier descriptor.       */
    int idx;                         /* Qualifiers iteration index. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if (NULL == stage_fc->f_qual_arr) {
        return (BCM_E_NONE);
    }

    for (idx = 0; idx < _bcmFieldQualifyCount; idx++) {
        f_qual = stage_fc->f_qual_arr[idx];

        /* Skip unused qualifiers. */
        if (NULL == f_qual) {
            continue;
        }
        /* Free qualifier configurations array. */
        if (NULL != f_qual->conf_arr) sal_free(f_qual->conf_arr);

        /* Free qualifier descriptor structure. */
        sal_free(f_qual);

        /* Mark qualifier as unused. */
        stage_fc->f_qual_arr[idx] = NULL;
    }

    /* Free qualifiers array. */
    sal_free(stage_fc->f_qual_arr);
    stage_fc->f_qual_arr = NULL;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qual_add
 * Purpose:
 *     Install field selector to selectors table.
 *
 * Parameters:
 *   fpf_info - (IN) FPF memory, field, qual table and selector table info.
 *   qid      - (IN) Qualifier id.
 *   offset   - (IN) Qualifier offset.
 *   width    - (IN) Qualifier width.
 *   code     - (IN) FPF table index.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qual_add (_field_fpf_info_t *fpf_info, int qid,
                 int offset, int width, int code)
{
    _qual_info_t     *fq_p;

    /* Input parameters check. */
    if ((code >= FPF_SZ_MAX) || (NULL == fpf_info)) {
         return (BCM_E_PARAM);
    }

    /* Allocate qualifier info. */
    fq_p = sal_alloc(sizeof(_qual_info_t), "Qualifier Info");
    if (NULL == fq_p) {
        return (BCM_E_MEMORY);
    }

    /* Set qualifier data. */
    _FP_QUAL_INFO_SET(qid, fpf_info->field, offset, width, fq_p);

    /* Insert qual_table */
    fq_p->next = fpf_info->qual_table[code];
    fpf_info->qual_table[code] = fq_p;

    /* Insert qual_table */
    BCM_FIELD_QSET_ADD_INTERNAL(fpf_info->sel_table[code], qid);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_group_slice_count_get
 * Purpose:
 *     Retrieve number of slices group occupies
 * Parameters:
 *     flags -(IN) Group flags.
 *     count -(OUT)Slice count (1-3).
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_group_slice_count_get(uint32 flags, int *count)
{

    if (NULL == count) {
        return (BCM_E_PARAM);
    }

    if (flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        *count = 3;
    } else if (flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        *count = 2;
    } else {
        *count = 1;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qual_offset_get
 * Purpose:
 *     Retrieve qualifier offsets
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Field entry structure.
 *     qid      - (IN) Qualifier id.
 *     offset   - (OUT) Qualifier offset and width.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qual_offset_get(int unit, _field_entry_t *f_ent, int qid,
                       _bcm_field_qual_offset_t **offset)
{
    _bcm_field_group_qual_t *q_arr;    /* Qualifiers array.          */
    _field_group_t          *fg;       /* Field group structure.     */
    uint8                   entry_part;/* Wide entry part number.    */
    uint8                   entry_type;  /* Index to tcam entries
                                              of multiple types      */
    int                     rv;        /* Operation return status.   */
    int                     idx;       /* Entry qualifiers iterator. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qual_offset_get\n")));

    /* Input parameters check. */
    if ((NULL == offset) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Get entry group. */
    fg = f_ent->group;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                        (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
        return (BCM_E_NONE);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (0 == BCM_FIELD_QSET_TEST(fg->qset, qid)) {
        /* Only qualifiers that were explicitly requested may be used */
#ifdef BROADCOM_DEBUG
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: qual=%s not in group=%d Qset\n"),
                   unit,
                   _field_qual_name(qid), f_ent->group->gid));
#endif
        return (BCM_E_PARAM);
    }

    /* Get field entry part where qualifier resides. */
    rv = _bcm_field_entry_flags_to_tcam_part (unit, f_ent->flags, fg,
                                              &entry_part);
    BCM_IF_ERROR_RETURN(rv);

    entry_type = _FP_ENTRY_TYPE_DEFAULT;

    /* Get qualifier information. */
    q_arr = &(fg->qual_arr[entry_type][entry_part]);
    for (idx = 0; idx < q_arr->size; idx++) {
        if (qid == q_arr->qid_arr[idx]) {
            *offset = q_arr->offset_arr + idx;
            break;
        }
    }

    if (idx == q_arr->size) {
        *offset = NULL;
        return (BCM_E_NOT_FOUND);
    }
    return (BCM_E_NONE);
}
#if defined(BCM_TRIDENT2_SUPPORT)
/*
 * Function:
 *     _field_qual_offset_get_by_entry_type
 * Purpose:
 *     Retrieve qualifier offsets
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_ent         - (IN) Field entry structure.
 *     qid           - (IN) Qualifier id.
 *     entry_type    - (IN) Index to groups qual_arr
 *     offset        - (OUT) Qualifier offset and width.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qual_offset_get_by_entry_type(int unit, _field_entry_t *f_ent, int qid,
                                     uint8 entry_type,
                                     _bcm_field_qual_offset_t **offset)
{
    _bcm_field_group_qual_t *q_arr;    /* Qualifiers array.          */
    _field_group_t          *fg;       /* Field group structure.     */
    uint8                   entry_part;/* Wide entry part number.    */
    int                     rv;        /* Operation return status.   */
    int                     idx;       /* Entry qualifiers iterator. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qual_offset_get_by_entry_type\n")));

    /* Input parameters check. */
    if ((NULL == offset) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Get entry group. */
    fg = f_ent->group;

    if (0 == BCM_FIELD_QSET_TEST(fg->qset, qid)) {
        /* Only qualifiers that were explicitly requested may be used */
#ifdef BROADCOM_DEBUG
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: qual=%s not in group=%d Qset\n"),
                   unit,
                   _field_qual_name(qid), f_ent->group->gid));
#endif
        return (BCM_E_PARAM);
    }

    /* Get field entry part where qualifier resides. */
    rv = _bcm_field_entry_flags_to_tcam_part (unit, f_ent->flags, fg,
                                              &entry_part);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifier information. */
    q_arr = &(fg->qual_arr[entry_type][entry_part]);
    for (idx = 0; idx < q_arr->size; idx++) {
        if (qid == q_arr->qid_arr[idx]) {
            *offset = q_arr->offset_arr + idx;
            break;
        }
    }

    if (idx == q_arr->size) {
        *offset = NULL;
        return (BCM_E_NOT_FOUND);
    }
    return (BCM_E_NONE);
}
#endif

/*
 * Function:
 *     _field_group_qualifiers_free
 * Purpose:
 *     Free group qualifiers array.
 * Parameters:
 *     fg   - (IN) Field group structure.
 *     idx  - (IN) Entry part.
 * Returns:
 *     void
 * Note:
 */
int
_bcm_field_group_qualifiers_free(_field_group_t *fg, int idx)
{
    _bcm_field_group_qual_t *q_arr;       /* Qualifiers array.        */
    int entry_type;    /* holds type(L3/FcoE/L2) of an entry in a group. */

    /* Input parameters check. */
    if ((NULL == fg) || (idx < 0) || (idx >= _FP_MAX_ENTRY_WIDTH)) {
        return BCM_E_PARAM;
    }

    for (entry_type = 0; entry_type < _FP_MAX_ENTRY_TYPES; entry_type++) {
        q_arr = &(fg->qual_arr[entry_type][idx]);

        /* Free qualifiers arrays. */
        if (NULL != q_arr->qid_arr) {
            sal_free(q_arr->qid_arr);
            q_arr->qid_arr = NULL;
        }
        if (NULL != q_arr->offset_arr) {
            sal_free(q_arr->offset_arr);
            q_arr->offset_arr = NULL;
        }
        /* Reset arrays size. */
        q_arr->size = 0;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _bcm_field_group_default_entry_set
 * Purpose:
 *  Set or Clear default entry status of a entry.
 * Parameters:
 *  unit    - (IN) BCM Device Number.
 *  group   - (IN) Field Group ID.
 *  entry   - (IN) Field Entry ID.
 *  enable  - (IN) Enable Flag.
 * Returns:
 *  BCM_E_XXX
 * Note:
 *  Currently it is applicable only for exact
 *  match stage.
 */
int
_bcm_field_group_default_entry_set(int unit, bcm_field_group_t group,
                                   bcm_field_entry_t entry, int enable)
{
    int rv = BCM_E_NONE;         /* Operation return status.         */
    int idx = 0;                 /* Entry index                      */
    _field_group_t *fg = NULL;   /* Field group structure.           */
    _field_entry_t *f_ent = NULL;/* Field entry pointer.             */
    _field_entry_t *f_ent_tmp = NULL;
                                 /* Field entry temp pointer.        */
    _field_entry_stat_t *f_ent_st = NULL;
                                 /* Field entry statistics structure.*/
    _field_entry_policer_t *f_ent_pl = NULL;
                                 /* Field entry policer structure.   */
    _field_action_t *fa = NULL;  /* Field action descriptor.         */
    int level = 0;               /* Field policer Level.             */
    int parts_cnt = 0;           /* Field Entry parts count.         */

    /* First validate if provided group and entry id exist. */
    BCM_IF_ERROR_RETURN(_field_group_get(unit, group, &fg));
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                                         _FP_ENTRY_PRIMARY, &f_ent));

    /* Check enable flag value. */
    if ((enable < 0) && (enable > 1)) {
        LOG_ERROR(BSL_LS_BCM_FP,
           (BSL_META_U(unit,
            "FP(unit %d) Error: enable flag value %d not valid.\n"),
            unit, enable));
        return (BCM_E_PARAM);
    }

    /* Check if entry belongs to same group provided. */
    if (f_ent->group->gid != group) {
        LOG_ERROR(BSL_LS_BCM_FP,
           (BSL_META_U(unit,
            "FP(unit %d) Error: entry=(%d) does not belong to group %d.\n"),
            unit, entry, group));
        return (BCM_E_CONFIG);
    }

    /* Check if Group belongs to exact match stage. */
    if (fg->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) {
        LOG_ERROR(BSL_LS_BCM_FP,
           (BSL_META_U(unit,
            "FP(unit %d) Error: group=(%d) stage is not exact match.\n"),
            unit, group));
        return (BCM_E_CONFIG);
    }

    /* Get Field Entry Parts. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                                                          fg->stage_id,
                                                          fg->flags,
                                                          &parts_cnt));

    /* Check existing set or clear status for entry default status flag. */
    if (enable) {
        if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
            return (BCM_E_NONE);
        }
    } else {
        if (!(f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT)) {
            return (BCM_E_NONE);
        }
    }

    /* Check group default entry status for set and clear. */
    if (enable) {
        for (idx = 0; idx < fg->group_status.entry_count; idx++) {
            f_ent_tmp = fg->entry_arr[idx];
            if (f_ent_tmp->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
                LOG_ERROR(BSL_LS_BCM_FP,
                   (BSL_META_U(unit,
                    "FP(unit %d) Error: group=(%d) already have existing"
                    "default entry %d.\n"),
                    unit, group, f_ent_tmp->eid));
                return (BCM_E_CONFIG);
            }
        }
    }

    /* Check if entry is installed. */
    if (f_ent->flags & _FP_ENTRY_INSTALLED) {
        LOG_ERROR(BSL_LS_BCM_FP,
           (BSL_META_U(unit,
            "FP(unit %d) Error: entry=(%d) is installed, "
            "cannot change default status.\n"),
             unit, entry));
        return (BCM_E_CONFIG);
    }

    /* Check if group have qualifier associated to it. */
    for(idx = 0; idx < parts_cnt; idx++) {
        f_ent_tmp = f_ent + idx;

        /* Check if any action is attached to entry. */
        fa = f_ent_tmp->actions;
        if (fa != NULL) {
            LOG_ERROR(BSL_LS_BCM_FP,
               (BSL_META_U(unit,
                "FP(unit %d) Error: entry=(%d) have action associated, "
                "cannot change default status.\n"),
                 unit, entry));
            return (BCM_E_CONFIG);
        }

        /* Check if valid stat is attached. */
        f_ent_st = &f_ent_tmp->statistic;
        if (f_ent_st->flags & _FP_ENTRY_STAT_VALID) {
            LOG_ERROR(BSL_LS_BCM_FP,
               (BSL_META_U(unit,
                "FP(unit %d) Error: entry=(%d) have stats attached to it, "
                "cannot change default status.\n"),
                unit, entry));
            return (BCM_E_CONFIG);
        }

        /* Check if valid policer is attached. */
        for (level = 0; level < _FP_POLICER_LEVEL_COUNT; level++) {
            f_ent_pl = f_ent_tmp->policer + level;
            if (f_ent_pl->flags & _FP_POLICER_VALID) {
                LOG_ERROR(BSL_LS_BCM_FP,
                   (BSL_META_U(unit,
                    "FP(unit %d) Error: entry=(%d) have policer attached to "
                    "it, cannot change default status.\n"),
                     unit, entry));
                return (BCM_E_CONFIG);
            }
        }
    }

    /* Configure entry as default. */
    if (enable) {
        /* Clear qualifier if any. */
        BCM_IF_ERROR_RETURN(bcm_esw_field_qualify_clear(unit, entry));
        f_ent->flags |= _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT;
    } else {
        f_ent->flags &= ~_FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT;
    }

    return (rv);
}

/*
 * Function:
 *  _bcm_field_group_default_entry_get
 * Purpose:
 *  Get Default Field entry ID associated to group.
 * Parameters:
 *  unit    - (IN) BCM Device Number.
 *  group   - (IN) Field Group ID.
 *  entry   - (OUT) Field Entry ID.
 * Returns:
 *  BCM_E_XXX
 * Note:
 */
int
_bcm_field_group_default_entry_get(int unit, bcm_field_group_t group,
                                            bcm_field_entry_t *entry)
{
    int rv = BCM_E_NONE;           /* Operation return status.    */
    _field_group_t *fg = NULL;     /* Field group structure.      */
    _field_entry_t *f_ent = NULL;  /* Field entry pointer.        */
    int found = 0;                 /* Entry Found Variable.       */
    int idx = 0;                   /* Entry index                 */

    /* Input Parameter Check. */
    if (entry == NULL) {
        return (BCM_E_PARAM);
    }

    /* First validate if provided group and entry id exist. */
    BCM_IF_ERROR_RETURN(_field_group_get(unit, group, &fg));

    /* Check if Group belongs to exact match stage. */
    if (fg->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) {
        LOG_ERROR(BSL_LS_BCM_FP,
           (BSL_META_U(unit,
            "FP(unit %d) Error: group=(%d) stage is not exact match.\n"),
             unit, group));
        return (BCM_E_PARAM);
    }

    /* Search for all entries in group. */
    for (idx = 0; idx < fg->group_status.entry_count; idx++) {
        f_ent = fg->entry_arr[idx];
        if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
            found = 1;
            break;
        }
    }

    /* Return entry id if found. */
    if (found) {
        *entry = f_ent->eid;
    } else {
        rv = BCM_E_NOT_FOUND;
    }

    return (rv);
}

/*
 * Function:
 *     _bcm_field_qual_list_append
 * Purpose:
 *     Append a copy of a qualify info linked list.
 * Parameters:
 *     fg         - (IN) Field group structure.
 *     entry_part - (IN) Field entry part.
 *     fq_src     - (IN) Copy source list.
 *     offset     - (IN) Offset within FPFx field.
 * Returns:
 *     BCM_E_NONE
 * Note:
 */
int
_bcm_field_qual_list_append(_field_group_t *fg, uint8 entry_part,
                            _qual_info_t *fq_src, int offset)
{
    _bcm_field_qual_offset_t *q_offset_arr;  /* Qualifier offsets array. */
    _bcm_field_group_qual_t  *q_arr;         /* Qualifiers array.        */
    _qual_info_t *fq_src_iter;               /* Qualifier list iterator. */
    uint16 *qid_arr;                         /* Qualifier id array.      */
    int    size;                             /* Qualifiers array size.   */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == fq_src) ||
        (entry_part >= _FP_MAX_ENTRY_WIDTH)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    qid_arr = NULL;
    q_offset_arr = NULL;
    q_arr = &(fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][entry_part]);

    /* Count number of group qualifiers. */
    fq_src_iter = fq_src;
    size = 0;

    while (NULL != fq_src_iter) {
        if (0 == BCM_FIELD_QSET_TEST(fg->qset, fq_src_iter->qid)) {
            fq_src_iter = fq_src_iter->next;
            continue;
        }
        size++;
        fq_src_iter = fq_src_iter->next;
    }

    if (0 == size) {
        return (BCM_E_NONE);
    }

    size += q_arr->size;

    /* Allocate qualifiers id and offsets array. */
    _FP_XGS3_ALLOC(qid_arr, size * sizeof (uint16), "Group qual id");
    if (NULL == qid_arr) {
        return (BCM_E_MEMORY);
    }

    _FP_XGS3_ALLOC(q_offset_arr, size * sizeof (_bcm_field_qual_offset_t),
                   "Group qual offset");
    if (NULL == q_offset_arr) {
        sal_free (qid_arr);
        return (BCM_E_MEMORY);
    }

    /* Copy original qualifiers array if any. */
    if (q_arr->size) {
        sal_memcpy(qid_arr, q_arr->qid_arr, q_arr->size * sizeof (uint16));
        sal_memcpy(q_offset_arr, q_arr->offset_arr, q_arr->size * sizeof (_bcm_field_qual_offset_t));
        sal_free (q_arr->qid_arr);
        sal_free (q_arr->offset_arr);
    }

    /* Copy qualifiers id and offsets. */
    q_arr->qid_arr = qid_arr;
    q_arr->offset_arr = q_offset_arr;
    fq_src_iter = fq_src;
    while (NULL != fq_src_iter) {
        if (0 == BCM_FIELD_QSET_TEST(fg->qset, fq_src_iter->qid)) {
            fq_src_iter = fq_src_iter->next;
            continue;
        }
        q_arr->qid_arr[q_arr->size] = fq_src_iter->qid;
        q_arr->offset_arr[q_arr->size].offset[0] = fq_src_iter->offset + offset;
        q_arr->offset_arr[q_arr->size].width[0] = fq_src_iter->width;
        q_arr->offset_arr[q_arr->size].field = fq_src_iter->fpf;
        q_arr->size++;
        fq_src_iter = fq_src_iter->next;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_tcam_memory_info_get
 * Purpose:
 *     Get TCAM memory and field names for specific entry.
 * Parameters:
 *     unit  - (IN)  BCM device number.
 *     f_ent - (IN)  Field entry.
 *     tcam  - (OUT) TCAM memory info.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entry_tcam_memory_info_get(int unit, _field_entry_t *f_ent,
    _field_tcam_mem_info_t *tcam, int ipbm_overlay)
{

    /* Input parameters check. */
    if ((NULL == f_ent)  || (NULL == tcam)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_FIREBOLT_SUPPORT)

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
           if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                tcam->key_field = (SOC_IS_HURRICANE2(unit) ||
                    SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                    SOC_IS_GREYHOUND2(unit)) ?
                    DATA_KEYf : DATAf;
                tcam->mask_field = DATA_MASKf;
                tcam->memory = FP_TCAMm;
           } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
                tcam->memory = EFP_TCAMm;
                tcam->key_field = KEYf;
                tcam->mask_field = KEY_MASKf;
            } else if (_BCM_FIELD_STAGE_LOOKUP== f_ent->group->stage_id) {
                tcam->memory = VFP_TCAMm;
                tcam->key_field = KEYf;
                tcam->mask_field = MASKf;
            }

        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_GREYHOUND_SUPPORT */

    if (SOC_IS_FBX(unit)) {
        if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
            tcam->memory = FP_TCAMm;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TD_TT(unit))
            {
                tcam->key_field = KEYf;
                tcam->mask_field = MASKf;

                if (ipbm_overlay)
                {
                    tcam->memory = FP_GM_FIELDSm;
                }
            } else if ((SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_KATANAX(unit))
                    && ipbm_overlay) {
                tcam->key_field = IPBMf;
                tcam->mask_field = IPBM_MASKf;
                tcam->memory = FP_GLOBAL_MASK_TCAMm;
            } else if ((SOC_IS_TRX(unit)) ||
                    (f_ent->flags & _FP_ENTRY_SECOND_HALF)) {
                tcam->key_field = DATAf;
                tcam->mask_field = DATA_MASKf;
            } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
            {
                tcam->key_field = KEYf;
                tcam->mask_field = MASKf;
            }
        }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_stage)) {
            if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
                tcam->memory = EFP_TCAMm;
                tcam->key_field = KEYf;
                tcam->mask_field = KEY_MASKf;
            } else if (_BCM_FIELD_STAGE_LOOKUP== f_ent->group->stage_id) {
                tcam->memory = VFP_TCAMm;
                tcam->key_field = KEYf;
                tcam->mask_field = MASKf;
            }
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    }
#endif /* BCM_FIREBOLT_SUPPORT */
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_qual_tcam_key_mask_free
 * Purpose:
 *     Free tcam key/mask buffers.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     f_ent - (IN/OUT) Field entry.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_tcam_key_mask_free(int unit, _field_entry_t *f_ent)
{
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if (NULL != f_ent->tcam.key) {
        sal_free(f_ent->tcam.key);
        f_ent->tcam.key = NULL;
    }
    if (NULL != f_ent->tcam.mask) {
        sal_free(f_ent->tcam.mask);
        f_ent->tcam.mask = NULL;
    }
    if (NULL != f_ent->tcam.key_hw) {
        sal_free(f_ent->tcam.key_hw);
        f_ent->tcam.key_hw = NULL;
    }
    if (NULL != f_ent->tcam.mask_hw) {
        sal_free(f_ent->tcam.mask_hw);
        f_ent->tcam.mask_hw = NULL;
    }
    if (NULL != f_ent->key_match_tcam.key) {
        sal_free(f_ent->key_match_tcam.key);
        f_ent->key_match_tcam.key = NULL;
    }
    if (NULL != f_ent->key_match_tcam.mask) {
        sal_free(f_ent->key_match_tcam.mask);
        f_ent->key_match_tcam.mask = NULL;
    }
    if (NULL != f_ent->key_match_tcam.key_hw) {
        sal_free(f_ent->key_match_tcam.key_hw);
        f_ent->key_match_tcam.key_hw = NULL;
    }
    if (NULL != f_ent->key_match_tcam.mask_hw) {
        sal_free(f_ent->key_match_tcam.mask_hw);
        f_ent->key_match_tcam.mask_hw = NULL;
    }
    if (NULL != f_ent->extra_tcam.key) {
        sal_free(f_ent->extra_tcam.key);
        f_ent->extra_tcam.key = NULL;
    }
    if (NULL != f_ent->extra_tcam.mask) {
        sal_free(f_ent->extra_tcam.mask);
        f_ent->extra_tcam.mask = NULL;
    }
    if (NULL != f_ent->extra_tcam.key_hw) {
        sal_free(f_ent->extra_tcam.key_hw);
        f_ent->extra_tcam.key_hw = NULL;
    }
    if (NULL != f_ent->extra_tcam.mask_hw) {
        sal_free(f_ent->extra_tcam.mask_hw);
        f_ent->extra_tcam.mask_hw = NULL;
    }
    return (BCM_E_NONE);
}

int _field_qual_tcam_key_mask_get(int unit, _field_entry_t *f_ent,
    _field_tcam_t *tcam, int ipbm_overlay)
{
    uint32 tcam_entry[SOC_MAX_MEM_FIELD_WORDS];
    _field_tcam_mem_info_t tcam_info = { 0 };
    int tcam_idx;
    int rv;
    int key_size;

    /* Get TCAM memory and Fields information. */

    BCM_IF_ERROR_RETURN(_field_entry_tcam_memory_info_get(unit, f_ent,
        &tcam_info, ipbm_overlay));

    if (!SOC_MEM_FIELD_VALID(unit, tcam_info.memory, tcam_info.key_field)) {
        return (BCM_E_INTERNAL);
    }
    /* Key size in bits. */
    key_size = soc_mem_field_length(unit, tcam_info.memory,
        tcam_info.key_field);
    /* Convert to bytes - full number of words alligned. */
    key_size = (((key_size >> 5) + 1) << 2);


    /* Allocate and zero memory for tcam image.*/
    tcam->key  = sal_alloc(key_size, "field_entry_tcam_key");
    tcam->mask = sal_alloc(key_size, "field_entry_tcam_mask");
    if ((NULL == tcam->key) || (NULL == tcam->mask)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                "FP(unit %d) Error: allocation failure for field_entry tcam\n"),
                 unit));
        if (tcam->key) sal_free(tcam->key);
        if (tcam->mask) sal_free(tcam->mask);
        return (BCM_E_MEMORY);
    }
    sal_memset(tcam->key, 0, key_size);
    sal_memset(tcam->mask, 0, key_size);
    tcam->key_size = key_size;

    /* Read entry from HW if it was installed previously. */
    if(f_ent->flags & _FP_ENTRY_INSTALLED) {
        rv = _bcm_field_entry_tcam_idx_get(unit, f_ent, &tcam_idx);
        if (BCM_FAILURE(rv)) {
            if (tcam->key) sal_free(tcam->key);
            if (tcam->mask) sal_free(tcam->mask);
            tcam->mask = tcam->key = NULL;
            return (rv);
        }
        rv = soc_mem_read(unit, tcam_info.memory, MEM_BLOCK_ANY,
                          tcam_idx, tcam_entry);
        if (BCM_FAILURE(rv)) {
            if (tcam->key) sal_free(tcam->key);
            if (tcam->mask) sal_free(tcam->mask);
            tcam->mask = tcam->key = NULL;
            return (rv);
        }
        soc_mem_field_get(unit, tcam_info.memory, tcam_entry,
                          tcam_info.key_field, tcam->key);
        soc_mem_field_get(unit, tcam_info.memory, tcam_entry,
                          tcam_info.mask_field, tcam->mask);
        if (SOC_MEM_FIELD_VALID(unit, tcam_info.memory, F4f)) {
            soc_mem_field_get(unit, tcam_info.memory, tcam_entry,
                              F4f, &tcam->f4);
            soc_mem_field_get(unit, tcam_info.memory, tcam_entry,
                              F4_MASKf, &tcam->f4_mask);
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_qual_tcam_key_mask_get
 * Purpose:
 *     Allocate & read from hw tcam key/mask image.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     f_ent - (IN/OUT) Field entry.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_tcam_key_mask_get(int unit, _field_entry_t *f_ent)
{
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if (f_ent->flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
        if (NULL == f_ent->extra_tcam.key) {
            BCM_IF_ERROR_RETURN(_field_qual_tcam_key_mask_get(unit, f_ent,
                &f_ent->extra_tcam, 1));
        }
    }

    /* Check if tcam info already present. */
    if (NULL != f_ent->tcam.key) {
        return (BCM_E_NONE);
    }

    if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->fs->stage_id) {
#if defined(BCM_TRIUMPH_SUPPORT)
        if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
            return _bcm_field_tr_external_tcam_key_mask_get(unit, f_ent);
        }
#endif /* BCM_TRIUMPH_SUPPORT */
    }

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
       if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
           ((_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id) ||
            (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id) ||
            (_BCM_FIELD_STAGE_EGRESS == f_ent->fs->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->fs->stage_id))) {
          BCM_IF_ERROR_RETURN
            (_bcm_field_th_qual_tcam_key_mask_get(unit, f_ent, &f_ent->tcam));
          /* EFP has 2 types of keys for each entry. 1. tcam will have
           * all the qualifiers i.e., default qset. 2. key_match_tcam is
           * a subset of default qset having only Not L3 and Not FCoE quals */
          if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
             if (NULL != f_ent->key_match_tcam.key) {
                return (BCM_E_NONE);
             }
             /* if key_match_tcam is Null, Allocate memory for it */
             BCM_IF_ERROR_RETURN
                (_bcm_field_th_qual_tcam_key_mask_get(unit, f_ent,
                                          &f_ent->key_match_tcam));

             /* At the time of entry install, both tcam and key_match_tcam
              * are freed. if entry is already installed, one key will be
              * updated from the h/w tcam, and the other key will be updated
              * in the below function depending on efp_key_match_type value*/
             if (f_ent->flags & _FP_ENTRY_INSTALLED) {
                  if(!(f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE
                       && f_ent->flags & _FP_ENTRY_PRIMARY)) {
                      return (bcm_field_efp_update_alternate_key_mask(unit, f_ent,
                                                f_ent->efp_key_match_type));
                  }
             }
             return (BCM_E_NONE);
          }

       } else
#endif /* BCM_TOMAHAWK_SUPPORT */
       {
          BCM_IF_ERROR_RETURN
              (_bcm_field_td2_qual_tcam_key_mask_get(unit, f_ent,
                                                     &f_ent->tcam));
       }

       if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
          if (NULL != f_ent->key_match_tcam.key) {
              return (BCM_E_NONE);
          }
          BCM_IF_ERROR_RETURN
           (_bcm_field_td2_qual_tcam_key_mask_get(unit, f_ent, &f_ent->key_match_tcam));

          if (f_ent->flags & _FP_ENTRY_INSTALLED) {
              if(!(f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE
                   && f_ent->flags & _FP_ENTRY_PRIMARY)) {
                  return (bcm_field_efp_update_alternate_key_mask(unit, f_ent,
                                            f_ent->efp_key_match_type));
              }
          }
          return (BCM_E_NONE);
       } else {
          return (BCM_E_NONE);
       }
    } else
#endif

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_qual_tcam_key_mask_get(unit, f_ent, &f_ent->tcam));
    }
#endif

#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        return (_bcm_field_kt2_qual_tcam_key_mask_get(unit, f_ent, &f_ent->tcam));
    }
#endif


    BCM_IF_ERROR_RETURN(_field_qual_tcam_key_mask_get(unit, f_ent,
                        &f_ent->tcam, 0));

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_qual_value_set
 *
 * Purpose:
 *     Set a qualifier field from the designated data and mask arrays.
 *
 * Parameters:
 *     unit    - (IN) BCM devices number
 *     qi      - (IN) Qualifier offset inside tcam.
 *     f_ent   - (IN) Field entry descriptor.
 *     p_data  - (IN) Inserted data.
 *     p_mask  - (IN) Data mask.
 *     ipbm_overlay - (IN) Flag to indicate extra_tcam has to be used or not
 *     key_match_tcam - (IN) Flag to indicate which tcam to use
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_qual_value_set(int unit, _qual_info_t *qi,
                      _field_entry_t *f_ent,
                      uint32 *p_data, uint32 *p_mask,
                      int ipbm_overlay, uint8 key_match_tcam)
{
    uint32              u32_mask, *p_fn_data, *p_fn_mask;
    int                 idx, wp, bp, len;

#define DATA_TOO_BIG_FOR_FIELD ((p_data[idx] & ~u32_mask) != 0)
    wp = qi->offset / 32;
    bp = qi->offset & (32 - 1);
    idx = 0;
    p_fn_data = p_fn_mask = NULL;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
              "FP(unit %d) vverb: qi={offset=%d, width=%d}, ipbm_overlay=%d, data=0x%08x, mask=0x%08x\n"),
               unit, qi->offset, qi->width, ipbm_overlay, *p_data, *p_mask));

    BCM_IF_ERROR_RETURN(_bcm_field_qual_tcam_key_mask_get(unit, f_ent));

    switch (qi->fpf) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
      case DATAf:
      case DATA_KEYf:
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
      case KEYf:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
          if (ipbm_overlay) {
              p_fn_data = f_ent->extra_tcam.key;
              p_fn_mask = f_ent->extra_tcam.mask;
          } else
#endif /* BCM_TRIDENT_SUPPORT */
          if (key_match_tcam) {
              p_fn_data = f_ent->key_match_tcam.key;
              p_fn_mask = f_ent->key_match_tcam.mask;
          } else {
              p_fn_data = f_ent->tcam.key;
              p_fn_mask = f_ent->tcam.mask;
          }

          break;
#ifdef BCM_FIREBOLT_SUPPORT
      case F4f:
          p_fn_data = &f_ent->tcam.f4;
          /* coverity[ptr_arith : FALSE] */
          p_fn_mask = &f_ent->tcam.f4_mask;
          break;
#endif /* BCM_FIREBOLT_SUPPORT */
      default:
          LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Bad TCAM field=%#05x\n"),
                     unit, qi->fpf));
          return (BCM_E_INTERNAL);
    };

    for (len = qi->width; len > 0; len -= 32) {
        if (bp) {
            if (len < 32) {
                u32_mask = (1 << len) - 1;
                /* Chop mask to fit mask field. */
                p_mask[idx] &= u32_mask;
                if (DATA_TOO_BIG_FOR_FIELD) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "FP(unit %d) Error: data=%#x "),
                               unit, *p_data));
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "or mask=%#x too big for field\n"),
                               *p_mask));
                    return (BCM_E_PARAM);
                }
            } else {
                u32_mask = 0xffffffff;
            }

            p_fn_data[wp] &= ~(u32_mask << bp);
            p_fn_data[wp] |= p_data[idx] << bp;
            /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[ptr_arith : FALSE] */

            p_fn_mask[wp] &= ~(u32_mask << bp);
            p_fn_mask[wp++] |= p_mask[idx] << bp;

            p_fn_data[wp] &= ~(u32_mask >> (32 - bp));
            p_fn_data[wp] |= p_data[idx] >> (32 - bp) & ((1 << bp) - 1);

            p_fn_mask[wp] &= ~(u32_mask >> (32 - bp));
            p_fn_mask[wp] |= p_mask[idx] >> (32 - bp) & ((1 << bp) - 1);
        } else {
            if (len < 32) {
                u32_mask = (1 << len) - 1;
                /* Chop mask to fit mask field. */
                p_mask[idx] &= u32_mask;
                if (DATA_TOO_BIG_FOR_FIELD) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "FP(unit %d) Error: data=%#x or mask=%#x "
                                           "too big for field\n"),
                               unit, *p_data, *p_mask));
                    return (BCM_E_PARAM);
                }
                p_fn_data[wp] &= ~u32_mask;
                p_fn_data[wp] |= p_data[idx];
                /* coverity[ptr_arith : FALSE] */
                p_fn_mask[wp] &= ~u32_mask;
                p_fn_mask[wp++] |= p_mask[idx];
            } else {
                p_fn_data[wp] = p_data[idx];
                /* coverity[ptr_arith : FALSE] */
                p_fn_mask[wp++] = p_mask[idx];
            }
        }

        idx++;
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;
    f_ent->flags &= ~(_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY);

    return (BCM_E_NONE);
}
#undef DATA_TOO_BIG_FOR_FIELD

/*
 * Function:
 *     _field_qual_value_get
 *
 * Purpose:
 *     Retrieve a qualifier value from the designated data/mask
 *     field pair, returning them to *p_data and *p_mask.
 *
 * Returns:
 *     BCM_E_NONE - Success
 */
STATIC int
_field_qual_value_get(int unit, _qual_info_t *qi, _field_entry_t *f_ent,
                      uint32 *p_data, uint32 *p_mask, int ipbm_overlay)
{
    uint32              *p_fn_data, *p_fn_mask;
    int                 idx, wp, bp, len;

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == p_data) ||
        (NULL == qi) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    wp = qi->offset / 32;
    bp = qi->offset & (32 - 1);
    idx = 0;
    p_fn_data = p_fn_mask = NULL;

    BCM_IF_ERROR_RETURN(_bcm_field_qual_tcam_key_mask_get(unit, f_ent));

    switch (qi->fpf) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        case DATAf:
        case DATA_KEYf:
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        case KEYf:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
            if (ipbm_overlay) {
                p_fn_data = f_ent->extra_tcam.key;
                p_fn_mask = f_ent->extra_tcam.mask;
            } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TD2_TT2(unit) &&
                ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) &&
                (f_ent->efp_key_match_type)) {
                p_fn_data = f_ent->key_match_tcam.key;
                p_fn_mask = f_ent->key_match_tcam.mask;
            } else
#endif
            {
                p_fn_data = f_ent->tcam.key;
                p_fn_mask = f_ent->tcam.mask;
            }
            break;
#ifdef BCM_FIREBOLT_SUPPORT
        case F4f:
            p_fn_data = &f_ent->tcam.f4;
            p_fn_mask = &f_ent->tcam.f4_mask;
            break;
#endif /* BCM_FIREBOLT_SUPPORT */
        default:
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: Bad TCAM field=%#05x\n"),
                       unit, qi->fpf));
            return (BCM_E_INTERNAL);
    };

    for (len = qi->width; len > 0; len -= 32) {
        if ((NULL == p_fn_data) || (NULL == p_fn_mask)) {
            /*
             * IPBM Overlay qualifier set in the group but
             * not qualified for this entry.
             */
            p_data[idx] = 0x0;
            p_mask[idx] = 0x0;
        } else {
            if (bp) {
                p_data[idx] = (p_fn_data[wp] >> bp) & ((1 << (32 - bp)) - 1);
                /* coverity[ptr_arith : FALSE] */
                p_mask[idx] = (p_fn_mask[wp++] >> bp) & ((1 << (32 - bp)) - 1);
                p_data[idx] |= p_fn_data[wp] << (32 - bp);
                p_mask[idx] |= p_fn_mask[wp] << (32 - bp);
            } else {
                p_data[idx] = p_fn_data[wp];
                /* coverity[ptr_arith : FALSE] */
                p_mask[idx] = p_fn_mask[wp++];
            }
        }

        if (len < 32) {
            p_data[idx] &= ((1 << len) - 1);
            p_mask[idx] &= ((1 << len) - 1);
        }

        idx++;
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_qual_partial_data_get
 * Purpose:
 *     Get a portion of a uint32 array
 * Parameters:
 *     in_data   - uint32 array
 *     start_pos - starting bit postion in above array requested (base-0)
 *     len       - length of data requested (in bits)
 *     out_data  - uint32 array of in_data from start_pos to start_pos + len
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     - Calculate the word in in_data where start_pos occurs
 *     - Calculate the bit position in above word where start_pos occurs
 *     - Iterate:
 *         - Get upper half of word (from bit position to end of word)
 *         - Get remainder portion from next word
 *             - If required: bit postion not 0 (start_pos not a multiple of 32)
 *             - If present
 *         - These two together form one word of out_data
 *         - Go to next word.
 *     - Mask the higher (extra) bits in last word of out_data
 *
 *     - max_size is set to 16 (128 bits) as this is used for Ip6 and DstMac
 *     - max_size is increased to 144 bits as this is used for bcmFieldQualifyL2PayLoad
 */
int
_bcm_field_qual_partial_data_get(uint32 *in_data, uint8 start_pos,
                                      uint8 len, uint32 *out_data)
{
    int current_word, bit_pos, result_word;
    int i;
    int max_size = 16;

    /* Input parameters check. */
    if ((NULL == in_data) || (NULL == out_data) ||
        ((start_pos + len) > 256)) {
        return (BCM_E_UNAVAIL);
    }

    current_word = start_pos / 32;
    bit_pos = start_pos - current_word * 32;

    sal_memset(out_data, 0, max_size);

    for (i = 0, result_word = 0; i < len;
         i += 32, current_word++, result_word++) {

        out_data[result_word] = in_data[current_word] >> bit_pos;

        if ((bit_pos != 0) && ((bit_pos + (len - i)) > 32)) {
            out_data[result_word] |= (in_data[current_word + 1] << (32 - bit_pos));
        }
    }
    /* This check may be redundant as -1 = 0xffffffff */
    if (i != len) {
        i -= 32;
        out_data[result_word - 1] &= ((1 << (len - i)) - 1);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_qual_partial_data_set
 * Purpose:
 *     Set a portion of a uint32 array
 * Parameters:
 *     in_data   - uint32 array
 *     start_pos - starting bit postion in above array requested (base-0)
 *     len       - length of data requested (in bits)
 *     out_data  - uint32 array of in_data from start_pos to start_pos + len
 * Returns:
 *     none
 * Notes:
 *     - Calculate the word in out_data where start_pos occurs
 *     - Calculate the bit position in above word where start_pos occurs
 *     - Iterate:
 *         - Or upper half of word (from bit position to end of word)
 *         - Set remainder portion to the next word
 *             - If required: bit postion not 0 (start_pos not a multiple of 32)
 *             - If present
 *         - These two together form one word of out_data
 *         - Go to next word.
 *     - Mask the higher (extra) bits in last word of out_data
 *
 *     - max_size is set to 16 (128 bits) as this is used for Ip6 and DstMac
 *     - max_size is increased to 144 bits as this is used for bcmFieldQualifyL2PayLoad
 *
 * NOTES
 * 1. Assumes that there are no extra bits in in_data, i.e. all of in_data is
 *    copied.
 * 2. Assumes that out_data has been zeroed-out.
 */
int
_bcm_field_qual_partial_data_set(uint32 *in_data, uint8 start_pos,
                                 uint8 len, uint32 *out_data)
{
    int current_word, bit_pos, result_word;
    int i;

    /* Input parameters check. */
    if ((NULL == in_data) || (NULL == out_data) ||
        ((start_pos + len) > 256)) {
        return (BCM_E_UNAVAIL);
    }

    result_word = start_pos / 32;
    bit_pos = start_pos - result_word * 32;

    for (i = 0, current_word= 0; i < len;
         i += 32, current_word++, result_word++) {

        out_data[result_word] |= (in_data[current_word] <<  bit_pos);

        if ((bit_pos != 0) && ((bit_pos + (len - i)) > 32)) {
            out_data[result_word + 1] |= (in_data[current_word] >> (32 - bit_pos));
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qual_part_value_get
 *
 * Purpose:
 *     Get a qualifier field from the designated data and mask arrays.
 *
 * Parameters:
 *     unit       - (IN) BCM devices number
 *     q_offset   - (IN) Qualifier offset inside tcam.
 *     f_ent      - (IN) Field entry descriptor.
 *     p_data     - (IN) Inserted data.
 *     p_mask     - (IN) Data mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_qual_part_value_get(int unit,
                           _bcm_field_qual_offset_t *q_offset,
                           uint8 qual_part,
                           _field_entry_t *f_ent,
                           _bcm_field_qual_data_t p_data,
                           _bcm_field_qual_data_t p_mask)
{
    _qual_info_t qi;
    int rv;
    _bcm_field_qual_data_t data;
    _bcm_field_qual_data_t mask;
    int offset = 0, idx = 0;
    int ipbm_overlay = 0;

    /* Input parameters check. */
    if ((NULL == q_offset) || (NULL == f_ent) ||
        (NULL == p_data) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    /* Primary offset handling. */
    sal_memset(&qi, 0, sizeof(_qual_info_t));

    _FP_QUAL_DATA_CLEAR(data);
    _FP_QUAL_DATA_CLEAR(mask);
    qi.fpf = q_offset->field;
    qi.offset = q_offset->offset[qual_part];
    qi.width = q_offset->width[qual_part];
    /* calculate offset */
    for (idx = 0; idx < qual_part; idx++) {
        offset += q_offset->width[idx];
    }

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    /*
     * 1. Check if the part goes into the IPBM TCAM.
     * 2. In slice Pairing mode, TCP control flag bits[5:0] are split between
     *    IFP_PAIRING_IPBM_F0:TCP_FN_5_1[5:1] and IFP_PAIRING_F1:TCP_FN_0[0]
     *    This special overlay case is handled here (1 == qual_part)...
     */
    if ((SOC_IS_TD_TT(unit) && q_offset->secondary &&
        ((qual_part == 0 && 1 != q_offset->width[0] && 5 != q_offset->width[1]) ||
        (1 == qual_part && 1 == q_offset->width[0] && 5 == q_offset->width[1])))
        || ((SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_KATANAX(unit))
             && q_offset->secondary)) {
        ipbm_overlay = 1;
    }
#endif

    /* Read qualifier information from tcam.. */
    rv = _field_qual_value_get(unit, &qi, f_ent, data, mask, ipbm_overlay);
    BCM_IF_ERROR_RETURN(rv);

    /* Split primary portion of the qualifier. */
    rv = _bcm_field_qual_partial_data_set(data, offset,
                                          qi.width, p_data);
    BCM_IF_ERROR_RETURN(rv);
    rv = _bcm_field_qual_partial_data_set(mask, offset,
                                          qi.width, p_mask);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_qual_value_get
 *
 * Purpose:
 *     Get a qualifier field from the designated data and mask arrays.
 *
 * Parameters:
 *     unit     - (IN) BCM devices number
 *     q_offset - (IN) Qualifier offset inside tcam.
 *     f_ent    - (IN) Field entry descriptor.
 *     p_data   - (IN) Inserted data.
 *     p_mask   - (IN) Data mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_value_get(int unit, _bcm_field_qual_offset_t *q_offset,
                          _field_entry_t *f_ent, _bcm_field_qual_data_t p_data,
                          _bcm_field_qual_data_t p_mask)
{
    int rv, qual_part;

    /* Input parameters check. */
    if ((NULL == q_offset) || (NULL == f_ent) ||
        (NULL == p_data) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    _FP_QUAL_DATA_CLEAR(p_data);
    _FP_QUAL_DATA_CLEAR(p_mask);

    /* offset handling */
    for (qual_part = 0; qual_part < q_offset->num_offsets; qual_part++) {
        if (q_offset->width[qual_part] > 0)
        {
           rv = _field_qual_part_value_get(unit, q_offset, qual_part,
                                           f_ent, p_data, p_mask);
           BCM_IF_ERROR_RETURN(rv);
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qual_part_value_set
 *
 * Purpose:
 *     Set a qualifier field from the designated data and mask arrays.
 *
 * Parameters:
 *     unit      - (IN) BCM devices number
 *     q_offset  - (IN) Qualifier offset inside tcam.
 *     qual_part - (IN) Split qualifier part.
 *     f_ent     - (IN) Field entry descriptor.
 *     p_data    - (IN) Inserted data.
 *     p_mask    - (IN) Data mask.
 *     key_match_tcam - (IN) Flag to indicate which tcam to use
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qual_part_value_set(int unit, _bcm_field_qual_offset_t *q_offset,
                               uint8 qual_part, _field_entry_t *f_ent,
                           uint32 *p_data, uint32 *p_mask,
                           uint8 key_match_tcam)
{
    uint32 data[_FP_QUAL_DATA_WORDS];
    uint32 mask[_FP_QUAL_DATA_WORDS];
    _qual_info_t qi;
    int offset = 0;
    int ipbm_overlay = 0;
    int rv, idx;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qual_part_value_set\n")));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qual_part_value_set:data:%x mask:%x\n"),
               *p_data, *p_mask));

    /* Input parameters check. */
    if ((NULL == q_offset) || (NULL == f_ent) ||
        (NULL == p_data) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    /* Primary offset handling. */
    sal_memset(&qi, 0, sizeof(_qual_info_t));
    qi.fpf = q_offset->field;
    qi.offset = q_offset->offset[qual_part];
    qi.width = q_offset->width[qual_part];
    /* calculate offset */
    for (idx = 0; idx < qual_part; idx++) {
        offset += q_offset->width[idx];
    }

    /* Split primary portion of the qualifier. */
    rv = _bcm_field_qual_partial_data_get (p_data, offset,
                                           qi.width, data);
    BCM_IF_ERROR_RETURN(rv);
    rv = _bcm_field_qual_partial_data_get(p_mask, offset,
                                          qi.width, mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    /*
     * 1. Check if the part goes into the IPBM TCAM.
     * 2. In slice Pairing mode, TCP control flag bits[5:0] are split between
     *    IFP_PAIRING_IPBM_F0:TCP_FN_5_1[5:1] and IFP_PAIRING_F1:TCP_FN_0[0]
     *    This special overlay case is handled here (1 == qual_part)...
     */
    if ((((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
            && SOC_IS_TD_TT(unit) && q_offset->secondary &&
        ((qual_part == 0 && 1 != q_offset->width[0] && 5 != q_offset->width[1]) ||
        (1 == qual_part && 1 == q_offset->width[0] && 5 == q_offset->width[1])))
        || ((SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_KATANAX(unit))
             && q_offset->secondary)) {
        ipbm_overlay = 1;
    }
#endif

    /* Program qualifier into tcam.. */
    rv = _field_qual_value_set(unit, &qi, f_ent, data, mask,
                               ipbm_overlay, key_match_tcam);
    return (rv);
}

/*
 * Function:
 *     _field_entry_qualifier_key_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     q_data    - Qualifier data array.
 *     q_mask    - Qualifier mask array.
 * Returns:
 *     Nothing.
 */
int
_field_entry_qualifier_key_get(int unit,
                               bcm_field_entry_t entry,
                               int qual_id,
                               _bcm_field_qual_data_t q_data,
                               _bcm_field_qual_data_t q_mask)
{
    uint8                     entry_part;  /* Tcam part number.             */
    uint8                     entry_type;  /* Index to tcam entries of
                                              multiple types                */
    _bcm_field_qual_offset_t  *q_offset;   /* Qualifier offset in the tcam. */
    int                       qual_idx;    /* Tcam part qualifiers iterator.*/
    _field_entry_t            *f_ent;      /* Field entry structure.        */
    _bcm_field_group_qual_t   *q_arr;      /* Tcam part Qualifiers array.   */
    _field_group_t            *fg;         /* Field group structure.        */
    int                       rv;          /* Operation return status.      */
    int                       free_tcam;   /* Free tcam key flag.           */
    uint32                    width;       /* Offset width                  */

    _FP_QUAL_DATA_CLEAR(q_data);
    _FP_QUAL_DATA_CLEAR(q_mask);

    q_offset = NULL;
    free_tcam = FALSE;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       return _bcm_field_presel_qualifier_get(unit, entry, qual_id,
                                              q_data, q_mask);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */


    /* Get entry part that contains requested qualifier. */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);
    if (SOC_IS_TD2_TT2(unit) &&
        (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
        f_ent = NULL;
        rv = _bcm_field_efp_entry_qual_get(unit, entry, qual_id, &f_ent);
    } else
#endif
    {
        f_ent = NULL;
        rv = _bcm_field_entry_qual_get(unit, entry, qual_id, &f_ent);
    }
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       if ((fg->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
           (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
          return _bcm_field_th_entry_qualifier_key_get(unit, entry, qual_id,
                                                       q_data, q_mask);
       }
       if (fg->stage_id == _BCM_FIELD_STAGE_CLASS) {
          return _bcm_field_th_class_entry_qualifier_key_get(unit, entry,
                                                             qual_id,
                                                             q_data, q_mask);
       }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get entry tcam part number. */
    rv = _bcm_field_entry_flags_to_tcam_part (unit, f_ent->flags,
                                              fg, &entry_part);
    BCM_IF_ERROR_RETURN(rv);

    /*  Check if tcam data has to be freed at the end. */
    if (NULL == f_ent->tcam.key) {
        free_tcam = TRUE;
    }

    entry_type = _FP_ENTRY_TYPE_DEFAULT;

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) &&
        (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {

        if (f_ent->efp_key_match_type) {
            entry_type = _FP_ENTRY_TYPE_1;
        } else {
            entry_type = _FP_ENTRY_TYPE_0;
        }
    }
#endif
    /* Get entry part qualifiers array. */
    q_arr = &(fg->qual_arr[entry_type][entry_part]);

    /* Search array by qualifier id to extract qualifier offsets in the tcam. */
    for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
        if ((uint16)qual_id == q_arr->qid_arr[qual_idx]) {
            q_offset = q_arr->offset_arr + qual_idx;
            break;
        }
    }
    if (NULL == q_offset) {
        return (BCM_E_INTERNAL);
    }

    /* Read tcam data/mask. */
    rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* There is no value associated with zero width qualifiers (Stage, Ip4 etc)
     */
/* MERGE-CHANGE */
    _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, width);
    if (width > 0) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, q_data, q_mask);
    }

    if (free_tcam) {
        if (NULL != f_ent->tcam.key) {
            sal_free(f_ent->tcam.key);
            sal_free(f_ent->tcam.mask);
        }
        if (f_ent->flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
            if (NULL != f_ent->extra_tcam.key) {
                sal_free(f_ent->extra_tcam.key);
                sal_free(f_ent->extra_tcam.mask);
            }
        }
        f_ent->tcam.key = f_ent->tcam.mask =
            f_ent->extra_tcam.key = f_ent->extra_tcam.mask = NULL;

#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {

            if (NULL != f_ent->key_match_tcam.key) {
                sal_free(f_ent->key_match_tcam.key);
                sal_free(f_ent->key_match_tcam.mask);
            }
            f_ent->key_match_tcam.key = f_ent->key_match_tcam.mask = NULL;
        }
#endif
        free_tcam = FALSE;
    }
    return (rv);
}
/*
 * Function:
 *     _bcm_field_entry_qualifier_uint8_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     data      - Qualifier data.
 *     mask      - Qualifier mask.
 * Returns:
 *     Nothing.
 */
int
_bcm_field_entry_qualifier_uint8_get(int unit, bcm_field_entry_t entry,
                                 int qual_id, uint8 *data,
                                 uint8 *mask)
{
    _bcm_field_qual_data_t     q_data;/* Qualifier match data.     */
    _bcm_field_qual_data_t     q_mask;/* Qualifier match mask.     */
    int                        rv;    /* Operation return status.  */
#if defined(BCM_TRIUMPH3_SUPPORT)
    esm_l3_protocol_fn_entry_t  l3_proto_fn_entry;
    uint32                      ip_proto, index;
    int                         idx_end;
    _bcm_field_qual_offset_t    *q_offset;
    _field_entry_t              *f_ent;
#endif
   /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }


    FP_LOCK(unit);

    rv = _field_entry_qualifier_key_get(unit, entry, qual_id, q_data, q_mask);

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit) &&
            (qual_id == bcmFieldQualifyIpProtocol) &&
            BCM_SUCCESS(rv)) {

        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);

        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {

            rv = _bcm_field_entry_qual_get(unit, entry, qual_id, &f_ent);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }

            rv = _field_qual_offset_get(unit, f_ent, qual_id, &q_offset);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }

            if (((q_offset->offset[0] == 132) || (q_offset->offset[0] == 4)) &&
                    (q_offset->width[0] == 4)) {
                /* For EXT_IP4 EXT_L2IP4 and EXT_IP6S ACL, L3_PROTOCOL_FN value from
                   ESM_L3_PROTOCOL_FN table is treated as data to send it to
                   external TCAM as key
                 */
                idx_end = soc_mem_index_max(unit, ESM_L3_PROTOCOL_FNm);
                for (index = 0; index < idx_end + 1; index++) {
                    rv = soc_mem_read(unit, ESM_L3_PROTOCOL_FNm,
                            MEM_BLOCK_ANY, index, &l3_proto_fn_entry);
                    if (BCM_FAILURE(rv)) {
                        FP_UNLOCK(unit);
                        return rv;
                    }

                    ip_proto = soc_mem_field32_get(unit, ESM_L3_PROTOCOL_FNm, &l3_proto_fn_entry,
                            L3_PROTOCOL_FNf);
                    if (ip_proto == (q_data[0] & 0xf)) {
                        q_data[0] = index;
                        q_mask[0] = 0xff;
                        break;
                    }
                }
            }
        }
    }
#endif

    FP_UNLOCK(unit);

    if (BCM_SUCCESS(rv)) {
        *data = (uint8)(q_data[0] & 0xff);
        *mask = (uint8)(q_mask[0] & 0xff);
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_entry_qualifier_uint16_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     data      - Qualifier data.
 *     mask      - Qualifier mask.
 * Returns:
 *     Nothing.
 */
int
_bcm_field_entry_qualifier_uint16_get(int unit, bcm_field_entry_t entry,
                                  int qual_id, uint16 *data,
                                  uint16 *mask)
{
    _bcm_field_qual_data_t     q_data;/* Qualifier match data.     */
    _bcm_field_qual_data_t     q_mask;/* Qualifier match mask.     */
    int                        rv;    /* Operation return status.  */
   /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }


    FP_LOCK(unit);

    rv = _field_entry_qualifier_key_get(unit, entry, qual_id, q_data, q_mask);

    FP_UNLOCK(unit);

    if (BCM_SUCCESS(rv)) {
        *data = (uint16)(q_data[0] & 0xffff);
        *mask = (uint16)(q_mask[0] & 0xffff);
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_entry_qualifier_uint32_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     data      - Qualifier data.
 *     mask      - Qualifier mask.
 * Returns:
 *     Nothing.
 */
int
_bcm_field_entry_qualifier_uint32_get(int unit, bcm_field_entry_t entry,
                                  int qual_id, uint32 *data,
                                  uint32 *mask)
{
    _bcm_field_qual_data_t     q_data;/* Qualifier match data.     */
    _bcm_field_qual_data_t     q_mask;/* Qualifier match mask.     */
    int                        rv;    /* Operation return status.  */

   /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }


    FP_LOCK(unit);

    rv = _field_entry_qualifier_key_get(unit, entry, qual_id, q_data, q_mask);

    FP_UNLOCK(unit);

    if (BCM_SUCCESS(rv)) {
        *data = q_data[0];
        *mask = q_mask[0];
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_entry_qualifier_uint64_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     data      - Qualifier data.
 *     mask      - Qualifier mask.
 * Returns:
 *     BCM_E_XXX.
 */
int
_bcm_field_entry_qualifier_uint64_get(int unit, bcm_field_entry_t entry,
                                      int qual_id, uint64 *data,
                                      uint64 *mask)
{
    _bcm_field_qual_data_t     q_data;/* Qualifier match data.     */
    _bcm_field_qual_data_t     q_mask;/* Qualifier match mask.     */
    int                        rv;    /* Operation return status.  */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }


    FP_LOCK(unit);

    rv = _field_entry_qualifier_key_get(unit, entry, qual_id, q_data, q_mask);

    FP_UNLOCK(unit);

    if (BCM_SUCCESS(rv)) {
        COMPILER_64_SET(*data, q_data[1], q_data[0]);
        COMPILER_64_SET(*mask, q_mask[1], q_mask[0]);
    }
    return (rv);
}


/*
 * Function:
 *     _bcm_field_qual_value_set
 *
 * Purpose:
 *     Set a qualifier field from the designated data and mask arrays.
 *
 * Parameters:
 *     unit     - (IN) BCM devices number
 *     q_offset - (IN) Qualifier offset inside tcam.
 *     f_ent    - (IN) Field entry descriptor.
 *     p_data   - (IN) Inserted data.
 *     p_mask   - (IN) Data mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_value_set(int unit, _bcm_field_qual_offset_t *q_offset,
                          _field_entry_t *f_ent,
                          uint32 *p_data, uint32 *p_mask)
{
    int    rv;
    uint8  qual_part;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_bcm_field_qual_value_set\n")));

    /* Input parameters check. */
    if ((NULL == q_offset) || (NULL == f_ent) ||
        (NULL == p_data) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    /* Primary offset handling. */
    for (qual_part = 0; qual_part < q_offset->num_offsets; qual_part++) {
        if (q_offset->width[qual_part] > 0)
        {
           rv = _field_qual_part_value_set(unit, q_offset, qual_part, f_ent,
                                              p_data, p_mask, 0);
           BCM_IF_ERROR_RETURN(rv);
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_qual_value_set_by_entry_type
 *
 * Purpose:
 *     Set a qualifier field from the designated data and mask arrays in the
 *     tcam of the given index.
 *
 * Parameters:
 *     unit       - (IN) BCM devices number
 *     q_offset   - (IN) Qualifier offset inside tcam.
 *     f_ent      - (IN) Field entry descriptor.
 *     p_data     - (IN) Inserted data.
 *     p_mask     - (IN) Data mask.
 *     entry_type - (IN) Index of the tcam entry
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_qual_value_set_by_entry_type(int unit,
                                        _bcm_field_qual_offset_t *q_offset,
                                        _field_entry_t *f_ent,
                                        uint32 *p_data,
                                        uint32 *p_mask,
                                        uint8 entry_type)
{
    uint8 qual_part;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_bcm_field_qual_value_set_by_index\n")));

    /* Input parameters check. */
    if ((NULL == q_offset) || (NULL == f_ent) ||
        (NULL == p_data) || (NULL == p_mask)) {
        return (BCM_E_PARAM);
    }

    /* Primary offset handling. */
    for (qual_part = 0; qual_part < q_offset->num_offsets; qual_part++) {
        if (q_offset->width[qual_part] > 0)
        {
           BCM_IF_ERROR_RETURN
                (_field_qual_part_value_set(unit, q_offset, qual_part, f_ent,
                                            p_data, p_mask, entry_type));
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_group_stage_get
 *
 * Purpose:
 *     Extract group pipeline stage from qualifiers set.
 *
 * Parameters:
 *     unit    - (IN)BCM device number.
 *     qset_p  - (IN)Group qualifiers set.
 *     stage   - (OUT)Pipeline stage id.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_stage_get(int unit, bcm_field_qset_t *qset_p,
                       _field_stage_id_t *stage)
{
    int stage_count = 0;   /* Check that only 1 stage specified in qset */

    /* Input parameters check. */
    if ((NULL == qset_p) || (NULL == stage)) {
        return (BCM_E_PARAM);
    }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    /* Set stage based on qualifiers set. */
    if (soc_feature(unit, soc_feature_field_multi_stage)) {
        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageIngress)) {
            *stage  = _BCM_FIELD_STAGE_INGRESS;
            stage_count++;
        }
        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageEgress)) {
            *stage  = _BCM_FIELD_STAGE_EGRESS;
            stage_count++;
        }

        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageLookup)) {
            *stage  = _BCM_FIELD_STAGE_LOOKUP;
            stage_count++;
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageExternal)) {
        *stage  = _BCM_FIELD_STAGE_EXTERNAL;
        stage_count++;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageClass)) {
        *stage  = _BCM_FIELD_STAGE_CLASS;
        stage_count++;
    }
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageClassExactMatch)) {
        *stage  = _BCM_FIELD_STAGE_CLASS;
        stage_count++;
    }
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageIngressExactMatch)) {
        *stage  = _BCM_FIELD_STAGE_EXACTMATCH;
        stage_count++;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (stage_count == 0) {
        /* Default to ingress. */
        *stage = _BCM_FIELD_STAGE_INGRESS;
        stage_count++;
    }

    if (stage_count > 1) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: More than one pipeline stage was specified.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_data_qualifier_free
 *
 * Purpose:
 *     Free data qualifier descriptor structure.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     qual       - (OUT)Qualifier strusture.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_data_qualifier_free(int unit, _field_data_qualifier_t *qual)
{
    /* Input parameters check. */
    if (NULL == qual) {
        return (BCM_E_PARAM);
    }

    /* Free data offset structure. */
    if (NULL != qual->spec) {
        sal_free(qual->spec);
    }

    /* Free data qualifier structure. */
    sal_free(qual);

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_data_qualifier_bmap_alloc
 *
 * Purpose:
 *     Allocate hw resources for data qualifier installation
 * Parameters:
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Stage field control.
 *     f_dq       - (IN) Field data qualifier descriptor.
 *     idx_low    - (IN) Lower boundary.
 *     idx_hi     - (IN) Upper boundary.
 *
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_data_qualifier_bmap_alloc(int unit,
                               _field_stage_t *stage_fc,
                               _field_data_qualifier_t *f_dq,
                               uint8 idx_low, uint8 idx_hi)
{
    int idx;                 /* Data qualifier word iterator. */
    int elem_count;          /* Number of elements allocated.    */
    int temp_elem_count = 0; /* Number of elements allocated.    */
    uint32   *usage_bmap;    /* Offset usage bitmap.          */
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT) || defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
                            /* Valid HW offsets for FPF1.9 and FPF3.9 */
    SHR_BITDCL udf1_hw_offsets;
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT or BCM_ENDURO_SUPPORT */

    /* Input parameters check. */
    if ((NULL == f_dq) || (NULL == stage_fc) ||
        (idx_low > 31) || (idx_hi > 31)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT) || defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    memset(&udf1_hw_offsets, 0x0, sizeof(udf1_hw_offsets));
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
         /* set UDF1.1 for FPF3.9 - {0 0 1 1 0 0 0 0} */
         SHR_BITSET(&udf1_hw_offsets, 0x2);
         SHR_BITSET(&udf1_hw_offsets, 0x3);
         /* set UDF1.3 for FPF1.9 - {0 0 0 0 0 0 1 1} */
         SHR_BITSET(&udf1_hw_offsets, 0x6);
         SHR_BITSET(&udf1_hw_offsets, 0x7);
    } else if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
         SOC_IS_GREYHOUND(unit) || SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)
         || SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND2(unit)) {
         /* set UDF1.1 for FPF3.9  - {0 1 0 0} 1st bit Position */
         SHR_BITSET(&udf1_hw_offsets, 0x1);
         /* set UDF1.3 for FPF1.9  - {0 0 0 1} 3rd bit Position */
         SHR_BITSET(&udf1_hw_offsets, 0x3);
    }
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT or BCM_ENDURO_SUPPORT */

    elem_count = 0;
    usage_bmap = &stage_fc->data_ctrl->usage_bmap;
    for (idx = idx_low; idx <= idx_hi; idx++) {
        if (0 == ((*usage_bmap) & (1 << idx))) {
            elem_count++;
        }
    }

    if (elem_count >= f_dq->elem_count) {
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT) || defined(BCM_ENDURO_SUPPORT)  || defined(BCM_TRIUMPH2_SUPPORT)
        if ((SOC_IS_TD_TT(unit)
             || SOC_IS_KATANAX(unit)
             || SOC_IS_TRIUMPH3(unit)
             || SOC_IS_ENDURO(unit)
             || SOC_IS_HURRICANEX(unit)
             || SOC_IS_GREYHOUND(unit)
             || SOC_IS_TRIUMPH2(unit)
             || SOC_IS_APOLLO(unit)
             || SOC_IS_VALKYRIE2(unit)
             || SOC_IS_GREYHOUND2(unit))
             && !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)) {
            /* Check if index is in UDF1 range (0 - 7) */
            if (((idx_low == 0)
                && (idx_hi <= (stage_fc->data_ctrl->num_elems - 1)))
                && (f_dq->elem_count > 0 && f_dq->elem_count <= 4)) {

                /* Get number of requested elements. */
                elem_count = f_dq->elem_count;

                /* Check if requested count of elements are available */
                for (idx = idx_low; ((idx <= idx_hi) && elem_count); idx++) {
                    /* We check the upper limit of idx_hi and idx_low
                       in the beginning of the function */
                    /* coverity[ptr_arith] */
                    if (SHR_BITGET(&udf1_hw_offsets, idx) == 0) {
                        continue;
                    }

                    if (0 == ((*usage_bmap) & (1 << idx))) {
                        elem_count--;
                    }
                }

                /*
                 * If elem_count is zero, required no. of elements are
                 * available.
                 */
                if (0 == elem_count) {
                    elem_count = f_dq->elem_count;
                    /* Reserve the indices */
                    for (idx = idx_hi; ((idx >= idx_low) && elem_count); idx--) {
                        /* We check the upper limit of idx_hi and idx_low
                           in the beginning of the function */
                        /* coverity[ptr_arith] */
                        if (SHR_BITGET(&udf1_hw_offsets, idx) == 0) {
                            continue;
                        }

                        if (0 == ((*usage_bmap) & (1 << idx))) {
                            f_dq->hw_bmap |= (1 << idx);
                            (*usage_bmap) |= (1 << idx);
                            elem_count--;
                        }
                    }
                    return (BCM_E_NONE);
                }
            } else if((idx_low == 0)
                    && (idx_hi == ((stage_fc->data_ctrl->num_elems * 2) - 1))) {
                /* When both UDF1 & UDF 2 are required
                 * Try to fill from UDF2 followed by
                 * UDF1 specical chunks(0,1,4,5) for more flexibilty and
                 * then from the remaining UDF1 chunks(2,3,6,7) */
                temp_elem_count = f_dq->elem_count;
                for (idx = stage_fc->data_ctrl->num_elems;
                        ((idx <= idx_hi) && temp_elem_count); idx++) {
                    if (0 == ((*usage_bmap) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        temp_elem_count--;
                    }
                }
                for (idx = stage_fc->data_ctrl->num_elems - 1 ;
                        ((idx >= idx_low) && temp_elem_count); idx--) {
                    /* We check the upper limit of idx_hi and idx_low
                       in the beginning of the function */
                    /* coverity[ptr_arith] */
                    if (SHR_BITGET(&udf1_hw_offsets, idx) == 0) {
                        continue;
                    }

                    if (0 == ((*usage_bmap) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        temp_elem_count--;
                    }
                }
                temp_elem_count = f_dq->elem_count - temp_elem_count;
            }
        }
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT or BCM_ENDURO_SUPPORT */

        elem_count = f_dq->elem_count - temp_elem_count;
        for (idx = idx_low; ((idx <= idx_hi) && elem_count); idx++) {
            if (0 == ((*usage_bmap) & (1 << idx))) {
                f_dq->hw_bmap |= (1 << idx);
                (*usage_bmap) |= (1 << idx);
                elem_count--;
            }
        }
        return (BCM_E_NONE);
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function:
 *     _field_data_qualifier_hw_alloc
 *
 * Purpose:
 *     Allocate hw resources for data qualifier installation
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Stage field control.
 *     f_dq       - (IN) Field data qualifier descriptor.
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_data_qualifier_hw_alloc(int unit,
                               _field_stage_t *stage_fc,
                               _field_data_qualifier_t *f_dq)
{
    int rv;               /* Operation return status.        */

    /* Input parameters check. */
    if ((NULL == f_dq) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)) {
        return _bcm_field_th_data_qualifier_hw_alloc(unit, stage_fc, f_dq);
    }
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) &&
        f_dq->flags & BCM_FIELD_DATA_QUALIFIER_OFFSET_FLEX_HASH) {
        /* flex hash uses UDF2_OFFSET4 to UDF2_OFFSET7 */
        rv = _field_data_qualifier_bmap_alloc
            (unit, stage_fc, f_dq, 12, ((2 * stage_fc->data_ctrl->num_elems) - 1));
        if (BCM_FAILURE(rv)) {
            return (BCM_E_FAIL);
        }
        return BCM_E_NONE;
    }
#endif

    /* First try to allocate with single udf */
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT) || defined(BCM_ENDURO_SUPPORT)
    if ((SOC_IS_TD_TT(unit)
         || SOC_IS_KATANAX(unit)
         || SOC_IS_TRIUMPH3(unit)
         || SOC_IS_ENDURO(unit)
         || SOC_IS_HURRICANEX(unit)
         || SOC_IS_GREYHOUND2(unit))
         && !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)
         && (f_dq->elem_count > 4)) {
        /* Try UDF 2  followed by UDF 1*/
        rv = _field_data_qualifier_bmap_alloc
            (unit, stage_fc, f_dq, stage_fc->data_ctrl->num_elems,
             stage_fc->data_ctrl->num_elems * 2 - 1);

        if (BCM_SUCCESS(rv)) {
            return (BCM_E_NONE);
        }
        rv = _field_data_qualifier_bmap_alloc
            (unit, stage_fc, f_dq, 0, stage_fc->data_ctrl->num_elems - 1);

        if (BCM_SUCCESS(rv)) {
            return (BCM_E_NONE);
        }
    } else
#endif
    {
        rv = _field_data_qualifier_bmap_alloc
            (unit, stage_fc, f_dq, 0, stage_fc->data_ctrl->num_elems - 1);

        if (BCM_SUCCESS(rv)) {
            return (BCM_E_NONE);
        }
        rv = _field_data_qualifier_bmap_alloc
            (unit, stage_fc, f_dq, stage_fc->data_ctrl->num_elems,
             stage_fc->data_ctrl->num_elems * 2 - 1);

        if (BCM_SUCCESS(rv)) {
            return (BCM_E_NONE);
        }
    }

    /* Need 2 udfs to insert the qualifier. */
    rv  = _field_data_qualifier_bmap_alloc
        (unit, stage_fc, f_dq, 0, stage_fc->data_ctrl->num_elems * 2 - 1);

    return (rv);
}

/*
 * Function:
 *     _bcm_field_data_qualifier_alloc
 *
 * Purpose:
 *     Allocate data qualifier descriptor structure.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     qual       - (OUT)Qualifier strusture.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_data_qualifier_alloc(int unit, _field_data_qualifier_t **qual)
{
    int mem_sz;                  /* Allocated memory size.  */
    _field_data_qualifier_p f_dq;/* Data qualifier pointer. */

    /* Input parameters check. */
    if (NULL == qual) {
        return (BCM_E_PARAM);
    }

    /* Allocate field data qualifier structure. */
    mem_sz = sizeof(_field_data_qualifier_t);
    f_dq = sal_alloc(mem_sz, "Data qualifier");
    if (NULL == f_dq) {
        return (BCM_E_MEMORY);
    }
    sal_memset(f_dq, 0, mem_sz);

    /* Allocate offsets spec required for qualifier. */
    mem_sz = sizeof(bcm_field_udf_spec_t);
    f_dq->spec = sal_alloc(mem_sz, "Data spec");
    if (NULL == f_dq->spec) {
        sal_free(f_dq);
        return (BCM_E_MEMORY);
    }
    sal_memset(f_dq->spec->offset, 0xff, sizeof(f_dq->spec->offset));
    *qual = f_dq;

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_stage_data_ctrl_init
 *
 * Purpose:
 *     Allocate and initialize data qualifiers control structure.
 *
 * Parameters:
 *     unit     - (IN)     BCM unit
 *     stage_fc - (IN/OUT) Stage to be initialize.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stage_data_ctrl_init(int unit, _field_stage_t *stage_fc)
{
    int mem_sz;
    _field_data_control_t *data_ctrl = NULL;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Allocate data control structure. */
    mem_sz = sizeof(_field_data_control_t);
    _FP_XGS3_ALLOC(data_ctrl, mem_sz,
                   "Data qualification control");
    if (NULL == data_ctrl) {
        return (BCM_E_MEMORY);
    }

#if defined(BCM_TRIUMPH2_SUPPORT)
    if (SOC_MEM_IS_VALID(unit, FP_UDF_TCAMm)) {
        mem_sz = sizeof (_field_data_tcam_entry_t) *
            soc_mem_index_count(unit, FP_UDF_TCAMm);
        _FP_XGS3_ALLOC(data_ctrl->tcam_entry_arr, mem_sz,
                       "Udf tcam entry array.");
        if (NULL == data_ctrl->tcam_entry_arr) {
            sal_free (data_ctrl);
            return (BCM_E_MEMORY);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    if (SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm, UDF1_OFFSET4f)) {
        data_ctrl->elem_size = 2;
        data_ctrl->num_elems = 8;
    } else {
        data_ctrl->elem_size = 4;
        data_ctrl->num_elems = 4;
    }

    stage_fc->data_ctrl = data_ctrl;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stage_external_data_ctrl_init
 *
 * Purpose:
 *     Allocate and initialize external data qualifiers control structure.
 *
 * Parameters:
 *     unit     - (IN)     BCM unit
 *     stage_fc - (IN/OUT) Stage to be initialize.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stage_external_data_ctrl_init(int unit, _field_control_t *fc)
{
    _field_stage_t *stage_ingress, *stage_external, *stage_p;

    stage_external = stage_ingress = NULL;
    stage_p = fc->stages;

    while (stage_p) {
        if (stage_p->stage_id == _BCM_FIELD_STAGE_INGRESS) {
            stage_ingress = stage_p;
        } else if (stage_p->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            stage_external = stage_p;
        }
        stage_p = stage_p->next;
    }

    if ((stage_ingress == NULL) || (stage_external == NULL)) {
        return (BCM_E_INTERNAL);
    }

    stage_external->data_ctrl = stage_ingress->data_ctrl;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_data_qualifier_destroy
 * Purpose:
 *      Destroy a data/offset based qualifier.
 * Parameters:
 *      unit  - (IN) Bcm device number.
 *      qid   - (IN) Data qualifier id.
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_data_qualifier_destroy(int unit, int qid)
{
    _field_data_qualifier_t *f_dq;/* Internal data qualifier descriptor. */
    _field_data_qualifier_t *f_dq_prev;/* Prev data qualifier descriptor.*/
    _field_stage_t  *stage_fc;    /* Stage field control.                */
    int rv;

#if defined (BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_udf_support) && UDF_CTRL(unit)) {
        if (UDF_CTRL(unit)->udf_used_by_module == UDF_USED_BY_UDF_MODULE) {
            LOG_CLI((BSL_META("Udf resource is used by UDF module. \n")));
            return (BCM_E_RESOURCE);
        }
    }
#endif

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    f_dq_prev = f_dq = stage_fc->data_ctrl->data_qual;
    while (NULL != f_dq) {
        if (f_dq->qid == qid) {
            /* Free used offset words bitmap. */
            stage_fc->data_ctrl->usage_bmap &= ~f_dq->hw_bmap;

            /* Remove qualifier from qualifiers linked list. */
            if (f_dq == f_dq_prev) {
                stage_fc->data_ctrl->data_qual = f_dq->next;
            } else {
                f_dq_prev->next = f_dq->next;
            }
            /* Free qualifieer allocated memory. */
            BCM_IF_ERROR_RETURN(_bcm_field_data_qualifier_free(unit, f_dq));

#if defined (BCM_TRIUMPH2_SUPPORT)
            if (soc_feature(unit, soc_feature_udf_support) && UDF_CTRL(unit)) {
                UDF_LOCK(unit);
                if (NULL == stage_fc->data_ctrl->data_qual) {
                    UDF_CTRL(unit)->udf_used_by_module = UDF_USED_BY_NONE;
                }
                UDF_UNLOCK(unit);
            }
#endif
            return (BCM_E_NONE);
        }
        f_dq_prev = f_dq;
        f_dq = f_dq->next;
    }
    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *      _field_data_qualifier_destroy_all
 * Purpose:
 *      Destroy all data/offset  based qualifiers.
 * Parameters:
 *      unit           - (IN) bcm device.
 * Returns:
 *      BCM_E_XXX
 */
int
_field_data_qualifier_destroy_all(int unit)
{
    _field_data_qualifier_t *f_dq;/* Internal data qualifier descriptor. */
    _field_stage_t  *stage_fc;    /* Stage field control.                */
    int rv;                       /* Operation return status.            */

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    while (NULL != stage_fc->data_ctrl->data_qual) {
        f_dq = stage_fc->data_ctrl->data_qual;
        BCM_IF_ERROR_RETURN (_bcm_field_data_qualifier_destroy(unit, f_dq->qid));
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stage_data_ctrl_deinit
 *
 * Purpose:
 *     De-allocate data qualifiers control structure.
 *
 * Parameters:
 *     unit     - (IN)     BCM unit
 *     stage_fc - (IN/OUT) Stage to be initialize.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stage_data_ctrl_deinit(int unit, _field_stage_t *stage_fc)
{
    _field_data_control_t *data_ctrl;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
        return (BCM_E_NONE);
    }

    data_ctrl = stage_fc->data_ctrl;
    if (NULL == data_ctrl) {
        return (BCM_E_NONE);
    }

    /* Delete all data qualifiers. */
    _field_data_qualifier_destroy_all(unit) ;

    /* Free control structures. */
    if (NULL != data_ctrl->tcam_entry_arr) {
        sal_free(data_ctrl->tcam_entry_arr);
    }

    if (NULL != data_ctrl) {
        sal_free(data_ctrl);
    }

    stage_fc->data_ctrl  = NULL;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_data_qualifier_get
 * Purpose:
 *      Get data qualifier by id.
 * Parameters:
 *      unit           - (IN) bcm device.
 *      stage_fc       - (IN) Stage field control.
 *      qid            - (IN) Qualifier id.
 *      data_qual      - (OUT) Internal data qualifier descriptor:
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_data_qualifier_get(int unit, _field_stage_t *stage_fc,
                              int qid, _field_data_qualifier_t **data_qual)
{
    _field_data_qualifier_p f_dq;  /* Field data qualifier iterator. */

    /* Input parameters check. */
    if((NULL == data_qual) ||  (NULL == stage_fc)){
        return (BCM_E_PARAM);
    }

    f_dq = stage_fc->data_ctrl->data_qual;
    while (NULL != f_dq) {
        if (f_dq->qid == qid) {
            *data_qual = f_dq;
            return (BCM_E_NONE);
        }
        f_dq = f_dq->next;
    }
    return (BCM_E_NOT_FOUND);
}


/*
 * Function:
 *      _field_data_qualifier_get
 *
 * Purpose:
 *      Get data qualifier by qualifier id.
 *
 * Parameters:
 *      unit       - (IN)  bcm device.
 *      qual_id    - (IN)  Id of data qualifier.
 *      data_qual  - (OUT) Internal data qualifier descriptor:
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_field_data_qualifier_get(int unit, int qual_id,
                           _field_data_qualifier_t *data_qual)
{
    int                     rv;
    _field_control_t        *fc;
    _field_stage_t          *stage_fc;
    _field_data_qualifier_t *f_dq;

    /* Parameter checking */
    if (data_qual == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data_qual == NULL.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    /* Point to needed things */
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if ((rv = _bcm_field_data_qualifier_get(unit,
                stage_fc, qual_id, &f_dq)) == BCM_E_NONE) {
        sal_memcpy(data_qual, f_dq, sizeof(_field_data_qualifier_t));
    }

    FP_UNLOCK(unit);

    return (rv);
}


/*
 * Function:
 *      _field_data_qualifier_id_alloc
 * Purpose:
 *      Allocate unused date qualifier id.
 * Parameters:
 *      unit           - (IN) bcm device.
 *      stage_fc       - (IN) Stage field control.
 *      data_qualifier - (IN) API level qualifier descriptor:
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_field_data_qualifier_id_alloc(int unit, _field_stage_t *stage_fc,
                             bcm_field_data_qualifier_t *data_qualifier)
{
    _field_data_qualifier_t *f_dq;    /* Data qualifier descriptor.    */
    static int last_allocated_qid = 0;/* last allocated qid. */
    int max_try;                      /* Maximum number of allocation. */
    int qid;                          /* Qualifier id.                 */
    int rv;                           /* Operation return status.      */


    /* Input parameters check. */
    if ((NULL == data_qualifier) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* If qualifier id was passed by the caller,
       verify the range and make sure id is not used. */
    if (data_qualifier->flags & BCM_FIELD_DATA_QUALIFIER_WITH_ID) {
        qid = data_qualifier->qual_id;
        rv = _bcm_field_data_qualifier_get(unit, stage_fc, qid, &f_dq);
        if (BCM_SUCCESS(rv)) {
            /*  Data qual with requested id already exists */

            if (!(data_qualifier->flags & BCM_FIELD_DATA_QUALIFIER_REPLACE)) {
                /* "Replace" flag was not specified => Return error */

                return (BCM_E_EXISTS);
            }

            /* Destroy existing one */

            _bcm_field_data_qualifier_destroy(unit, qid);
        }
        return (BCM_E_NONE);
    }
    max_try = _FP_ID_MAX;
    qid = last_allocated_qid;
    while (max_try--) {
        qid++;
        if ((qid < _FP_ID_BASE) || (qid >= _FP_ID_MAX)) {
            qid = _FP_ID_BASE;
        }
        rv = _bcm_field_data_qualifier_get(unit, stage_fc, qid, &f_dq);
        if (BCM_E_NOT_FOUND == rv) {
            last_allocated_qid =  qid;
            data_qualifier->qual_id = qid;
            return (BCM_E_NONE);
        }
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }
    return (BCM_E_RESOURCE);
}


int
_field_data_qualifier_init2(int                        unit,
                            _field_stage_t             *stage_fc,
                            _field_data_qualifier_t    *f_dq
                            )
{
    int add_offset;               /* Additional offset due to l2         */
                                  /* header size is not multiples of 4.  */

    /* Add to stage's data qual list */
    f_dq->next        = stage_fc->data_ctrl->data_qual;
    stage_fc->data_ctrl->data_qual = f_dq;

    /* Verify data qualifier offset base value. */
    switch (f_dq->offset_base) {
      /* The following data qualifier offsets are not supported by XGS */
      case bcmFieldDataOffsetBaseTrillPayload:
      case bcmFieldDataOffsetBaseTrillHeader:
#ifdef BCM_TRIUMPH2_SUPPORT
          /* The following chips support the above mentioned offset base */
          if ((SOC_IS_TD2_TT2(unit)) || (SOC_IS_KATANAX(unit)) ||
              (SOC_IS_TRIUMPH3(unit)) || (SOC_IS_TRIDENT(unit))) {
              break;
          }
#endif
      case bcmFieldDataOffsetBaseEndTag:
      case bcmFieldDataOffsetBaseL2Header:
      case bcmFieldDataOffsetBaseFirstHeader:
      case bcmFieldDataOffsetBaseSecondHeader:
      case bcmFieldDataOffsetBaseThirdHeader:
      case bcmFieldDataOffsetBaseMplsLabel1Header:
      case bcmFieldDataOffsetBaseMplsLabel2Header:
      case bcmFieldDataOffsetBaseMplsLabel3Header:
      case bcmFieldDataOffsetBaseInnerL2Header:
      case bcmFieldDataOffsetBaseFourthHeader:
      case bcmFieldDataOffsetBaseForwardingHeader:
      case bcmFieldDataOffsetBaseNextForwardingHeader:
           {
             return (BCM_E_PARAM);
           }
           break;
      default:
           break;
    }

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
    if (SOC_MEM_IS_VALID(unit, FP_UDF_TCAMm)) {
        if (stage_fc->data_ctrl->elem_size <= 2) { /* no wrap around needed */
            f_dq->byte_offset = f_dq->offset %
                stage_fc->data_ctrl->elem_size;
        } else {
            if (bcmFieldDataOffsetBasePacketStart ==
                f_dq->offset_base) {
                f_dq->byte_offset = (f_dq->offset + 2) % 4;
            } else {
                f_dq->byte_offset = f_dq->offset % 4;
            }
        }
    } else
#endif /* BCM_TRIUMPH2_SUPPORT */
    {
        switch (f_dq->offset_base) {
          case bcmFieldDataOffsetBaseOuterL3Header:
          case bcmFieldDataOffsetBaseInnerL3Header:
          case bcmFieldDataOffsetBaseOuterL4Header:
          case bcmFieldDataOffsetBaseInnerL4Header:
              /* Older devices supports Start of Packet offset only. */
              return (BCM_E_PARAM);
          case bcmFieldDataOffsetBasePacketStart:
              add_offset = 0;
              break;
          case bcmFieldDataOffsetBaseHigigHeader:
              if (SOC_IS_FB(unit) ||
                  SOC_IS_HB_GW(unit) ||
                  SOC_IS_SC_CQ(unit) ||
                  soc_feature(unit, soc_feature_field_udf_offset_hg_114B)) {
                  add_offset = 2;
              } else {
                  add_offset = 0;
              }
              break;
          case bcmFieldDataOffsetBaseHigig2Header:
              if (SOC_IS_FB(unit) ||
                  SOC_IS_HB_GW(unit) ||
                  SOC_IS_SC_CQ(unit) ||
                  soc_feature(unit, soc_feature_field_udf_offset_hg2_110B)) {
                  add_offset = 2;
              } else {
                  add_offset = 0;
              }
              break;
          default:
              return (BCM_E_PARAM);
        }

        f_dq->byte_offset = (f_dq->offset + add_offset + 2) % 4;
    }

    return (BCM_E_NONE);
}


int
_field_data_qualifier_init(int                        unit,
                           _field_stage_t             *stage_fc,
                           _field_data_qualifier_t    *f_dq,
                           bcm_field_data_qualifier_t *data_qualifier
                           )
{
    f_dq->qid         = data_qualifier->qual_id;
    f_dq->offset_base = data_qualifier->offset_base;
    f_dq->offset      = data_qualifier->offset;
    f_dq->length      = data_qualifier->length;
    f_dq->flags       = data_qualifier->flags & _BCM_FIELD_DATA_QUALIFIER_FLAGS;

    BCM_IF_ERROR_RETURN(_field_data_qualifier_init2(unit, stage_fc, f_dq));

    f_dq->elem_count = (f_dq->length + f_dq->byte_offset +
                        stage_fc->data_ctrl->elem_size - 1
                        )
        / stage_fc->data_ctrl->elem_size;

    return (BCM_E_NONE);
}

void
_field_data_qualifier_debug(int unit,
                            _field_stage_t *stage_fc,
                            _field_data_qualifier_t *f_dq)
{
    int  idx, first=1;
    int  num_elems;

    if (stage_fc == NULL || f_dq == NULL) {
       return;
    }

    num_elems = stage_fc->data_ctrl->num_elems;
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "Chunks allocated for Data Qualifier ID - %d:\n\r"),
                 f_dq->qid));
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "UDF1{")));
    for (idx = 0; idx < num_elems; idx++) {
       if (f_dq->hw_bmap & (1 << idx)) {
          if (first == 0) {
             LOG_VERBOSE(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "), ")));
          }
          first = 0;
          LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "%d"),
                       idx));
       }
    }
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "%s}\n\r"),
                 (first == 1)?"None":""));
    first = 1;
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "UDF2{")));
    for (idx = num_elems; idx < num_elems * 2; idx++) {
       if (f_dq->hw_bmap & (1 << idx)) {
          if (first == 0) {
             LOG_VERBOSE(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "), ")));
          }
          first = 0;
          LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "%d"),
                       idx));
       }
    }
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "%s}\n\r"),
                 (first == 1)?"None":""));
}

int
_field_data_qualifier_create(int unit,
                             bcm_field_data_qualifier_t *data_qualifier)
{
    _field_data_qualifier_t *f_dq;/* Internal data qualifier descriptor. */
    _field_stage_t  *stage_fc;    /* Stage field control.                */
    int rv;                       /* Operation return status.            */

    /* Input parameters check. */
    if (NULL == data_qualifier) {
        return (BCM_E_PARAM);
    }

#if defined (BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_udf_support)) {
        if (UDF_CTRL(unit) == NULL) {
            LOG_CLI((BSL_META("UDF module is not initialized. \n")));
            return (BCM_E_RESOURCE);
        }
        if (UDF_CTRL(unit)->udf_used_by_module == UDF_USED_BY_UDF_MODULE) {
            LOG_CLI((BSL_META("Udf resource is used by UDF module. \n")));
            return (BCM_E_RESOURCE);
        }
    }
#endif

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate data qualifier id. */
    rv = _field_data_qualifier_id_alloc(unit, stage_fc, data_qualifier);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocated internal data qualifier descriptor. */
    rv = _bcm_field_data_qualifier_alloc(unit, &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize internal data qualifier record from given one */
    rv = _field_data_qualifier_init(unit, stage_fc, f_dq, data_qualifier);
    if (BCM_FAILURE(rv)) {
        goto error_cleanup;
    }

    /* Allocate words in hw to accommodate data qualifier. */
    rv = _field_data_qualifier_hw_alloc(unit, stage_fc, f_dq);
    if (BCM_FAILURE(rv)) {
        goto error_cleanup;
    }

    if (FP_VERB_CHECK()) {
      (void)_field_data_qualifier_debug(unit, stage_fc, f_dq);
    }

#if defined (BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_udf_support)) {
        UDF_LOCK(unit);
        UDF_CTRL(unit)->udf_used_by_module = UDF_USED_BY_FIELD_MODULE;
        UDF_UNLOCK(unit);
    }
#endif

    return (BCM_E_NONE);

 error_cleanup:
    _bcm_field_data_qualifier_destroy(unit, f_dq->qid);

    return (rv);
}

/*
 * Function: _field_qualify_data_elem
 *
 * Purpose:
 *
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     eid           - (IN) Entry ID.
 *     f_dq          - (IN) Data qualifier descriptor.
 *     qual_elem_idx - (IN) Data qualifier element index.
 *     data          - (IN) Data bytes for the indicated data qualifier.
 *                Network byte ordered.
 *     mask     - Mask bytes for the indicated data qualifier.
 *                Network byte ordered.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qualify_data_elem(int unit, bcm_field_entry_t eid,
                         _field_data_qualifier_t *f_dq,
                         uint8 qual_elem_idx,
                         uint32 data, uint32 mask)
{
    _field_stage_t           *stage_fc;
    _bcm_field_qual_offset_t *q_offset;
    _bcm_field_qual_offset_t q_offset_temp;
    _field_entry_t           *f_ent = NULL;
    int                      idx;
    int                      rv;
    int                      elem_idx = 0;
    int                      qid = 0;

    /* Input parameters check. */
    if (NULL == f_dq) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    /* Find a proper element to insert the data. */
    for (idx = 0; idx < stage_fc->data_ctrl->num_elems * 2; idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            if (elem_idx == qual_elem_idx) {
                break;
            } else {
                elem_idx++;
            }
        }
    }

    /* Get entry info. */
    BCM_IF_ERROR_RETURN
        (_field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent));

    /* Get data qualifier id. */
    if (idx >= 0 && idx < stage_fc->data_ctrl->num_elems) {
#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_ENDURO(unit)
            || SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit)
            || SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)
            || SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND2(unit)) {
            /* Check in group Qset if Data0 is set. */
            if (!BCM_FIELD_QSET_TEST_INTERNAL
                    (f_ent->group->qset, _bcmFieldQualifyData0)) {
                if ((1 == idx)
                    && !(f_dq->hw_bmap & (1 << 0x0))
                    && !(f_dq->hw_bmap & (1 << 0x2))) {
                    /* qid = UDF1_31_0 */
                    qid = _bcmFieldQualifyData3;
                } else if ((3 == idx)
                    && !(f_dq->hw_bmap & (1 << 0x0))
                    && !(f_dq->hw_bmap & (1 << 0x2))) {
                    /* qid = UDF1_95_64 */
                    qid = _bcmFieldQualifyData2;
                } else {
                    return (BCM_E_INTERNAL);
                }
            } else {
                /* qid = UDF1_127_0 */
                qid = _bcmFieldQualifyData0;
            }
        } else
#endif /* BCM_ENDURO_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_TD_TT(unit)
            || SOC_IS_KATANAX(unit)
            || SOC_IS_TRIUMPH3(unit)) {
            /* Check in group Qset if Data0 is set. */
            if (!BCM_FIELD_QSET_TEST_INTERNAL
                    (f_ent->group->qset, _bcmFieldQualifyData0)) {
                if ((2 == idx || 3 == idx)
                    && !(f_dq->hw_bmap & 0x33)) {
                    /* UDF1_95_64 */
                    qid = _bcmFieldQualifyData3;
                } else if ((6 == idx || 7 == idx)
                           && !(f_dq->hw_bmap & 0x33)) {
                    /* UDF1_31_0 */
                    qid = _bcmFieldQualifyData2;
                } else {
                    /*
                     * udf_offset0_1 and udf_offset4_5 must be in
                     * _bcmFieldQualifyData0
                     */
                    return (BCM_E_INTERNAL);
                }
            } else {
                /* UDF1_127_0 */
                qid = _bcmFieldQualifyData0;
            }
        } else
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT*/
        {
            qid =  _bcmFieldQualifyData0;
        }
    } else if (idx >= stage_fc->data_ctrl->num_elems &&
               idx < stage_fc->data_ctrl->num_elems * 2) {
        qid =  _bcmFieldQualifyData1;
        idx -= stage_fc->data_ctrl->num_elems;
    } else {
        return (BCM_E_INTERNAL);
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, eid, qid,
                                          &data, &mask,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, eid, qid,
                                                &data, &mask));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get entry qualifier should be installed in. */
    f_ent = NULL;
    rv = _bcm_field_entry_qual_get(unit, eid, qid, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get entry qualifier offset in tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qid, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    if (SOC_IS_ENDURO(unit)
        || SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit)
        || SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)
        || SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND2(unit)) {
        if ((qid == _bcmFieldQualifyData2)
            || (qid == _bcmFieldQualifyData3)) {
            /* Don't have to swap if only one chunk used in UDF1 */
            idx = 0;
        } else {
            idx = (stage_fc->data_ctrl->num_elems - 1) - idx;
        }
    } else
#endif /* !BCM_ENDURO_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_TD_TT(unit)
        || SOC_IS_KATANAX(unit)
        || SOC_IS_TRIUMPH3(unit)) {
        if (qid == _bcmFieldQualifyData3) {
            if (2 == idx) {
                /* Shift of 2 bytes (16 bits). */
                idx = 1;
            } else {
                idx = 0;
            }
        } else {
            idx = (stage_fc->data_ctrl->num_elems - 1) - idx;
        }
    } else
#endif
    {
        idx = (stage_fc->data_ctrl->num_elems - 1) - idx;
    }

    sal_memcpy(&q_offset_temp, q_offset,
               sizeof(_bcm_field_qual_offset_t));

    q_offset_temp.offset[0] += idx * stage_fc->data_ctrl->elem_size * 8;
    q_offset_temp.width[0] = stage_fc->data_ctrl->elem_size * 8;
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, &q_offset_temp, f_ent, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function: _field_external_qualify_data_elem
 *
 * Purpose:
 *
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     eid           - (IN) Entry ID.
 *     f_dq          - (IN) Data qualifier descriptor.
 *     qual_elem_idx - (IN) Data qualifier element index.
 *     data          - (IN) Data bytes for the indicated data qualifier.
 *                Network byte ordered.
 *     mask     - Mask bytes for the indicated data qualifier.
 *                Network byte ordered.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_external_qualify_data_elem(int unit, bcm_field_entry_t eid,
                         _field_data_qualifier_t *f_dq,
                         uint8 qual_elem_idx,
                         uint32 data, uint32 mask)
{
    _field_stage_t           *stage_fc;
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent = NULL;
    int                      idx;
    int                      rv;
    int                      elem_idx = 0;
    int                      qid = 0;

    /* Input parameters check. */
    if (NULL == f_dq) {
        return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: eid (%d): qual_elem_idx (%d)"
                           "data (%x) mask (%x)\n"), unit, eid, qual_elem_idx, data, mask));

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    /* Find a proper element to insert the data. */
    for (idx = 0; idx < (stage_fc->data_ctrl->num_elems - 2); idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            if (elem_idx == qual_elem_idx) {
                break;
            } else {
                elem_idx++;
            }
        }
    }

    /* Get data qualifier id. */
    if ((f_dq->hw_bmap & 0x1) && (idx >= 0 && idx < 2)) {
        qid =  _bcmFieldQualifyData0;
    } else if ((f_dq->hw_bmap & 0x2) && (idx == 1)) {
        qid =  _bcmFieldQualifyData2;
    } else {
        return (BCM_E_INTERNAL);
    }

    /* Get entry qualifier should be installed in. */
    rv = _bcm_field_entry_qual_get(unit, eid, qid, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get entry qualifier offset in tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qid, &q_offset);
    BCM_IF_ERROR_RETURN(rv);
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}


/*
 * Function: _field_qualify_data
 *
 * Purpose:
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     eid      - (IN) Entry ID.
 *     qual_id  - (IN) Data qualifier id.
 *     data     - (IN) Data bytes for the indicated data qualifier.
 *                     Network byte ordered.
 *     mask     - (IN) Mask bytes for the indicated data qualifier.
 *                     Network byte ordered.
 *     length   - (IN) data/mask length.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qualify_data (int unit, bcm_field_entry_t eid, int qual_id,
                     uint8 *data, uint8 *mask, uint16 length)
{
    _field_stage_t          *stage_fc;  /* Stage field control.       */
    _field_data_qualifier_t *f_dq;      /* Data qualifier descriptor. */
    int                     idx;        /* HW bitmap iteration index. */
    int                     byte_offset;/* Byte offset in the word.   */
    int                     qual_elem_idx; /* Qualifier element index.*/
    uint32                  data_elem;  /* Hw info data word.         */
    uint32                  mask_elem;  /* Hw info data mask.         */
    uint8                   data_qual_done = 0;
    int                     rv;         /* Operation return status.   */
#ifdef BCM_TRIUMPH_SUPPORT
    _field_entry_t          *entry_p = NULL; /* Field entry pointer */
#endif

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
            return (BCM_E_PARAM);
    }



    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

#ifdef BCM_TRIUMPH_SUPPORT
    rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &entry_p);
    BCM_IF_ERROR_RETURN(rv);
#endif

    /*
     * If provided entry data length is greater than data length used
     * to create qualifier then return error
     */

    if (length > f_dq->length) {
        return (BCM_E_PARAM);
    }

#ifdef BCM_TOMAHAWK_SUPPORT
   if (_BCM_FIELD_STAGE_EXACTMATCH == entry_p->group->stage_id) {
       if (length != f_dq->length) {
           return BCM_E_PARAM;
       }
   }
#endif

#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
        /* Get entry qualifier should be installed in. */
        if (entry_p->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            if (length > 4) {
                return (BCM_E_PARAM);
            }
        }
    }
#endif

    data_elem = 0;
    mask_elem = 0;
    qual_elem_idx = 0;
    byte_offset = f_dq->byte_offset;
    for (idx = 0; idx < length; idx++) {

#ifdef BCM_TOMAHAWK_SUPPORT
        if (_BCM_FIELD_STAGE_EXACTMATCH == entry_p->group->stage_id) {
            if (0xFF != mask[idx]) {
                return BCM_E_PARAM;
            }
        }
#endif

        data_elem |= (data[idx] << (8 * (stage_fc->data_ctrl->elem_size - 1 -
                                         byte_offset)));
        mask_elem |= (mask[idx] << (8 * (stage_fc->data_ctrl->elem_size - 1 -
                                         byte_offset)));
        byte_offset++;
        data_qual_done = 0;

        if (byte_offset == stage_fc->data_ctrl->elem_size) {
            /* Install the element data & mask. */
#ifdef BCM_TRIUMPH_SUPPORT
            if ((SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) &&
                (entry_p->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL)) {
                rv = _field_external_qualify_data_elem(unit, eid,
                                                       f_dq, qual_elem_idx,
                                                       data_elem, mask_elem);
            } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
            if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                    !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)) {
                rv = _bcm_field_th_field_qualify_data_elem(unit, eid, f_dq, qual_elem_idx,
                        data_elem, mask_elem);
            } else
#endif
            {
                rv = _field_qualify_data_elem(unit, eid, f_dq, qual_elem_idx,
                                              data_elem, mask_elem);
            }
            BCM_IF_ERROR_RETURN(rv);
            qual_elem_idx++;
            byte_offset = 0;
            data_elem = 0;
            mask_elem = 0;
            data_qual_done = 1;
        }
    }

    /* Install last element data & mask, if data/mask still exists to be qualified.
     * (data_qual_done == 0)
     */

    if (data_qual_done != 1) {
#ifdef BCM_TRIUMPH_SUPPORT
        if ((SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) &&
            (entry_p->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL)) {
            rv = _field_external_qualify_data_elem(unit, eid, f_dq,
                                                   qual_elem_idx, data_elem,
                                                   mask_elem);
        } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)) {
            rv = _bcm_field_th_field_qualify_data_elem(unit, eid, f_dq, qual_elem_idx,
                    data_elem, mask_elem);
        } else
#endif
        {
            rv = _field_qualify_data_elem(unit, eid, f_dq, qual_elem_idx,
                                          data_elem, mask_elem);
        }
    }
    return (rv);
}

/*
 * Function:
 *     _field_selcode_assign
 *
 * Purpose:
 *     Calculate the FPFx select codes from a qualifier set and group mode.
 *
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     qset           - (IN) Client qualifier set.
 *     selcode_clear  - (IN) Clear the selcodes
 *     fg             - (IN/OUT) Group info structure.
 *
 * Returns:
 *     BCM_E_PARAM    - mode unknown
 *     BCM_E_RESOURCE - No select code will satisfy qualifier set
 *     BCM_E_NONE     - Success
 *
 * Notes:
 *     Calling function is responsible for ensuring appropriate slices
 *     are available.
 *     selcode_clear will be 0 (don't clear) when this function is called
 *         from bcm_field_group_set
 */
int
_field_selcode_assign(int unit, bcm_field_qset_t qset, int selcode_clear,
                      _field_group_t *fg)
{
    _field_stage_t      *stage_fc;  /* Stage field control structure. */
    _field_control_t    *fc;        /* Field control structure.       */
    int                 idx;        /* Generic iteration index.       */

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure for this device. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get stage FP control info. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, fg->stage_id, &stage_fc));

    /*
     * Clear the group's slice Qsets.
     *   Selcodes need not be cleared if this function is called from group_set
     */
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        if (selcode_clear) {
            _FIELD_SELCODE_CLEAR(fg->sel_codes[idx]);
            BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(fg, idx));
        }
    }

    /* Get select codes based on group flags. */
    BCM_IF_ERROR_RETURN (fc->functions.fp_selcode_get(unit, stage_fc,
                                                      &qset, fg));
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_meters_deinit
 * Purpose:
 *     Deinitialize field slice meters usage bitmap.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     The External stage of Triumph shares the meter pool with Ingress.
 *         free only when it is called for Ingress.
 */
STATIC int
_field_meters_deinit (int unit, _field_stage_t *stage_fc)
{
    _field_slice_t   *slice;      /* Slice config structure. */
    int              slice_idx;   /* Slices iterator.        */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_NONE);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        int i;
        if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            return (BCM_E_NONE);
        }
        for (i = 0; i < stage_fc->num_meter_pools; i++) {
            if (stage_fc->meter_pool[_FP_DEF_INST][i] != NULL) {
                if (stage_fc->meter_pool[_FP_DEF_INST][i]->meter_bmp.w
                    != NULL) {
                    sal_free(
                        stage_fc->meter_pool[_FP_DEF_INST][i]->meter_bmp.w);
                }
                sal_free(stage_fc->meter_pool[_FP_DEF_INST][i]);
                stage_fc->meter_pool[_FP_DEF_INST][i] = NULL;
            }
        }

#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit)) {
            for (i = 0; i < stage_fc->num_logical_meter_pools; i++) {
                if (stage_fc->logical_meter_pool[i] != NULL) {
                    if (stage_fc->logical_meter_pool[i]->meter_bmp.w != NULL) {
                        sal_free(stage_fc->logical_meter_pool[i]->meter_bmp.w);
                    }
                    sal_free(stage_fc->logical_meter_pool[i]);
                    stage_fc->logical_meter_pool[i] = NULL;
                }
            }
        }
#endif

        return BCM_E_NONE;
    }

    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        slice = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        if (NULL != slice->meter_bmp.w) {
            sal_free(slice->meter_bmp.w);
        }
        slice->meter_bmp.w = NULL;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_counters_deinit
 * Purpose:
 *     Deinitialize field slice counters bitmap.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */

STATIC void
_field_cntr_pools_deinit(int unit, _field_stage_t *stage_fc)
{
    _field_cntr_pool_t **pp, *p;
    unsigned           n;

    for (pp = stage_fc->cntr_pool, n = COUNTOF(stage_fc->cntr_pool); n; --n, ++pp) {
        if ((p = *pp) == 0) {
            continue;
        }

        sal_free(p->cntr_bmp.w);
        sal_free(p);

        *pp = 0;
    }
}


STATIC int
_field_counters_deinit(int unit, _field_stage_t *stage_fc)
{
    _field_slice_t   *slice;      /* Slice config structure.   */
    int              slice_idx;   /* Slices iterator.        */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_NONE);
    }

    /* Destroy 64 bit counters. */
    _field_counter_collect_deinit(unit, stage_fc);

    /*
     * There is an 1-1 mapping between rules and counters
     * for external FP, so no bitmap was allocated.
     *     (Triumph)
     */
    if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
        return (BCM_E_NONE);
    }

    /* Denitialize stage slices info. */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id) {
        if (NULL != stage_fc->slices[_FP_DEF_INST][0].counter_bmp.w) {
            sal_free (stage_fc->slices[_FP_DEF_INST][0].counter_bmp.w);
        }
        for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            stage_fc->slices[_FP_DEF_INST][slice_idx].counter_bmp.w = NULL;
        }
    } else if (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) {
#if defined(BCM_TRIUMPH2_SUPPORT)
        /* Deallocate flexible stat counters. */
        if (soc_feature(unit, soc_feature_field_vfp_flex_counter)) {
            _bcm_esw_flex_stat_release_handles(unit, _bcmFlexStatTypeFp);
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
    } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    {
        for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            slice = stage_fc->slices[_FP_DEF_INST] + slice_idx;
            if (NULL != slice->counter_bmp.w) {
                sal_free (slice->counter_bmp.w);
            }
            slice->counter_bmp.w = NULL;
        }
    }

    _field_cntr_pools_deinit(unit, stage_fc);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stage_delete
 *
 * Purpose:
 *     Deinitialize field stage.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     fc        - (IN/OUT)Field control info for device.
 *     stage_fc  - (IN) Stage control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_stage_delete(int unit, _field_control_t *fc, _field_stage_t *stage_fc)
{
    _field_stage_t        *stage_iter;    /* Device stages iterator. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Destroy data qualifiers control structure */
    _field_stage_data_ctrl_deinit(unit, stage_fc);

    /* Deallocate stage qualifiers */
    _bcm_field_stage_qualifiers_free(unit, stage_fc);

    /* Free stage slices info. */
    if (NULL != stage_fc->slices[_FP_DEF_INST]) {

        /* Deallocate counters usage bitmap. */
        _field_counters_deinit(unit, stage_fc);

        /* Deallocate meters usage bitmap. */
        _field_meters_deinit(unit, stage_fc);

        /* Deallocate the entry pointers */
        _bcm_field_stage_entries_free(unit, stage_fc);

        /* Deallocate the priority management structures */
        _bcm_field_prio_mgmt_deinit(unit, stage_fc);

        sal_free(stage_fc->slices[_FP_DEF_INST]);
        stage_fc->slices[_FP_DEF_INST] = NULL;
    }

    /* destroy all ranges */
    while (stage_fc->ranges != NULL) {
        bcm_esw_field_range_destroy(unit, stage_fc->ranges->rid);
    }

    /* Destroy redirect action profile. */
    soc_profile_mem_destroy(unit, &stage_fc->redirect_profile);

    /* Destroy action profile */
    soc_profile_mem_destroy(unit, &stage_fc->ext_act_profile);
#ifdef  BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        soc_profile_mem_destroy(unit, &stage_fc->hash_select[0]);

        soc_profile_mem_destroy(unit, &stage_fc->hash_select[1]);
    }
#endif
    /* Remove stage from stages linked list. */
    stage_iter = fc->stages;
    while (NULL != stage_iter) {
        if (stage_iter == stage_fc) {
            fc->stages = stage_fc->next;
            break;
        } else if (stage_iter->next == stage_fc) {
            stage_iter->next = stage_fc->next;
            break;
        }
        stage_iter = stage_iter->next;
    }

    /* Free stage info. */
    sal_free(stage_fc);
    stage_fc = NULL;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stages_destroy
 *
 * Purpose:
 *     Deinitialize field stages within the field control struct.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fc -   (IN/OUT)Field control info for device.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_stages_destroy(int unit, _field_control_t *fc)
{
    _field_stage_t *stage_fc; /* Stage field control structure. */

    /* Input parameters check. */
    if (fc == NULL) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    /* Free stages & slices structures. */
    while (NULL != fc->stages) {
        stage_fc = fc->stages;

        /* Free stage resources & stage itself. */
        _field_stage_delete(unit, fc, stage_fc);
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qset_union
 *
 * Purpose:
 *     make a union of two qsets
 *
 * Parameters:
 *     qset1      - source 1
 *     qset2      - source 2
 *     qset_union - (OUT) result of union operation
 *
 * Returns:
 *     BCM_E_NONE - Success
 */
int
_field_qset_union(const bcm_field_qset_t *qset1,
                  const bcm_field_qset_t *qset2,
                  bcm_field_qset_t *qset_union)
{
    int                    idx;

    if (NULL == qset_union) {
        return (BCM_E_PARAM);
    }


    /* Perform the union of the qualifier bitmap. */
    for (idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_QUALIFY_MAX); idx++) {
        qset_union->w[idx] = qset1->w[idx] | qset2->w[idx];
    }

    /* Perform the union of the qualifier udfs. */
    for (idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_USER_NUM_UDFS); idx++) {
        qset_union->udf_map[idx] = qset1->udf_map[idx] | qset2->udf_map[idx];
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qset_is_subset
 * Purpose:
 *     Determine if qset one is a subset of qset two.
 * Parameters:
 *     qset_1
 *     qset_2
 * Returns:
 *     TRUE - if 'qset_1' is a subset of 'qset_2'
 *     FALSE - if 'qset_1' is NOT a subset of 'qset_2'
 */
int
_field_qset_is_subset(const bcm_field_qset_t *qset_1,
                      const bcm_field_qset_t *qset_2)
{
    int                 idx;

    for (idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_QUALIFY_MAX); idx++) {
        if ((qset_1->w[idx] | qset_2->w[idx]) & ~qset_2->w[idx]) {
            return (FALSE);
        }
    }
    return (TRUE);
}

/*
 * Function:
 *     _field_qset_diff
 * Purpose:
 *     Calculate the result of subtracting qset_2 from qset_1
 * Parameters:
 *     qset_1 - First parameter
 *     qset_2 - Second parameter
 * Returns:
 *     (qset_1 - qset_2)
 */
bcm_field_qset_t
_field_qset_diff(const bcm_field_qset_t qset_1,
                 const bcm_field_qset_t qset_2)
{
    int                 idx;
    bcm_field_qset_t    qset_result;

    BCM_FIELD_QSET_INIT(qset_result);
    for (idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_QUALIFY_MAX); idx++) {
        qset_result.w[idx] = qset_1.w[idx] & ~qset_2.w[idx];
    }
    return qset_result;
}

/*
 * Function:
 *     _field_qset_is_empty
 * Purpose:
 *     Detect empty Qsets
 * Parameters:
 *     qset - Qset to be tested
 * Returns:
 *     1 if qset has no qualifiers
 *     0 if qset has at least one qualifier
 */
int
_field_qset_is_empty(const bcm_field_qset_t qset)
{
    int                 idx;

    for (idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_QUALIFY_MAX); idx++) {
        if (qset.w[idx] != 0) {
            return 0;
        }
    }
    return 1;
}

/*
 * Function:
 *     _bcm_field_qset_test
 * Purpose:
 *     Identify if qualifier is part of the qset.
 * Parameters:
 *     qid    - Qualifier id.
 *     qset   - Qset to be tested
 *     result - Result
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qset_test(bcm_field_qualify_t qid, bcm_field_qset_t *qset,
                             uint8 *result)
{
    bcm_field_qset_t  test_qset;

    /* Input parameters check. */
    if ((NULL == qset) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    BCM_FIELD_QSET_INIT(test_qset);
    BCM_FIELD_QSET_ADD(test_qset, qid);

    *result = (_field_qset_is_subset(&test_qset, qset)) ? TRUE : FALSE;
    return (BCM_E_NONE);
}

/*
 * Function: _bcm_esw_field_group_mode_get
 *
 * Purpose:
 *     Return the mode of a Group ID. This is its single, double or triple-wide
 *     state. Mode specified the number of slices allocated to the group.
 *
 * Parameters:
 *     flags - (IN) Field group flags.
 *     mode  - (OUT) single, double, triple or auto mode.
 *
 * Returns:
 *     BCM_E_XXX
 *
 */
int
_bcm_esw_field_group_mode_get(uint32 flags, bcm_field_group_mode_t *mode)
{
    /* Input parameters check. */
    if (mode == NULL) {
        return (BCM_E_PARAM);
    }

    if (flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        *mode = bcmFieldGroupModeTriple;
    } else if (flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        if (flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            *mode = bcmFieldGroupModeQuad;
        } else {
            *mode = bcmFieldGroupModeDouble;
        }
    } else if (flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        if (flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            *mode = bcmFieldGroupModeIntraSliceDouble;
        } else {
            *mode = bcmFieldGroupModeSingle;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qual_name
 * Purpose:
 *     Translate a Qualifier enum value to a text string.
 * Parameters:
 *     Enum value from bcm_field_qualify_e. (ex.bcmFieldQualifyInPorts)
 * Returns:
 *     Text name of indicated qualifier enum value.
 */
char *
_field_qual_name(bcm_field_qualify_t qid)
{
    /* Text names of the enumerated qualifier IDs. */
    static char *qual_text[bcmFieldQualifyCount] = BCM_FIELD_QUALIFY_STRINGS;
    static char *_qual_text[_bcmFieldQualifyCount - bcmFieldQualifyCount] =
                                                  _BCM_FIELD_QUALIFY_STRINGS;

    if (qid < bcmFieldQualifyCount) {
        return qual_text[qid];
    } else if ((int)qid < _bcmFieldQualifyCount) {
        return _qual_text[qid - bcmFieldQualifyCount];
    }
    return "UnknownQualifier";
}

/*
 * Function:
 *     _field_stage_name
 * Purpose:
 *     Translate group pipeline  stage to a text string.
 * Parameters:
 *     stage_fc stage field control structure.
 * Returns:
 *     Text name of indicated stage qualifier enum value.
 */
char *
_field_stage_name(_field_stage_t *stage_fc)
{
    static char *stage_text[] = _BCM_FIELD_STAGE_STRINGS;

    if (stage_fc->stage_id >= COUNTOF(stage_text)) {
        return "??";
    }
    return stage_text[stage_fc->stage_id];
}

/*
 * Function:
 *     _field_action_name
 * Purpose:
 *     Return text name of indicated action enum value.
 */
char *
_field_action_name(bcm_field_action_t action)
{
    /* Text names of Actions. These are used for debugging output and CLIs.
     * Note that the order needs to match the bcm_field_action_t enum order.
     */
    static char *action_text[] = BCM_FIELD_ACTION_STRINGS;
    assert(COUNTOF(action_text)     == bcmFieldActionCount);

    return (action >= bcmFieldActionCount ? "??" : action_text[action]);
}


/*
 * Function:
 *     _field_group_mode_name
 * Purpose:
 *     Return text name of indicated group mode enum value.
 */
char *
_field_group_mode_name(uint32 group_flags)
{
    bcm_field_group_mode_t mode = 0;
    static char *mode_text[bcmFieldGroupModeCount] =
                 BCM_FIELD_GROUP_MODE_STRINGS;

    _bcm_esw_field_group_mode_get(group_flags, &mode);

    return (mode >= bcmFieldGroupModeCount ? "??" : mode_text[mode]);
}

/* Section: Field Initialization */

/*
 * Function: _field_control_free
 *
 * Purpose:
 *    Free field_control structure.
 *
 * Parameters:
 *     unit - (IN) BCM device number
 *     fc   - (IN) Field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_control_free(int unit, _field_control_t *fc)
{
 #ifdef BCM_TOMAHAWK_SUPPORT
    int inst;       /* Instance Iterator.   */
    int lt_idx;     /* Logical Table Index. */
 #endif
    _field_control[unit] = NULL;

    if (NULL == fc) {
        return (BCM_E_NONE);
    }

    /* Free policers lookup hash. */
    if (NULL != fc->policer_hash) {
        sal_free(fc->policer_hash);
        fc->policer_hash = NULL;
    }

    /* Free counters lookup hash. */
    if (NULL != fc->stat_hash) {
        sal_free(fc->stat_hash);
        fc->stat_hash = NULL;
    }

    /* Free udf configuration. */
    if (NULL != fc->udf) {
        sal_free(fc->udf);
        fc->udf = NULL;
    }

    /* Free Hints lookup hash. */
    if (NULL != fc->hints_hash) {
        sal_free(fc->hints_hash);
        fc->hints_hash = NULL;
    }

    /* Free Hints bitmap. */
    if (NULL != fc->hintid_bmp.w) {
        sal_free(fc->hintid_bmp.w);
        fc->hintid_bmp.w = NULL;
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    /* Free presel lookup database. */
    if (NULL != fc->presel_db) {
        sal_free(fc->presel_db);
        fc->presel_db = NULL;
    }

    /* Free presel information. */
    if (NULL != fc->presel_info) {
        sal_free(fc->presel_info);
        fc->presel_info = NULL;
    }

    /* Free logical table information. */
    for (inst = 0; inst < NUM_PIPE(unit); inst++) {
        for (lt_idx = 0; lt_idx < _FP_MAX_NUM_LT; lt_idx++) {
            if (NULL != fc->lt_info[inst][lt_idx]) {
                sal_free(fc->lt_info[inst][lt_idx]);
                fc->lt_info[inst][lt_idx] = NULL;
            }
        }
    }
#endif

#if defined (BCM_TRIUMPH3_SUPPORT)
    /* Free L2changeFields bitmap. */
    if( (SOC_IS_TRIUMPH3(unit)) &&
        (NULL != fc->field_action_l2mod_index_bmp.w) ) {
        sal_free (fc->field_action_l2mod_index_bmp.w);
        fc->field_action_l2mod_index_bmp.w = NULL;
    }
#endif

    /* Free module control structure. */
    sal_free(fc);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_egr_ports_recovery_control_free
 * Purpose:
 *         Free f_egr_recovery structure
 * Parameters:
 *     unit           -  (IN) BCM unit number.
 *     f_egr_recovery - (OUT) Field Egr_ports_recovery
 *                            structure.
 * Returns:
 *     BCM_E_XXX
 */

int
_field_egr_ports_recovery_control_free (int unit,
                        _field_egr_ports_recovery_t *f_egr_recovery
                                       )
{
    _field_egr_ports_recovery[unit] = NULL;

    if (NULL == f_egr_recovery) {
        return (BCM_E_PARAM);
    }

    if (f_egr_recovery->entry_recover_egr_ports != NULL) {
        sal_free (f_egr_recovery->entry_recover_egr_ports);
        f_egr_recovery->entry_recover_egr_ports = NULL;
    }

    sal_free (f_egr_recovery);
    f_egr_recovery = NULL;

    return BCM_E_NONE;
}


/*
 * Function:
 *     _bcm_field_stages_supported_qset_init
 *
 * Purpose:
 *     Initialize field stages supported qset for each stage
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_MEMORY - Allocation failure
 */
int
_bcm_field_stages_supported_qset_init(int unit, _field_control_t *fc)
{
    _field_stage_t   *stage_fc; /* Stage field control structure. */
    bcm_field_qset_t *qset;     /* Operation result.              */
    int idx;                    /* Iteration index.               */

    /* Fill supported qset for each  pipeline stage. */
    stage_fc = fc->stages;
    while (NULL != stage_fc) {
        qset = &stage_fc->_field_supported_qset;
        if (stage_fc->f_qual_arr != NULL ) {
            for (idx = 0; idx < _bcmFieldQualifyCount; idx++) {
                if (NULL != stage_fc->f_qual_arr[idx]) {
                    BCM_FIELD_QSET_ADD(*qset, (stage_fc->f_qual_arr[idx])->qid);
                }
            }
        }
        stage_fc = stage_fc->next;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_tcam_info_init
 * Purpose:
 *     Initialize TCAM related information in Field Control
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Stage field control structure pointer.
 *     fc       - (IN/OUT) Field control infoformation for device.
 *
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_tcam_info_init(int unit, _field_stage_t *stage_fc,  _field_control_t *fc)
{
    soc_mem_t mem = INVALIDm;            /* FP tcam memory id for stage/device. */

    /* Input parameters check. */
    if ((NULL == fc) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
#ifdef BCM_TRIUMPH_SUPPORT
        if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
            stage_fc->tcam_slices = 9;
    }
#endif /* BCM_TRIUMPH_SUPPORT */
        return BCM_E_NONE;
    }

    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
#ifdef BCM_FIREBOLT_SUPPORT
          if (SOC_IS_FBX(unit)) {
              mem = FP_TCAMm;
          }
#endif /* BCM_FIREBOLT_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (soc_feature(unit, soc_feature_field_multi_stage)) {

        if (_BCM_FIELD_STAGE_LOOKUP  == stage_fc->stage_id) {
            mem = VFP_TCAMm;
        } else if (_BCM_FIELD_STAGE_EGRESS  == stage_fc->stage_id) {
            mem = EFP_TCAMm;
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT*/
    } else {
        return (BCM_E_UNAVAIL);
    }

    if (INVALIDm == mem) {
        return (BCM_E_UNAVAIL);
    }

    /* Get tcam size. */
    stage_fc->tcam_sz = soc_mem_index_count(unit, mem);

    /* Note fc->tcam_slices only counts internal slices. */
    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        if (soc_feature(unit, soc_feature_field_slices2)) {
            stage_fc->tcam_slices   = 2;
        } else if (soc_feature(unit, soc_feature_field_slices4)) {
            stage_fc->tcam_slices  = 4;
        } else if (soc_feature(unit, soc_feature_field_slices8))  {
            stage_fc->tcam_slices  = 8;
        } else if (soc_feature(unit, soc_feature_field_slices12)) {
            stage_fc->tcam_slices  = 12;
        } else if (soc_feature(unit, soc_feature_field_slices10)) {
            stage_fc->tcam_slices  = 10;
        } else {
            stage_fc->tcam_slices  = 16;
        }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (soc_feature(unit, soc_feature_field_multi_stage)) {
        if (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) {
            stage_fc->tcam_slices = 4;
        } else if (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id) {
            stage_fc->tcam_slices = 4;
        } else {
            return (BCM_E_PARAM);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    } else {
        return (BCM_E_PARAM);
    }


    /*  Check external tcam presence for ingress (default stage) */
    /* Only for EasyRider; Triumph taken care of elsewhere */
    fc->tcam_ext_numb = FP_EXT_TCAM_NONE;

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_meter_pools_init
 * Purpose:
 *     Initialize field meter pools usage bitmap.
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_meter_pools_init(int unit, _field_stage_t *stage_fc)
{
    int              meter_pair_num;   /* Number of meter pairs.           */
    int              pool_idx;         /* Meter pools iterator.            */
    int              size;             /* Allocation size.                 */
    uint16           pool_size;        /* Total number of meters in pool.  */
#ifdef BCM_TRIUMPH3_SUPPORT
    int              rv;               /* Operation return status.         */
#endif


    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if (0 == (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_INTERNAL);
    }

    /* Set number of meters. */
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
    if (soc_feature(unit, soc_feature_field_meter_pools4)) {
        meter_pair_num = _BCM_FIELD_SC_INGRESS_DOUBLE_WIDE_SLICE_SZ;
    } else
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIUMPH_SUPPORT)
    if ((stage_fc->flags & _FP_STAGE_HALF_SLICE) &&  \
        (!soc_feature(unit,soc_feature_field_slice_size128))) {
        meter_pair_num = _BCM_FIELD_SLICE_SIZE(stage_fc, _FP_DEF_INST, 0);
    } else
#endif /* BCM_TRIUMPH_SUPPORT */
    {
        meter_pair_num = _BCM_FIELD_SLICE_SIZE(stage_fc, _FP_DEF_INST, 0) >> 1;
#if defined(BCM_HURRICANE1_SUPPORT)
        if (SOC_IS_HURRICANE(unit)) {
            /* hurricane has 64 meter pairs/pool */
            meter_pair_num = meter_pair_num / 2;
        }
#endif /* BCM_HURRICANE1_SUPPORT */
    }

    pool_size = (meter_pair_num * 2);

    /* Get number of meter pools for the device. */
    if (soc_feature(unit, soc_feature_field_meter_pools4)) {
        stage_fc->num_meter_pools = 4;
    } else if (soc_feature(unit, soc_feature_field_meter_pools8)) {
        stage_fc->num_meter_pools = 8;
    } else if (soc_feature(unit, soc_feature_field_meter_pools12)) {
        stage_fc->num_meter_pools = 12;
    } else {
        stage_fc->num_meter_pools = 16;
    }

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_meter_pool_info(unit,
                                                    stage_fc,
                                                    &stage_fc->num_meter_pools,
                                                    &meter_pair_num, &pool_size)
                            );
    }
#endif

    /* Total meters per pool = 2 * (No. of meter pairs) */
    size = SHR_BITALLOCSIZE(meter_pair_num << 1);

    for (pool_idx = 0; pool_idx < stage_fc->num_meter_pools; pool_idx++) {
        /* Allocate pool usage bitmap. */
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx] =
            sal_alloc(sizeof(_field_meter_pool_t), "fp_meter_pool");
        if (stage_fc->meter_pool[_FP_DEF_INST][pool_idx] == NULL) {
            _field_meters_deinit (unit, stage_fc);
            return (BCM_E_MEMORY);
        }

        /* Initalize stage meter pool info. */
        /* Pool is not in use. */
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->slice_id = -1;
        /* Level not yet set */
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->level = -1;
        /* Total number of meters in pool. */
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->pool_size = pool_size;
        /* Number of valid meters in pool.*/
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->size = (meter_pair_num
                                                                * 2);
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->free_meters =
            (meter_pair_num * 2);
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->num_meter_pairs =
            meter_pair_num;
        stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->meter_bmp.w =
            sal_alloc(size, "fp_meters_map");
        if (stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->meter_bmp.w == NULL) {
            _field_meters_deinit(unit, stage_fc);
            return (BCM_E_MEMORY);
        }

        /* Reset pool usage bitmap. */
        sal_memset(stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->meter_bmp.w,
            0, size);
    }

#ifdef BCM_TRIUMPH3_SUPPORT
        /* Logical Pools supported in Triumph3.Init corresponding
         * data structures.
         */
        if (SOC_IS_TRIUMPH3(unit)) {
            rv =  _field_tr3_logical_meter_pools_init (unit, stage_fc);
            if (rv == BCM_E_MEMORY) {
                _field_meters_deinit(unit, stage_fc);
            }
            return (rv);
        }
#endif
    return BCM_E_NONE;
}


STATIC int
_field_cntr_pool_info(int            unit,
                      _field_stage_t *stage_fc,
                      unsigned       *cntrs_per_pool
                      )
{
    stage_fc->num_cntr_pools = 0;

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_cntr_pool_info(unit,
                                                          stage_fc,
                                                          &stage_fc->num_cntr_pools,
                                                          cntrs_per_pool
                                                          )
                            );
    }
#endif

    return (BCM_E_NONE);
}


STATIC int
_field_cntr_pools_init(int unit, _field_stage_t *stage_fc)
{
    int                errcode = BCM_E_NONE;
    unsigned           cntrs_per_pool, bmap_size_bytes, n;
    _field_cntr_pool_t **pp, *p;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_INTERNAL);
    }

    BCM_IF_ERROR_RETURN(_field_cntr_pool_info(unit,
                                              stage_fc,
                                              &cntrs_per_pool
                                              )
                        );

    bmap_size_bytes = SHR_BITALLOCSIZE(cntrs_per_pool);

    for (pp = stage_fc->cntr_pool, n = stage_fc->num_cntr_pools; n; --n, ++pp) {
        if ((p = SAL_ALLOC_T(_field_cntr_pool_t, 1)) == 0) {
            errcode = BCM_E_MEMORY;
            break;
        }

        p->slice_id = -1;
        p->size = p->free_cntrs = cntrs_per_pool;
        if ((p->cntr_bmp.w = (SHR_BITDCL *) sal_alloc(bmap_size_bytes, " ")) == 0) {
            sal_free(p);
            errcode = BCM_E_MEMORY;
            break;
        }
        sal_memset(p->cntr_bmp.w, 0, bmap_size_bytes);

        *pp = p;
    }

    if (errcode != BCM_E_NONE) {
        _field_counters_deinit(unit, stage_fc);
    }

    return (errcode);
}


/*
 * Function:
 *     _field_meters_init
 * Purpose:
 *     Initialize field slice meters usage bitmap.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN) Field control structure.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     Triumph External stage uses the same meter pool as Ingress
 *     It is inited in _field_external_meters_init
 */
STATIC int
_field_meters_init(int unit, _field_stage_t *stage_fc)
{
    int              slice_idx;        /* Slices iterator.          */
    int              size;             /* Allocation size.          */
    _field_slice_t   *fs;              /* Slice config structure.   */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }


    /* External config was not processed yet - don't initialize meters.
     * Lookup stage has no meter support.
     */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL
        || stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
        return (BCM_E_NONE);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_INTERNAL);
    }

    /*
     * For devices with global meter pools
     * Initialize meter pools, skip slice bounded meters .
     */
    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        return _field_meter_pools_init(unit, stage_fc);
    }

    size = SHR_BITALLOCSIZE(_BCM_FIELD_SLICE_SIZE(stage_fc, _FP_DEF_INST, 0));

    /* Iterate over slices & initialize meter infor. */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;

        /* Allocate meter usage bitmap. */
        fs->meter_bmp.w = sal_alloc(size, "fp_meters_map");
        if (NULL == fs->meter_bmp.w) {
            _field_meters_deinit(unit, stage_fc);
            return (BCM_E_MEMORY);
        }

        /* Set slice meter count & reset usage bitmap. */
        fs->meters_count = _BCM_FIELD_SLICE_SIZE(stage_fc, _FP_DEF_INST, 0);
        sal_memset(fs->meter_bmp.w, 0, size);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_external_meters_init
 * Purpose:
 *     Initialize field meters for external FP
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN) Field control structure
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_external_meters_init(int unit, _field_control_t *fc)
{
    int i;
    _field_stage_t *stage_ingress, *stage_external, *stage_p;

    stage_external = stage_ingress = NULL;
    stage_p = fc->stages;

    while (stage_p) {
        if (stage_p->stage_id == _BCM_FIELD_STAGE_INGRESS) {
            stage_ingress = stage_p;
        } else if (stage_p->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            stage_external = stage_p;
        }
        stage_p = stage_p->next;
    }
    if ((stage_ingress == NULL) || (stage_external == NULL)) {
        return (BCM_E_INTERNAL);
    }

    stage_external->flags |=  _FP_STAGE_GLOBAL_METER_POOLS;
    stage_external->num_meter_pools = stage_ingress->num_meter_pools;
    for (i = 0; i < stage_external->num_meter_pools; i++) {
        if (stage_ingress->meter_pool[_FP_DEF_INST][i] == NULL) {
            return (BCM_E_INTERNAL);
        }
        stage_external->meter_pool[_FP_DEF_INST][i]
            = stage_ingress->meter_pool[_FP_DEF_INST][i];
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slice_counters_alloc
 * Purpose:
 *     Allocate counters usage bitmap for a slice.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     fs          - (IN/OUT) Slice control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_counters_alloc(int unit, _field_slice_t *fs)
{
    int size;            /* Allocation size. */
    /* Input parameters check. */
    if (NULL == fs) {
        return (BCM_E_PARAM);
    }

    size = SHR_BITALLOCSIZE(fs->counters_count);
    fs->counter_bmp.w = sal_alloc(size, "fp_counter_map");
    if (NULL == fs->counter_bmp.w) {
        return (BCM_E_MEMORY);
    }
    sal_memset(fs->counter_bmp.w, 0, size);
    return (BCM_E_NONE);
}

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *     _field_slice_counters_share
 * Purpose:
 *     Share counters usage bitmap between slices.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     stage_fc    - (IN/OUT) Stage field control structure.
 *     slice_src   - (IN) Slice sharing counters.
 *     slice_dst   - (IN) Slice receivingshared counters.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slice_counters_share(int unit, _field_stage_t *stage_fc,
                            int slice_src, int slice_dst)
{

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if (((slice_src < 0) || (slice_src >= stage_fc->tcam_slices)) ||
        ((slice_dst < 0) || (slice_dst >= stage_fc->tcam_slices))) {
        return (BCM_E_PARAM);
    }

    stage_fc->slices[_FP_DEF_INST][slice_dst].counter_bmp.w =
        stage_fc->slices[_FP_DEF_INST][slice_src].counter_bmp.w;

    return (BCM_E_NONE);
}
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */


/*
 * Function:
 *     _field_counter_memacc_alloc
 * Purpose:
 *     Initialize software cached memory access info for field counters
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_counter_memacc_alloc(int unit, soc_memacc_t **memacc_ptr)
{
    int mem_size;

    /* Input parameters check. */
    if (NULL == memacc_ptr) {
        return (BCM_E_PARAM);
    }

    mem_size = _FIELD_COUNTER_MEMACC_NUM * sizeof(soc_memacc_t);
    *memacc_ptr = sal_alloc(mem_size, "FP counter memory access cache");
    if (NULL == *memacc_ptr) {
        return (BCM_E_MEMORY);
    }
    sal_memset(*memacc_ptr, 0, mem_size);
    return (BCM_E_NONE);
}
/*
 * Function:
 *     _field_counter_collect_init
 * Purpose:
 *     Initialize software field 64bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN) Field control structure.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_counter_collect_init(int unit, _field_control_t *fc,
                            _field_stage_t *stage_fc)
{
    soc_mem_t counter_x_mem;        /* Pipeline 1 counters memory. */
    soc_mem_t counter_y_mem;        /* Pipeline 2 counters memory. */
    soc_memacc_t *memacc_list;      /* Memory access cache list.   */
    int retval = BCM_E_NONE;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (stage_fc->flags & _FP_STAGE_MULTI_PIPE_COUNTERS) {
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            return BCM_E_NONE;
        }
    }
#endif

    /*
     * For counter collection in chunks
     *     Relevant for External Counter Table of Triumph
     */
    stage_fc->counter_collect_table = 0;
    stage_fc->counter_collect_index = 0;

    BCM_IF_ERROR_RETURN(_field_counter_mem_get(unit, stage_fc,
                                               &counter_x_mem, &counter_y_mem));

    /* Check if stage has counters. */
    if (INVALIDm == counter_x_mem) {
        return (BCM_E_NONE);
    }

    /* Allocate space for cached counter memory access info */
    retval = _field_counter_memacc_alloc(unit,
                                   &(stage_fc->_field_memacc_counters));
    if (BCM_FAILURE(retval)) {
        return (retval);
    }
    memacc_list = stage_fc->_field_memacc_counters;

#if defined(BCM_TRX_SUPPORT)
    if (stage_fc->flags & _FP_STAGE_SEPARATE_PACKET_BYTE_COUNTERS) {
        retval = _field_counter32_collect_alloc(unit, counter_x_mem,
                                                "FP pipeline X counters",
                                                &stage_fc->_field_x32_counters);
        if (BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = _field_counter64_collect_alloc(unit, counter_x_mem,
                                                "FP pipeline X byte counters",
                                                &stage_fc->_field_x64_counters);
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = soc_memacc_init(unit, counter_x_mem, BYTE_COUNTERf,
                                 &(memacc_list[_FIELD_COUNTER_MEMACC_BYTE]));
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = soc_memacc_init(unit, counter_x_mem, PACKET_COUNTERf,
                            &(memacc_list[_FIELD_COUNTER_MEMACC_PACKET]));
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

#if defined (BCM_SCORPION_SUPPORT)
        if (soc_feature(unit, soc_feature_two_ingress_pipes)) {
            retval = _field_counter32_collect_alloc(unit, counter_y_mem,
                                                    "FP pipeline Y counters",
                                                    &stage_fc->_field_y32_counters);
            if(BCM_FAILURE(retval)) {
                _field_counter_collect_deinit(unit, stage_fc);
                return (retval);
            }

            retval = _field_counter64_collect_alloc(unit, counter_y_mem,
                                                    "FP pipeline Y byte counters",
                                                    &stage_fc->_field_y64_counters);
            if(BCM_FAILURE(retval)) {
                _field_counter_collect_deinit(unit, stage_fc);
                return (retval);
            }

            retval = soc_memacc_init(unit, counter_y_mem, BYTE_COUNTERf,
                         &(memacc_list[_FIELD_COUNTER_MEMACC_BYTE_Y]));
            if(BCM_FAILURE(retval)) {
                _field_counter_collect_deinit(unit, stage_fc);
                return (retval);
            }

            retval = soc_memacc_init(unit, counter_y_mem, PACKET_COUNTERf,
                         &(memacc_list[_FIELD_COUNTER_MEMACC_PACKET_Y]));
            if(BCM_FAILURE(retval)) {
                _field_counter_collect_deinit(unit, stage_fc);
                return (retval);
            }

        }
#endif /* BCM_SCORPION_SUPPORT */
    } else
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_BRADLEY_SUPPORT)
    if (soc_feature(unit, soc_feature_two_ingress_pipes)) {
        retval = _field_counter64_collect_alloc(unit, counter_x_mem,
                                                "FP pipeline X byte cntrs",
                                                &stage_fc->_field_x64_counters);
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = soc_memacc_init(unit, counter_x_mem, COUNTERf,
                     &(memacc_list[_FIELD_COUNTER_MEMACC_COUNTER]));
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = _field_counter64_collect_alloc(unit, counter_y_mem,
                                                "FP pipeline Y byte cntrs",
                                                &stage_fc->_field_y64_counters);
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = soc_memacc_init(unit, counter_y_mem, COUNTERf,
                     &(memacc_list[_FIELD_COUNTER_MEMACC_COUNTER_Y]));
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }
    } else
#endif /* BCM_BRADLEY_SUPPORT */
    {
        retval = _field_counter32_collect_alloc(unit, counter_x_mem,
                                                "FP pipeline X counters",
                                                &stage_fc->_field_x32_counters);
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }

        retval = soc_memacc_init(unit, counter_x_mem, COUNTERf,
                     &(memacc_list[_FIELD_COUNTER_MEMACC_COUNTER]));
        if(BCM_FAILURE(retval)) {
            _field_counter_collect_deinit(unit, stage_fc);
            return (retval);
        }
    }

    return (retval);
}

/*
 * Function:
 *     _field_counters_init
 * Purpose:
 *     Initialize field slice counters bitmap.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN) Field control structure.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_counters_init(int unit, _field_control_t *fc,
                         _field_stage_t *stage_fc)
{
    _field_slice_t   *fs;                 /* Slice config structure.    */
    int              slice_idx;           /* Slices iterator.           */
    int              retval;              /* Operation return value.    */
    int              cntr_share = FALSE;  /* Share counter with slice 0 */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_INTERNAL);
    }

    /* Allocate software 64 bit counters image. */
    BCM_IF_ERROR_RETURN(_field_counter_collect_init(unit, fc, stage_fc));

#if defined(BCM_TRIUMPH_SUPPORT)     \
    || defined(BCM_TRIUMPH2_SUPPORT) \
    || defined(BCM_TRIUMPH3_SUPPORT)
    /*
     * There is an 1-1 mapping between rules and counters
     * for external FP, so no bitmap needs to be allocated (Triumph and
     * Triumph2); Triumph3 EXTFP can access only flex counters.
     */
    if (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) {
        return (BCM_E_NONE);
    }
#endif /* BCM_TRIUMPH_SUPPORT || BCM_TRIUMPH2_SUPPORT || BCM_TRIUMPH3_SUPPORT */

    if (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS) {
        return (_field_cntr_pools_init(unit, stage_fc));
    }

    /* Allocate counters for each of the tcam slices. */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) {
            fs->counters_count = 0;
            continue;
        } else if (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id) {
            fs->counters_count = soc_mem_index_count(unit, EFP_COUNTER_TABLEm);

            if(stage_fc->flags & _FP_STAGE_HALF_SLICE) {
                fs->counters_count = fs->counters_count / 2;
            }
            if (slice_idx) {
                cntr_share = TRUE;
            }
        } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        {
           if (soc_feature(unit,soc_feature_field_slice_size128)) {
              fs->counters_count = fs->entry_count * 2;     /*Counters are double the number of TCAM entries*/
           } else {
              fs->counters_count = fs->entry_count;
           }
        }

        if (cntr_share) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            /* Share counters with slice zero(Global counter pool). */
            retval = _field_slice_counters_share(unit, stage_fc,
                                                 0, slice_idx);
            if (BCM_FAILURE(retval)) {
                _field_counters_deinit(unit, stage_fc);
                return (retval);
            }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        } else {
            /* Allocate new set of counters for the slice. */
            retval = _field_slice_counters_alloc(unit, fs);
            if (BCM_FAILURE(retval)) {
                _field_counters_deinit(unit, stage_fc);
                return (retval);
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entries_init
 * Purpose:
 *     Allocate the memory for entries in all the slices of the stage.
 *     External TCAM (for Triumph) is taken care of in _bcm_tr_field_init.
 *     Entries  will be de-allocated in bcm_esw_field_detach
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entries_init(int unit, _field_stage_t *stage_fc)
{
    int              slice_idx;    /* Slices iterator.                      */
    int              tcam_idx;     /* Slice first entry tcam index tracker. */
    int              mem_size;     /* Allocation size.                      */
    int              entry_ratio;  /* Invalid entries ratio.                */
    int              entry_ratio_per_slice; /* Invalid entries ratio for each
                                               slice. */
    _field_slice_t   *fs;          /* Slice config structure.               */

    /* Input parameters check. */
    if (NULL == stage_fc)  {
        return (BCM_E_PARAM);
    }

    /* Triumph external slice handled in _bcm_tr_field_init. */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        return (BCM_E_NONE);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[_FP_DEF_INST]) {
        return (BCM_E_INTERNAL);
    }

    entry_ratio = (stage_fc->flags & _FP_STAGE_QUARTER_SLICE) ? 4:
                      ((stage_fc->flags & _FP_STAGE_HALF_SLICE) ? 2 : 1);

    /* Iterate over all stage slices and allocated entries for each slice. */
    for (slice_idx = 0, tcam_idx = 0;
         slice_idx < stage_fc->tcam_slices; slice_idx++) {

        /* Default entry ratio per each slice equals to global entry ratio */
        entry_ratio_per_slice = entry_ratio;

        /* Get slice control structure pointer. */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;

        /* Get number of entries in the slice. */
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_field_ingress_two_slice_types)) &&
            (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            if (SOC_IS_TD2_TT2(unit)){
                if (slice_idx < _BCM_FIELD_TD2_INGRESS_DOUBLE_WIDE_SLICE0) {
                    fs->entry_count =
                        _BCM_FIELD_TD2_INGRESS_LARGE_SLICE_SZ;
                    if (soc_feature(unit,
                        soc_feature_field_stage_ingress_512_half_slice)) {
                        entry_ratio_per_slice = 2;
                        fs->entry_count /= entry_ratio_per_slice;
                    }
                } else {
                    fs->entry_count =
                        _BCM_FIELD_TD2_INGRESS_SMALL_SLICE_SZ;
                }

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                /* In Trident2 Plus number of entries in each slice is 4
                 * times entries in Trident2. For OTP variants of Td2Plus
                 * entry ratio will be used to reduce the entry count
                 */
                if (SOC_IS_TD2P_TT2P(unit)) {
                    fs->entry_count = ((fs->entry_count * 4) / entry_ratio);
                }
#endif
#if defined(BCM_APACHE_SUPPORT)
                /* In Apache number of entries in each slice is 2
                 * times entries in Trident2.
                 */
                if(SOC_IS_APACHE(unit)) {
                    fs->entry_count = (fs->entry_count * 2) / entry_ratio;
                }
#endif
            } else if (SOC_IS_TD_TT(unit)){
                if (slice_idx < _BCM_FIELD_TD_INGRESS_DOUBLE_WIDE_SLICE0) {
                    fs->entry_count =
                        _BCM_FIELD_TD_INGRESS_SINGLE_WIDE_SLICE_SZ;
                } else {
                    fs->entry_count =
                        _BCM_FIELD_TD_INGRESS_DOUBLE_WIDE_SLICE_SZ;
                }
            } else {
                if (slice_idx < _BCM_FIELD_SC_INGRESS_DOUBLE_WIDE_SLICE0) {
                    fs->entry_count =
                        _BCM_FIELD_SC_INGRESS_SINGLE_WIDE_SLICE_SZ;
                } else {
                    fs->entry_count =
                        _BCM_FIELD_SC_INGRESS_DOUBLE_WIDE_SLICE_SZ;
                }
            }
        } else
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIDENT_SUPPORT */
        {
            fs->entry_count = stage_fc->tcam_sz /  \
                            (entry_ratio_per_slice * stage_fc->tcam_slices);
        }

        /* Allocate slice entries pointers array. */
        mem_size = fs->entry_count * sizeof (void *);
        _FP_XGS3_ALLOC(fs->entries, mem_size, "array of entry pointers");
        if (fs->entries == NULL) {
            /* Allocation failed free all previously allocated entries. */
            _bcm_field_stage_entries_free(unit, stage_fc);
            return (BCM_E_MEMORY);
        }
        fs->start_tcam_idx = tcam_idx;
        tcam_idx += fs->entry_count * entry_ratio_per_slice;
        fs->free_count = fs->entry_count;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slices_init
 * Purpose:
 *     Allocate the memory for slices.
 *     Initialize slice specific flags, parameters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *     fc           - (IN/OUT) Field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_slices_init(int unit, _field_stage_t *stage_fc, _field_control_t *fc)
{
    struct _field_slice_s *fs; /* Slice info.                    */
    int             slice_idx; /* Slice iteration index.         */
    int              mem_size; /* Memory allocation buffer size. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Allocate slices info. */
    mem_size = stage_fc->tcam_slices * sizeof(struct _field_slice_s);
    fs = sal_alloc(mem_size, "stage slices info");
    if (NULL == fs) {
        return (BCM_E_MEMORY);
    }

    sal_memset(fs, 0, mem_size);
    stage_fc->slices[_FP_DEF_INST] = fs;

    /* Initialize stage slices info. */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        fs[slice_idx].slice_number = slice_idx;
        fs[slice_idx].stage_id = stage_fc->stage_id;
        fs[slice_idx].next = NULL;
        fs[slice_idx].prev = NULL;
        fs[slice_idx].doublewide_key_select = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].src_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].dst_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].intf_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].loopback_type_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].ingress_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].src_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].dst_fwd_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].fwd_field_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].ttl_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].tcp_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice_idx].tos_class_sel = _FP_SELCODE_DONT_CARE;

        /* Set intraslice  capable flag if appropriate. */
#if defined(BCM_HURRICANE_SUPPORT)
        if (SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_INTRASLICE_CAPABLE;
        }
#endif
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_stage)) {
            if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
                (_BCM_FIELD_STAGE_LOOKUP  != stage_fc->stage_id)) {
                continue;
            }

#if defined(BCM_SCORPION_SUPPORT) || defined (BCM_TRIDENT_SUPPORT)
            /* Skip single wide slices on 5682x devices. */
            if ((soc_feature(unit, soc_feature_field_ingress_two_slice_types)) &&
                (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
                if (SOC_IS_TD2_TT2(unit)) {
                    if (_BCM_FIELD_TD2_INGRESS_DOUBLE_WIDE_SLICE0 <= slice_idx) {
                        fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_SIZE_SMALL;
                        continue;
                    }
                } else if (SOC_IS_TD_TT(unit)) {
                    if (_BCM_FIELD_TD_INGRESS_DOUBLE_WIDE_SLICE0 > slice_idx) {
                        fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_SIZE_SMALL;
                        continue;
                    }
                } else {
                    if (_BCM_FIELD_SC_INGRESS_DOUBLE_WIDE_SLICE0 > slice_idx) {
                        fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_SIZE_SMALL;
                        continue;
                    }
                }
                fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_SIZE_LARGE;

                /* TD2: Intra Slice mode not available from IFP stage */
                if (SOC_IS_TD_TT(unit)) {
                    continue;
                }
            }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIDENT_SUPPORT */
            fs[slice_idx].slice_flags |= _BCM_FIELD_SLICE_INTRASLICE_CAPABLE;
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stage_add
 *
 * Purpose:
 *     Add stage to field processor pipeline.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fc -   (IN/OUT)Field control info for device.
 *
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_MEMORY - Allocation failure
 */
STATIC int
_field_stage_add(int unit, _field_control_t *fc, _field_stage_id_t stage_id)
{
    _field_stage_t *stage_fc; /* Stage info.                 */
    int    ret_val;           /* Operation return value.     */
    int    idx;
    int    map_id;
#if defined(BCM_TRX_SUPPORT)
    soc_mem_t mem;
    int entry_words;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_TRIUMPH_SUPPORT)
    uint16              dev_id;
    uint8               rev_id;
#endif /* BCM_TRIUMPH_SUPPORT */
    int                 inst;  /* Pipe Instance. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    /* Allocate stage structure. */
    stage_fc = sal_alloc(sizeof(_field_stage_t), "FP stage info");
    if (NULL == stage_fc) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Allocation failure for stage info\n"),
                   unit));
        return (BCM_E_MEMORY);
    }
    /* Reset allocated buffer. */
    sal_memset(stage_fc, 0, sizeof(_field_stage_t));

    /* Set stage id. */
    stage_fc->stage_id = stage_id;
    /* Set default num instances to 1 */
    stage_fc->num_instances = 1;

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        ret_val = _bcm_field_td2_stage_init(unit, stage_fc);
        if (BCM_FAILURE(ret_val)) {
            sal_free(stage_fc);
            return (ret_val);
        }
    } else
#endif
#ifdef BCM_HELIX4_SUPPORT
    if (SOC_IS_HELIX4(unit)) {
        ret_val = _bcm_field_helix4_stage_init(unit, stage_fc);
        if (BCM_FAILURE(ret_val)) {
            sal_free(stage_fc);
            return (ret_val);
        }
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
if (SOC_IS_TRIUMPH3(unit)) {
        ret_val = _bcm_field_tr3_stage_init(unit, stage_fc);
        if (BCM_FAILURE(ret_val)) {
            sal_free(stage_fc);
            return (ret_val);
        }
    } else
#endif
    {
        /* Set the stage features */
        if ((soc_feature(unit, soc_feature_field_ingress_global_meter_pools)) &&
            (stage_id == _BCM_FIELD_STAGE_INGRESS)) {
            stage_fc->flags |= _FP_STAGE_GLOBAL_METER_POOLS;
        }

#if defined(BCM_TRIUMPH_SUPPORT)
        if (SOC_IS_VALKYRIE(unit) || SOC_IS_VALKYRIE2(unit)) {
           stage_fc->flags |= _FP_STAGE_HALF_SLICE;
        } else if (SOC_IS_APOLLO(unit)
            && (_BCM_FIELD_STAGE_LOOKUP != stage_id)) {
            stage_fc->flags |= _FP_STAGE_HALF_SLICE;
        }

        /* 56620/56630 devices have full slices on all stages. */
        /* 56538/56534 devices have half slices on ingress and egress */
        soc_cm_get_id(unit, &dev_id, &rev_id);
        if (((BCM56538_DEVICE_ID == dev_id) || (BCM56534_DEVICE_ID == dev_id))
            && (_BCM_FIELD_STAGE_LOOKUP != stage_id)) {
            stage_fc->flags |= _FP_STAGE_HALF_SLICE;
        }

        if ((BCM56630_DEVICE_ID == dev_id) || (BCM56620_DEVICE_ID == dev_id)) {
            stage_fc->flags &= ~_FP_STAGE_HALF_SLICE;
        }

#ifdef BCM_HURRICANE2_SUPPORT
        if (soc_feature(unit, soc_feature_field_slice_size128)) {
            stage_fc->flags |= _FP_STAGE_HALF_SLICE;
        }
#endif
#endif /* BCM_TRIUMPH_SUPPORT */

#if defined(BCM_TRX_SUPPORT)
        if ((soc_feature(unit,
            soc_feature_field_ing_egr_separate_packet_byte_counters))
            && ((stage_id == _BCM_FIELD_STAGE_INGRESS)
                || (stage_id == _BCM_FIELD_STAGE_EXTERNAL)
                || (stage_id == _BCM_FIELD_STAGE_EGRESS))) {
            stage_fc->flags |= _FP_STAGE_SEPARATE_PACKET_BYTE_COUNTERS;
        }
#endif /* BCM_TRX_SUPPORT  */


#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if ((soc_feature(unit, soc_feature_field_egress_global_counters))
            && (stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            stage_fc->flags |= _FP_STAGE_GLOBAL_COUNTERS;
        }

        if ((soc_feature(unit, soc_feature_field_vfp_flex_counter))
            && (stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
            stage_fc->flags |= _FP_STAGE_GLOBAL_COUNTERS;
        }

        if (SOC_IS_KATANAX(unit)) {
            if ((soc_feature(unit, soc_feature_advanced_flex_counter))
                && (stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
                stage_fc->flags |= _FP_STAGE_GLOBAL_COUNTERS;
            }
        }
        if ((soc_feature(unit, soc_feature_flowcnt))
                && (stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
            stage_fc->flags |= _FP_STAGE_GLOBAL_COUNTERS;
        }
#endif /* BCM_FIREBOLT2_SUPPORT  || BCM_TRX_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) || \
    defined(BCM_RAPTOR_SUPPORT)
        if ((soc_feature(unit, soc_feature_field_virtual_slice_group)
            && (_BCM_FIELD_STAGE_INGRESS == stage_id))
            || (SOC_IS_TRX(unit)
                && (_BCM_FIELD_STAGE_EXTERNAL != stage_id)
                && soc_feature(unit, soc_feature_field_virtual_slice_group))) {
            stage_fc->flags |= _FP_STAGE_AUTO_EXPANSION;
        }
#endif /* BCM_FIREBOLT2_SUPPORT  || BCM_TRX_SUPPORT || BCM_RAPTOR_SUPPORT */

        if ((soc_feature(unit, soc_feature_field_slice_enable))
            && (_BCM_FIELD_STAGE_EXTERNAL != stage_id)) {
            stage_fc->flags |= _FP_STAGE_SLICE_ENABLE;
        }


        /* Init tcam info for stage. */
        ret_val = _field_tcam_info_init(unit, stage_fc, fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stage_delete(unit, fc, stage_fc);
            return (ret_val);
        }
    }

    /* Initialize slices information. */
    ret_val = _field_slices_init (unit, stage_fc, fc);
    if (BCM_FAILURE(ret_val)) {
        _field_stage_delete(unit, fc, stage_fc);
        return (ret_val);
    }

    /*
     * Allocate the memory for entries in all the slices
     *     external TCAM (for Triumph) is taken care of in _bcm_tr_field_init.
     * This will be de-allocated in bcm_esw_field_detach
     */
    if (stage_fc->stage_id != _BCM_FIELD_STAGE_EXTERNAL) {
        /* Initialize stage slices . */
        ret_val = _field_entries_init (unit, stage_fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stage_delete(unit, fc, stage_fc);
            return (ret_val);
        }
    }

    /* Initialize meters usage bitmap. */
    ret_val = _field_meters_init (unit, stage_fc);
    if (BCM_FAILURE(ret_val)) {
        _field_stage_delete(unit, fc, stage_fc);
        return (ret_val);
    }

    /* Initialize counters usage bitmap. */
    ret_val = _field_counters_init(unit, fc, stage_fc);
    if (BCM_FAILURE(ret_val)) {
        _field_stage_delete(unit, fc, stage_fc);
        return (ret_val);
    }

    /* Redirect action memory profile initialization. */
    soc_profile_mem_t_init(&stage_fc->redirect_profile);

    /* Action profile; will be setup in chip-specific init */
    soc_profile_mem_t_init(&stage_fc->ext_act_profile);

#if defined(BCM_TRIDENT2_SUPPORT)
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        /* hash select 0 action memory profile initialization. */
        soc_profile_mem_t_init(&stage_fc->hash_select[0]);

        /* hash select 1 action memory profile initialization. */
        soc_profile_mem_t_init(&stage_fc->hash_select[1]);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    /* Ingress specific initialization. */
    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {

#if defined(BCM_TRX_SUPPORT)
        /* Redirection action profile table initialization. */
        if (SOC_MEM_IS_VALID(unit, IFP_REDIRECTION_PROFILEm)) {
            mem = IFP_REDIRECTION_PROFILEm;
            entry_words = sizeof(ifp_redirection_profile_entry_t) /
                sizeof(uint32);
            ret_val = soc_profile_mem_create(unit, &mem, &entry_words, 1,
                                             &stage_fc->redirect_profile);

            if (BCM_FAILURE(ret_val)) {
                _field_stage_delete(unit, fc, stage_fc);
                return (ret_val);
            }
        }
#endif /* BCM_TRX_SUPPORT */
        stage_fc->range_id = 1;

        /* Initialize stage select codes table. */
        ret_val = _field_stage_data_ctrl_init(unit, stage_fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stage_delete(unit, fc, stage_fc);
            return (ret_val);
        }
    }

#if defined(BCM_TRIDENT2_SUPPORT)
    /* Lookup stage specific initialization. */
    if (((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) &&
        (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id)) {
        /* hash select action memory profile initialization. */
        soc_profile_mem_t_init(&stage_fc->hash_select[0]);
        soc_profile_mem_t_init(&stage_fc->hash_select[1]);

        /* Hash select 0 action profile table initialization. */
        if (SOC_MEM_IS_VALID(unit, VFP_HASH_FIELD_BMAP_TABLE_Am)) {
            mem = VFP_HASH_FIELD_BMAP_TABLE_Am;
            entry_words = sizeof(vfp_hash_field_bmap_table_a_entry_t) /
                                 sizeof(uint32);
            ret_val = soc_profile_mem_create(unit, &mem, &entry_words, 1,
                                             &stage_fc->hash_select[0]);

            if (BCM_FAILURE(ret_val)) {
                _field_stage_delete(unit, fc, stage_fc);
                return (ret_val);
            }
        }
        /* Hash select 1 action profile table initialization. */
        if (SOC_MEM_IS_VALID(unit, VFP_HASH_FIELD_BMAP_TABLE_Bm)) {
            mem = VFP_HASH_FIELD_BMAP_TABLE_Bm;
            entry_words = sizeof(vfp_hash_field_bmap_table_a_entry_t) /
                                 sizeof(uint32);
            ret_val = soc_profile_mem_create(unit, &mem, &entry_words, 1,
                                             &stage_fc->hash_select[1]);

            if (BCM_FAILURE(ret_val)) {
                _field_stage_delete(unit, fc, stage_fc);
                return (ret_val);
            }
        }
        /*
         * Index 0 of vfp_hash_field_bmap_table_a/b is invalid as the
         * hardware will consider hash bitmap selection from VFP only
         * if HASH_FIELD_BITMAP_PTR_A and HASH_FIELD_BITMAP_PTR_B are non-zero.
         * Making the entry to NULL.
         */
        ret_val = _bcm_field_td2_hash_select_profile_alloc_reserve_entry(unit,
                                                                    stage_fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stage_delete(unit, fc, stage_fc);
            return (ret_val);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */
    /* Initializing supported Qset*/
    sal_memset(&stage_fc->_field_supported_qset, 0, sizeof(bcm_field_qset_t));

    /*
     * Initialize the FP_SLICE_MAP
     *     physical_slice and virtual_group are H/W initial values
     * Although initialized for all stages, valid only on Raptor (1 stage)
     *     , FB-2 Ingress stage, Triumph
     */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        for (map_id = 0; map_id < _FP_VMAP_CNT; map_id++) {
            for (idx = 0; idx < _FP_VMAP_SIZE; idx++) {
                stage_fc->vmap[inst][map_id][idx].valid = FALSE;
                stage_fc->vmap[inst][map_id][idx].vmap_key = idx;
                stage_fc->vmap[inst][map_id][idx].virtual_group = idx;
                stage_fc->vmap[inst][map_id][idx].flags = 0;
            }
        }
    }

    FP_LOCK(unit);
    /* Add stage to field control structure. */
    stage_fc->next = fc->stages;
    fc->stages = stage_fc;
    FP_UNLOCK(unit);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_stages_init
 *
 * Purpose:
 *     Initialize field stages array within the field control struct.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fc -   (IN/OUT)Field control info for device.
 *
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_MEMORY - Allocation failure
 *
 * Notes:
 *     It is important that _BCM_FIELD_STAGE_INGRESS be inited before
 *         _BCM_FIELD_STAGE_EXTERNAL
 */
int
_field_stages_init(int unit, _field_control_t *fc)
{
    int            ret_val;    /* Operation return value.     */


    /* Input parameters check. */
    if (fc == NULL) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Initialize stage add and delete functions for tomahawk device. */
        fc->stage_func.fp_stages_add = _bcm_field_th_stages_add;
        fc->stage_func.fp_stages_delete = _bcm_field_th_stages_delete;

        /* Invoke stage add function. */
        return (fc->stage_func.fp_stages_add(unit, fc));
    }
#endif /* !BCM_TOMAHAWK_SUPPORT*/

    /* Based on unit type add pipeline stages to field control. */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if ((soc_feature(unit, soc_feature_field_multi_stage)) &&
        (SOC_SWITCH_BYPASS_MODE_L3_ONLY != SOC_SWITCH_BYPASS_MODE(unit))) {

        ret_val = _field_stage_add(unit, fc, _BCM_FIELD_STAGE_LOOKUP);
        if (BCM_FAILURE(ret_val)) {
            _field_stages_destroy(unit, fc);
            return (ret_val);
        }

        ret_val = _field_stage_add(unit, fc, _BCM_FIELD_STAGE_EGRESS);
        if (BCM_FAILURE(ret_val)) {
            _field_stages_destroy(unit, fc);
            return (ret_val);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    ret_val = _field_stage_add(unit, fc, _BCM_FIELD_STAGE_INGRESS);
    if (BCM_FAILURE(ret_val)) {
        _field_stages_destroy(unit, fc);
        return (ret_val);
    }

    /* Add the External TCAM (stage) */
    if ((soc_feature(unit, soc_feature_esm_support)) &&
        (fc->flags & _FP_EXTERNAL_PRESENT)) {
        ret_val = _field_stage_add(unit, fc, _BCM_FIELD_STAGE_EXTERNAL);
        if (BCM_FAILURE(ret_val)) {
            _field_stages_destroy(unit, fc);
            return (ret_val);
        }

        ret_val = _field_external_meters_init(unit, fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stages_destroy(unit, fc);
            return (ret_val);
        }

        ret_val = _field_stage_external_data_ctrl_init(unit, fc);
        if (BCM_FAILURE(ret_val)) {
            _field_stages_destroy(unit, fc);
            return (ret_val);
        }
    }
    return (ret_val);

}
/*
 * Function: _field_min_virtual_priorty_group_get
 *
 * Purpose:
 *     Service routine used to update virtual priority map.
 *     Function returns a minimum priority group, which
 *     might be assigned a virtual priority passed to the function.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     vmap           - (IN) Virutal map array.
 *     vmap_size      - (IN) Map size.
 *     unused_groups  - (OUT) Unused virtual groups.
 *     unused_slices  - (OUT) Unused physical slices.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_min_virtual_priorty_group_get(int unit, _field_virtual_map_t *vmap,
                                     int vmap_size, int *virtual_priority,
                                     int *candidate)
{
    int idx;                     /* Virtual map iteration index.  */
    int prio_max;                /* Max limit on group priority.  */
    int min_group;               /* Minimum priority group index. */
    int even_boundary_constraint;/*  even boundary constraint     */
    int incr_priority = FALSE;   /* Increment priority to meet    */

    /* Input parameters check. */
    if ((NULL == vmap) || (NULL ==  candidate) || (NULL == virtual_priority)) {
        return (BCM_E_PARAM);
    }

    /* Initialize max limit for group priority to ANY (unlimited). */
    prio_max  = 0x7fffffff; /* Unlimited priority.*/
    min_group = -1;         /* No candidates.    */

    /* FB2 double wide group must reside in even virtual priority. */
    even_boundary_constraint = (SOC_IS_FIREBOLT2(unit)) ? TRUE : FALSE;

    /* Fill new virtual map. */
    for (idx = 0; idx <  vmap_size; idx++) {

        /* Skip unused virtual priorities. */
        if (vmap[idx].valid == FALSE) {
            continue;
        }

        /* Skip groups not meeting even_boundary_constraint */
        if ((even_boundary_constraint) &&
            (vmap[idx].flags & _FP_GROUP_SPAN_DOUBLE_SLICE)  &&
            (0 != ((*virtual_priority) % 2))) {
            if (prio_max > vmap[idx].priority) {
                prio_max = vmap[idx].priority;
            }
            if (-1 == min_group)  {
                min_group = idx;
                /* Priority increment is required.*/
                incr_priority = TRUE;
            }
            /* Double wide group -> no point to check next map. */
            idx ++;
            continue;
        }

        /*
         *  Make sure double wide group with
         *  lower priority was not skipped because of even_boundary_constraint.
         */
        if (prio_max >= vmap[idx].priority) {
            min_group = idx;
            incr_priority = FALSE;
        }
        break;
    }

    if (incr_priority) {
        /*
         *  Originally, a candidate was skipped because of
         *  even boundary constraint violation (virtual_priority is odd).
         *  lets use next priority.
         */
        (*virtual_priority)++;
    }

    *candidate = min_group;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_slice_clear
 *
 * Purpose:
 *     Reset the fields in a slice. Note that the entries list must be
 *     empty before calling this. Also, this does NOT deallocate the memory for
 *     the slice itself. Normally, this is used when a group no longer needs
 *     ownership of a slice so the slice gets returned to the pool of available
 *     slices.
 *
 * Paramters:
 *     unit  - BCM device number
 *     fg    - Field group structure.
 *     fs    - Link to physical slice structure to be cleared
 *     pbmp  - Port bitmap to remove from slice
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_BUSY      - Entries still in slice, can't clear slice
 */
STATIC int
_field_slice_clear(int unit, _field_group_t *fg,
                   _field_slice_t *fs, bcm_pbmp_t pbmp)
{
    _field_stage_t      *stage_fc;      /* Stage field control structure. */
    _field_control_t    *fc;            /* Field control structure.       */
    bcm_port_t          port;           /* Port iterator.                 */
    uint32              entry_idx;      /* Slice entries iterator.        */

    /* Input parameters check. */
    if ((NULL == fs) || (NULL == fg)){
       return (BCM_E_PARAM);
    }
    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get stage field control structure. */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fs->stage_id, &stage_fc));


    for (entry_idx = 0; entry_idx < fs->entry_count; entry_idx++) {
        if (fs->entries[entry_idx] != NULL &&
            fs->entries[entry_idx]->group->gid == fg->gid) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: Entries still in slice=%d.\n"),
                       unit, fs->slice_number));
            return (BCM_E_BUSY);
        }
    }

    /* Remove ports from slice's port bit map. */
    BCM_PBMP_ITER(pbmp, port) {
        BCM_PBMP_PORT_REMOVE(fs->pbmp, port);
    }

    /* Clean up group configuration if last group was removed from the slice. */
    if(BCM_PBMP_IS_NULL(fs->pbmp)) {
        /* Clear slice configuration in hw. */
        if (NULL != fc->functions.fp_slice_clear) {
            BCM_IF_ERROR_RETURN(fc->functions.fp_slice_clear(unit, fg, fs));
        }

        fs->group_flags = 0;
        fs->doublewide_key_select = _FP_SELCODE_DONT_CARE;
        fs->src_class_sel = _FP_SELCODE_DONT_CARE;
        fs->dst_class_sel = _FP_SELCODE_DONT_CARE;
        fs->intf_class_sel = _FP_SELCODE_DONT_CARE;
        fs->loopback_type_sel = _FP_SELCODE_DONT_CARE;
        fs->ingress_entity_sel = _FP_SELCODE_DONT_CARE;
        fs->src_entity_sel = _FP_SELCODE_DONT_CARE;
        fs->dst_fwd_entity_sel = _FP_SELCODE_DONT_CARE;
        fs->fwd_field_sel = _FP_SELCODE_DONT_CARE;
        fs->ttl_class_sel
            = fs->tcp_class_sel
            = fs->tos_class_sel
            =_FP_SELCODE_DONT_CARE;
        fs->aux_tag_1_sel
            = fs->aux_tag_2_sel
            = fs->oam_overlay_sel
            = fs->egr_class_f1_sel
            = fs->egr_class_f2_sel
            = fs->egr_class_f3_sel
            = fs->egr_class_f4_sel
            = fs->src_dest_class_f1_sel
            = fs->src_dest_class_f3_sel
            = fs->egr_key4_dvp_sel
            = fs->egr_key4_mdl_sel
            = fs->egr_oam_overlay_sel
            = fs->oam_intf_class_sel
            = fs->egr_dest_port_f1_sel
            = fs->egr_dest_port_f5_sel
            = _FP_SELCODE_DONT_CARE;
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_vmap_unused_resources_get
 *
 * Purpose:
 *     Service routine used to retrieve unused virtual groups
 *     and physical slices
 * Parameter
 *     unit           - (IN) BCM device number.
 *     vmap           - (IN) Virutal map array.
 *     vmap_size      - (IN) Virtual map size.
 *     unused_groups  - (OUT) Unused virtual groups.
 *     unused_slices  - (OUT) Unused physical slices.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_vmap_unused_resources_get(int unit, _field_virtual_map_t *vmap,
                                 int vmap_size, uint32 *unused_groups,
                                 uint32 *unused_slices)
{
    int idx;                   /* Virtual map iteration index. */
    uint32 used_groups = 0;    /* Used virtual groups.         */
    uint32 used_slices = 0;    /* Used physical slices.        */

    /* Input parameters check. */
    if ((NULL == vmap) || (NULL == unused_groups) || (NULL == unused_slices)) {
        return (BCM_E_PARAM);
    }


    /* Iterate over all currently used groups & update bitmap. */
    for (idx = 0; idx < vmap_size; idx++) {
        /* Skip unused virtual priorities. */
        if (vmap[idx].valid == FALSE) {
            continue;
        }

        used_groups |= (1 << vmap[idx].virtual_group);
        used_slices |= (1 << vmap[idx].vmap_key);
    }

    /* Update caller information. */
    *unused_groups = ~used_groups;
    *unused_slices = ~used_slices;

    return (BCM_E_NONE);
}

/*
 * Function: _field_vmap_resource_alloc
 *
 * Purpose:
 *     Service routine used to allocate virutal group/physical
 *     slice from unused resources map.
 * Parameter
 *     unit           - (IN) BCM device number.
 *     vmap           - (IN) Virutal map array.
 *     vmap_size      - (IN) Virtual map size.
 *     resource       - (IN) Available resources bitmap.
 *     allocated_idx  - (OUT) Allocated index.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_vmap_resource_alloc(int unit, _field_virtual_map_t *vmap,
                           int vmap_size, uint32 *resource,
                           int *allocated_idx)
{
    int idx;                      /* Tcam slices iteration index. */

    /* Input parameters check. */
    if ((NULL == vmap) || (NULL == resource) || (NULL == allocated_idx)) {
        return (BCM_E_PARAM);
    }

    /* Iterate over all currently used groups & update bitmap. */
    for (idx = 0; idx < vmap_size; idx++) {
        if ((*resource) & (1 << idx)) {
            break;
        }
    }

    /* Check if any resources are available. */
    if (idx == vmap_size) {
        return (BCM_E_RESOURCE);
    }

    *resource &= ~(1 << idx);
    *allocated_idx = idx;
    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_group_virtual_map_update
 *
 * Purpose:
 *     Find the map between virtual group and vmap group id
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fg           - (INOUT) Field Group Structure.
 * Returns:
 *     BCM_E_XXX
 */
 int
 _bcm_field_group_virtual_map_update(int unit, _field_group_t *fg)
{
    _field_control_t *fc;             /* Field control structure. */
    _field_group_t *temp_fg = NULL;
    int idx = 0;

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
        fg->vmap_group[idx] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    }
    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (temp_fg = fc->groups; temp_fg != NULL ; temp_fg = temp_fg->next) {
        /* Skip other stages. */
        if (temp_fg->stage_id != fg->stage_id) {
            continue;
        }

        if (temp_fg->action_res_id == BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT) {
            continue;
        }

        if(temp_fg->action_res_id == fg->action_res_id) {
            /* ALL VALID action Resoultion Id will have same virtual group */
            for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
                fg->vmap_group[idx] = temp_fg->vmap_group[0];
            }
            break;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_group_slice_sharing_virtual_map_group
 *
 * Purpose:
 *     Find the map between physical slice and vmap group id
 *     for slice sharing case
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN) Stage field control structure.
 *     fg           - (INOUT) Field Group Structure.
 * Returns:
 *     BCM_E_XXX
 */
 int
_field_group_slice_sharing_virtual_map_group(int unit, _field_stage_t *stage_fc, _field_group_t *fg)
{
    _field_virtual_map_t *vmap = NULL;
    int                  idx;
    int                  idx1;
    int                  vmap_key;
    int                  vmap_size;
    uint8                map_id = _FP_VMAP_DEFAULT;
    int                  rv;
    int                  slice_count = 0;

    /* Input parameters check. */
    if ((stage_fc == NULL) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    vmap_key = (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) ? \
               (_FP_VMAP_SIZE - 1) : fg->slices->slice_number;


    if (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) {
        /* Slice sharing is not supported by EXTERNAL stage
         * This check should be never hit
         * External slices controlled by stage ingress map. */
        rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,
                &stage_fc);
        BCM_IF_ERROR_RETURN(rv);
        if((fg->slices)->pkt_type[_FP_EXT_L2]) {
            map_id = _FP_EXT_L2;
        } else if ((fg->slices)->pkt_type[_FP_EXT_IP4]) {
            map_id = _FP_EXT_IP4;
        } else if ((fg->slices)->pkt_type[_FP_EXT_IP6]) {
            map_id = _FP_EXT_IP6;
        } else {
            return (BCM_E_INTERNAL);
        }
        return (BCM_E_UNAVAIL);
    }

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_group_slice_count_get(fg->flags, &slice_count);
    BCM_IF_ERROR_RETURN(rv);

    /* check only in default map */
    for (idx = 0; idx < vmap_size; idx++) {
        vmap = (stage_fc->vmap[fg->instance][map_id]) + idx;
        if (TRUE != vmap->valid) {
            continue;
        }
        /* Slice sharing is possible only for groups of same mode */
        if ((vmap->vmap_key == vmap_key)
                && ((idx + slice_count -1)  < vmap_size)){
            for (idx1 = 0; idx1 < slice_count; idx1++) {
                fg->vmap_group[idx1] = (vmap + idx1)->virtual_group;
            }
            if (fg->action_res_id != BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT)
            {
                for (idx1 = slice_count; idx1 < _FP_PAIR_MAX; idx1++) {
                    fg->vmap_group[idx1] = fg->vmap_group[0];
                }
            }
            break;
        }
    }

    if(idx == vmap_size)
    {
        return (BCM_E_CONFIG);
    }

    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_virtual_map_size_get
 *
 * Purpose:
 *     Calculate virtual map size.
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     stage_fc     - (IN) Stage field control structure.
 *     vmap_size    - (OUT) Virtual map size.
 * Returns:
 *     BCM_E_XXX
 */
 int
 _bcm_field_virtual_map_size_get(int unit, _field_stage_t *stage_fc, int *vmap_size)
{
    _field_control_t *fc;             /* Field control structure. */
    uint16              dev_id;
    uint8               rev_id;
    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == vmap_size)) {
        return (BCM_E_PARAM);
    }

    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));


    /* Virtual map on stage ingress contains includes priority
       for external slice.
     */
    if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) &&  \
        (fc->flags & _FP_EXTERNAL_PRESENT)) {
        *vmap_size = stage_fc->tcam_slices + 1;
    } else {
        *vmap_size = stage_fc->tcam_slices;
        if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) &&
           ((dev_id == BCM55441_DEVICE_ID) ||
            (dev_id == BCM56240_DEVICE_ID) ||
            (dev_id == BCM56241_DEVICE_ID) ||
            (dev_id == BCM56242_DEVICE_ID) ||
            (dev_id == BCM56243_DEVICE_ID) ||
            (dev_id == BCM56245_DEVICE_ID) ||
            (dev_id == BCM56246_DEVICE_ID))) {
            *vmap_size = 12;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_virtual_map_insert2
 *
 * Purpose:
 *     For chips which support the virtual slice/group feature,
 *     1) Sort groups by priority.
 *     2) Aggregate expanded slices into virtual group priority.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field group structure.
 *     map_id         - (IN) Virtual map id.
 *     vmap_key       - (IN) Virtual map key.
 *     virtual_group  - (IN/OUT) Array of up to _FP_PAIR_MAX virtual group ids
 *                               or -1 if Virtual group id needs to be assigned.
 *     install        - (IN) Perform installation in HW flag.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_virtual_map_insert2(int unit, _field_stage_t *stage_fc,
                          _field_group_t *fg, uint8 map_id,
                          int vmap_key, int *virtual_group,
                          int install)
{
    int idx;                      /* Virtual map iteration index.        */
    int idx_tmp;                  /* Temp iteration index.               */
    int sizeof_vmap;              /* Virtual map byte size.              */
    int candidate;                /* Virtual priority candidate group.   */
    int slice_count;              /* Number of slices for each map entry.*/
    int group_installed;          /* Group installation is complete.     */
    _field_control_t *fc;         /* Field control structure.            */
    uint32 unused_groups;         /* Unused virtual groups bitmap.       */
    uint32 unused_slices;         /* Unused physical slices bitmap       */
                                  /* Updated virtual map.                */
    _field_virtual_map_t vmap_new[_FP_VMAP_SIZE];
                                  /* Original virtual map.               */
    _field_virtual_map_t vmap_orig[_FP_VMAP_SIZE];
    _field_virtual_map_t *vmap;   /* Currently used virtual map.         */
    int even_boundary_constraint = FALSE; /* Flag for double wide slices.*/
    int vmap_size;                /* Virtual map index count.            */
    int rv;                       /* Operation return status.            */
    int idx_pair;                 /* Virtual map iteration index.        */
    int inst;                     /* Pipe Instance.                      */

    /* Input parameters check */
    if ((NULL == fg) || (NULL == stage_fc) || (NULL == virtual_group)) {
        return (BCM_E_PARAM);
    }

    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    inst = fg->instance;

#if defined(BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit)) {
        /* FB2 supports virtual priority in stage ingress only. */
        if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
            return (BCM_E_NONE);
        }
        /* FB2 double wide group must reside in even virtual priority. */
        even_boundary_constraint = TRUE;
    }
#endif /* BCM_FIREBOLT2_SUPPORT */

    /* Reset new virtual map. */
    sizeof_vmap = _FP_VMAP_SIZE * sizeof(_field_virtual_map_t);
    sal_memset(vmap_new, 0, sizeof_vmap);

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    /* Get unused virtual groups & physical slices */
    sal_memcpy(vmap_orig, stage_fc->vmap[inst][map_id], sizeof_vmap);
    vmap = vmap_orig;
    rv = _field_vmap_unused_resources_get(unit, vmap, vmap_size,
                                          &unused_groups, &unused_slices);
    BCM_IF_ERROR_RETURN(rv);

    group_installed = FALSE;
    /* Fill new virtual map. */
    for (idx = 0; idx < vmap_size;) {
        idx_tmp = idx;
        vmap = vmap_orig;
        rv = _field_min_virtual_priorty_group_get(unit, vmap, vmap_size,
                                                  &idx_tmp, &candidate);
        BCM_IF_ERROR_RETURN(rv);

        if (_FP_INVALID_INDEX != candidate) {
            vmap = vmap_orig + candidate;
            if ((group_installed) || (vmap->priority <= fg->priority)) {
                idx = idx_tmp;
                /* Get number of slices required for this map. */
                rv = _bcm_field_group_slice_count_get(vmap->flags, &slice_count);
                BCM_IF_ERROR_RETURN(rv);
                /* Copy map info for each of the slices. */
                for (idx_tmp = 0; idx_tmp < slice_count; idx_tmp++, idx++) {
                    vmap_new[idx] = vmap[idx_tmp];
                    vmap[idx_tmp].valid = FALSE;
                }
                continue;
            }
        }

        if (FALSE == group_installed) {
            /* New group insertion portion. */
            /*
             * Increment virtual priority index to meet even boundary
             * constraints.
             */
            if ((even_boundary_constraint) &&
                (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)  &&
                (0 != (idx % 2))) {
                idx++;
            }

            /* Get number of slices required for this map. */
            rv = _bcm_field_group_slice_count_get(fg->flags, &slice_count);
            BCM_IF_ERROR_RETURN(rv);

            /* Set virtual map info. */
            for (idx_tmp = 0; idx_tmp < slice_count; idx_tmp++, idx++) {
                /* Allocate virtual group id. */
                if (BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT == virtual_group[idx_tmp]) {
                    vmap = vmap_orig;
                    rv = _field_vmap_resource_alloc(unit, vmap, vmap_size,
                                                    &unused_groups,
                                                    &virtual_group[idx_tmp]);
                    BCM_IF_ERROR_RETURN(rv);
                    /* Valid action res id will have all slices mapped to same virtual group */
                    if (BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT != fg->action_res_id) {
                        for (idx_pair = 1; idx_pair < _FP_PAIR_MAX; idx_pair++) {
                            virtual_group[idx_pair] = virtual_group[idx_tmp];
                        }
                    }
                }
                vmap_new[idx].valid = TRUE;
                vmap_new[idx].vmap_key = vmap_key + idx_tmp;
                vmap_new[idx].virtual_group = virtual_group[idx_tmp];
                vmap_new[idx].priority = fg->priority;
                vmap_new[idx].flags = fg->flags;

                unused_slices &= ~(1 << (vmap_key + idx_tmp));
            }
            group_installed = TRUE;
        }
        if (-1 == candidate) {
            /* No more groups to install. */
            break;
        }
    }

    if (group_installed == FALSE) {
        return BCM_E_RESOURCE;
    }

    /* Assign distinct virtual group numbers to unused virtual slices */
    vmap = vmap_orig;
    for (idx = 0; idx < vmap_size; idx++) {
        if (vmap_new[idx].valid == TRUE) {
            continue;
        }
        /* Allocated unused virtual group id. */
        rv = _field_vmap_resource_alloc(unit, vmap, vmap_size,
                                        &unused_groups, &idx_tmp);
        BCM_IF_ERROR_RETURN(rv);
        vmap_new[idx].virtual_group = idx_tmp;

        /* Allocated unused physical slice. */
        rv = _field_vmap_resource_alloc(unit, vmap, vmap_size,
                                        &unused_slices, &idx_tmp);
        BCM_IF_ERROR_RETURN(rv);
        vmap_new[idx].vmap_key = idx_tmp;
    }

    /* Write new map to the slice virtual map. */
    sal_memcpy(stage_fc->vmap[inst][map_id], vmap_new, sizeof_vmap);

    /*
     * Write the new_fp_virtual_map to H/W, and
     *     copy to stage's fp_virtual_map
     */
    if (install) {
        rv = fc->functions.fp_write_slice_map(unit, stage_fc, fg);
        BCM_IF_ERROR_RETURN(rv);
    }
#if defined(BROADCOM_DEBUG)
    for (idx = 0; idx < vmap_size; idx++) {
        vmap = stage_fc->vmap[inst][map_id] + idx;
        if (0 == vmap->valid)  {
            continue;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                           "FP(unit %d) vverb: vmap_id (%d): virutal group (%d)"
                           "physical slice (%d) flags (%d)\n"),
                   unit, idx, vmap->virtual_group,
                   vmap->vmap_key,
                   vmap->flags));
    }
#endif /* BROADCOM_DEBUG */
    return BCM_E_NONE;
}

/*
 * Function: _field_virtual_map_insert
 *
 * Purpose:
 *     Insert fp group slices
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field group structure.
 *     map_id         - (IN) Virtual map id.
 *     install        - (IN) Install the map in hw flag.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_virtual_map_insert(int unit, _field_stage_t *stage_fc,
                          _field_group_t *fg, uint8 map_id,
                          uint8 install)
{
    int  v_group[_FP_PAIR_MAX];  /* Virtual group id.        */
    _field_slice_t *fs;          /* Field slice pointer.     */
    int vmap_key;                /* Virtual map key.         */
    int tmp_install;             /* Install map in hw.       */
    int idx;                     /* group iteration index.   */
    int rv;                      /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    /* Initialize virtual group ids. */
    for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
        v_group[idx] = fg->vmap_group[idx];
    }

    /* Get to the last slice. */
    fs = fg->slices;
    while (fs->next != NULL) {
        fs = fs->next;
    }

    while (fs != NULL) {
        tmp_install = ((fs == fg->slices) && (install)) ? TRUE : FALSE;
        vmap_key = (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) ? \
                   (_FP_VMAP_SIZE - 1) : fs->slice_number;
        rv = _field_virtual_map_insert2(unit, stage_fc, fg, map_id,
                                        vmap_key, v_group, tmp_install);
        BCM_IF_ERROR_RETURN(rv);
        fs = fs->prev;
    }

    /* Update virtual group index */
    if (fg->vmap_group[0] == BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT) {
        for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
            fg->vmap_group[idx] = v_group[idx];
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_virtual_map_remove
 *
 * Purpose:
 *     For chips which support the virtual slice/group feature,
 *     Wipe out groups physical slices from virtual map.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field Group Structure.
 *     map_id         - (IN) Virtual map id.
 *     vmap_key       - (IN) Virtual map key.
 *     install        - (IN) Perform installation in HW flag.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_virtual_map_remove(int unit, _field_stage_t *stage_fc, _field_group_t *fg,
                          uint8 map_id, int vmap_key, int install)
{
    int idx;                           /* Virtual map iteration index.   */
    int idx_tmp=0;                     /* Temp iteration index.          */
    int slice_count;                   /* Number of slices used by group.*/
    _field_control_t *fc;              /* Field control structure.       */
    uint32 unused_groups;              /* Unused virtual groups bitmap.  */
    uint32 unused_slices;              /* Unused physical slices bitmap  */
    int rv = BCM_E_NONE;               /* Operation return status.       */
    int v_group[_FP_PAIR_MAX];         /* Virtual group id.              */
    _field_virtual_map_t *vmap = NULL; /* Currently used virtual map.    */
    int vmap_size;                     /* Virtual map size.              */
    int inst;                          /* Pipe Instance.                 */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    inst = fg->instance;
#if defined(BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit)) {
        /* FB2 supports virtual priority in stage ingress only. */
        if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
            return (BCM_E_NONE);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT */

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);


    /* Get virtual group id. */
    for (idx = 0; idx <  _FP_PAIR_MAX; idx++) {
        v_group[idx] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    }

    for (idx = 0; idx < vmap_size; idx++) {
        vmap = (stage_fc->vmap[inst][map_id]) + idx;
        if (TRUE != vmap->valid) {
            continue;
        }
        if (vmap->vmap_key == vmap_key) {
            break;
        }
    }

    /* Make sure virtual group was found. */
    if (idx == vmap_size) {
        /* No such virtual group. */
        return (rv);
    }

    /* Get group width. */
    rv = _bcm_field_group_slice_count_get(vmap->flags, &slice_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Get virtual group ids. */
    for (idx = 0; idx < slice_count; idx++) {
        v_group[idx] = (vmap + idx)->virtual_group;
    }

    /* Mark group maps as invalid. */
    for (idx = 0; idx <  vmap_size; idx++) {
        vmap = stage_fc->vmap[inst][map_id] + idx;
        if (TRUE != vmap->valid) {
            continue;
        }
        /* Check if slice and virtual group matches to mark it invalid*/
        for (idx_tmp = 0; idx_tmp < slice_count; idx_tmp++) {
            if ((vmap->virtual_group == v_group[idx_tmp]) &&
                (vmap->vmap_key == (vmap_key + idx_tmp))){
                vmap->valid = FALSE;
            }
        }
    }

    /* Get unused virtual groups & physical slices */
    vmap = stage_fc->vmap[inst][map_id];
    rv = _field_vmap_unused_resources_get(unit, vmap, vmap_size,
                                          &unused_groups, &unused_slices);
    BCM_IF_ERROR_RETURN(rv);


    /* Assign distinct virtual group numbers to unused virtual slices */
    for (idx = 0; idx < vmap_size; idx++) {
        vmap = (stage_fc->vmap[inst][map_id]) + idx;
        if (vmap->valid == TRUE) {
            continue;
        }
        /* Allocated unused virtual group id. */
        rv = _field_vmap_resource_alloc(unit, vmap, vmap_size,
                                        &unused_groups, &idx_tmp);
        vmap->virtual_group = idx_tmp;

        /* Allocated unused physical slice. */
        rv = _field_vmap_resource_alloc(unit, vmap, vmap_size,
                                        &unused_slices, &idx_tmp);
        vmap->vmap_key = idx_tmp;
    }


    /*
     * Write the new_fp_virtual_map to H/W, and copy to stage's fp_virtual_map
     */
    if (install) {
        rv = fc->functions.fp_write_slice_map(unit, stage_fc, fg);
    }
#if defined(BROADCOM_DEBUG)
    for (idx = 0; idx < vmap_size; idx++) {
        vmap = stage_fc->vmap[inst][map_id] + idx;
        if (0 == vmap->valid)  {
            continue;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: vmap_id (%d): virutal group (%d)"
                               "physical slice (%d) flags (%d)\n"),
                   unit, idx, vmap->virtual_group,
                   vmap->vmap_key,
                   vmap->flags));
    }
#endif /* BROADCOM_DEBUG */

    return rv;
}


/*
 * Function: _field_group_vmap_delete
 *
 * Purpose:
 *     For chips which support the virtual slice/group feature,
 *     Wipe out groups physical slices from virtual map.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field group structure.
 *     install        - (IN) Perform installation in HW flag.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_vmap_delete(int unit, _field_stage_t *stage_fc,
                      _field_group_t *fg, int install)
{
    _field_slice_t   *fs;                    /* Field slice structure.  */
    int              idx;                    /* Temp iteration index.   */
    int              rv;                     /* Operation return status.*/

    fs = fg->slices;

    /* Find and validate field control. */


    /* Loop for deleting all the AUTO expanded slices in group */
    while(fs != NULL) {

        switch (stage_fc->stage_id) {
            case _BCM_FIELD_STAGE_LOOKUP:
            case _BCM_FIELD_STAGE_EGRESS:
                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_VMAP_DEFAULT, fs->slice_number, install);
                BCM_IF_ERROR_RETURN(rv);
                break;
            case _BCM_FIELD_STAGE_EXTERNAL:
                idx = (_FP_VMAP_SIZE) - 1;
                /* External slices controlled by stage ingress map. */
                rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,
                        &stage_fc);
                BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TRIUMPH3(unit)) {
                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_VMAP_DEFAULT, idx, FALSE);
                BCM_IF_ERROR_RETURN(rv);

                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_EXT_IP4, idx, FALSE);
                BCM_IF_ERROR_RETURN(rv);

                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_EXT_IP6, idx, install);
                } else
#endif
                {
                if ((fg->slices)->pkt_type[_FP_EXT_L2]) {
                    rv = _field_virtual_map_remove(unit, stage_fc, fg,
                            _FP_EXT_L2, idx, install);
                } else if ((fg->slices)->pkt_type[_FP_EXT_IP4]) {
                    rv = _field_virtual_map_remove(unit, stage_fc, fg,
                            _FP_EXT_IP4, idx, install);
                } else if ((fg->slices)->pkt_type[_FP_EXT_IP6]) {
                    rv = _field_virtual_map_remove(unit, stage_fc, fg,
                            _FP_EXT_IP6, idx, install);
                } else {
                    rv = BCM_E_INTERNAL;
                }
                }
                BCM_IF_ERROR_RETURN(rv);
                break;
            case _BCM_FIELD_STAGE_INGRESS:
                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_VMAP_DEFAULT, fs->slice_number, FALSE);
                BCM_IF_ERROR_RETURN(rv);

                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_EXT_IP4, fs->slice_number, FALSE);
                BCM_IF_ERROR_RETURN(rv);

                rv = _field_virtual_map_remove(unit, stage_fc, fg,
                        _FP_EXT_IP6, fs->slice_number, install);
                BCM_IF_ERROR_RETURN(rv);
                break;
            default:
                return BCM_E_INTERNAL;
        }
        fs = fs->next;
    }

    return (BCM_E_NONE);
}


/*
 * Function: _field_group_vmap_add
 *
 * Purpose:
 *     For chips which support the virtual slice/group feature,
 *     Add group physical slices to virtual map.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field group structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_vmap_add(int unit, _field_stage_t *stage_fc,
                      _field_group_t *fg)
{
    int              rv;              /* Operation return status.*/

    switch (stage_fc->stage_id) {
      case _BCM_FIELD_STAGE_LOOKUP:
      case _BCM_FIELD_STAGE_EGRESS:
          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_VMAP_DEFAULT, TRUE);
          BCM_IF_ERROR_RETURN(rv);
          break;
      case _BCM_FIELD_STAGE_EXTERNAL:
          /* External slices controlled by stage ingress map. */
          rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,
                                        &stage_fc);
          BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIUMPH3_SUPPORT)
          if (SOC_IS_TRIUMPH3(unit)) {
          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_VMAP_DEFAULT, FALSE);
          BCM_IF_ERROR_RETURN(rv);

          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_EXT_IP4, FALSE);
          BCM_IF_ERROR_RETURN(rv);

          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_EXT_IP6, TRUE);
          } else
#endif
          {
          if ((fg->slices)->pkt_type[_FP_EXT_L2]) {
              rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                             _FP_EXT_L2, TRUE);
          } else if ((fg->slices)->pkt_type[_FP_EXT_IP4]) {
              rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                             _FP_EXT_IP4, TRUE);
          } else if ((fg->slices)->pkt_type[_FP_EXT_IP6]) {
              rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                             _FP_EXT_IP6, TRUE);
          } else {
              rv = BCM_E_INTERNAL;
          }
          }
          BCM_IF_ERROR_RETURN(rv);
          break;
      case _BCM_FIELD_STAGE_INGRESS:
          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_VMAP_DEFAULT, FALSE);
          BCM_IF_ERROR_RETURN(rv);

          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_EXT_IP4, FALSE);
          BCM_IF_ERROR_RETURN(rv);

          rv = _field_virtual_map_insert(unit, stage_fc, fg,
                                         _FP_EXT_IP6, TRUE);
          BCM_IF_ERROR_RETURN(rv);
          break;
      default:
          return BCM_E_INTERNAL;
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_group_free_unused_slices
 *
 * Purpose:
 *     Unallocate group unused slices.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     fg             - (IN) Field group structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_free_unused_slices(int unit, _field_stage_t *stage_fc,
                                _field_group_t *fg)
{
    _field_slice_t *fs;       /* Field slice structure.        */
    _field_slice_t *fs_next;  /* Field slice structure.        */
    _field_slice_t *fs_ptr;   /* Field slice structure.        */
    uint8          empty;     /* Slice is empty flag.          */
    int            idx;       /* Group slices iteration index. */
    int            remap;     /* Reinstall virtual slice map.  */
    int            count;     /* Group slices iteration index. */
    int            rv;        /* Operation return status.      */
    int            virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* We never free first group slice. */
    fs = fg->slices->next;
    remap = FALSE;

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    while (fs != NULL) {
        fs_next = fs->next;
        rv = _field_slice_is_empty(unit, fs, &empty);
        BCM_IF_ERROR_RETURN(rv);
        if (empty) {
            BCM_IF_ERROR_RETURN
                (_bcm_field_group_slice_count_get(fs->group_flags, &count));

            if ((remap == FALSE)
                    && (virtual_priority)) {
                BCM_IF_ERROR_RETURN(_field_group_vmap_delete(unit, stage_fc, fg, FALSE));
            }

            remap = TRUE;
            /* Preserve next slice to continue the loop over group slices. */

            for (idx = 0; idx < count; idx++) {
                /* Remove slice from group slices linked list. */
                fs_ptr = fs + idx;
                if (fs_ptr->prev != NULL) {
                    fs_ptr->prev->next = fs_ptr->next;
                }

                if (fs_ptr->next != NULL) {
                    fs_ptr->next->prev = fs_ptr->prev;
                }

                /* Clear used entries pbmp. */
                rv = _field_slice_clear(unit, fg, fs_ptr, fg->pbmp);
                BCM_IF_ERROR_RETURN(rv);
                fs_ptr->next = fs_ptr->prev = NULL;
            }
        }
        fs = fs_next;
    }

    if ((remap)
            && (virtual_priority)){
        /* Remove the group from virtual map . */
        BCM_IF_ERROR_RETURN(_field_group_vmap_add(unit, stage_fc, fg));
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_group_uninstall
 *
 * Purpose:
 *     Uninstall group from all slices.
 *
 * Parameters:
 *     unit - (IN)BCM device number.
 *     fg   - (IN)Field group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_uninstall(int unit, _field_group_t *fg)
{
    _field_slice_t      *fs;         /* Field slice structure.   */
    _field_slice_t      *temp_fs;    /* Expanded slices iterator.*/
    int                 parts_count = 0; /* Number of entry parts.   */
    uint32              entry_flags; /* Entry part flags.        */
    uint8               slice_number;/* Slices iterator.         */
    int                 rv;          /* Operation return status. */
    int                 idx;         /* Slices iterator.         */


    /* Find and validate field control. */


    /* Get number of entry parts . */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);


    for (idx = parts_count - 1; idx >= 0; idx--) {
        /* Get entry flags. */
        rv = _bcm_field_tcam_part_to_entry_flags(unit, idx, fg,
                                                 &entry_flags);
        BCM_IF_ERROR_RETURN(rv);

        if (entry_flags & _FP_ENTRY_SECOND_HALF) {
            continue;
        }

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, idx, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        fs = fg->slices + slice_number;
        while (fs != NULL) {
            /* Clear tertiary slice, if in-use. */
            BCM_IF_ERROR_RETURN(_field_slice_clear(unit, fg, fs, fg->pbmp));
            temp_fs = fs->next;
            if (fs->prev != NULL) {
                fs->prev->next = NULL;
                fs->prev = NULL;
            }
            fs = temp_fs;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_group_linked_list_remove
 * Purpose:
 *     Remove field group from unit's groups list
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fg       - (IN) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_linked_list_remove(int unit, _field_group_t *fg)
{
    _field_control_t *fc;      /* Field control structure.    */
    _field_group_t   *fg_prev; /* Fied group iterator.        */

    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Remove this group from device's linked-list of groups. */
    if (fc->groups == fg) {
        fc->groups = fg->next;
    }
    else {
        fg_prev = fc->groups;
        while (NULL != fg_prev) {
            if (fg_prev->next ==  fg) {
                fg_prev->next = fg->next;
                break;
            }
            fg_prev = fg_prev->next;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_linked_list_insert
 * Purpose:
 *     Insert new field group into unit's groups list sorted
 *     by priority & group width.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fsm_ptr  - (IN) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_linked_list_insert(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_group_t      *fg;           /* Field group pointer.     */
    _field_group_t      *fg_iter;      /* Field group iterator.    */
    _field_group_t      *fg_iter_prev; /* Field group iterator.    */


    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    fg = fsm_ptr->fg;
    if (NULL == fg) {
         return (BCM_E_PARAM);
    }

    /* Linked list insertion must be done after group mode was
       decided(after select codes selection stage). On 5682x devices
       we might need to reselect select codes based on slice availability,
       to avoid double insertion remove any installed group first.
     */
    BCM_IF_ERROR_RETURN(_bcm_field_group_linked_list_remove(unit, fg));

    /* Insert new field group into unit's groups list sorted by priority. */
    fg_iter_prev = fg_iter = fsm_ptr->fc->groups;
    while (fg_iter != NULL)  {
        /* Priority comparison: low to high insertion. */
        if (fg_iter->priority > fg->priority) {
            break;
        }

        /* Group width comparison: wide group first. */
        if (fg_iter->priority ==  fg->priority) {
            if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
                break;
            }

            if ((0 == (fg_iter->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) &&
                (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)) {
                break;
            }
        }

        fg_iter_prev = fg_iter;
        fg_iter = fg_iter->next;
    }

    /* Head of the list insertion. */
    if (fg_iter == fg_iter_prev) {
        fg->next = fg_iter;
        fsm_ptr->fc->groups = fg;
    } else {
        fg_iter_prev->next = fg;
        fg->next = fg_iter;
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_group_deinit
 * Purpose:
 *    Destroy field group structure.
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     fg     - (IN) Allocated group structure.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 */
int
_field_group_deinit(int unit, _field_group_t *fg)
{
    _field_control_t *fc;          /* Field control structure.    */
    int idx;                       /* Qualifiers iteration index. */
    int rv = BCM_E_NONE;           /* OPerational Status. */

    if (NULL == fg) {
        return (BCM_E_NONE);
    }

    /* Find and validate field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Uninstall group from every slice. */
    if (NULL != fg->slices) {
        _field_group_uninstall(unit, fg);
    }

    /* Deallocate group qualifiers list. */
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        /* If qualifier set was updated free original qualifiers array. */
        BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(fg, idx));
    }

    /* Decrement the use counts for any UDFs used by the group */
    for (idx = 0; idx < BCM_FIELD_USER_NUM_UDFS; idx++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(fg->qset.udf_map, idx))  {
            if (fc->udf[idx].use_count > 0) {
                fc->udf[idx].use_count--;
            }
        }
    }

    /* Deallocate group entry array if any. */
    if (NULL != fg->entry_arr) {
        sal_free(fg->entry_arr);
    }

    rv = _bcm_field_group_stat_destroy(unit, fg->gid);
    BCM_IF_ERROR_RETURN(rv);

    /* Remove group from units group list. */
    BCM_IF_ERROR_RETURN(_bcm_field_group_linked_list_remove(unit, fg));

    if ( soc_feature(unit, soc_feature_field_multi_pipe_support) ||
         soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
        /* Group has been destroyed, Decrement group ref count in
         * corresponding hintid in hints hash lookup table */
        BCM_IF_ERROR_RETURN(
                _bcm_field_hints_group_count_update (unit, fg->hintid, 0));
    }

    sal_free(fg);
    return (BCM_E_NONE);
}

#ifdef BCM_FIREBOLT_SUPPORT
/*
 * Function:
 *     _field_fb_slice_to_field
 *
 * Purpose:
 *     Determines which FP_SLICE_ENABLEr field corresponds to given slice.
 *
 * Parameters:
 *     slice - slice number
 *     field - (OUT) FP_SLICE_ENABLE register field
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_PARAM     - slice number out of range
 */
STATIC int
_field_fb_slice_to_field(_field_group_t *fg,
                         int slice, soc_field_t *field)
{
    static soc_field_t _ifp_slice_enable_field[16] = {
                                               FP_LOOKUP_ENABLE_SLICE_0f,
                                               FP_LOOKUP_ENABLE_SLICE_1f,
                                               FP_LOOKUP_ENABLE_SLICE_2f,
                                               FP_LOOKUP_ENABLE_SLICE_3f,
                                               FP_LOOKUP_ENABLE_SLICE_4f,
                                               FP_LOOKUP_ENABLE_SLICE_5f,
                                               FP_LOOKUP_ENABLE_SLICE_6f,
                                               FP_LOOKUP_ENABLE_SLICE_7f,
                                               FP_LOOKUP_ENABLE_SLICE_8f,
                                               FP_LOOKUP_ENABLE_SLICE_9f,
                                               FP_LOOKUP_ENABLE_SLICE_10f,
                                               FP_LOOKUP_ENABLE_SLICE_11f,
                                               FP_LOOKUP_ENABLE_SLICE_12f,
                                               FP_LOOKUP_ENABLE_SLICE_13f,
                                               FP_LOOKUP_ENABLE_SLICE_14f,
                                               FP_LOOKUP_ENABLE_SLICE_15f};

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    static soc_field_t _vfp_slice_enable_field[4] = {LOOKUP_ENABLE_SLICE_0f,
                                                     LOOKUP_ENABLE_SLICE_1f,
                                                     LOOKUP_ENABLE_SLICE_2f,
                                                     LOOKUP_ENABLE_SLICE_3f};

    static soc_field_t _efp_slice_enable_field[4] = {LOOKUP_ENABLE_SLICE_0f,
                                                     LOOKUP_ENABLE_SLICE_1f,
                                                     LOOKUP_ENABLE_SLICE_2f,
                                                     LOOKUP_ENABLE_SLICE_3f};
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    assert(fg != NULL && field != NULL);
    if (_BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
         if (slice < 0 || slice >= COUNTOF(_ifp_slice_enable_field)) {
             return (BCM_E_PARAM);
         }
         *field = _ifp_slice_enable_field[slice];
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) {
         if (slice < 0 || slice >= COUNTOF(_vfp_slice_enable_field)) {
             return (BCM_E_PARAM);
         }
         *field = _vfp_slice_enable_field[slice];

    } else if (_BCM_FIELD_STAGE_EGRESS == fg->stage_id) {
         if (slice < 0 || slice >= COUNTOF(_efp_slice_enable_field)) {
             return (BCM_E_PARAM);
         }
         *field = _efp_slice_enable_field[slice];
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    } else {
         return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_fb_slice_enable_set
 *
 * Purpose:
 *     Enables or disables packet lookup on a hardware slice.
 *
 * Parameters:
 *     unit   - BCM device number
 *     slice  - Slice number to enable
 *     enable - enable/disable state of slice
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_INTERNAL  - SOC read/write error
 *
 * Note:
 *     Calling function is responsible for checking feature availability.
 */
int
_bcm_field_fb_slice_enable_set(int unit, _field_group_t *fg,
                           uint8 slice, int enable)
{
    uint32              reg_val_old, reg_val_new;
    soc_field_t         field;

    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                       "FP: _field_fb_slice_enable_set(slice=%d, enable=%d)\n"),
                 slice, enable));

    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_fb_slice_to_field(fg, slice, &field));
    enable = (enable ? 1 : 0);
    if (_BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        SOC_IF_ERROR_RETURN(READ_FP_SLICE_ENABLEr(unit, &reg_val_old));
        reg_val_new = reg_val_old;
        soc_reg_field_set(unit, FP_SLICE_ENABLEr, &reg_val_new, field, enable);
        if (reg_val_new != reg_val_old) {
            BCM_IF_ERROR_RETURN(WRITE_FP_SLICE_ENABLEr(unit, reg_val_new));
        }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) {
        SOC_IF_ERROR_RETURN(READ_VFP_SLICE_CONTROLr(unit, &reg_val_old));
        reg_val_new = reg_val_old;
        soc_reg_field_set(unit, VFP_SLICE_CONTROLr, &reg_val_new,
                          field, enable);
        if (reg_val_new != reg_val_old) {
            SOC_IF_ERROR_RETURN(WRITE_VFP_SLICE_CONTROLr(unit, reg_val_new));
        }
    } else if (_BCM_FIELD_STAGE_EGRESS == fg->stage_id) {
        SOC_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &reg_val_old));
        reg_val_new = reg_val_old;
        soc_reg_field_set(unit, EFP_SLICE_CONTROLr, &reg_val_new,
                          field, enable);
        if (reg_val_new != reg_val_old) {
            BCM_IF_ERROR_RETURN(WRITE_EFP_SLICE_CONTROLr(unit, reg_val_new));
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT  */
    } else {
         return (BCM_E_INTERNAL);
    }


    return (BCM_E_NONE);
}
#endif /* BCM_FIREBOLT_SUPPORT */


STATIC int
_field_slice_enable_set(int            unit,
                        _field_stage_t *stage_fc,
                        _field_group_t *fg,
                        _field_slice_t *fs,
                        unsigned       enable
                        )
{
    if (stage_fc->flags & _FP_STAGE_SLICE_ENABLE) {
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit)) {
            return (_bcm_field_tr3_slice_enable_set(unit, stage_fc, fg, fs, 1));
        }
#endif
#ifdef BCM_FIREBOLT_SUPPORT
        return (_bcm_field_fb_slice_enable_set(unit, fg, fs->slice_number, 1));
#endif /* BCM_FIREBOLT_SUPPORT */
    }

    return (BCM_E_NONE);
}


unsigned
_field_stage_action_support_check(int              unit,
                                  _field_group_t   *fg,
                                  unsigned         action
                                  )
{
    _field_control_t *fc;
    _field_entry_t   f_ent[1];  /* Dummy entry */
    int              suppf = 0;

    if (BCM_FAILURE(_field_control_get(unit, &fc))) {
        return (FALSE);
    }

    /* Set group in dummy entry, since old code takes entry as parameter
       (nothing else in entry matters).
     */

    f_ent->group = fg;

    return (BCM_SUCCESS(fc->functions.fp_action_support_check(unit,
                                                              f_ent,
                                                              action,
                                                              &suppf
                                                              )
                        )
            && suppf
            );
}


int
_bcm_field_group_default_aset_set(int unit, _field_group_t *fg)
{
    /* Set group's aset to all actions supported by stage */

    unsigned action;

    for (action = 0; action < bcmFieldActionCount; ++action) {
        if (_field_stage_action_support_check(unit, fg, action)) {
            SHR_BITSET(fg->aset.w, action);
        }
    }

    return (BCM_E_NONE);
}


int
_field_group_default_aset_set(int unit, _field_group_t *fg)
{
    sal_memset(fg->aset.w, 0, sizeof(fg->aset.w));

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_group_default_aset_set(unit, fg));
    }
#endif

    /* Default aset is set of all supported actions */

    return (_bcm_field_group_default_aset_set(unit, fg));
}

/*
 * Function:
 *     _field_group_add_selcodes_install
 * Purpose:
 *     Update allocated slice sw controls &
 *     install slice select codes into hw.
 * Parameters:

 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_selcodes_install(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_slice_t *fs;                /* Slice pointer.          */
    _field_group_t *fg;                /* Field group pointer.    */
    uint32         entry_flags;        /* Entry lookup flags.     */
    uint8          slice_number;       /* Slices iterator.        */
    int            idx;                /* Slice iteration index.  */
    int            parts_count = 0;    /* Number of entry parts.  */
    int            slice_init;         /* Slice sw init needed.   */
    int            rv;                 /* Operation return status.*/

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    fg = fsm_ptr->fg;

    /* Check if this is the first group installed in slice. */
    slice_init = BCM_PBMP_IS_NULL(fg->slices[0].pbmp) ? TRUE : FALSE;

    /* Install slice/s select codes. */
    BCM_PBMP_OR(fg->slices[0].pbmp, fg->pbmp);

    /* Write group parameters to hardware. */
    BCM_IF_ERROR_RETURN(fsm_ptr->fc->functions.fp_group_install(unit, fg));

    /* Get number of entry parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = parts_count - 1; idx >= 0; idx--) {
        /* Get entry flags. */
        rv = _bcm_field_tcam_part_to_entry_flags(unit, idx, fg,
                                                 &entry_flags);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, idx, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice pointer. */
        fs = fg->slices + slice_number;

        /* Enable slice. */
        if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {

            /* Set per slice configuration &  number of free entries in the slice.*/
            if (slice_init)  {
                fs->free_count = fs->entry_count;
                if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                    fs->free_count >>= 1;
                }
                /* Set group flags in in slice.*/
                fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;
            }

            /* Set slice usage by device ports. */
            BCM_PBMP_OR(fs->pbmp, fg->pbmp);
        }
        /* Set source class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].src_class_sel) {
            fs->src_class_sel = fg->sel_codes[idx].src_class_sel;
        }
        /* Set destination class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].dst_class_sel) {
            fs->dst_class_sel = fg->sel_codes[idx].dst_class_sel;
        }
        /* Set interface class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].intf_class_sel) {
            fs->intf_class_sel = fg->sel_codes[idx].intf_class_sel;
        }
        /* Set loopback type/tunnel type selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].loopback_type_sel) {
            fs->loopback_type_sel = fg->sel_codes[idx].loopback_type_sel;
        }
        /* Set ingress entity selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].ingress_entity_sel) {
            fs->ingress_entity_sel = fg->sel_codes[idx].ingress_entity_sel;
        }
        /* Set src entity selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].src_entity_sel) {
            fs->src_entity_sel = fg->sel_codes[idx].src_entity_sel;
        }
        /* Set destination forwarding entity selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].dst_fwd_entity_sel) {
            fs->dst_fwd_entity_sel = fg->sel_codes[idx].dst_fwd_entity_sel;
        }

        /* Set destination forwarding field selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].fwd_field_sel) {
            fs->fwd_field_sel = fg->sel_codes[idx].fwd_field_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].ttl_class_sel) {
            fs->ttl_class_sel = fg->sel_codes[idx].ttl_class_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].tcp_class_sel) {
            fs->tcp_class_sel = fg->sel_codes[idx].tcp_class_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].tos_class_sel) {
            fs->tos_class_sel = fg->sel_codes[idx].tos_class_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].aux_tag_1_sel) {
            fs->aux_tag_1_sel = fg->sel_codes[idx].aux_tag_1_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].aux_tag_2_sel) {
            fs->aux_tag_2_sel = fg->sel_codes[idx].aux_tag_2_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].oam_overlay_sel) {
            fs->oam_overlay_sel = fg->sel_codes[idx].oam_overlay_sel;
        }

        if (fg->sel_codes[idx].egr_class_f1_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_class_f1_sel = fg->sel_codes[idx].egr_class_f1_sel;
        }

        if (fg->sel_codes[idx].egr_class_f2_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_class_f2_sel = fg->sel_codes[idx].egr_class_f2_sel;
        }

        if (fg->sel_codes[idx].egr_class_f3_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_class_f3_sel = fg->sel_codes[idx].egr_class_f3_sel;
        }

        if (fg->sel_codes[idx].egr_class_f4_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_class_f4_sel = fg->sel_codes[idx].egr_class_f4_sel;
        }

        if (fg->sel_codes[idx].src_dest_class_f1_sel != _FP_SELCODE_DONT_CARE) {
            fs->src_dest_class_f1_sel = fg->sel_codes[idx].src_dest_class_f1_sel;
        }

        if (fg->sel_codes[idx].src_dest_class_f3_sel != _FP_SELCODE_DONT_CARE) {
            fs->src_dest_class_f3_sel = fg->sel_codes[idx].src_dest_class_f3_sel;
        }

        if (fg->sel_codes[idx].egr_key4_dvp_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_key4_dvp_sel = fg->sel_codes[idx].egr_key4_dvp_sel;
        }

        if (fg->sel_codes[idx].egr_key4_mdl_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_key4_mdl_sel = fg->sel_codes[idx].egr_key4_mdl_sel;
        }

        if (fg->sel_codes[idx].egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_oam_overlay_sel = fg->sel_codes[idx].egr_oam_overlay_sel;
        }

        if (fg->sel_codes[idx].oam_intf_class_sel != _FP_SELCODE_DONT_CARE) {
            fs->oam_intf_class_sel = fg->sel_codes[idx].oam_intf_class_sel;
        }

        if (fg->sel_codes[idx].egr_dest_port_f1_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_dest_port_f1_sel = fg->sel_codes[idx].egr_dest_port_f1_sel;
        }

        if (fg->sel_codes[idx].egr_dest_port_f5_sel != _FP_SELCODE_DONT_CARE) {
            fs->egr_dest_port_f5_sel = fg->sel_codes[idx].egr_dest_port_f5_sel;
        }

        /* Set intraslice double wide key selection. */
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            if ((_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].fpf2) &&
                ((idx == _FP_INTRA_SLICE_PART_1) ||
                 (idx == _FP_INTRA_SLICE_PART_3))) {
                fs->doublewide_key_select = fg->sel_codes[idx].fpf2;
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_add_adjust_virtual_map
 * Purpose:
 *     Update slices virtual priorities map.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_adjust_virtual_map(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_group_t   *fg;         /* Field group control structure.  */
    int              virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    _field_virtual_priority_support(unit, fsm_ptr->stage_fc, &virtual_priority);

    /* Initialize group pointer. */
    fg = fsm_ptr->fg;

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /*  Update slices virtual priorities map.  */
    if (virtual_priority) {
        if (BCM_PBMP_EQ(fg->slices->pbmp, fg->pbmp)) {
            /*
             * If this is a first group in a slice
             * a) allocate virtual group.
             * b) Update slice virtual priority.
             */
            fsm_ptr->rv = _field_group_vmap_add(unit, fsm_ptr->stage_fc, fg);
        } else {
            /* Slice sharing find the slice in VMAP
             * and update the corresponding VMAP group */
            fsm_ptr->rv = _field_group_slice_sharing_virtual_map_group(unit, fsm_ptr->stage_fc, fg);
        }
    }

    if (BCM_SUCCESS(fsm_ptr->rv)) {
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_UDF_UPDATE;
    } else {
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
    }
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_group_add_hw_qual_list_get
 * Purpose:
 *     Get qualifiers offset in hw.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_hw_qual_list_get(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

   /*
    * Set the FPFx metadata (bit offset, width) for this HW
    * this fills the group's qualifier lists.
    */
    fsm_ptr->rv = fsm_ptr->fc->functions.fp_qual_list_get(unit,
                                                          fsm_ptr->stage_fc,
                                                          fsm_ptr->fg);
    if (BCM_FAILURE(fsm_ptr->rv)) {
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
    } else {
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_ADJUST_VIRTUAL_MAP;
    }
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_udf_usecount_increment
 *
 * Purpose:
 *     Increment the use counts for any UDFs used
 *
 * Parameters:
 *     fc - unit's field control struct
 *     fg - group's metadata struct
 *
 * Returns:
 *     BCM_E_RESOURCE - Invalid UDF
 *     BCM_E_NONE     - Success
 *
 */
STATIC int
_field_udf_usecount_increment(_field_control_t *fc, _field_group_t *fg)
{
    int                 idx;

    for (idx = 0; idx < BCM_FIELD_USER_NUM_UDFS; idx++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(fg->qset.udf_map, idx)) {
            fc->udf[idx].use_count++;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_add_udf_update
 * Purpose:
 *     Update udf usage count.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_udf_update(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /* Increment the use counts for any UDFs used */
    fsm_ptr->rv = _field_udf_usecount_increment(fsm_ptr->fc, fsm_ptr->fg);
    fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;

    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function: _field_group_virtual_group_validate
 *
 * Purpose:
 *  Verify that there is no virtual group conflict between
 *  group & other groups in the slice.
 *
 * Parameters:
 *     unit          - (IN)BCM device number.
 *     stage_fc      - (IN)FP stage control info.
 *     fg            - (IN)FP group
 *     slice_numb    - (IN)Slice number where mode is to be programmed.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_CONFIG    - Slice is already programmed with conflicting priority.
 *     BCM_E_XXX       - Any other error.
 */
STATIC int
_field_group_virtual_group_validate(int unit, _field_stage_t *stage_fc,
                                       _field_group_t *fg, int slice_numb)
{
    _field_slice_t       *fs;    /* First group slice.          */
    _field_control_t     *fc;
    _field_group_t       *fg_temp = NULL;

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    if (slice_numb > stage_fc->tcam_slices) {
        return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                     "FP(unit %d) vverb: _field_group_virtual_group_validate"
                     "(slice_numb=%d, Virtual group=%d)\n"), unit, slice_numb,
               fg->action_res_id));

    /*
     *  Since we already checked ports & mode it is enough to check
     *  virtual priority for first slice only.
     */
    fs = stage_fc->slices[fg->instance] + slice_numb;
    if (BCM_PBMP_IS_NULL(fs->pbmp)) {
        /* Slice is not used -> no conflicts. */
        return (BCM_E_NONE);
    }


    /*
     * If two groups sharing a slice they should have the same action resolution id.
     */

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (fg_temp =  fc->groups; fg_temp != NULL; fg_temp = fg_temp->next) {
        if (fg_temp->stage_id != stage_fc->stage_id) {
            continue;
        }

        if (fg_temp == fg) {
            continue;
        }

        /* If slice doesn't belong to group continue */
        if (fg_temp->slices[0].slice_number != fs->slice_number) {
            continue;
        }

        if (fg->action_res_id == fg_temp->action_res_id){
            return (BCM_E_NONE);
        }
    }

    return (BCM_E_CONFIG);
}

/*
 * Function: _field_group_virtual_priority_validate
 *
 * Purpose:
 *  Verify that ther is no virtual priority conflict between
 *  group & other groups in the slice.
 *
 * Parameters:
 *     unit          - (IN)BCM device number.
 *     stage_fc      - (IN)FP stage control info.
 *     fg            - (IN)FP group
 *     slice_numb    - (IN)Slice number where mode is to be programmed.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_CONFIG    - Slice is already programmed with conflicting priority.
 *     BCM_E_XXX       - Any other error.
 */
STATIC int
_field_group_virtual_priority_validate(int unit, _field_stage_t *stage_fc,
                                       _field_group_t *fg, int slice_numb)
{
    _field_slice_t       *fs;    /* First group slice.          */
    int                  idx;    /* Virtual map iteration index.*/
    _field_virtual_map_t *vmap;  /* Virtual map for stage.      */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    if (slice_numb > stage_fc->tcam_slices) {
        return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                     "FP(unit %d) vverb: _field_group_virtual_priority_validate"
                     "(slice_numb=%d, priority=%d)\n"), unit, slice_numb,
               fg->priority));

    /* If group doesn't care about priority - done. */
    if (BCM_FIELD_GROUP_PRIO_ANY == fg->priority) {
        return (BCM_E_NONE);
    }

    /*
     *  Since we already checked ports & mode it is enough to check
     *  virtual priority for first slice only.
     */
    fs = stage_fc->slices[fg->instance] + slice_numb;
    if (BCM_PBMP_IS_NULL(fs->pbmp)) {
        /* Slice is not used -> no conflicts. */
        return (BCM_E_NONE);
    }

    /*
     * If two groups sharing a slice they should have the same priority.
     */
    vmap = stage_fc->vmap[fg->instance][_FP_VMAP_DEFAULT];
    for (idx = 0; idx < stage_fc->tcam_slices; idx++) {
        if (vmap[idx].valid == FALSE) {
            continue;
        } else {
            if (fs->slice_number != vmap[idx].vmap_key) {
                continue;
            }
            if (fg->priority != vmap[idx].priority) {
                return (BCM_E_CONFIG);
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_group_ports_validate
 *
 * Purpose:
 *     Test requested group ports against available ports in the slice or
 *     slices needed by the group.
 *
 *     Test to see if mode is appropriate for device. Basically this means
 *     checking for double and triple wide requests on devices that do not
 *     support it. There are additional range checks, but those should almost
 *     never fail.
 *
 * Parameters:
 *     unit          - (IN)BCM device number
 *     stage_fc      - (IN)Stage FP control info.
 *     instance      - (IN)Pipe Instance the group belongs to.
 *     slice_base    - (IN)Primary slice number.
 *     flags         - (IN)Flags with group mode (single, double, triple or Auto-wide).
 *     pbmp          - (IN)Bit map of ports that group is requesting.
 *
 * Returns:
 *     BCM_E_CONFIG    - Requested at least one port unavailable on one or more
 *                       slices.
 *     BCM_E_NONE      - Success
 */
STATIC int
_field_group_ports_validate(int unit, const _field_stage_t *stage_fc,
                            int instance, const int slice_base,
                            const uint8 flags, const bcm_pbmp_t pbmp)
{
    _field_slice_t     *fs;          /* Field slice structure. */
    bcm_pbmp_t          pbmp_temp;
    bcm_pbmp_t          group_pbmp;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
               "FP(unit %d) vverb: _field_group_ports_validate(slice_base=%d,"
               " flags=%d)\n"), unit, slice_base, flags));

    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    BCM_PBMP_ASSIGN(group_pbmp, pbmp);
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id))) {
        bcm_port_config_t  *port_config;/* Device port config.    */
        int                 rv = BCM_E_NONE;  /* Return Variable */

        /* Read device port configuration. */
        port_config = NULL;
        _FP_XGS3_ALLOC(port_config, sizeof(bcm_port_config_t),
                       "Port config info ");
        rv = bcm_esw_port_config_get(unit, port_config);
        if (rv < 0) {
            if (port_config !=NULL) {
                sal_free(port_config);
            }
        }
        BCM_PBMP_CLEAR(group_pbmp);
        /*
         * To return the valid free slice, the slice's pbmp must to NULL for VFP
         * and EFP. To find out, it has to be AND with all_pbmp in-case of TH,
         * as the group's might contain per-pipe pbmp.
         */
        if (port_config !=NULL) {
            BCM_PBMP_ASSIGN(group_pbmp, port_config->all);
            sal_free(port_config);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        if (slice_base % 4 != 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                       "FP(unit %d) Error: bad slice=%d for triple-mode.\n"),
                       unit,
                       slice_base));
            return (BCM_E_PARAM);
        }
        if ((slice_base + 2) > stage_fc->tcam_slices) {
            return (BCM_E_CONFIG);
        }
        fs = stage_fc->slices[instance] + slice_base + 2;
        BCM_PBMP_ASSIGN(pbmp_temp, fs->pbmp);
        BCM_PBMP_AND(pbmp_temp, group_pbmp);
        if (BCM_PBMP_NOT_NULL(pbmp_temp)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) vverb: slice=%d in-use.\n"),
                       unit, slice_base));
            return (BCM_E_CONFIG);
        }
    }

    if ((flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {

        if (slice_base % 2 != 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                       "FP(unit %d) Error: bad slice=%d for double-mode.\n"),
                       unit,
                       slice_base));
            return (BCM_E_PARAM);
        }

        if ((slice_base + 1) > stage_fc->tcam_slices) {
            return (BCM_E_CONFIG);
        }
        fs = stage_fc->slices[instance] + slice_base + 1;
        /* If group is intraslice verify that slice is intraslice capable. */
        if (flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)  {
             if (0 == (fs->slice_flags & _BCM_FIELD_SLICE_INTRASLICE_CAPABLE)) {
                 return (BCM_E_CONFIG);
             }
        }

        BCM_PBMP_ASSIGN(pbmp_temp, fs->pbmp);
        BCM_PBMP_AND(pbmp_temp, group_pbmp);
        if (BCM_PBMP_NOT_NULL(pbmp_temp)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) vverb: slice=%d in-use.\n"),
                       unit, slice_base));
            return (BCM_E_CONFIG);
        }
    }

    fs = stage_fc->slices[instance] + slice_base;
    /* If group is intraslice verify that slice is intraslice capable. */
    if (flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)  {
        if (0 == (fs->slice_flags & _BCM_FIELD_SLICE_INTRASLICE_CAPABLE)) {
            return (BCM_E_CONFIG);
        }
    }

    BCM_PBMP_ASSIGN(pbmp_temp, fs->pbmp);
    BCM_PBMP_AND(pbmp_temp, group_pbmp);
    if (BCM_PBMP_NOT_NULL(pbmp_temp)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: slice=%d in-use.\n"),
                   unit, slice_base));
        return (BCM_E_CONFIG);
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_group_slice_mode_validate
 *
 * Purpose:
 *     Check if group can use the slice e.g.
 *     per slice configuration for other installed groups
 *     doesn't create a conflict.
 * Parameters:
 *     unit      - (IN)BCM device number.
 *     slice_num - (IN)Group slice number.
 *     fs        - (IN)Slice control structure.
 *     fg        - (IN)Field group structure.
 *
 * Returns:
 *     BCM_E_NONE      - No conflicts
 *     BCM_E_CONFIG    - Slice is already programmed with conflicting mode.
 *     BCM_E_XXX - other errors.
 */
STATIC int
_field_group_slice_mode_validate(int unit, int slice_num,
                                 _field_slice_t *fs, _field_group_t *fg)
{
    uint8          slice_number;       /* Slices iterator.        */
    int            idx;                /* Slice iteration index.  */
    int            parts_count = 0;    /* Number of entry parts.  */
    int            rv;                 /* Operation return status.*/

    /* Input parameters check. */
    if ((NULL == fs) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    if (BCM_PBMP_IS_NULL(fs->pbmp)) {
        /* Slice is not used -> no conflicts. */
        return (BCM_E_NONE);
    }

    /* Check for single/double/triple wide mode match. */
    if ((fg->flags & _FP_GROUP_STATUS_MASK) !=
        (fs->group_flags & _FP_GROUP_STATUS_MASK)) {
        return (BCM_E_CONFIG);
    }

    /* Get number of entry parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < parts_count; idx++) {
        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, idx, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice pointer. */
        fs += slice_number;

        /* Source class selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->src_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].src_class_sel) &&
            (fs->src_class_sel != fg->sel_codes[idx].src_class_sel)) {
            return (BCM_E_CONFIG);
        }

        /* Destination class selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->dst_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].dst_class_sel) &&
            (fs->dst_class_sel != fg->sel_codes[idx].dst_class_sel)) {
            return (BCM_E_CONFIG);
        }
        /* Interface class selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->intf_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].intf_class_sel) &&
            (fs->intf_class_sel != fg->sel_codes[idx].intf_class_sel)) {
            return (BCM_E_CONFIG);
        }
        /* Loopback type/Tunnel type selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->loopback_type_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].loopback_type_sel) &&
            (fs->loopback_type_sel != fg->sel_codes[idx].loopback_type_sel)) {
            return (BCM_E_CONFIG);
        }
        /* Ingress entity selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->ingress_entity_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].ingress_entity_sel) &&
            (fs->ingress_entity_sel != fg->sel_codes[idx].ingress_entity_sel)) {
            return (BCM_E_CONFIG);
        }
        /* Src entity selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->src_entity_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].src_entity_sel) &&
            (fs->src_entity_sel != fg->sel_codes[idx].src_entity_sel)) {
            return (BCM_E_CONFIG);
        }
        /* Dstination forwarding entity selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->dst_fwd_entity_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].dst_fwd_entity_sel) &&
            (fs->dst_fwd_entity_sel != fg->sel_codes[idx].dst_fwd_entity_sel)) {
            return (BCM_E_CONFIG);
        }

        /* Dstination forwarding entity selection comparison. */
        if ((_FP_SELCODE_DONT_CARE != fs->fwd_field_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].fwd_field_sel) &&
            (fs->fwd_field_sel != fg->sel_codes[idx].fwd_field_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->ttl_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].ttl_class_sel) &&
            (fs->ttl_class_sel != fg->sel_codes[idx].ttl_class_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->tos_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].tos_class_sel) &&
            (fs->tos_class_sel != fg->sel_codes[idx].tos_class_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->tcp_class_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].tcp_class_sel) &&
            (fs->tcp_class_sel != fg->sel_codes[idx].tcp_class_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->aux_tag_1_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].aux_tag_1_sel) &&
            (fs->aux_tag_1_sel != fg->sel_codes[idx].aux_tag_1_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->aux_tag_2_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].aux_tag_2_sel) &&
            (fs->aux_tag_2_sel != fg->sel_codes[idx].aux_tag_2_sel)) {
            return (BCM_E_CONFIG);
        }

        if ((_FP_SELCODE_DONT_CARE != fs->oam_overlay_sel) &&
            (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].oam_overlay_sel) &&
            (fs->oam_overlay_sel != fg->sel_codes[idx].oam_overlay_sel)) {
            return (BCM_E_CONFIG);
        }
        if (fs->egr_class_f1_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_class_f1_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_class_f1_sel != fg->sel_codes[idx].egr_class_f1_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_class_f2_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_class_f2_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_class_f2_sel != fg->sel_codes[idx].egr_class_f2_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_class_f3_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_class_f3_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_class_f3_sel != fg->sel_codes[idx].egr_class_f3_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_class_f4_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_class_f4_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_class_f4_sel != fg->sel_codes[idx].egr_class_f4_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->src_dest_class_f1_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].src_dest_class_f1_sel != _FP_SELCODE_DONT_CARE
            && fs->src_dest_class_f1_sel != fg->sel_codes[idx].src_dest_class_f1_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->src_dest_class_f3_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].src_dest_class_f3_sel != _FP_SELCODE_DONT_CARE
            && fs->src_dest_class_f3_sel != fg->sel_codes[idx].src_dest_class_f3_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_key4_dvp_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_key4_dvp_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_key4_dvp_sel != fg->sel_codes[idx].egr_key4_dvp_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_key4_mdl_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_key4_mdl_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_key4_mdl_sel != fg->sel_codes[idx].egr_key4_mdl_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_oam_overlay_sel != fg->sel_codes[idx].egr_oam_overlay_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->oam_intf_class_sel != _FP_SELCODE_DONT_CARE
                && fg->sel_codes[idx].oam_intf_class_sel != _FP_SELCODE_DONT_CARE
                && fs->oam_intf_class_sel != fg->sel_codes[idx].oam_intf_class_sel
           ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_dest_port_f1_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_dest_port_f1_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_dest_port_f1_sel != fg->sel_codes[idx].egr_dest_port_f1_sel
            ) {
            return (BCM_E_CONFIG);
        }

        if (fs->egr_dest_port_f5_sel != _FP_SELCODE_DONT_CARE
            && fg->sel_codes[idx].egr_dest_port_f5_sel != _FP_SELCODE_DONT_CARE
            && fs->egr_dest_port_f5_sel != fg->sel_codes[idx].egr_dest_port_f5_sel
            ) {
            return (BCM_E_CONFIG);
        }

        /* Set intraslice double wide key selection. */
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            if (((idx == _FP_INTRA_SLICE_PART_1) ||
                 (idx == _FP_INTRA_SLICE_PART_3)) &&
                ((_FP_SELCODE_DONT_CARE != fs->doublewide_key_select) &&
                 (_FP_SELCODE_DONT_CARE != fg->sel_codes[idx].fpf2) &&
                 (fs->doublewide_key_select != fg->sel_codes[idx].fpf2))) {
                return (BCM_E_CONFIG);
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_group_mode_validate
 *
 * Purpose:
 *      Check if set of slices are usable for a new group.
 *
 * Parameters:
 *     unit          - (IN)BCM device number.
 *     stage_fc      - (IN)FP stage control info.
 *     fg            - (IN)FP group
 *     slice_numb    - (IN)Slice number where mode is to be programmed.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_CONFIG    - Slice is already programmed with conflicting mode.
 *     BCM_E_XXX       - Any other error.
 */
STATIC int
_field_group_mode_validate(int unit, _field_stage_t *stage_fc,
                           _field_group_t *fg, int slice_numb)
{
    _field_slice_t *fs;

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
       return (BCM_E_PARAM);
    }

    if (slice_numb > stage_fc->tcam_slices) {
       return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
              "FP(unit %d) vverb: _field_group_mode_validate(slice_numb=%d, "
              "flags=%d)\n"), unit, slice_numb, fg->flags));

    /* Confirm that mode will work on specific slice(s). If another group is
     * already defined on slice(s), then the requested mode has to match
     * the hardware mode. */
    fs = stage_fc->slices[fg->instance] + slice_numb;

    return
      _field_group_slice_mode_validate(unit, _FP_INTER_SLICE_PART_2, fs, fg);
}

/*
 * Function:
 *     _field_group_add_slice_validate
 * Purpose:
 *     Validate a candidate slice if it fits for a group.
 * Parameters:
 *     unit     - (IN  BCM device number.
 *     stage_fc - (IN) State machine tracking structure.
 *     fg       - (IN) Field group structure.
 *     slice_id - (IN) Candidate slice id.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_slice_validate(int unit, _field_stage_t *stage_fc,
                                _field_group_t *fg, int slice_id)
{
    int rv;                       /* Operation return status. */
    int virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == fg)) {
        return (BCM_E_PARAM);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    /*
     * If this slice belongs to an auto-expanded group, AND
     *     is not the first one of that group,
     *         cannot use it
     */
    if (stage_fc->slices[fg->instance][slice_id].prev != NULL) {
        return (BCM_E_CONFIG);
    }

    /*
     *  Skip the slice if group is intraslice and
     *  slice is not intraslice capable.
     */
    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
        (0 == (stage_fc->slices[fg->instance][slice_id].slice_flags &
               _BCM_FIELD_SLICE_INTRASLICE_CAPABLE))) {
        return (BCM_E_CONFIG);
    }

    /*
     *  Skip the slice if group slice size is small  and
     *  slice is not of smaller size.
     */
    if ((fg->flags & _FP_GROUP_SELECT_SMALL_SLICE) &&
        (0 == (stage_fc->slices[fg->instance][slice_id].slice_flags &
               _BCM_FIELD_SLICE_SIZE_SMALL))) {
        return (BCM_E_CONFIG);
    }

    /*
     *  Skip the slice if group slice size is large  and
     *  slice is not of large size.
     */
    if ((fg->flags & _FP_GROUP_SELECT_LARGE_SLICE) &&
        (0 == (stage_fc->slices[fg->instance][slice_id].slice_flags &
               _BCM_FIELD_SLICE_SIZE_LARGE))) {
        return (BCM_E_CONFIG);
    }

    /*
     *  Make sure there is no conflict between groups ports
     *  and other groups in the slice.
     */
    rv = _field_group_ports_validate(unit, stage_fc, fg->instance, slice_id,
                                     fg->flags, fg->pbmp);
    BCM_IF_ERROR_RETURN(rv);

    /*
     *  Make sure there is no conflict between
     *  group & other groups mode. (single/double/triple)
     *  do not coexist.
     */
    rv = _field_group_mode_validate(unit, stage_fc, fg, slice_id);
    BCM_IF_ERROR_RETURN(rv);

    /*
     *  Make sure there is no virtual priority conflict between
     *  group & other groups in the slice.
     */
    if (virtual_priority) {
        if (stage_fc->flags & _FP_STAGE_AUTO_EXPANSION) {
            fg->flags |= _FP_GROUP_SELECT_AUTO_EXPANSION;
        }
        rv = _field_group_virtual_priority_validate(unit, stage_fc,
                                                    fg, slice_id);
        BCM_IF_ERROR_RETURN(rv);
        rv = _field_group_virtual_group_validate(unit, stage_fc,
                                                    fg, slice_id);
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_virtual_priority_support
 * Purpose:
 *     Check if device supports virtual priority.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Field stage control.
 *     support  - (OUT) TRUE supports virtual priority.
 *                      FALSE otherwise.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_virtual_priority_support(int unit, _field_stage_t *stage_fc, int *support)
{

    /* Input parameters check. */
    if ((NULL == stage_fc) ||  (NULL == support)){
        return (BCM_E_PARAM);
    }

    if (0 == soc_feature(unit, soc_feature_field_virtual_slice_group)) {
        *support = FALSE;
    } else if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        *support = TRUE;
    } else if (SOC_IS_FIREBOLT2(unit)) {
        *support = FALSE;
    } else {
        *support = TRUE;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_add_slice_allocate
 * Purpose:
 *     Allocate slice for a new group.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_slice_allocate(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_group_t      *fg;             /* Field group pointer.          */
    _field_stage_t      *stage_fc;       /* Stage field control.          */
    int                 slice_id;        /* Slices iterator.              */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Group pointer initialization. */
    fg = fsm_ptr->fg;
    stage_fc = fsm_ptr->stage_fc;
    slice_id = -1;

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    if ((_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id)) {
        /* External slices mapped 1-1 to selected keys.*/
        fg->slices = stage_fc->slices[_FP_DEF_INST] + fg->sel_codes[0].extn;
        slice_id = fg->sel_codes[0].extn;
    } else if ((BCM_FIELD_GROUP_PRIO_ANY == fsm_ptr->priority) || (virtual_priority)) {
        /* If not specified, generate a priority. */
        for (slice_id = 0; slice_id < stage_fc->tcam_slices; slice_id++) {
            fsm_ptr->rv = _field_group_add_slice_validate(unit, stage_fc,
                                                          fg, slice_id);
            if(BCM_SUCCESS(fsm_ptr->rv)) {
                break;
            }
        }
        /* Check if allocation was successful. */
        if (slice_id == stage_fc->tcam_slices) {
            fsm_ptr->rv = (BCM_E_RESOURCE);
        }
    } else {
        if ((fsm_ptr->priority < 0) ||
            (fsm_ptr->stage_fc->tcam_slices <= fsm_ptr->priority)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: pri=%d out-of-range.\n"),
                       unit, fsm_ptr->priority));
            fsm_ptr->rv = BCM_E_PARAM;
        } else {
            slice_id = fsm_ptr->priority;
            fsm_ptr->rv = _field_group_add_slice_validate(unit, stage_fc,
                                                          fg, slice_id);
        }
    }

    if (BCM_FAILURE(fsm_ptr->rv)) {
        /* Different select codes might help for 5682x devices. */
        if ((soc_feature(unit, soc_feature_two_ingress_pipes)) &&
            (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
            ((0 == (fsm_ptr->priority % 2)) ||
             (BCM_FIELD_GROUP_PRIO_ANY == fsm_ptr->priority))) {
            fsm_ptr->rv = (BCM_E_NONE);
            fsm_ptr->flags &= ~_BCM_FP_GROUP_ADD_INTRA_SLICE;
            fg->flags &= ~_FP_GROUP_INTRASLICE_DOUBLEWIDE;
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
        } else if ((fsm_ptr->fsm_state_prev !=
                    _BCM_FP_GROUP_ADD_STATE_CAM_COMPRESS) && virtual_priority) {
            fsm_ptr->rv = (BCM_E_NONE);
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_CAM_COMPRESS;
        } else {
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        }
    } else {
        fg->slices = stage_fc->slices[fg->instance] + slice_id;
        fsm_ptr->rv = _field_group_add_selcodes_install(unit, fsm_ptr);
        if (BCM_SUCCESS(fsm_ptr->rv)) {
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_HW_QUAL_LIST_GET;
        } else {
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        }
    }
    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = _BCM_FP_GROUP_ADD_STATE_SLICE_ALLOCATE;
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function: _field_group_compress
 *
 * Purpose:
 *     Compress filed group entries,
 *     in order to free slices used by the group.
 * Paramters:
 *     unit     - (IN) BCM device number
 *     fg       - (IN) Field group structure
 *     stage_fc - (IN) Stage field control structure.
 * Returns:
 *     BCM_E_XXX
 */

int
_field_group_compress(int unit, _field_group_t *fg,
                      _field_stage_t *stage_fc)
{
    _field_slice_t       *fs; /* Field slice structure.         */
    _field_slice_t      *efs; /* Slice that contains free slots.*/
    int                 eidx; /* Empty slot index.              */
    int                  idx; /* Slice iteration index.         */
    int             tmp_idx1; /* Slice entry index 1.           */
    int             tmp_idx2; /* Slice entry index 2.           */
    int             slice_sz; /* Number of entries in a slice.  */
    int                   rv; /* Operation return status.       */

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Stage External doesn't require compression. */
    if (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) {
        return (BCM_E_NONE);
    }

    /* Get group slice pointer. */
    fs = fg->slices;

    efs = NULL;
    eidx = -1;
    while (NULL != fs) {
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        for (idx = 0; idx < slice_sz; idx ++)  {
            /* Find an empty slot. */
            if (NULL == fs->entries[idx]) {
                if (NULL == efs) {
                    efs = fs;
                    eidx = idx;
                }
                continue;
            }

            if (NULL != efs) {
                rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                         fg->instance,
                                                         efs->slice_number,
                                                         eidx, &tmp_idx1);
                BCM_IF_ERROR_RETURN(rv);

                rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                         fg->instance,
                                                         fs->slice_number,
                                                         idx, &tmp_idx2);
                BCM_IF_ERROR_RETURN(rv);

                rv = _field_entry_move(unit, fs->entries[idx],
                                       (tmp_idx1 - tmp_idx2));
                BCM_IF_ERROR_RETURN(rv);
                fs = efs;
                idx = eidx;
                efs = NULL;
                eidx = -1;
                _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
            }
        }
        fs = fs->next;
    }
    rv = _field_group_free_unused_slices(unit, stage_fc, fg);
    return (rv);
}

/*
 * Function:
 *     _field_stage_groups_compress
 * Purpose:
 *     Compress stage groups to free room for inserted group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     fc        - (IN) Field control structure.
 *     stage_fc  - (IN) Stage field control.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_stage_groups_compress(int unit, _field_control_t *fc,
                             _field_stage_t *stage_fc)
{
    _field_group_t *fg;              /* Field group structure. */
    int             rv = BCM_E_NONE; /* Operation return Status */

    /* Input parameters check. */
    if ((NULL == fc) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* Compress expanded groups. */
    for (fg = fc->groups; fg != NULL; fg = fg->next) {
        /* Skip other stages. */
        if (fg->stage_id != stage_fc->stage_id) {
            continue;
        }

        /* Skip new group. */
        if (NULL == fg->slices) {
            continue;
        }

        /* Ignore not expanded groups. */
        if (NULL == fg->slices->next)  {
            continue;
        }

        /* Best effort to compress expanded virtual groups. */
        rv = _field_group_compress(unit, fg, stage_fc);
    }
    return (rv);
}

/*
 * Function:
 *     _field_group_add_cam_compress
 * Purpose:
 *     Compress other groups to free room for inserted group.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_cam_compress(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /* Compress expanded groups. */
    BCM_IF_ERROR_RETURN
        (_field_stage_groups_compress(unit, fsm_ptr->fc, fsm_ptr->stage_fc));

    fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SLICE_ALLOCATE;
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_group_add_initialize
 * Purpose:
 *     Perform fsm initialization & execute basic checks
 *     required before field group creation.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX.
 */
STATIC int
_field_group_add_initialize(int unit, _field_group_add_fsm_t *fsm_ptr)
{

    _field_stage_id_t stage = _BCM_FIELD_STAGE_INGRESS; /* Group pipeline stage id.*/
    _field_group_t      *fg_temp; /* Existing field group pointer. */

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /* Group IDs must be unique within a unit. */
    if(BCM_SUCCESS(_field_group_get(unit, fsm_ptr->group_id, &fg_temp))) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group=%d already exists.\n"),
                   unit, fsm_ptr->group_id));
        fsm_ptr->rv = (BCM_E_EXISTS);
    }

    /* Get field stage control pointer. */
    if (BCM_SUCCESS(fsm_ptr->rv)) {
        fsm_ptr->rv = _field_control_get(unit, &fsm_ptr->fc);
    }

    /* Get pipeline stage from qualifiers set. */
    if (BCM_SUCCESS(fsm_ptr->rv)) {
        fsm_ptr->rv = _bcm_field_group_stage_get(unit, &fsm_ptr->qset, &stage);
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    /* Allow intraslice select codes if they are supported by the stage. */
    if (BCM_SUCCESS(fsm_ptr->rv)  &&
        soc_feature(unit, soc_feature_field_intraslice_double_wide) &&
        (fsm_ptr->fc->flags & _FP_INTRASLICE_ENABLE) &&
        (_BCM_FIELD_STAGE_EGRESS != stage) &&
        (_BCM_FIELD_STAGE_EXTERNAL != stage)) {
            /* We might try intraslice group. */
        if (((!SOC_IS_TD_TT(unit)) &&
             (!((SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
                 SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit) ||
                 (SOC_IS_TRIUMPH3(unit) &&
                  soc_feature(unit, soc_feature_field_stage_quarter_slice)))
             && (_BCM_FIELD_STAGE_LOOKUP == stage))))
            || (SOC_IS_TD_TT(unit) && (_BCM_FIELD_STAGE_LOOKUP == stage))) {
            /* Hurricane2/GH does not support intraslice double wide mode in VFP */
            /* In Ranger+ one TCAM in each slice is fused out in VFP stage.
             * Hence it can not support intraslice double wide mode in VFP */
            /* For TD and TT Intra-slice mode supported only for VFP */
            fsm_ptr->flags |= _BCM_FP_GROUP_ADD_INTRA_SLICE;
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    /* Get field stage control pointer. */
    if (BCM_SUCCESS(fsm_ptr->rv)) {
        fsm_ptr->rv  = _field_stage_control_get(unit, stage, &fsm_ptr->stage_fc);
    }

#ifdef BCM_TRIUMPH_SUPPORT
    /* _bcmFieldQualifyData2 is valid only for external stage on Triumph */
    if (SOC_IS_TRIUMPH(unit)) {
        if ((BCM_FIELD_QSET_TEST(fsm_ptr->qset,
                bcmFieldQualifyStageExternal) == 0) &&
            (BCM_FIELD_QSET_TEST(fsm_ptr->qset,
                _bcmFieldQualifyData2))) {
            BCM_FIELD_QSET_REMOVE_INTERNAL(fsm_ptr->qset,
                _bcmFieldQualifyData2);
        }
    }
#endif /* !BCM_TRIUMPH_SUPPORT || BCM_TRIUMPH2_SUPPORT */

    /* Verify that requested qualifiers set is supported by stage. */
    if (BCM_SUCCESS(fsm_ptr->rv)) {
        if (FALSE == _field_qset_is_subset(&fsm_ptr->qset,
                                           &fsm_ptr->stage_fc->_field_supported_qset)) {
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: Qualifier set is not supported by the device.\n"),
                       unit));
            fsm_ptr->rv = BCM_E_UNAVAIL;
        }
    }

    if (BCM_FAILURE(fsm_ptr->rv)) {
        /* Error occured -> clean up.. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
    } else {
        /* Proceed to group allocation stage. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_ALLOC;
    }
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_group_add_alloc
 * Purpose:
 *     Allocate & initialize field group structure.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX.
 */
STATIC int
_field_group_add_alloc(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    int                 idx;         /* Misc iterator.           */
    int                 mem_sz;      /* Allocated memory size.   */
    _field_group_t      *fg = NULL;  /* New group info.          */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/


    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /* Allocate & initialize memory for field group. */
    mem_sz = sizeof(_field_group_t);
    _FP_XGS3_ALLOC(fg, mem_sz, "field group");
    if (NULL == fg) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error:Allocation failure for _field_group_t\n"),
                   unit));
        fsm_ptr->rv = BCM_E_MEMORY;
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        return _bcm_field_group_add(unit, fsm_ptr);
    }


    /* Initialize group structure. */
    fg->gid            = fsm_ptr->group_id;
    fg->stage_id       = fsm_ptr->stage_fc->stage_id;
    fg->qset           = fsm_ptr->qset;
    fg->pbmp           = fsm_ptr->pbmp;
    fg->priority       = fsm_ptr->priority;

    if ( soc_feature(unit, soc_feature_field_multi_pipe_support) ||
         soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
        fg->hintid         = fsm_ptr->hintid;
         /* Group has been created, Increment group ref count in
         * corresponding hintid in hints hash lookup table */
        fsm_ptr->rv = _bcm_field_hints_group_count_update (unit, fg->hintid, 1);
        if (BCM_FAILURE(fsm_ptr->rv)) {
            sal_free (fg);
            fg = NULL;
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
            /* coverity[leaked_storage: FALSE] */
            return _bcm_field_group_add(unit, fsm_ptr);
        }
    }

    /* Initialize group status. */
    fsm_ptr->rv = _bcm_field_group_status_init(unit, &fg->group_status);
    if (BCM_FAILURE(fsm_ptr->rv)) {
        sal_free (fg);
        fg = NULL;
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        /* coverity[leaked_storage: FALSE] */
        return _bcm_field_group_add(unit, fsm_ptr);
    }

    if ( soc_feature(unit, soc_feature_field_multi_pipe_support) ||
         soc_feature(unit, soc_feature_field_ingress_two_slice_types) ) {
        /* Update group datastructure from hintid */
        fsm_ptr->rv = _bcm_field_hints_group_info_update (unit, fg);
        if (BCM_FAILURE(fsm_ptr->rv)) {
            sal_free (fg);
            fg = NULL;
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
            /* coverity[leaked_storage: FALSE] */
            return _bcm_field_group_add(unit, fsm_ptr);
        }
    }


    /* Clear the group's select codes and its slice Qsets. */
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        _FIELD_SELCODE_CLEAR(fg->sel_codes[idx]);
    }

    /* By default mark group as active. */
    fg->flags |= _FP_GROUP_LOOKUP_ENABLED;

    /* Set special group flags. */
    if (fsm_ptr->flags & _BCM_FP_GROUP_ADD_WLAN) {
        fg->flags |= _FP_GROUP_WLAN;
    }

    /* Set slice size selection group flags. */
    if (fsm_ptr->flags & _BCM_FP_GROUP_ADD_SMALL_SLICE) {
        fg->flags |= _FP_GROUP_SELECT_SMALL_SLICE;
    } else if (fsm_ptr->flags & _BCM_FP_GROUP_ADD_LARGE_SLICE) {
        fg->flags |= _FP_GROUP_SELECT_LARGE_SLICE;
    }

    /* Set action res id and vmap group to default */
    fg->action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
        fg->vmap_group[idx] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    }

    _field_virtual_priority_support(unit, fsm_ptr->stage_fc, &virtual_priority);

    /* Update virtual group related parameters */
    if ((virtual_priority == TRUE)
            && (fsm_ptr->stage_fc->stage_id != _BCM_FIELD_STAGE_EXTERNAL)) {
        fg->action_res_id = fsm_ptr->action_res_id;
        /* If virtual group is valid check if any existing internal vmap group exists */
        if(fg->action_res_id != BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT)
        {
            fsm_ptr->rv = _bcm_field_group_virtual_map_update(unit, fg);
            if (BCM_FAILURE(fsm_ptr->rv)) {
                sal_free (fg);
                fg = NULL;
                fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
                return _bcm_field_group_add(unit, fsm_ptr);
            }
        }
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EGRESS == fg->stage_id))) {

       /* Set the Field Group's instance information. */
       fsm_ptr->rv = _bcm_field_th_group_instance_set(unit, fg);
       if (BCM_FAILURE(fsm_ptr->rv)) {
           sal_free (fg);
           fg = NULL;
           fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
           return _bcm_field_group_add(unit, fsm_ptr);
       }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Set allocated pointer to FSM structure. */
    fsm_ptr->fg = fg;
    /* Update group qset with internal qualifiers. */
    fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_QSET_UPDATE;

    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_group_add_qualify_in_ports
 * Purpose:
 *     Update group application requested qset
 *     if group is restricted to subset of device ports.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fg       - (IN/OUT) Field Group pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_qualify_in_ports(int unit, _field_group_t *fg)
{
    bcm_port_config_t  port_config;/* Device port config.    */
    bcm_pbmp_t  pbmp_temp;       /* Port bitmap buffer.      */
    int         count;           /* Number of ports in PBMP. */
    int         qual_in_ports;   /* Qualify InPorts flag.    */


    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EGRESS == fg->stage_id))) {
        /* Do nothing */
        return BCM_E_NONE;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Read device port configuration. */
    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
    BCM_PBMP_CLEAR(pbmp_temp);
    BCM_PBMP_ASSIGN(pbmp_temp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &pbmp_temp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp_temp);
    }
#endif

    /*
     *  If group active on on all ports no InPort/InPorts
     *  qualification  is required.
     */
    if (BCM_PBMP_EQ(fg->pbmp, pbmp_temp)) {
        /* Update the instance to default. */
        fg->instance = _FP_DEF_INST;
        return (BCM_E_NONE);
    }

    if (_BCM_FIELD_STAGE_INGRESS != fg->stage_id) {
        return (BCM_E_RESOURCE);
    }

    qual_in_ports = TRUE;
    /*
     * If there's only 1 port and device capable efficiently
     * qualify on source port use InPort qualifier in stead of InPorts
     */
    BCM_PBMP_COUNT(fg->pbmp, count);
    if ((count == 1) && (!soc_feature(unit, soc_feature_table_hi))) {
        if (soc_feature(unit, soc_feature_field_multi_stage)) {
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInPort);
            qual_in_ports = FALSE;
        } else if (SOC_MEM_FIELD_VALID(unit, FP_TCAMm, SOURCE_PORT_NUMBER_MASKf)) {
            /*
             *  In Order to qualify on a single Higig port -
             *  Higig quailifier must be  present in each rule.
             */
            BCM_PBMP_ASSIGN(pbmp_temp, fg->pbmp);
            BCM_PBMP_AND(pbmp_temp, PBMP_HG_ALL(unit));
            if (BCM_PBMP_IS_NULL(pbmp_temp)) {
                BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInPort);
                qual_in_ports = FALSE;
            }
        }
    }
    if (qual_in_ports) {
        if (soc_feature(unit, soc_feature_ifp_no_inports_support)) {
            return (BCM_E_UNAVAIL);
        } else {
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInPorts);
        }
    }
    return (BCM_E_NONE);
}

#if defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *     _field_group_qset_rangecheck_update
 * Purpose:
 *     Update application requested qset with internal qualifiers.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     fg    - (IN/OUT) Field group structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_qset_rangecheck_update(int unit, _field_group_t *fg)
{
    _field_stage_t   *stage_fc; /* Stage field control structure. */
    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }


    if (_BCM_FIELD_STAGE_INGRESS != fg->stage_id) {
        return (BCM_E_NONE);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    /* Check if interface Class id qualifiers are not present */
    if (!(BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassPort) ||
            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassL3) ||
            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassVPort) ||
            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassL2))) {
        /* Check if stage supports the new internal qualifier */
        if (BCM_FIELD_QSET_TEST(stage_fc->_field_supported_qset,
                    _bcmFieldQualifyRangeCheckBits24_31)) {
            BCM_FIELD_QSET_ADD(fg->qset, _bcmFieldQualifyRangeCheckBits24_31);
        }
    }
    return (BCM_E_NONE);
}
#endif

 /*
 * Function:
 *     _field_group_qset_update
 * Purpose:
 *     Update application requested qset with internal qualifiers.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     fg    - (IN/OUT) Field group structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_group_qset_update(int unit, _field_group_t *fg)
{
    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* All ingress devices implicitly have bcmFieldQualifyStage in Qsets.*/
    if (_BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyStage);
    }

    /*
     * Vlan qualifiers ared extended to Id/Cfi/Pri
     */
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyOuterVlan)) {
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyOuterVlanId);
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyOuterVlanPri);
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyOuterVlanCfi);
    }
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInnerVlan)) {
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInnerVlanId);
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInnerVlanPri);
        BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyInnerVlanCfi);
    }
#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyMimlVlan)) {
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyMimlVlanId);
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyMimlVlanPri);
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyMimlVlanCfi);
        }
    }
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        if (BCM_FIELD_QSET_TEST(fg->qset,
                            bcmFieldQualifyCapwapPayloadOuterVlan)) {
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadOuterVlanId);
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadOuterVlanPri);
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadOuterVlanCfi);
        }
        if (BCM_FIELD_QSET_TEST(fg->qset,
                            bcmFieldQualifyCapwapPayloadInnerVlan)) {
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadInnerVlanId);
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadInnerVlanPri);
            BCM_FIELD_QSET_ADD(fg->qset,
                            bcmFieldQualifyCapwapPayloadInnerVlanCfi);
        }
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    /*
     * Automatically include IpType
     * if the qset contains PacketFormat/Ip4/Ip6.
     * FB2 stage egress and stage external are an exception.
     */
    if (_BCM_FIELD_STAGE_EXTERNAL != fg->stage_id) {
        if (
#if defined (BCM_FIREBOLT2_SUPPORT)
                ((0 == SOC_IS_FIREBOLT2(unit)) ||
                 (_BCM_FIELD_STAGE_EGRESS != fg->stage_id)) &&
#endif /* BCM_FIREBOLT2_SUPPORT */
                ((BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) ||
                 (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp6)))) {
            BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyIpType);
        }
    }

#if defined(BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit)) {
        /* Device doesn't support qualification on IP without version. */
        if  ((BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) &&
             (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp6))) {
            return  (BCM_E_RESOURCE);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT */

    /*
     * Add qualification on InPorts/InPort in case group applicable only
     * to part of the ports.
     */
    BCM_IF_ERROR_RETURN(_field_group_add_qualify_in_ports(unit, fg));

#ifdef BCM_TRIUMPH3_SUPPORT
    if ((SOC_IS_TRIUMPH3(unit))
        || ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)))
        || (SOC_IS_KATANA2(unit))) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_group_qset_update(unit, fg));
    }
#endif

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) &&
          !(soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
          BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyRangeCheck)) {
        BCM_IF_ERROR_RETURN(_field_group_qset_rangecheck_update(unit, fg));
    }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_add_qset_update
 * Purpose:
 *     Update application requested qset with internal qualifiers.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_qset_update(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    if (NULL == fsm_ptr->fg) {
        fsm_ptr->rv = (BCM_E_PARAM);
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        return _bcm_field_group_add(unit, fsm_ptr);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

    /* Update group qset with internal qualifiers. */
    fsm_ptr->rv = _field_group_qset_update(unit, fsm_ptr->fg);

    if (BCM_FAILURE(fsm_ptr->rv)) {
        /* Qset verification/modification failed - clean up. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
    } else {
        /* Proceed to select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    }
    return _bcm_field_group_add(unit, fsm_ptr);
}


/*
 * Function:
 *     _field_selcode_assign_udf_alternative
 * Purpose:
 *     Calculate the FPFx select codes from a qualifier set and group mode.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_selcode_assign_udf_alternative(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_group_t      *fg;                 /* Field group pointer.     */
    bcm_field_qset_t   temp_qset;

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    if (NULL == fsm_ptr->fg) {
        return (BCM_E_PARAM);
    }

    /* Group pointer initialization. */
    fg = fsm_ptr->fg;

    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
            (BCM_FIELD_QSET_TEST(fg->qset, _bcmFieldQualifyData2) ||
             BCM_FIELD_QSET_TEST(fg->qset, _bcmFieldQualifyData3))) {
        /* Try with Data0 instead of optimized Data2/Data3 qualifiers */
        temp_qset = fg->qset;
        BCM_FIELD_QSET_REMOVE_INTERNAL(fg->qset, _bcmFieldQualifyData2);
        BCM_FIELD_QSET_REMOVE_INTERNAL(fg->qset, _bcmFieldQualifyData3);
        BCM_FIELD_QSET_ADD_INTERNAL(fg->qset, _bcmFieldQualifyData0);

        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "Trying with alternative udf...\n")));
        fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
        /* Restore back the old qset in case of failure */
        if (BCM_FAILURE(fsm_ptr->rv)) {
            fg->qset = temp_qset;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_add_sel_codes_get
 * Purpose:
 *     Calculate the FPFx select codes from a qualifier set and group mode.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_sel_codes_get(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    _field_group_t      *fg;                 /* Field group pointer.     */
    int                orig_group_flags;     /* Original group flags.    */


    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    if (NULL == fsm_ptr->fg) {
        fsm_ptr->rv = (BCM_E_PARAM);
    }

    /* Check if requested mode is supported by device. */
    switch (fsm_ptr->mode) {
      case bcmFieldGroupModeQuad:
          if (0 == soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
              fsm_ptr->rv = (BCM_E_RESOURCE);
          }
          break;
      case bcmFieldGroupModeTriple:
          if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
              fsm_ptr->rv = (BCM_E_RESOURCE);
          }
#ifdef BCM_TRIDENT_SUPPORT
          if (SOC_IS_TD_TT(unit))
          {
              fsm_ptr->rv = (BCM_E_UNAVAIL);
          }
#endif
          /* Fall through. */
      case bcmFieldGroupModeDouble:
          if (0 == soc_feature(unit, soc_feature_field_wide)) {
              fsm_ptr->rv = (BCM_E_RESOURCE);
          }
          break;
      case bcmFieldGroupModeIntraSliceDouble:
          if (0 == soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
              fsm_ptr->rv = (BCM_E_RESOURCE);
          }
          break;
      default:
          break;
    }
    if (BCM_FAILURE(fsm_ptr->rv)) {
        fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
        return _bcm_field_group_add(unit, fsm_ptr);
    }

    /* Group pointer initialization. */
    fg = fsm_ptr->fg;

    fsm_ptr->rv = BCM_E_RESOURCE;
    orig_group_flags = fg->flags;

    /* Allocate & initialize memory for field group. */
    if (fsm_ptr->mode == bcmFieldGroupModeAuto)
    {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Group mode auto.\n")));

        /* For Auto mode, try Single, Double, then Triple. */
        /* Single wide non intra slice selection. */
        if (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "Trying single...\n")));
            fg->flags = (orig_group_flags | _FP_GROUP_SPAN_SINGLE_SLICE);
            fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
            if (BCM_FAILURE(fsm_ptr->rv)) {
                BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
            }
        }

        /* Double wide intra slice selection. */
        if ((BCM_FAILURE(fsm_ptr->rv) &&
             (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE))) {
            if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "Trying intra...\n")));
                fg->flags = (orig_group_flags |
                             _FP_GROUP_SPAN_SINGLE_SLICE |
                             _FP_GROUP_INTRASLICE_DOUBLEWIDE);
                fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                if (BCM_FAILURE(fsm_ptr->rv)) {
                    BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                }
            }
        }

        /* Double wide inter slice selection. */
        if (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY)) {
            if (BCM_FAILURE(fsm_ptr->rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "Trying double...\n")));
                fg->flags = (orig_group_flags | _FP_GROUP_SPAN_DOUBLE_SLICE);
                fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                if (BCM_FAILURE(fsm_ptr->rv)) {
                    BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                }
            }
        }

        /* Quad wide inter & intra slice selection. */
        if ((BCM_FAILURE(fsm_ptr->rv) &&
             (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE))) {
            if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "Trying quad...\n")));
                fg->flags = (orig_group_flags |
                             _FP_GROUP_SPAN_DOUBLE_SLICE |
                             _FP_GROUP_INTRASLICE_DOUBLEWIDE);
                fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                if (BCM_FAILURE(fsm_ptr->rv)) {
                    BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                }
            }
        }

        /* Triple wide inter slice selection. */
        if ((0 == soc_feature(unit, soc_feature_field_intraslice_double_wide)) &&
            (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY)) &&
            (!SOC_IS_TD_TT(unit))) {
            if (BCM_FAILURE(fsm_ptr->rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "Trying triple...\n")));
                fg->flags = (orig_group_flags | _FP_GROUP_SPAN_TRIPLE_SLICE);
                fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                if (BCM_FAILURE(fsm_ptr->rv)) {
                    BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                }
            }
        }
    } else {
        switch (fsm_ptr->mode) {
          case bcmFieldGroupModeSingle:
              /* Single wide non intra slice selection. */
              if (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY)) {
                  fg->flags = (orig_group_flags | _FP_GROUP_SPAN_SINGLE_SLICE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              break;
          case bcmFieldGroupModeIntraSliceDouble:
              /* Double wide intra slice selection. */
              if ((soc_feature(unit, soc_feature_field_intraslice_double_wide)) &&
                   (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE)) {
                  fg->flags = (orig_group_flags |
                               _FP_GROUP_SPAN_SINGLE_SLICE |
                               _FP_GROUP_INTRASLICE_DOUBLEWIDE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              break;
          case bcmFieldGroupModeDouble:
              /* Double wide intra slice selection. */
              if ((soc_feature(unit, soc_feature_field_intraslice_double_wide) &&
                   (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE))) {
                  fg->flags = (orig_group_flags |
                               _FP_GROUP_SPAN_SINGLE_SLICE |
                               _FP_GROUP_INTRASLICE_DOUBLEWIDE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              /* Double wide inter slice selection. */
              if ((BCM_FAILURE(fsm_ptr->rv)) &&
                  (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY))) {
                  fg->flags = (orig_group_flags | _FP_GROUP_SPAN_DOUBLE_SLICE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              break;
          case bcmFieldGroupModeTriple:
              /* Triple wide inter slice selection. */
              if (0 == (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY)) {
                  fg->flags = (orig_group_flags | _FP_GROUP_SPAN_TRIPLE_SLICE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              break;
          case bcmFieldGroupModeQuad:
              if ((soc_feature(unit, soc_feature_field_intraslice_double_wide) &&
                   (fsm_ptr->flags & _BCM_FP_GROUP_ADD_INTRA_SLICE))) {
                  fg->flags = (orig_group_flags | _FP_GROUP_SPAN_DOUBLE_SLICE |
                               _FP_GROUP_INTRASLICE_DOUBLEWIDE);
                  fsm_ptr->rv = _field_selcode_assign(unit, fg->qset, 1, fg);
                  if (BCM_FAILURE(fsm_ptr->rv)) {
                      BCM_IF_ERROR_RETURN(_field_selcode_assign_udf_alternative(unit, fsm_ptr));
                  }
              }
              break;
          default:
              fsm_ptr->rv = (BCM_E_PARAM);
        }
    }

    if (BCM_FAILURE(fsm_ptr->rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "No success so far.\n")));
        /* No luck so far - try different alternative qset if possible. */
        if ((BCM_E_RESOURCE == fsm_ptr->rv) &&
            (_BCM_FP_GROUP_ADD_STATE_QSET_UPDATE == fsm_ptr->fsm_state_prev)) {
            fsm_ptr->rv = (BCM_E_NONE);
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_QSET_ALTERNATE;
        }
    } else {
#ifdef BCM_TRIUMPH2_SUPPORT /* BCM_TRIUMPH2_SUPPORT */
        int i, ingress_entity = 0;
#endif /* !BCM_TRIUMPH2_SUPPORT */

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Configuration found...\n")));
        /* Check if unit supports wide rules. */
        if ((!soc_feature(unit, soc_feature_field_wide)) &&
            (!(fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE)))
        {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "Double not supported.\n")));
            fsm_ptr->rv = (BCM_E_UNAVAIL);
        }

#ifdef BCM_TRIUMPH2_SUPPORT /* BCM_TRIUMPH2_SUPPORT */
        /*
         * Check which configuration of SrcMplsGport/SrcMimGport/
         * SrcNivGport is in use.
         */
        for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
            if ((fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityMimGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityMplsGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityNivGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityWlanGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityVxlanGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityVlanGport) ||
                (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityCommonGport)) {
                ingress_entity = 1;
                break;
            }
        }

        /* Adjust for SvpValid where applicable */
        if (soc_feature(unit, soc_feature_mim) &&
              (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcMimGport) ||
              (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcMimGports)) ||
               BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcGports) ||
               BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcGport)) &&
               !BCM_FIELD_QSET_TEST(fg->qset, _bcmFieldQualifySvpValid) &&
               (1 == ingress_entity)) {

            /* SrcMimGport */
            BCM_FIELD_QSET_ADD(fg->qset, _bcmFieldQualifySvpValid);
            fsm_ptr->rv = (BCM_E_NONE);
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_QSET_ALTERNATE;

        } else if ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) &&
                (1 == ingress_entity) &&
                !BCM_FIELD_QSET_TEST(fg->qset, _bcmFieldQualifySvpValid) &&
                (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcMplsGport) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcMplsGports) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcGports) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcGport)  ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcNivGport) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcNivGports) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcVxlanGport) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcVxlanGports) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcVlanGport) ||
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcVlanGports))) {
            /* SrcMplsGport or SrcNivGport or SrcVxlanGport or SrcVlanGport */
            BCM_FIELD_QSET_ADD(fg->qset, _bcmFieldQualifySvpValid);
            fsm_ptr->rv = (BCM_E_NONE);
            fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_QSET_ALTERNATE;
        } else
#endif /* !BCM_TRIUMPH2_SUPPORT */
        {
            /* Insert group into units group list. */
            if (BCM_SUCCESS(fsm_ptr->rv)) {
                fsm_ptr->rv = _bcm_field_group_linked_list_insert(unit, fsm_ptr);
            }

            /* Success proceed to slice allocation. */
            if (BCM_SUCCESS(fsm_ptr->rv)) {
                if ((fsm_ptr->flags & _FP_GROUP_CONFIG_VALIDATE)) {
                    fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
                } else {
                    fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SLICE_ALLOCATE;
                }
            } else {
                fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
            }
        }
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;

    return _bcm_field_group_add(unit, fsm_ptr);
}


/*
 * Function:
 *     _field_group_add_qset_alternate
 * Purpose:
 *     Update application requested qset with equivalent one
 *     which might allow to select F1, F2 Fn  select codes.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_qset_alternate(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    /* Set current state to be previous state. */
    fsm_ptr->fsm_state_prev = fsm_ptr->fsm_state;

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAPTOR_SUPPORT)
    if ((SOC_IS_FIREBOLT2(unit) || SOC_IS_HAWKEYE(unit))
        && (BCM_FIELD_QSET_TEST(fsm_ptr->fg->qset, bcmFieldQualifyTtl))) {

        BCM_FIELD_QSET_REMOVE(fsm_ptr->fg->qset, bcmFieldQualifyTtl);
        if (SOC_IS_FIREBOLT2(unit)) {
            fsm_ptr->flags |= _BCM_FP_GROUP_ADD_INTRA_SLICE_ONLY;
        }

        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAPTOR_SUPPORT */
#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_mim)) {
        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else if (BCM_FIELD_QSET_TEST(fsm_ptr->fg->qset, bcmFieldQualifySrcMplsGport)) {
        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else if (BCM_FIELD_QSET_TEST(fsm_ptr->fg->qset, bcmFieldQualifySrcNivGport)) {
        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else if (BCM_FIELD_QSET_TEST(fsm_ptr->fg->qset, bcmFieldQualifySrcVxlanGport)) {
        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else if (BCM_FIELD_QSET_TEST(fsm_ptr->fg->qset, bcmFieldQualifySrcVlanGport)) {
        /* Proceed to a second attempt of select codes selection. */
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET;
    } else
#endif
    {
        fsm_ptr->rv = (BCM_E_RESOURCE);
        fsm_ptr->fsm_state = _BCM_FP_GROUP_ADD_STATE_END;
    }
    return _bcm_field_group_add(unit, fsm_ptr);
}

/*
 * Function:
 *     _field_group_add_end
 * Purpose:
 *     Group add state machine last /clean up state.
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_add_end(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    if (BCM_FAILURE(fsm_ptr->rv)
        || BCM_FAILURE(fsm_ptr->rv = _field_group_default_aset_set(unit, fsm_ptr->fg))
        ) {
        _field_group_deinit(unit, fsm_ptr->fg);
    }

    return (fsm_ptr->rv);
}

/*
 * Function: _bcm_field_group_add
 *
 * Purpose:
 *     Create a field processor group
 * Parameters:
 *     unit     - (IN)     BCM device number.
 *     fsm_ptr  - (IN/OUT) State machine tracking structure.
 * Returns:
 *     BCM_E_XXX.
 */
int
_bcm_field_group_add(int unit, _field_group_add_fsm_t *fsm_ptr)
{
    int rv;             /* Operation return status.   */
                        /* Group add fsm state names. */
#if defined(BROADCOM_DEBUG)
    static char *_bcm_fp_group_add_state[bcmFieldQualifyCount] = \
        _BCM_FP_GROUP_ADD_STATE_STRINGS;
#endif /* BROADCOM_DEBUG */

    /* Input parameters check. */
    if (NULL == fsm_ptr) {
        return (BCM_E_PARAM);
    }

    rv = (BCM_E_NONE);

#if defined(BROADCOM_DEBUG)
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: group add: state (%s) state_prev (%s)  status (%d).\n"),
               unit,
               _bcm_fp_group_add_state[fsm_ptr->fsm_state],
               _bcm_fp_group_add_state[fsm_ptr->fsm_state_prev],
               fsm_ptr->rv));
#endif /* BROADCOM_DEBUG */

    /* Run through group creation states. */
    switch (fsm_ptr->fsm_state) {
      case _BCM_FP_GROUP_ADD_STATE_START:
          rv = _field_group_add_initialize(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_ALLOC:
          rv = _field_group_add_alloc(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_QSET_UPDATE:
          rv = _field_group_add_qset_update(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_SEL_CODES_GET:
          rv = _field_group_add_sel_codes_get(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_QSET_ALTERNATE:
          rv = _field_group_add_qset_alternate(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_SLICE_ALLOCATE:
          rv = _field_group_add_slice_allocate(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_CAM_COMPRESS:
          rv = _field_group_add_cam_compress(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_HW_QUAL_LIST_GET:
          rv = _field_group_add_hw_qual_list_get(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_UDF_UPDATE:
          rv = _field_group_add_udf_update(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_ADJUST_VIRTUAL_MAP:
          rv = _field_group_add_adjust_virtual_map(unit, fsm_ptr);
          break;

      case _BCM_FP_GROUP_ADD_STATE_END:
          rv = _field_group_add_end(unit, fsm_ptr);
          break;

    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_entries_free_get
 *
 * Purpose:
 *     Return the number of free entries in a slice.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     fs          - (IN) Slice to count free entries in.
 *     fg          - (IN) Group (for checking the INTRASLICE-DW flag)
 *     free_cnt  - (OUT)Count of unused entries.
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     Assumes all groups in a slice have the same mode (regular/INTRASLICE-DW)
 */
int
_bcm_field_entries_free_get(int unit, _field_slice_t *fs,
                            _field_group_t *fg, int *free_cnt)
{
    /* Input parameters check. */
    if ((NULL == fs) || (NULL == free_cnt)) {
        return (BCM_E_PARAM);
    }

    /* Initialization check. */
    FIELD_IS_INIT(unit);

    *free_cnt = fs->free_count;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_counters_total_get
 *
 * Purpose:
 *     Report total number of counters available.
 *
 * Parameters:
 *     stage_fc     - (IN) Stage field control structure.
 *     fs           - (IN) Slice to count the total counters.
 *
 * Returns:
 *     Number of unused counters in slice.
 */
int
_bcm_field_counters_total_get(const _field_stage_t *stage_fc,
                              const _field_slice_t *fs)
{
    int total_count = 0;
    /* Input parameters check. */
    if ((NULL == fs) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    if (fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        /*
         * There is an 1-1 mapping between rules and counters
         * for external FP. So, total number of counters is equal
         * to number of entries on that slice.
         */
        return fs->entry_count;
    } else {
           if (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS) {
               int i;
               for (i = 0; i < stage_fc->num_cntr_pools; i++) {
               total_count += stage_fc->cntr_pool[i]->size;
               }
               return total_count;
           }
           return fs->counters_count;
      }
}

/*
 * Function:
 *     _bcm_field_counter_free_get
 *
 * Purpose:
 *     Report the number of unused counter pairs in a slice.
 *
 * Parameters:
 *     stage_fc     - (IN) Stage field control structure.
 *     fs           - (IN) Slice to count free counters in.
 *
 * Returns:
 *     Number of unused counters in slice.
 */
int
_bcm_field_counter_free_get(const _field_stage_t *stage_fc,
                            const _field_slice_t *fs)
{
    int                 counter;
    int                 free_count = 0;

    /* Input parameters check. */
    if ((NULL == fs) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    if (fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        return fs->free_count;
    }
    if (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS) {
        int i;
        for (i = 0; i < stage_fc->num_cntr_pools; i++) {
            free_count += stage_fc->cntr_pool[i]->free_cntrs;
        }
        return free_count;
    }

    /* Count unused counters. */
    for (counter = 0; counter < fs->counters_count; counter++) {
        if (0 == _FP_COUNTER_BMP_TEST(fs->counter_bmp, counter)) {
            free_count++;
        }
    }
    return free_count;
}

/*
 * Function:
 *     _bcm_field_meters_total_get
 *
 * Purpose:
 *     Return total number of meters/meter pairs on device.
 *
 * Parameters:
 *     stage_fc    - (IN) Stage field control structure.
 *     instance    - (IN) Pipe Instance.
 *     fs          - (IN) Slice to count number of meters.
 *
 * Returns:
 *     Total number of meters/meter pairs on device.
 */
int
_bcm_field_meters_total_get(const _field_stage_t *stage_fc, int instance,
                            const _field_slice_t *fs)
{
    int                 numb_meters = 0;

    /* Input parameters check. */
    if ((NULL == fs) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        int i;
        for (i = 0; i < stage_fc->num_meter_pools; i++) {
            numb_meters += stage_fc->meter_pool[instance][i]->size;
        }
        return numb_meters;
    } else {
        return  fs->meters_count;
    }
}

/*
 * Function:
 *     _bcm_field_meter_free_get
 *
 * Purpose:
 *     Fill in the values of a group status struct.
 *
 * Parameters:
 *     stage_fc    - (IN) Stage field control structure.
 *     fg          - (IN) field group structure.
 *     fs          - (IN) Slice to count free counters in.
 *
 * Returns:
 *     Number of unused meters in slice.
 */
int
_bcm_field_meter_free_get(const _field_stage_t *stage_fc, const
                          _field_group_t *fg, const _field_slice_t *fs)
{
    int                 meter;
    int                 numb_meters = 0;
    int                 slice_id;

    /* Input parameters check. */
    if ((NULL == fs) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* For stages ExactMatch and External meter pool slice id is
       equal to tcam slices */
    if ((_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) {
        slice_id = stage_fc->tcam_slices;
    } else {
        slice_id = fs->slice_number;
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        int i;
        for (i = 0; i < stage_fc->num_meter_pools; i++) {
            _field_meter_pool_t *mp = stage_fc->meter_pool[fg->instance][i];

            if (mp->slice_id == slice_id /* Pool belongs to slice */
                || mp->slice_id == _FP_INVALID_INDEX /* Pool is unallocated */
                ) {
                numb_meters += mp->free_meters;
            }
        }
        return numb_meters;
    }

    for (meter = 0; meter < fs->meters_count; meter++) {
        if (_FP_METER_BMP_TEST(fs->meter_bmp, meter)) {
            numb_meters++;
        }
    }
    return  fs->meters_count - numb_meters;
}


/*
 * Function:
 *     _field_udf_usecount_update
 *
 * Purpose:
 *     Increment the use-counts of any new UDFs.
 *
 * Parameters:
 *     udf      - Unit's control array of UDFs
 *     qset_old - Previous Qset
 *     qset_new - New Qset
 *
 * Returns:
 *     nothing
 */
void
_field_udf_usecount_update(_field_udf_t *udf,
                           bcm_field_qset_t *qset_old,
                           bcm_field_qset_t *qset_new)
{
    int                  idx_new;

    /* For all UDFs in new Qset. */
    for (idx_new = 0; idx_new < BCM_FIELD_USER_NUM_UDFS; idx_new++) {
        if (!SHR_BITGET(qset_new->udf_map, idx_new)) {
            continue;
        }

        /* If UDF is in new Qset but not in old Qset, increment use-count. */
        if (!SHR_BITGET(qset_old->udf_map, idx_new)) {
            udf[idx_new].use_count++;
        }
    }
}

/*
 * Function: _field_fb_entries_enable_set
 *
 * Purpose:
 *     Enable/disable the lookup of entries of a group
 *
 * Parameters:
 *     unit   - BCM device number
 *     fg     - Group the entry belongs to
 *     fs     - Slice the entry is present in
 *     enable - lookup enable!=0/disable==0 state of group
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX       - BCM error codes
 *
 * Note:
 *     For Intraslice-dw (FB2), we run over entries in both half's.
 *
 *     A group may be spanning multiple slices
 *         (due to group autoexpansion)
 */
int
_field_fb_entries_enable_set(int unit, _field_group_t *fg,
                              _field_slice_t *fs, int enable)
{
    _field_stage_t *stage_fc;
    soc_mem_t mem = INVALIDm;
    uint32  e[SOC_MAX_MEM_FIELD_WORDS];
    int index, i;

    /* External stage entries are always enabled */
    if (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) {
        return (BCM_E_NONE);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, fg->stage_id, &stage_fc));

    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        mem = FP_TCAMm;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    } else if (soc_feature(unit, soc_feature_field_multi_stage)) {
        if (_BCM_FIELD_STAGE_LOOKUP  == stage_fc->stage_id) {
            mem = VFP_TCAMm;
        } else if (_BCM_FIELD_STAGE_EGRESS  == stage_fc->stage_id) {
            mem = EFP_TCAMm;
        } else {
            return (BCM_E_INTERNAL);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    } else {
        return BCM_E_INTERNAL;
    }

    while (fs->next != NULL) {
        fs = fs->next;
    }

    while (fs != NULL) {
        for (i = fs->entry_count - 1; i >= 0; i--) {
            if (fs->entries[i] != NULL) {
                if (fs->entries[i]->group->gid == fg->gid) {
                    BCM_IF_ERROR_RETURN(
                       _bcm_field_entry_tcam_idx_get(unit, fs->entries[i], &index));
                    /* Read tcam entry from index. */
                    SOC_IF_ERROR_RETURN
                        (soc_mem_read(unit, mem, MEM_BLOCK_ANY, index, e));

                    /* Set the VALIDf bits appropriately, VALIDf in VFP_TCAM on TH2 only has one bit*/
#if defined(BCM_TOMAHAWK2_SUPPORT)
                    if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced) &&
                        _BCM_FIELD_STAGE_LOOKUP  == stage_fc->stage_id) {
                        soc_mem_field32_set(unit, mem, e, VALIDf, enable? 1 : 0);
                    } else
#endif /* BCM_TOMAHAWK2_SUPPORT */
                    {
                        if (enable) {
                            if (fs->entries[i]->flags & _FP_ENTRY_INSTALLED) {
                                soc_mem_field32_set(unit, mem, e, VALIDf, 3);
                            } else {
                                soc_mem_field32_set(unit, mem, e, VALIDf, 0);
                            }
                        } else {
                            soc_mem_field32_set(unit, mem, e, VALIDf, 2);
                        }
                    }

                    /* Write back the TCAM entry */
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, mem, MEM_BLOCK_ALL, index, e));
                }
            }
        }
        fs = fs->prev;
    }

    if (enable) {
        fg->flags |= _FP_GROUP_LOOKUP_ENABLED;
    } else {
        fg->flags &= ~_FP_GROUP_LOOKUP_ENABLED;
    }

    return BCM_E_NONE;
}

/*
 * Function: _field_range_flags_check
 *
 * Purpose:
 *     Sanity check on range flags.
 *
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     flags  - (IN) One or more of BCM_FIELD_RANGE_* flags.
 *
 * Returns:
 *     BCM_E_XXX  - Flags are valid & supported.
 */
int
_field_range_flags_check(int unit, uint32 flags)
{
    int   cntr;                 /* Range types counter.  */

    /* ESW family of devices do not support range check in lookup stage */
    if (flags & BCM_FIELD_RANGE_LOOKUP) {
        return (BCM_E_UNAVAIL);
    }

    /* Make sure only one range was selected. */
    cntr = 0;
    if (flags & BCM_FIELD_RANGE_SRCPORT) {
        cntr++;
    }
    if (flags & BCM_FIELD_RANGE_DSTPORT) {
        cntr++;
    }
    if (flags & BCM_FIELD_RANGE_OUTER_VLAN) {
        cntr++;
    }
    if (flags & BCM_FIELD_RANGE_PACKET_LENGTH) {
        cntr++;
    }
    if (cntr > 1) {
        return (BCM_E_PARAM);
    }

    /* Outer vlan & packet length ranges supported by trx devices only.*/
    if ((flags & BCM_FIELD_RANGE_OUTER_VLAN)  ||
        (flags & BCM_FIELD_RANGE_PACKET_LENGTH)) {
        if (0 == SOC_IS_TRX(unit)) {
            return (BCM_E_UNAVAIL);
        }
    }

    /* Range TCP/UDP/Invert supported on 5660x devices only. */
    if (flags & (BCM_FIELD_RANGE_TCP |
                 BCM_FIELD_RANGE_UDP |
                 BCM_FIELD_RANGE_INVERT)) {
        return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}


/*
 * Function: _field_range_create
 *
 * Purpose:
 *     Create field range object.
 *
 * Parameters:
 *     unit   - (IN) BCM device number.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_range_create(int unit, bcm_field_range_t *range,
                    uint32 flags, bcm_l4_port_t min,
                    bcm_l4_port_t max, bcm_if_group_t group)
{
    _field_stage_t      *stage_fc;
    int                 rv;

    if (flags & BCM_FIELD_RANGE_EXTERNAL) {
        BCM_IF_ERROR_RETURN
            (_field_stage_control_get(unit, _BCM_FIELD_STAGE_EXTERNAL,
                                      &stage_fc));
    } else {
        BCM_IF_ERROR_RETURN
            (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,
                                      &stage_fc));
    }

    for (;;) {
        if (group == -1) {
            rv = bcm_esw_field_range_create_id(unit, stage_fc->range_id,
                                               flags, min, max);
        } else {
            rv = bcm_esw_field_range_group_create_id(unit, stage_fc->range_id,
                                                     flags, min, max, group);
        }

        if (rv != BCM_E_EXISTS) {
            break;
        }

        if (++stage_fc->range_id == 0) {
            stage_fc->range_id = 1;
        }
    }

    if (BCM_SUCCESS(rv)) {
        *range = stage_fc->range_id;

        if (++stage_fc->range_id == 0) {
            stage_fc->range_id = 1;
        }
    }
    return rv;
}

/*
 * Function:
 *     _field_fb_er_range_check_set
 * Purpose:
 *     Write the group's range checking parameters into the FP_RANGE_CHECK
 *     memory.
 * Parameters:
 *     unit   - BCM unit
 *     range  - Range HW index
 *     flags  - One of more of the BCM_FIELD_RANGE_* flags
 *     enable - TRUE or FALSE
 *     min    - Lower bounds of port range to be checked
 *     max    - Upper bounds of port range to be checked
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Unrecognized flag.
 * Notes:
 *    Calling function should have unit's lock.
 */
int
_field_fb_er_range_check_set(int unit, int range, uint32 flags, int enable,
                             bcm_l4_port_t min, bcm_l4_port_t max)
{
    fp_range_check_entry_t  tbl_entry;
    uint32                  src_chk = 0;

    assert(soc_mem_index_valid(unit, FP_RANGE_CHECKm, range));

    if (enable) {
        switch (flags & (BCM_FIELD_RANGE_SRCPORT | BCM_FIELD_RANGE_DSTPORT)) {
        case BCM_FIELD_RANGE_SRCPORT:
            src_chk = 1;
            break;
        case BCM_FIELD_RANGE_DSTPORT:
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: unsupported flags %#x\n"),
                       unit, flags));
            return (BCM_E_PARAM);
        }
    }

    /* read/modify/write range check memory */
    SOC_IF_ERROR_RETURN(READ_FP_RANGE_CHECKm(unit, MEM_BLOCK_ANY,
                                             range, &tbl_entry));

    soc_FP_RANGE_CHECKm_field32_set(unit, &tbl_entry,
                                    SOURCE_DESTINATION_SELECTf, src_chk);
    soc_FP_RANGE_CHECKm_field32_set(unit, &tbl_entry, ENABLEf, enable);
    soc_FP_RANGE_CHECKm_field32_set(unit, &tbl_entry, LOWER_BOUNDSf, min);
    soc_FP_RANGE_CHECKm_field32_set(unit, &tbl_entry, UPPER_BOUNDSf, max);

    SOC_IF_ERROR_RETURN(WRITE_FP_RANGE_CHECKm(unit, MEM_BLOCK_ALL,
                                              range, &tbl_entry));

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _bcm_field_modify_range_checker
 * Purpose:
 *  Modify the configurations of an existing range checker.
 * Parameters:
 *  unit        - (IN) BCM device number.
 *  stage_id    - (IN) Pipeline stage id.
 *  range_id    - (IN) Range check ID to use.
 *  flags       - (IN) Range checker type to be set.
 *  min         - (IN) Lower bounds of range to be checked, inclusive.
 *  max         - (IN) Upper bounds of range to be checked, inclusive.
 * Returns:
 *  BCM_E_NOT_FOUND - Range Check id to be modified does not exist.
 *  BCM_E_NONE      - Success.
 * Notes:
 *    Calling function should have unit's lock.
 */

int _bcm_field_modify_range_checker(int unit, _field_stage_id_t stage_id,
        int range_id, uint32 flags,
        bcm_l4_port_t min, bcm_l4_port_t max)
{
    _field_stage_t      *stage_fc;      /* Stage field control info.*/
    _field_range_t      *fr;            /* Field range info.        */
    int                 rv;             /* Operation return value.  */

    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        return rv;
    }

    for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
        if (fr->rid == range_id) {
            /* Try to program hardware */
#if defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TRX(unit)) {
                rv = _bcm_field_trx_range_check_set(unit, fr->hw_index,
                        flags, 1, min, max);
            } else
#endif /* BCM_TRX_SUPPORT */
            {
                rv = _field_fb_er_range_check_set(unit, fr->hw_index,
                        flags, 1, min, max);
            }
            return rv;
        }
    }

    return BCM_E_NOT_FOUND;
}

/*
 * Function: _field_fill_slice_array
 *
 * Purpose:
 *      Based on GroupAutoExpansion Flags and MaxGroupSize
 *      Fill the slice_array with slice ids.
 *
 * Parameters:
 *     unit        - (IN) BCM device number
 *     fg          - (IN) field group
 *     slice_array - (INOUT) Array where the slice ids will be filled.
 *
 * Returns:
 *     BCM_E_xxx
 *
 */
int _field_fill_slice_array (int unit, _field_group_t *fg, uint8 *slice_array)
{
    _field_control_t *fc;             /* Field control structure. */
    _field_stage_t   *stage_fc;       /* Field stage control.     */
    int rv = 0;                       /* Operation return status. */
    int slice_index = 0;              /* Slice Index */
    uint8 idx = 0;                    /* Slice Index */
    int8 autoexpand_hints_set = -1;   /* Check AutoExpansion Flag is set*/
    uint16 small_slice_size = 0;      /* Small Slice Size */
    uint8 prioritize_large_slice = 0; /* Prioritize large entries */
    int remaining_entries = 0;        /* Remaining allowed entries in a group */

    if (NULL == slice_array) {
        return BCM_E_PARAM;
    }

    /* Get field control structure. */
    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* AutoExpansion Hints Flags supported only for Ingress Stage */
    if ((stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS)
            || (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
        return BCM_E_NONE;
    }

    /* AutoExpansion Hints Flags supported only for Ingress Stage which
     * has two slice types */
    if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
        return BCM_E_NONE;
    }

    /* If both autoexpansion hint flags specified or both not specified
     * it means autoexpansion is not set */
    if ((fg->flags & _FP_GROUP_AUTO_EXPAND_SMALL_SLICE)
            && (fg->flags & _FP_GROUP_AUTO_EXPAND_LARGE_SLICE)) {
        autoexpand_hints_set = 0;
    }

    if (((fg->flags & _FP_GROUP_AUTO_EXPAND_SMALL_SLICE) == 0)
            && ((fg->flags & _FP_GROUP_AUTO_EXPAND_LARGE_SLICE) == 0)) {
        autoexpand_hints_set = 0;
    }

    /* If AutoExpansion hints not set and maxGroupSize not specified
     * Slice allocation will follow default pattern */
    if ((autoexpand_hints_set == 0) && (fg->max_group_size == 0)) {
        return BCM_E_NONE;
    }

    for (slice_index = 0;
            slice_index < stage_fc->tcam_slices; slice_index++) {
        if (stage_fc->slices[fg->instance][slice_index].slice_flags &
                _BCM_FIELD_SLICE_SIZE_SMALL) {
            small_slice_size  =
                  stage_fc->slices[fg->instance][slice_index].entry_count;
            break;
        }
    }

    if (autoexpand_hints_set == 0) {
        remaining_entries = fg->max_group_size - (fg->group_status.entry_count);
        if (remaining_entries <= 0) {
            /* Falling back to default slice allocation pattern */
            return BCM_E_NONE;
        } else {
            if (remaining_entries <= small_slice_size) {
                prioritize_large_slice = 0;
            } else {
                prioritize_large_slice = 1;
            }
        }
    } else if (fg->flags & _FP_GROUP_AUTO_EXPAND_SMALL_SLICE) {
        prioritize_large_slice = 0;
    }else if (fg->flags & _FP_GROUP_AUTO_EXPAND_LARGE_SLICE) {
        prioritize_large_slice = 1;
    }

    if (prioritize_large_slice) {
        while (idx < stage_fc->tcam_slices) {
            for (slice_index = 0;
                    slice_index < stage_fc->tcam_slices; slice_index++) {
                if (stage_fc->slices[fg->instance][slice_index].slice_flags &
                        _BCM_FIELD_SLICE_SIZE_LARGE) {
                    slice_array[idx] = slice_index;
                    idx++;
                }
            }
            for (slice_index = 0;
                    slice_index < stage_fc->tcam_slices; slice_index++) {
                if (stage_fc->slices[fg->instance][slice_index].slice_flags &
                        _BCM_FIELD_SLICE_SIZE_SMALL) {
                    slice_array[idx] = slice_index;
                    idx++;
                }
            }
        }
    } else {
        while (idx < stage_fc->tcam_slices) {
            for (slice_index = 0;
                    slice_index < stage_fc->tcam_slices; slice_index++) {
                if (stage_fc->slices[fg->instance][slice_index].slice_flags &
                        _BCM_FIELD_SLICE_SIZE_SMALL) {
                    slice_array[idx] = slice_index;
                    idx++;
                }
            }
            for (slice_index = 0;
                    slice_index < stage_fc->tcam_slices; slice_index++) {
                if (stage_fc->slices[fg->instance][slice_index].slice_flags &
                        _BCM_FIELD_SLICE_SIZE_LARGE) {
                    slice_array[idx] = slice_index;
                    idx++;
                }
            }
        }
    }

    return BCM_E_NONE;
}

/*
 * Function: _field_find_empty_slice
 *
 * Purpose:
 *     Get a new slice for an existing group if available.
 *     Used for auto-expansion of groups
 *     Currently: supported in Raptor, Firebolt2.
 *
 * Parameters:
 *     unit  - BCM device number
 *     fg - field group
 *     fs_ptr - _field_slice_t for the PRIMARY if there is one available.
 *
 * Returns:
 *     BCM_E_xxx
 *
 * Notes:
 *     Need to change the array size (16) for devices which support
 *     more slices, and correspondingly change the map arrays in
 *     bcm_int/esw/field.h
 */
STATIC int
_field_find_empty_slice(int unit, _field_group_t *fg, _field_slice_t **fs_ptr)
{
    _field_control_t *fc;          /* Field control structure. */
    _field_stage_t   *stage_fc;    /* Field stage control.     */
    _field_slice_t   *fs;          /* Field slice pointer.     */
    uint8 slice_number;            /* Slice iterator.          */
    int parts_count = 0;           /* Number of entry parts.   */
    uint32 entry_flags;            /* Field entry part flags.  */
    int rv;                        /* Operation return status. */
    int part_index;                /* Tcam Part Index */
    int slice_index;               /* Slice Index */
    uint8 old_physical_slice;      /* Last slice in group.     */
    uint8 new_physical_slice;      /* Allocated slice.         */
    bcm_port_config_t  port_config;/* Device port config.      */
    bcm_pbmp_t all_pbmp;           /* Port bitmap */
    uint8  *slice_array = NULL;    /* Array containing slice ids */
    int  virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Get field control structure. */
    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Read device port configuration. */
    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (0 == (stage_fc->flags & _FP_STAGE_AUTO_EXPANSION)) {
        return (BCM_E_RESOURCE);
    }

    fs = &fg->slices[0];
    while (fs->next != NULL) {
        fs = fs->next;
    }
    old_physical_slice = fs->slice_number;

    _FP_XGS3_ALLOC(slice_array, sizeof(uint8) * stage_fc->tcam_slices,
                      "Slice Array");
    if (NULL == slice_array) {
        return BCM_E_MEMORY;
    }

    for (slice_index = 0; slice_index < stage_fc->tcam_slices; slice_index++) {
        slice_array[slice_index] = slice_index;
    }

    rv = _field_fill_slice_array (unit, fg, slice_array);
    if (rv != BCM_E_NONE) {
        sal_free (slice_array);
        slice_array = NULL;
        return rv;
    }

    /*
     * Find an empty slice
     * Validate the ports and mode
     */
    for (slice_index = 0; slice_index < stage_fc->tcam_slices; slice_index++) {
        if (slice_index == old_physical_slice) {
           continue;
        }
        rv = _field_group_ports_validate(unit, stage_fc, fg->instance,
                                         slice_array[slice_index],
                                         fg->flags, all_pbmp);
        if (BCM_SUCCESS(rv)) {
            break;
        }
    }

    if (slice_index == stage_fc->tcam_slices) {
        /* No free slice; attempt to compress existing auto expanded  groups. */
        rv = _field_stage_groups_compress(unit, fc, stage_fc);
        if (rv != BCM_E_NONE) {
            sal_free (slice_array);
            slice_array = NULL;
            return rv;
        }

        /* Retry slice allocation. */
        for (slice_index = 0; slice_index < stage_fc->tcam_slices;
             slice_index++) {
            rv = _field_group_ports_validate(unit, stage_fc, fg->instance,
                                             slice_array[slice_index], fg->flags,
                                             all_pbmp);
            if (BCM_SUCCESS(rv)) {
                break;
            }
        }
    }

    if (slice_index == stage_fc->tcam_slices)
    {
        /* No free slice */
        sal_free (slice_array);
        slice_array = NULL;
        return (BCM_E_RESOURCE);
    }

    new_physical_slice = slice_array[slice_index];
    sal_free (slice_array);
    slice_array = NULL;

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    /* Remove original group from the map. */
    if (virtual_priority) {
        rv = _field_group_vmap_delete(unit, stage_fc, fg, FALSE);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get number of entry parts for the group. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id, fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);


    /* Set up the new physical slice parameters in Software */
    for(part_index = parts_count - 1; part_index >= 0; part_index--) {
        /* Get entry flags. */
        rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg,
                                                 &entry_flags);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, part_index, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice pointer. */
        fs = stage_fc->slices[fg->instance] + new_physical_slice
                + slice_number;

        /* Enable slice. */
        if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
            BCM_IF_ERROR_RETURN
                (_field_slice_enable_set(unit, stage_fc, fg, fs, 1));

            /* Set per slice configuration & number of free entries in the slice.*/
            fs->free_count = fs->entry_count;
            if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                fs->free_count >>= 1;
            }
            /* Set group flags in in slice.*/
            fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

            /* Add slice to slices linked list . */
            stage_fc->slices[fg->instance][old_physical_slice + slice_number].
                next = fs;
            fs->prev =
             &stage_fc->slices[fg->instance][old_physical_slice + slice_number];
            BCM_PBMP_OR(fs->pbmp, fg->pbmp);
        }

        rv = fc->functions.fp_selcodes_install(unit, fg,
                                              new_physical_slice + slice_number,
                                              fs->pbmp, part_index);
        BCM_IF_ERROR_RETURN(rv);

        /* Set source class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].src_class_sel) {
            fs->src_class_sel = fg->sel_codes[part_index].src_class_sel;
        }
        /* Set destination class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].dst_class_sel) {
            fs->dst_class_sel = fg->sel_codes[part_index].dst_class_sel;
        }
        /* Set interface class selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].intf_class_sel) {
            fs->intf_class_sel = fg->sel_codes[part_index].intf_class_sel;
        }
        /* Set loopback type/tunnel type selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].loopback_type_sel) {
            fs->loopback_type_sel = fg->sel_codes[part_index].loopback_type_sel;
        }
        /* Set ingress entity type selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].ingress_entity_sel) {
            fs->ingress_entity_sel = fg->sel_codes[part_index].ingress_entity_sel;
        }
        /* Set src entity type selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].src_entity_sel) {
            fs->src_entity_sel = fg->sel_codes[part_index].src_entity_sel;
        }
        /* Set destination forwarding entity type selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].dst_fwd_entity_sel) {
            fs->dst_fwd_entity_sel = fg->sel_codes[part_index].dst_fwd_entity_sel;
        }

        /* Set destination forwarding field selection. */
        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].fwd_field_sel) {
            fs->fwd_field_sel = fg->sel_codes[part_index].fwd_field_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].ttl_class_sel) {
            fs->ttl_class_sel = fg->sel_codes[part_index].ttl_class_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].tos_class_sel) {
            fs->tos_class_sel = fg->sel_codes[part_index].tos_class_sel;
        }

        if (_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].tcp_class_sel) {
            fs->tcp_class_sel = fg->sel_codes[part_index].tcp_class_sel;
        }

        /* Set intraslice double wide key selection. */
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            if ((_FP_SELCODE_DONT_CARE != fg->sel_codes[part_index].fpf2) &&
                ((part_index == _FP_INTRA_SLICE_PART_1) ||
                 (part_index == _FP_INTRA_SLICE_PART_3))) {
                fs->doublewide_key_select = fg->sel_codes[part_index].fpf2;
            }
        }
    }

    /* Reinstall group virtual map . */
    if (virtual_priority) {
        BCM_IF_ERROR_RETURN (_field_group_vmap_add(unit, stage_fc, fg));
    }

    *fs_ptr = stage_fc->slices[fg->instance] + new_physical_slice;
    return (BCM_E_NONE);
}

/*
 * Function: _field_group_check_and_install_selcodes
 *
 * Purpose:
 *      Check if this is the first entry for the group
 *      in the given slice. If this is the first entry
 *      install the selcodes for the group in this slice
 *      This function is called when the slice is not empty
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     fg    - (IN) Field group.
 *     fs    - (IN) Slice pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_check_and_install_selcodes(int unit, _field_group_t *fg,
                                        _field_slice_t *fs)
{
    _field_control_t   *fc;             /* Field control structure.           */
    _field_stage_t     *stage_fc;       /* Field stage control.               */
    uint32              entry_flags;    /* Field entry part flags.            */
    uint8               new_physical_slice;
                                        /* Allocated slice.                   */
    uint8               slice_number = 0;
                                        /* Slice index based on the TCAM parts*/
    int                 idx = 0;        /* Index to iter the entries in slice */
    int                 part_index = 0; /* TCAM parts index                   */
    int                 rv = 0;         /* Operation return status            */
    int                 parts_count = 0;
                                        /* Number of entry parts.             */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    /* If the slice is empty, then return BCM_E_NONE */
    if (fs->free_count == fs->entry_count) {
        return (BCM_E_NONE);
    }

    /*
     * Scan through all the entries in the slice and check if any
     * entry belongs to the given group. If any entry belongs to
     * this group, then return. Else, install the selcodes for the
     * group
     */
    for (idx = 0; idx < fs->entry_count; idx++) {
        if ((NULL != fs->entries[idx]) &&
            (NULL != fs->entries[idx]->group) &&
            (fs->entries[idx]->group->gid == fg->gid)) {
            break;
        }
    }

    if (idx != fs->entry_count) {
        /*
         * This means that there is an entry in the slice belonging
         * to the same group. So, no need to install the selcodes
         */
        return (BCM_E_NONE);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    new_physical_slice = fs->slice_number;

    /*
     * Add the selcodes. This case occurs when the slice contains some entries
     * from another group and a new entry is to be added in this slice for this
     * group. This scenario is for the group with port modes and so, no need
     * to update the virtual slice priority.
     *
     * Get number of entry parts for the group.
     */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Set up the new physical slice parameters in Software */
    for(part_index = parts_count - 1; part_index >= 0; part_index--) {
        /* Get entry flags. */
        rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg,
                                                 &entry_flags);
        BCM_IF_ERROR_RETURN(rv);

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, part_index, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        fs = stage_fc->slices[fg->instance] + new_physical_slice
                + slice_number;

        /* Enable slice. */
        if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
            /* Set group flags in in slice.*/
            fs->group_flags |= fg->flags & _FP_GROUP_STATUS_MASK;

            BCM_PBMP_OR(fs->pbmp, fg->pbmp);
        }

        rv = fc->functions.fp_selcodes_install(unit, fg,
                                               new_physical_slice +
                                               slice_number,
                                               fg->pbmp, part_index);
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}

STATIC int _field_group_is_policer_attached(int unit,
                                 _field_group_t *fg,
                                 int *is_pol_attached) {
    int idx, pidx;
    _field_entry_t  *f_ent; /* Field entry info */
    bcm_policer_t   policer_id;  /* Policer id. */
    int rv;
    *is_pol_attached = 0;

    if (NULL == fg) {
        return (BCM_E_PARAM);
    }
    /*loop throught he entries of the group */
    for (idx = 0; idx < fg->group_status.entry_count; idx++) {
        f_ent = fg->entry_arr[idx];
        /* check if entry has a policer attached */
        if(f_ent != NULL) {
            for (pidx = 0; pidx < _FP_POLICER_LEVEL_COUNT; pidx++) {
               /* Read policer id from entry. */
                rv = bcm_esw_field_entry_policer_get(unit, f_ent->eid,
                                             pidx, &policer_id);
                if (BCM_E_NOT_FOUND == rv) {
                    continue;
                }
                if (!BCM_FAILURE(rv)) {
                    *is_pol_attached = 1;
                    return BCM_E_NONE;
                } else {
                    return rv;
                }
            }
        }
    }
    return BCM_E_NONE;
}

/*
 * Function: _field_group_slice_entry_reserve
 *
 * Purpose:
 *      Find a slice attached to a group which has a room
 *      to insert a new entry.
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     fg    - (IN/OUT) Field group.
 *     fs    - (OUT) Slice pointer or NULL.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_slice_entry_reserve(int unit, _field_group_t *fg,
                                 _field_slice_t **fs)
{
    _field_slice_t  *slice;        /* Slice iteration count.           */
    int             free_entry_cnt;/* Free entries in slice count.     */
    _field_stage_t  *stage_fc;     /* Stage field control info.        */
    int is_pol_attached;
    int rv;


    /* Input parameters check. */
    if ((NULL == fg) || (NULL == fs)) {
        return (BCM_E_PARAM);
    }

    /* Find an empty spot in one of the groups slices.  */
    slice = &fg->slices[0];
    while (slice->next != NULL) {
        slice = slice->next; /* Start from the last slice */
    }

    while (slice != NULL) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
            BCM_IF_ERROR_RETURN
                (_field_th_em_entries_free_get(unit, fg,
                                               &free_entry_cnt));
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
            BCM_IF_ERROR_RETURN
                (_bcm_field_entries_free_get(unit, slice, fg,
                                             &free_entry_cnt));
        }
        if (free_entry_cnt) {
            break;
        }
        slice = slice->prev;
    }

    /*
     * If there is no room in existing group slices try to allocate a new one.
     * Find a feasible empty slice for auto-expand
     * Set these slices in the same virtual group
     */
    if (slice == NULL) {
        /* Need to check if you need to allocate a new slice */
        if (!(fg->flags & _FP_GROUP_SELECT_AUTO_EXPANSION)) {
            return (BCM_E_RESOURCE);
        }

        /*
         * Auto expansion is not allowed if a policer a policer is attached
         * to an entry in the group which doesnot support global pools
         */
        rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                  "FP(unit %d) Error: Stage (%d) control get failure.\n"),
                  unit, fg->stage_id));
            return (rv);
        }
        if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS))  {
            is_pol_attached = 0;
            BCM_IF_ERROR_RETURN(_field_group_is_policer_attached(
                                  unit, fg, &is_pol_attached));
            if(is_pol_attached) {
                return BCM_E_RESOURCE;
            }
        }

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)
             && (fg->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
           BCM_IF_ERROR_RETURN
                (_bcm_field_th_find_empty_slice(unit, fg, &slice));
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
           BCM_IF_ERROR_RETURN(_field_find_empty_slice(unit, fg, &slice));
        }

        BCM_IF_ERROR_RETURN
            (_bcm_field_entries_free_get(unit, slice, fg, &free_entry_cnt));

        if (0 == free_entry_cnt) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                       "FP(unit %d) Error: No entries free in slice.\n"),
                       unit));
            return (BCM_E_RESOURCE);
        }
    } else {
        BCM_IF_ERROR_RETURN
            (_field_group_check_and_install_selcodes(unit, fg, slice));
    }
    *fs = slice;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_actions_free
 * Purpose:
 *     Free and deinitialize field entry actions linked list
 * Parameters:
 *     f_ent       - (IN/OUT) Field entry with actions.
 *     color_only  - (IN) Color based actions only.
 *
 * Returns:
 *     BCM_E_MEMORY - allocation failure
 *     BCM_E_NONE   - Success
 */
STATIC int
_field_entry_actions_free (int unit, _field_entry_t *f_ent, int color_only)
{
    _field_action_t *fa;        /* Action structure pointer. */
    _field_action_t *fa_prev;   /* Action structure pointer. */

    /* Input parameters check.*/
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    fa_prev = fa = f_ent->actions;

    /* Free actions from the entry. */
    while (fa != NULL) {
        if (color_only && (!_FP_ACTION_IS_COLOR_BASED(fa->action))) {
            fa_prev = fa;
            fa = fa->next;
            continue;
        }

        /* Head entry deletion. */
        if (fa == f_ent->actions) {
            f_ent->actions = fa->next;
            sal_free(fa);
            fa_prev = fa = f_ent->actions;
        } else {
            /* Middle/Tail entry deletion. */
            fa_prev->next = fa->next;
            sal_free(fa);
            fa = fa_prev->next;
        }
    }

    /* Destroy Oam related actions */
#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)){
        BCM_IF_ERROR_RETURN(_bcm_field_oam_stat_actions_destroy (unit,f_ent));
    }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_phys_destroy
 *
 * Purpose:
 *     Destroy a physical entry from a slice. Note that this does not remove
 *     the entry from the hardware.
 *
 * Parameters:
 *     unit      - BCM device number
 *     fs        - slice that entry resides in
 *     entry     - Entry ID to remove
 *
 * Returns:
 *     BCM_E_NONE - Success
 */
int
_field_entry_phys_destroy (int unit, _field_entry_t *f_ent)
{
    _field_stage_t   *stage_fc;   /* Stage field control.            */
    _field_group_t   *fg;         /* Field group structure.          */
    _field_slice_t   *fs;         /* Field slice structure.          */
    int              parts_count = 0; /* Entry parts count.              */
    uint8            slice_number;/* Field entry part slice number.  */
    int              idx;         /* Entry parts iterator.           */
    int              rv;          /* Operation return status.        */

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    fs = f_ent->fs;
    fg = f_ent->group;

    /* Get field control structure. */


    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fs->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < parts_count; idx++) {
        /* Destroy all actions from entry. */
        rv = _field_entry_actions_free (unit, f_ent + idx, FALSE);
        BCM_IF_ERROR_RETURN(rv);

        /* Free tcam image. */
        if(NULL != f_ent[idx].tcam.key) {
            sal_free(f_ent[idx].tcam.key);
        }
        if(NULL != f_ent[idx].tcam.mask) {
            sal_free(f_ent[idx].tcam.mask);
        }
        if(NULL != f_ent[idx].tcam.key_hw) {
            sal_free(f_ent[idx].tcam.key_hw);
        }
        if(NULL != f_ent[idx].tcam.mask_hw) {
            sal_free(f_ent[idx].tcam.mask_hw);
        }
        if(NULL != f_ent[idx].extra_tcam.key) {
            sal_free(f_ent[idx].extra_tcam.key);
        }
        if(NULL != f_ent[idx].extra_tcam.mask) {
            sal_free(f_ent[idx].extra_tcam.mask);
        }
        if(NULL != f_ent[idx].extra_tcam.key_hw) {
            sal_free(f_ent[idx].extra_tcam.key_hw);
        }
        if(NULL != f_ent[idx].extra_tcam.mask_hw) {
            sal_free(f_ent[idx].extra_tcam.mask_hw);
        }
        if(NULL != f_ent[idx].key_match_tcam.key) {
            sal_free(f_ent[idx].key_match_tcam.key);
        }
        if(NULL != f_ent[idx].key_match_tcam.mask) {
            sal_free(f_ent[idx].key_match_tcam.mask);
        }
        if(NULL != f_ent[idx].key_match_tcam.key_hw) {
            sal_free(f_ent[idx].key_match_tcam.key_hw);
        }
        if(NULL != f_ent[idx].key_match_tcam.mask_hw) {
            sal_free(f_ent[idx].key_match_tcam.mask_hw);
        }

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, idx, fg,
                                                  &slice_number);
        BCM_IF_ERROR_RETURN(rv);

        /* Remove entry pointer from the slice. */
        if ((stage_fc->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
            (stage_fc->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {
            fs[slice_number].entries[f_ent[idx].slice_idx] = NULL;
        }

        /* Increment slice unused entry count. */
        if (0 == (f_ent[idx].flags & _FP_ENTRY_SECOND_HALF)) {
            fs[slice_number].free_count++;
        }
    }

    /* Remove the entry from group entry array. */
    rv = _field_group_entry_delete(unit, fg,  f_ent);
    if (BCM_FAILURE(rv)) {
        sal_free(f_ent);
        return (rv);
    }

    /* Free the entry */
    sal_free(f_ent);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_entry_part_tcam_idx_get
 *
 * Purpose:
 *     Given primary entry slice/idx calculate
 *     secondary/tertiary/second half slice/index.
 *
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     f_ent   - (IN) Field entry pointer.
 *     idx_pri - (IN) Primary entry tcam index.
 *     ent_part    - (IN) Entry part id.
 *     idx_out - (OUT) Entry part tcam index.
 * Returns
 *     BCM_E_XXX
 *
 */
int
_bcm_field_entry_part_tcam_idx_get(int unit, _field_entry_t *f_ent,
                                   uint32 idx_pri, uint8 ent_part,
                                   int *idx_out)
{
    uint8            slice_number = 0;/* Primary entry slice number.    */
    int              pri_slice = 0;   /* Primary entry slice number.    */
    int              pri_index = 0;   /* Primary entry in slice index.  */
    int              part_index;      /* Entry part slice index.        */
    _field_stage_t   *stage_fc;       /* Stage field control.           */
    _field_slice_t   *fs;             /* Field slice structure.         */
    _field_group_t   *fg;             /* Field group structure.         */
    int              rv;              /* Operation return status.       */

    /* Input parameters ceck. */
    if ((NULL == f_ent) || (NULL == idx_out)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
       return _bcm_field_th_entry_part_tcam_idx_get(unit, f_ent, idx_pri,
                                                    ent_part, idx_out);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Primary entry index. */
    if (0 == ent_part) {
        *idx_out = idx_pri;
        return (BCM_E_NONE);
    }

    fg = f_ent->group;

    /* External tcam doesn't support wide entries. */
    if (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) {
        return (BCM_E_INTERNAL);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get primary part entry index & slice. */
    rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, fg->instance,
                                              idx_pri, &pri_slice,
                                              &pri_index);
    BCM_IF_ERROR_RETURN(rv);

    /* Get entry part slice number 0,1,2 */
    rv = _bcm_field_tcam_part_to_slice_number(unit, ent_part, fg,
                                              &slice_number);
    BCM_IF_ERROR_RETURN(rv);

    /* Get slice description structure. */
    fs = stage_fc->slices[fg->instance] + (pri_slice + slice_number);

    if (f_ent[ent_part].flags &  _FP_ENTRY_SECOND_HALF) {
        part_index = pri_index + (fs->entry_count >> 1);
    } else {
        part_index = pri_index;
    }

    rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc, fg->instance,
                                             fs->slice_number, part_index,
                                             idx_out);
    return (rv);
}

/*
 * Function:
 *     _field_entry_phys_create
 *
 * Purpose:
 *     Initialize a physical entry structure.
 *
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Stage field control structure.
 *     entry          - (IN) Entry ID.
 *     prio           - (IN) Priority relative to other entries in group.
 *     fs             - (IN) Slice where entry resides.
 *     fg             - (IN) Entry's group.
 *     entry_p        - (OUT)Allocated & initialized entry.
 *
 * Returns
 *     BCM_E_XXX
 *
 * Notes:
 *     Assumes that for wide-mode, the same index within the slice
 *     is assigned for the 2(3) slices.
 */
STATIC int
_field_entry_phys_create(int unit, _field_stage_t *stage_fc,
                         bcm_field_entry_t entry, int prio,
                         _field_slice_t *fs, _field_group_t *fg,
                         _field_entry_t **entry_p)
{
    _field_control_t    *fc;          /* Field control structure.         */
    int                 idx;          /* Slice entries iteration index.   */
    int                 parts_count = 0;/* Number of entry parts.           */
    int                 part_index;   /* Entry parts iterator.            */
    int                 rv;           /* Operation return status.         */
    int                 mem_sz;       /* Memory allocation size.          */
    int                 slice_number = 0;/* Field entry part slice number.*/
    _field_entry_t      *f_ent = NULL;/* Field entry structure.           */
    int                 pri_tcam_idx = -1; /* Primary entry tcam index.   */
#if defined(BCM_TOMAHAWK_SUPPORT)
    int                 free_count = 0;    /* Free entry count.           */
#endif /* BCM_TOMAHAWK_SUPPORT */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
               "FP(unit %d): BEGIN "
               "_field_entry_phys_create(entry=%d, prio=%d, gid=%d)\n"),
               unit, entry, prio, fg->gid));

    if ((NULL == fs) || (NULL == fg) || (NULL == entry_p)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        BCM_IF_ERROR_RETURN(_field_th_em_entries_free_get(unit, fg,
                                                          &free_count));
        /* Check if free entries are available in the UFT. */
        if (0 == free_count) {
            return (BCM_E_RESOURCE);
        }
    } else
#endif
    {
        /* Check if free entries are available in the slice. */
        if (0 == fs->free_count) {
            return (BCM_E_RESOURCE);
        }
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get number of parts in field entry based on group flags. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate and zero memory for field entry. */
    mem_sz = parts_count * sizeof (_field_entry_t);

    _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
    if (f_ent == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                    "FP(unit %d) Error: allocation failure for field_entry\n"),
                    unit));
        return (BCM_E_MEMORY);
    }

    /* Initalize policer id as invalid for all policer levels. */
    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent->policer[idx].pid = _FP_INVALID_INDEX;
    }

    /*
     * In External TCAM, each slice has different number of entries
     *     Also, allocation happens only at Install time
     */
    if (fg->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        f_ent->slice_idx = -1;
    } else if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        f_ent->slice_idx = _FP_INVALID_INDEX;
    } else {
        /* Get index for primary entry. */
        for (idx = 0; idx < fs->entry_count; idx++) {
            if (NULL == fs->entries[idx]) {
                f_ent->slice_idx = idx;
                break;
            }
        }
        rv = _bcm_field_slice_offset_to_tcam_idx (unit, stage_fc,
                                                  fg->instance,
                                                  fs->slice_number,
                                                  f_ent->slice_idx,
                                                  &pri_tcam_idx);
        if (BCM_FAILURE(rv)) {
            sal_free(f_ent);
            return (rv);
        }
    }

    for (idx = 0; idx < parts_count; idx++) {
        /* Fill in entry primitives. */
        f_ent[idx].eid          = entry;
        f_ent[idx].prio         = prio;
        f_ent[idx].group        = fg;
        f_ent[idx].ent_copy     = NULL;
        f_ent[idx].efp_key_match_type = _FP_ENTRY_TYPE_1;

        /* Get entry part flags. */
        rv = _bcm_field_tcam_part_to_entry_flags(unit, idx, fg,
                                                 &f_ent[idx].flags);
        if (BCM_FAILURE(rv)) {
            sal_free(f_ent);
            return (rv);
        }

        /* Enable color independent actions based on field control. */
        if (fc->flags & _FP_COLOR_INDEPENDENT) {
            f_ent[idx].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
        }

        /* Given primary entry tcam index calculate entry part tcam index. */
        if (idx && ((_BCM_FIELD_STAGE_EXTERNAL != fg->stage_id) &&
                    (_BCM_FIELD_STAGE_EXACTMATCH != fg->stage_id))) {
            rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent, pri_tcam_idx,
                                                    idx, &part_index);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                return (rv);
            }

#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_field_multi_pipe_support)
                 && (fg->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
                rv = _bcm_field_th_tcam_idx_to_slice_offset(unit, stage_fc,
                                                  f_ent, part_index,
                                                  &slice_number,
                                                  (int *)&f_ent[idx].slice_idx);
            } else
#endif /* BCM_TOMAHAWK_SUPPORT */
            {
                rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc,
                                                  fg->instance, part_index,
                                                  &slice_number,
                                                  (int *)&f_ent[idx].slice_idx);
            }
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                return (rv);
            }
            f_ent[idx].fs = stage_fc->slices[fg->instance] + slice_number;
        } else {
            /* Set entry slice. */
            f_ent[idx].fs = fs;
        }

        if (0 == (f_ent[idx].flags & _FP_ENTRY_SECOND_HALF)) {
            /* Decrement slice free entry count for primary entries. */
            f_ent[idx].fs->free_count--;
        }

        /* Assign entry to a slice */
        if ((fg->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
            (fg->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {
            f_ent[idx].fs->entries[f_ent[idx].slice_idx] = f_ent + idx;
        }

        /* Mark entry dirty. */
        f_ent[idx].flags |=  _FP_ENTRY_DIRTY;
    }

    /* Insert the entry into group entry array. */
    rv = _field_group_entry_add(unit, fg,  f_ent);
    if (BCM_FAILURE(rv)) {
        sal_free(f_ent);
        return (rv);
    }

    /* Return allocated/filled entry structure to the caller. */
    *entry_p = f_ent;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_tcam_policy_external_reinstall
 *
 * Purpose:
 *     Re-Install POLICY_TABLE entry. This writes the
 *     actions to the hardware.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry to be installed.
 *
 * Returns:
 *     BCM_E_INTERNAL  - Memory Read failure
 *     BCM_E_UNAVAIL   - Device not supported
 *     BCM_E_NONE      - Success
 *
 * Notes:
 */
STATIC int
_field_tcam_policy_external_reinstall(int unit, _field_entry_t *f_ent)
{
    _field_control_t    *fc;         /* Field control structure.  */
    int                 rv;          /* Operation return status.  */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* If not installed, and no qualifiers yet
     *     i.e. installing empty entry for first time
     */
    if (0 == (f_ent->flags & _FP_ENTRY_INSTALLED)) {
        BCM_IF_ERROR_RETURN (_bcm_field_qual_tcam_key_mask_get(unit, f_ent));
    }

    /* Next copy S/W copy to H/W copy if required */
    if(NULL != f_ent->tcam.key) {
        sal_memcpy(f_ent->tcam.key_hw, f_ent->tcam.key,
                   f_ent->tcam.key_size);
        sal_free(f_ent->tcam.key);
        f_ent->tcam.key = NULL;
    }
    if(NULL != f_ent->tcam.mask) {
        sal_memcpy(f_ent->tcam.mask_hw, f_ent->tcam.mask,
                   f_ent->tcam.key_size);
        sal_free(f_ent->tcam.mask);
        f_ent->tcam.mask = NULL;
    }

    /* Then install the H/W copy into H/W */
    rv = fc->functions.fp_external_entry_reinstall(unit, f_ent);

    if (rv == BCM_E_NONE) {
        f_ent->flags &= ~_FP_ENTRY_DIRTY;
        f_ent->flags &= ~(_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY);
    }
    return (rv);
}

/*
 * Function:
 *     _field_tcam_policy_external_install
 *
 * Purpose:
 *     Install a combined TCAM and POLICY_TABLE entry. This writes the
 *     qualifiers and actions to the hardware.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry to be installed.
 *
 * Returns:
 *     BCM_E_INTERNAL  - Memory Read failure
 *     BCM_E_UNAVAIL   - Device not supported
 *     BCM_E_NONE      - Success
 *
 * Notes:
 */
STATIC int
_field_tcam_policy_external_install(int unit, _field_entry_t *f_ent)
{
    _field_control_t    *fc;         /* Field control structure.  */
    int                 rv;          /* Operation return status.  */


    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* If not installed, and no qualifiers yet
     *     i.e. installing empty entry for first time
     */
    if (0 == (f_ent->flags & _FP_ENTRY_INSTALLED)) {
        BCM_IF_ERROR_RETURN (_bcm_field_qual_tcam_key_mask_get(unit, f_ent));
    }

    /* Next copy S/W copy to H/W copy if required */
    if(NULL != f_ent->tcam.key) {
        sal_memcpy(f_ent->tcam.key_hw, f_ent->tcam.key,
                   f_ent->tcam.key_size);
        sal_free(f_ent->tcam.key);
        f_ent->tcam.key = NULL;
    }
    if(NULL != f_ent->tcam.mask) {
        sal_memcpy(f_ent->tcam.mask_hw, f_ent->tcam.mask,
                   f_ent->tcam.key_size);
        sal_free(f_ent->tcam.mask);
        f_ent->tcam.mask = NULL;
    }

    /* Then install the H/W copy into H/W */
    rv = fc->functions.fp_external_entry_install(unit, f_ent);

    if (rv == BCM_E_NONE) {
        f_ent->flags &= ~_FP_ENTRY_DIRTY;
        f_ent->flags |= _FP_ENTRY_INSTALLED;
        f_ent->flags |= _FP_ENTRY_ENABLED;
    }
    return (rv);
}

#ifdef INCLUDE_L3
#if defined (BCM_TRIDENT2_SUPPORT) /* BCM_TRIDENT2_SUPPORT */
/*
 * Function: _bcm_field_nat_actions_update
 *
 * Purpose: Update Egress Nat Reference Count for
 * NatEgressOverride action.
 *
 * Parameters:
 * unit      - (IN) Device number.
 * f_ent     - (IN) Field entry.
 * set       - (IN) Set or reset the Reference count
 *                  based on action add/delete.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_field_nat_actions_update(int unit, _field_entry_t *f_ent,
        int set)
{
    _field_action_t *fa;            /* Field action descriptor. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) &&
            (_BCM_FIELD_STAGE_EXACTMATCH != f_ent->group->stage_id)){
        return (BCM_E_NONE);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions;
         ((fa != NULL) && (_FP_ACTION_VALID & fa->flags));
         fa = fa->next) {
        if (fa->action != bcmFieldActionNatEgressOverride) {
            continue;
        }

        if (set) {
            /* Action is added, increment reference count if not already done.*/
            if ((_FP_ACTION_DIRTY & fa->flags) || SOC_WARM_BOOT(unit)) {
                BCM_IF_ERROR_RETURN(_bcm_esw_nat_egress_ref_count_update(unit, fa->param[0], 1));
                /* Setting hw_index to non-zero in order to handle fp action remove, fp action add
                 * config sequence */
                fa->hw_index = 1;
            }
        }
        else {
            /* Action is deleted, decrement reference count if not already done.*/
            if ((fa->flags & _FP_ACTION_DIRTY)) {
                continue;
            }

            BCM_IF_ERROR_RETURN(_bcm_esw_nat_egress_ref_count_update(unit, fa->param[0], 0));
            fa->hw_index = _FP_INVALID_INDEX;
            fa->flags |= _FP_ACTION_DIRTY;
        }
    }
    return BCM_E_NONE;
}
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
        || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
        || defined (BCM_ENDURO_SUPPORT) \


/*
 * Function:
 *    _field_nh_ref_count_incr
 *
 * Purpose:
 *     Increment next hop refCount for RedirectEgrNextHop and
 *     L3Switch action.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_field_nh_ref_count_incr (int unit, _field_entry_t *f_ent)
{
    _field_action_t *fa = NULL;  /* Field action descriptor. */
    uint32 flags;                /* L3 forwarding flags.    */
    int nh_ecmp_id;              /* Next hop/Ecmp group id. */

    /* Extract action info from the entry structure. */
    for (fa = f_ent->actions; ((fa != NULL) && (_FP_ACTION_VALID & fa->flags)
                && ((_FP_ACTION_DIRTY & fa->flags) || SOC_WARM_BOOT(unit)));
            fa = fa->next) {
        if ((fa->action != bcmFieldActionRedirectEgrNextHop)
                && (fa->action != bcmFieldActionL3Switch)) {
            continue;
        }

        BCM_IF_ERROR_RETURN(_bcm_field_policy_set_l3_nh_resolve (unit,
                    fa->param[0], &flags, &nh_ecmp_id));

        BCM_IF_ERROR_RETURN(bcmi_esw_l3_egress_ref_count_update (unit,
                    fa->param[0], flags, nh_ecmp_id,1));

        /* Setting hw_index to non-zero in order to handle fp action remove, fp action add
         * config sequence */
        fa->hw_index = 1;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *    _field_nh_ref_count_decr
 *
 * Purpose:
 *     Decrement next hop refCount for RedirectEgrNextHop and
 *     L3Switch action.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_nh_ref_count_decr (int unit, _field_entry_t *f_ent)
{
    _field_action_t *fa = NULL;  /* Field action descriptor. */
    uint32 flags;                /* L3 forwarding flags.    */
    int nh_ecmp_id;              /* Next hop/Ecmp group id. */

    /* Extract action info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if ((fa->action != bcmFieldActionRedirectEgrNextHop)
                && (fa->action != bcmFieldActionL3Switch)) {
            continue;
        }

        /* If action is not valid and dirty, do not decrement
         * the ref Count. For modified action, the ref count
         * decrement will happen in invalid_actions_free */
        if ((fa->flags & _FP_ACTION_VALID) == 0) {
            continue;
        }

        if ((fa->flags & _FP_ACTION_DIRTY)) {
            continue;
        }

        BCM_IF_ERROR_RETURN(_bcm_field_policy_set_l3_nh_resolve (unit,
                    fa->param[0], &flags, &nh_ecmp_id));

        BCM_IF_ERROR_RETURN(bcmi_esw_l3_egress_ref_count_update (unit,
                    fa->param[0], flags, nh_ecmp_id,0));
        fa->hw_index = _FP_INVALID_INDEX;
        fa->flags |= _FP_ACTION_DIRTY;
    }

    return BCM_E_NONE;
}



/*
 * Function:
 *   bcmi_xgs3_fp_l3_egress_ref_count_update
 *
 * Purpose:
 *     Increment next hop refCount for RedirectEgrNextHop and
 *     L3Switch action after warmboot.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
bcmi_xgs3_fp_l3_egress_ref_count_update (int unit)
{
    _field_group_t      *fg;      /* Group information. */
    _field_control_t    *fc;      /* Field Control Structure. */
    _field_entry_t      *f_ent;   /* Field Entry. */
    int                  idx = 0; /* Iteration index. */
    int                   rv = 0; /* Return Value. */

    /* Get unit FP control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Iterate over the groups linked-list */
    fg = fc->groups;
    while (fg != NULL) {
        if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS ||
            fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
            /* Now iterate over the entries in this group */
            for (idx = 0; idx < fg->group_status.entry_count; idx++) {
                f_ent = fg->entry_arr[idx];
                rv = _field_nh_ref_count_incr (unit, f_ent);
                BCM_IF_ERROR_RETURN(rv);
#if defined (BCM_TRIDENT2_SUPPORT) /* BCM_TRIDENT2_SUPPORT */
                rv = _bcm_field_nat_actions_update(unit, f_ent, 1);
                BCM_IF_ERROR_RETURN(rv);
#endif /* BCM_TRIDENT2_SUPPORT */
            }
        }
        fg = fg->next;
    }

    return rv;
}


#endif /* BCM_KATANA_SUPPORT || BCM_TRIDENT_SUPPORT || BCM_TRIUMPH3_SUPPORT \
          || BCM_GREYHOUND_SUPPORT */

#endif /* INCLUDE_L3 */

/*
 * Function:
 *     _field_resources_free
 *
 * Purpose:
 *     Free hw resources used in FP entry.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry structure.
 *     flags     - (IN) Old/installed resource to free.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_resources_free(int unit, _field_entry_t *f_ent, uint32 flags)
{
    int rv;   /* Operation return status. */
    _field_control_t *fc; /* Field Control Structure. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));

    /* Free redirection profiles. */
    rv = _field_redirect_profile_hw_free(unit, f_ent, flags);
    BCM_IF_ERROR_RETURN(rv);

    /* Free mirror destination indexes. */
    rv = _field_mtp_hw_free(unit, f_ent, flags);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIDENT2_SUPPORT)
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        rv = _bcm_field_td2_hash_select_profile_hw_free(unit, f_ent, flags);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif

    /* Free counters. */
    if (flags & _FP_ACTION_RESOURCE_FREE) {
        rv = fc->functions.fp_stat_hw_free(unit, f_ent);
        BCM_IF_ERROR_RETURN(rv);
    }


#if defined(INCLUDE_L3)
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_action_l2_change)) {
        rv = _bcm_field_l2_actions_hw_free(unit, f_ent, flags);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif /* BCM_TRIUMPH2_SUPPORT || BCM_TRIDENT_SUPPORT */

#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
         || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
         || defined (BCM_ENDURO_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)
        || SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANEX(unit)
        || SOC_IS_ENDURO(unit) || SOC_IS_GREYHOUND2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_l3_egress_actions_reset(unit, f_ent,
                                                               flags));

        /* Decrement next hop ref Count. */
        if (flags & _FP_ACTION_RESOURCE_FREE) {
            rv = _field_nh_ref_count_decr (unit, f_ent);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

#endif /* BCM_KATANA_SUPPORT || BCM_TRIDENT_SUPPORT || BCM_TRIUMPH3_SUPPORT \
          || BCM_GREYHOUND_SUPPORT || BCM_ENDURO_SUPPORT */

#if defined (BCM_TRIDENT2_SUPPORT) /* BCM_TRIDENT2_SUPPORT */
    if (flags & _FP_ACTION_RESOURCE_FREE) {
        BCM_IF_ERROR_RETURN(_bcm_field_nat_actions_update(unit, f_ent, 0));
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#endif /* INCLUDE_L3 */

#if defined(BCM_TOMAHAWK_SUPPORT)
     if(NULL != fc->functions.fp_eh_mask_profile_hw_free) {
         fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent, flags);
         BCM_IF_ERROR_RETURN(rv);
     }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_hw_resources_free
 *
 * Purpose:
 *     Free hw resources used in FP entry.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Field entry structure.
 *     flags     - (IN) Old/installed resource to free.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_hw_resources_free(int unit, _field_entry_t *f_ent, uint32 flags)
{
    int rv;	/* Operation return status. */

    rv = _field_resources_free(unit, f_ent, flags);
    BCM_IF_ERROR_RETURN(rv);

    /* Free policers. */
    if (flags & _FP_ACTION_RESOURCE_FREE) {
        if (flags & _FP_ACTION_POLICER_SW_UPDATE) {
            rv = _field_policers_hw_free(unit, f_ent,
                    _FP_ACTION_RESOURCE_FREE|_FP_ACTION_POLICER_SW_UPDATE);
        } else {
            rv = _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
        }
        BCM_IF_ERROR_RETURN(rv);
    }

    if (flags & _FP_ACTION_OLD_RESOURCE_FREE) {
        if (flags & _FP_ACTION_POLICER_SW_UPDATE) {
            rv = _field_policers_hw_free(unit, f_ent,
                    _FP_ACTION_OLD_RESOURCE_FREE|_FP_ACTION_POLICER_SW_UPDATE);
        } else {
            rv = _field_policers_hw_free(unit, f_ent, _FP_ACTION_OLD_RESOURCE_FREE);
        }
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_hw_resources_alloc
 *
 * Purpose:
 *     Allocate hw resources required for entry installation.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
STATIC int
_field_hw_resources_alloc(int unit, _field_entry_t *f_ent)
{
    _field_control_t *fc;
    _field_stage_t   *stage_fc;    /* Stage field control.     */
    int rv;                        /* Operation return status. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));

    /* Get Stage Control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Select slice for hw resources allocation. */
    rv = _field_entry_install_slice_fit(unit, stage_fc, f_ent, f_ent->fs);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate policers. */
    BCM_IF_ERROR_RETURN(_field_policers_hw_alloc(unit, f_ent));

    /* Allocate statistics. */
    rv = fc->functions.fp_stat_hw_alloc(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
        return (rv);
    }

    /* Allocate mirror destination indexes. */
    rv = _field_mtp_hw_alloc(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        fc->functions.fp_stat_hw_free(unit, f_ent);
        _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
        return (rv);
    }

    /* Allocate redirection profiles. */
    rv = _field_redirect_profile_hw_alloc(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
        fc->functions.fp_stat_hw_free(unit, f_ent);
        _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Allocate redirection profiles. */
    if (NULL != fc->functions.fp_eh_mask_profile_hw_alloc) {
        rv = fc->functions.fp_eh_mask_profile_hw_alloc(unit, f_ent);
        if (BCM_FAILURE(rv)) {
            _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            fc->functions.fp_stat_hw_free(unit, f_ent);
            _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
            _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            return (rv);
        }
    }
#endif

#if defined(BCM_TRIDENT2_SUPPORT)
    /* Allocate hash select profiles. */
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        rv = _bcm_field_td2_hash_select_profile_hw_alloc(unit, f_ent);
        if (BCM_FAILURE(rv)) {
            _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            fc->functions.fp_stat_hw_free(unit, f_ent);
            _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
            _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (NULL != fc->functions.fp_eh_mask_profile_hw_free) {
               fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent,
                                                     _FP_ACTION_HW_FREE);
            }
#endif
            return (rv);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined (INCLUDE_L3)
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_action_l2_change)) {
        rv =  _bcm_field_l2_actions_hw_alloc(unit, f_ent);
        if (BCM_FAILURE(rv)) {
            _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            fc->functions.fp_stat_hw_free(unit, f_ent);
            _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
            _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
#if defined(BCM_TRIDENT2_SUPPORT)
            if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                _bcm_field_td2_hash_select_profile_hw_free(unit,
                                                           f_ent,
                                                           _FP_ACTION_HW_FREE);
            }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (NULL != fc->functions.fp_eh_mask_profile_hw_free) {
               fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent,
                                                     _FP_ACTION_HW_FREE);
            }
#endif
            return (rv);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT || defined (BCM_TRIDENT_SUPPORT) */
#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIDENT_SUPPORT) \
         || defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_GREYHOUND_SUPPORT) \
         || defined (BCM_ENDURO_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)
        || SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANEX(unit)
        || SOC_IS_ENDURO(unit) || SOC_IS_GREYHOUND2(unit)) {
        rv = _bcm_field_l3_egress_actions_set(unit, f_ent);
        if (BCM_SUCCESS(rv)) {
            rv = _field_nh_ref_count_incr(unit, f_ent);
            if (BCM_FAILURE(rv)) {
                _bcm_field_l3_egress_actions_reset(unit,
                                                   f_ent, _FP_ACTION_HW_FREE);
            }
        }

        if (BCM_FAILURE(rv)) {
            if (soc_feature(unit, soc_feature_field_action_l2_change)) {
                _bcm_field_l2_actions_hw_free(unit, f_ent,
                                            _FP_ACTION_RESOURCE_FREE);
            }
            _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
            fc->functions.fp_stat_hw_free(unit, f_ent);
            _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
            _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (NULL != fc->functions.fp_eh_mask_profile_hw_free) {
               fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent,
                                                     _FP_ACTION_HW_FREE);
            }
#endif
            return (rv);
        }
    }
#endif /* BCM_KATANA_SUPPORT || BCM_TRIDENT_SUPPORT || BCM_TRIUMPH3_SUPPORT \
          || BCM_GREYHOUND_SUPPORT || BCM_ENDURO_SUPPORT */

#if defined (BCM_TRIDENT2_SUPPORT)
    rv = _bcm_field_nat_actions_update(unit, f_ent, 1);
    if (BCM_FAILURE(rv)) {
        if (SOC_IS_KATANAX(unit) || SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)
                || SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANEX(unit)
                || SOC_IS_ENDURO(unit)) {
            _field_nh_ref_count_decr (unit, f_ent);
            _bcm_field_l3_egress_actions_reset(unit,
                    f_ent, _FP_ACTION_HW_FREE);
        }
        if (soc_feature(unit, soc_feature_field_action_l2_change)) {
            _bcm_field_l2_actions_hw_free(unit, f_ent,
                    _FP_ACTION_RESOURCE_FREE);
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            _bcm_field_td2_hash_select_profile_hw_free(unit,
                    f_ent,
                    _FP_ACTION_HW_FREE);
        }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (NULL != fc->functions.fp_eh_mask_profile_hw_free) {
            fc->functions.fp_eh_mask_profile_hw_free(unit, f_ent,
                    _FP_ACTION_HW_FREE);
        }
#endif
        _field_redirect_profile_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
        _field_mtp_hw_free(unit, f_ent, _FP_ACTION_HW_FREE);
        fc->functions.fp_stat_hw_free(unit, f_ent);
        _field_policers_hw_free(unit, f_ent, _FP_ACTION_RESOURCE_FREE);
    }
#endif

#endif /* INCLUDE_L3 */

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_policer_stat_slice_move
 * Purpose:
 *     Move policer to slice in which counter resides
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_ent         - (IN) Entry to be installed.
 *     to_secondary  - (IN) Movement direction.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entry_policer_stat_slice_move(int unit,
                                     _field_entry_t *f_ent,
                                     int to_secondary)
{
    _field_entry_policer_t *f_ent_pl_src; /* Src entry policer descriptor  */
    _field_entry_policer_t *f_ent_pl_dst; /* Dest entry policer descriptor */
    _field_stage_t *stage_fc;             /* Stage field control.          */
    uint8 src_idx;                        /* Source entry hardware index.  */
    uint8 dst_idx;                        /* Dest entry hardware index.    */
    uint8 level;                          /* Policer level.                */
    _field_action_t  *fa;                 /* Entry actions iterator.       */
    _field_action_t  *fa_next;            /* Entry actions iterator.       */

    /* Input parameters check */
    if  (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );

    if ((stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)
        && !(stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS)
        && (f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE)) {
        /* Get entry secondary part hardware index. */
        BCM_IF_ERROR_RETURN
            (_bcm_field_entry_flags_to_tcam_part(unit, _FP_ENTRY_SECONDARY,
                                                 f_ent->group,
                                                 &dst_idx
                                                 )
            );

        /* Determine source and destination slice indices. */
        if (to_secondary) {
            src_idx = 0;
        } else {
            src_idx = dst_idx;
            dst_idx = 0;
        }

        fa = f_ent[src_idx].actions;
        /* Copy all actions from source index to destination index. */
        while (NULL != fa)  {
            fa_next = fa->next;
            /* Insert action to the destination slice actions list. */
            fa->next = f_ent[dst_idx].actions;
            f_ent[dst_idx].actions = fa;
            /* Remove action from the primary slice actions list. */
            f_ent[src_idx].actions = fa_next;
            fa = fa_next;
        }

        for (level = 0; level < _FP_POLICER_LEVEL_COUNT; level++) {
            f_ent_pl_src = f_ent[src_idx].policer + level;

            if (f_ent_pl_src->flags & _FP_POLICER_INSTALLED) {
                f_ent_pl_dst = (f_ent[dst_idx].policer + level);
                f_ent_pl_dst->pid = f_ent_pl_src->pid;
                f_ent_pl_dst->flags |= _FP_POLICER_INSTALLED;

                f_ent_pl_src->flags &= ~_FP_POLICER_INSTALLED;
                f_ent_pl_src->pid = _FP_INVALID_INDEX;
            }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_actions_meter_slice_move
 * Purpose:
 *    Move actions to a slice where meter resides.
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     f_ent - (IN) Entry to be installed.
 *     to_secondary  - (IN) Movement direction.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_entry_actions_meter_slice_move(int unit, _field_entry_t *f_ent,
                                      int to_secondary)
{
    _field_stage_t   *stage_fc;   /* Stage field control.              */
    _field_action_t  *fa;         /* Entry actions iterator.           */
    _field_action_t  *fa_prev;    /* Entry actions iterator.           */
    _field_action_t  *fa_next;    /* Entry actions iterator.           */
    uint8            src_idx;     /* Entry array action source index.  */
    uint8            dst_idx;     /* Entry array action dest index.    */
    int              rv;          /* Operation return status.          */


    /* Input parameters check */
    if  (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if ((0 == (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) &&
        (f_ent->flags & _FP_ENTRY_POLICER_IN_SECONDARY_SLICE)) {
          rv =
            _bcm_field_entry_flags_to_tcam_part(unit, _FP_ENTRY_SECONDARY,
                                                f_ent->group, &dst_idx);
          BCM_IF_ERROR_RETURN(rv);

          if (to_secondary) {
              src_idx = 0;
          } else {
              src_idx = dst_idx;
              dst_idx = 0;
          }

          /* Copy all but counter action. */
          fa = f_ent[src_idx].actions;
          fa_prev = NULL;
          while (NULL != fa)  {
              fa_next = fa->next;
              /* coverity[always_true_or : FALSE]*/
              if ((fa->action != bcmFieldActionUpdateCounter) ||
                  (fa->action != bcmFieldActionCosQCpuNew)||
                  (fa->action != bcmFieldActionServicePoolIdNew)||
                  (fa->action != bcmFieldActionServicePoolIdPrecedenceNew)) {

                  /* Insert action to the destination slice actions list. */
                  fa->next = f_ent[dst_idx].actions;
                  f_ent[dst_idx].actions = fa;
                  /* Remove action from the primary slice actions list. */
                  if (NULL == fa_prev)  {
                      f_ent[src_idx].actions = fa_next;
                  } else {
                      fa_prev->next = fa_next;
                  }
              } else {
                  fa_prev = fa;
              }
              fa = fa_next;
          }
    }
    return (BCM_E_NONE);
}

/*
 * Function: _field_entry_tcam_remove
 *
 * Purpose:
 *     Remove an entry from the FP tcam.
 *
 * Parameters:
 *     unit     - (IN) BCM device number
 *     fc       - (IN) Field control structure.
 *     f_ent    - (IN) Primary entry pointer.
 *     tcam_idx - (IN) Entry tcam index.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_tcam_remove(int unit, _field_control_t *fc,
                         _field_entry_t *f_ent, int tcam_idx)
{
    int rv;           /* Operation return status. */

    /* Input parameter check. */
    if ((NULL == fc) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }
    /* Remove entry in slice. */
    if (f_ent->fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        rv = fc->functions.fp_external_entry_remove(unit, f_ent);
        BCM_IF_ERROR_RETURN(rv);
    } else {
        rv = fc->functions.fp_entry_remove(unit, f_ent, tcam_idx);
        BCM_IF_ERROR_RETURN(rv);
    }
    return (rv);
}

/*
 * Function:
 *     _field_tcam_policy_reinstall
 *
 * Purpose:
 *     Re-Install a POLICY_TABLE entry. This re-writes the
 *     modified actions to the hardware.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     entry - (IN) Entry to be installed.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_tcam_policy_reinstall(int unit, bcm_field_entry_t entry)
{
    int                 tcam_idx[_FP_MAX_ENTRY_WIDTH]; /* Entry tcam index. */
    int                 parts_count = 0;       /* Field entry parts count.  */
    _field_entry_t      *f_ent;                /* Field entry pointer.      */
    _field_control_t    *fc;                   /* Field control structure.  */
    int                 idx;                   /* Iteration index.          */
    int                 rv;                    /* Operation return status.  */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
    _field_entry_stat_t  *f_ent_st = NULL;     /* Field entry statistics
                                                  structure.                */
    _field_stat_t        *f_st = NULL;         /* Statistics entity
                                                  descriptor.               */
#endif

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
               "FP(unit %d) vverb: _field_tcam_policy_reinstall (%d)\n"),
               unit, entry));


    /* Installing the entry. */
    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get number of parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                            f_ent->group->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize tcam_idx array. */
    sal_memset(tcam_idx, 0, sizeof(tcam_idx));

    /* Get tcam indexes for installed entry. */
    if (f_ent->group->stage_id != _BCM_FIELD_STAGE_EXTERNAL) {
        for (idx = parts_count - 1; idx >=0; idx--) {
            rv = _bcm_field_entry_tcam_idx_get(unit, f_ent + idx,
                                               tcam_idx + idx);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    /* Advanced flex STAT counters reference count handled here. */
    if ((f_ent->flags & _FP_ENTRY_INSTALLED) && 
        (soc_feature(unit, soc_feature_advanced_flex_counter)) &&
         !(soc_feature(unit, soc_feature_field_multi_pipe_support))) {

        for (idx = 0; idx < parts_count; idx++) {
            /* Read existing entry qualifiers from the HW. */
            BCM_IF_ERROR_RETURN
                (_bcm_field_qual_tcam_key_mask_get(unit,
                                                   f_ent + idx));

            if (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id) {
                f_ent_st = &((f_ent + idx)->statistic);
                if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {
                    /* Read stat entity configuration. */
                    BCM_IF_ERROR_RETURN
                        (_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
                    if (f_st->hw_ref_count > 0) {
                        /*
                         * If this is the only entry using this stat, store the stat
                         * values to retain on next attach.
                         */
                        if (1 == f_st->hw_ref_count) {
                            int  i;
                            for (i= 0; i < f_st->nstat; i++) {
                                rv = _field_stat_value_get(unit, 0, f_st,
                                        f_st->stat_arr[i],
                                        f_st->stat_values + i);
                                BCM_IF_ERROR_RETURN(rv);
                            }
                        }
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_stat_flex_detach_ingress_table_counters
                             (unit, VFP_POLICY_TABLEm, tcam_idx[idx]));
                        f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                        f_st->hw_ref_count--;
                    }
                }
            }

            if (_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id) {
                f_ent_st = &((f_ent + idx)->statistic);
                if (f_ent_st->flags & _FP_ENTRY_EXTENDED_STAT_INSTALLED) {
                    /* Read stat entity configuration. */
                    BCM_IF_ERROR_RETURN
                        (_bcm_field_stat_get(unit, f_ent_st->extended_sid, &f_st));
                    if (f_st->hw_ref_count > 0) {
                        /*
                         * If this is the only entry using this stat, store the stat
                         * values to retain on next attach.
                         */
                        if (1 == f_st->hw_ref_count) {
                            int  i;
                            for (i= 0; i < f_st->nstat; i++) {
                                rv = _field_stat_value_get(unit, 0, f_st,
                                        f_st->stat_arr[i],
                                        f_st->stat_values + i);
                                BCM_IF_ERROR_RETURN(rv);
                            }
                        }

                        rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                            (unit, FP_POLICY_TABLEm, tcam_idx[idx]);
                        BCM_IF_ERROR_RETURN(rv);
                        f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_INSTALLED;
                        f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_RESERVED;
                        f_st->hw_ref_count--;
                    }
                }
            }

            if (_BCM_FIELD_STAGE_EGRESS == f_ent->fs->stage_id) {
                f_ent_st = &((f_ent + idx)->statistic);
                if (f_ent_st->flags & _FP_ENTRY_EXTENDED_STAT_INSTALLED) {
                    /* Read stat entity configuration. */
                    BCM_IF_ERROR_RETURN
                        (_bcm_field_stat_get(unit, f_ent_st->extended_sid, &f_st));
                    if (f_st->hw_ref_count > 0) {
                        /*
                         * If this is the only entry using this stat, store the stat
                         * values to retain on next attach.
                         */
                        if (1 == f_st->hw_ref_count) {
                            int  i;
                            for (i= 0; i < f_st->nstat; i++) {
                                rv = _field_stat_value_get(unit, 0, f_st,
                                        f_st->stat_arr[i],
                                        f_st->stat_values + i);
                                BCM_IF_ERROR_RETURN(rv);
                            }
                        }

                        rv = _bcm_esw_stat_flex_detach_egress_table_counters
                            (unit, 0, EFP_POLICY_TABLEm, tcam_idx[idx]);
                        BCM_IF_ERROR_RETURN(rv);
                        f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_INSTALLED;
                        f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_RESERVED;
                        f_st->hw_ref_count--;
                    }
                }
            }
        }
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    /* Advanced flowcnt STAT counters reference count handled here. */
    if ((f_ent->flags & _FP_ENTRY_INSTALLED) &&
        (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id) &&
        (soc_feature(unit, soc_feature_flowcnt))) {

        for (idx = 0; idx < parts_count; idx++) {
            /* Read existing entry qualifiers from the HW. */
            BCM_IF_ERROR_RETURN
                (_bcm_field_qual_tcam_key_mask_get(unit,
                                                   f_ent + idx));

            f_ent_st = &((f_ent + idx)->statistic);
            if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {
                /* Read stat entity configuration. */
                BCM_IF_ERROR_RETURN
                   (_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
                if (f_st->hw_ref_count > 0) {

                    /*
                     * If this is the only entry using this stat, store the stat
                     * values to retain on next attach.
                     */
                    if (1 == f_st->hw_ref_count) {
                        int  i;
                        for (i= 0; i < f_st->nstat; i++) {
                            rv = _field_stat_value_get(unit, 0, f_st,
                                    f_st->stat_arr[i],
                                    f_st->stat_values + i);
                            BCM_IF_ERROR_RETURN(rv);
                        }
                    }

                    BCM_IF_ERROR_RETURN(
                                _bcm_esw_flowcnt_object_table_detach(unit,
                                VFP_POLICY_TABLEm, tcam_idx[idx]));
                    f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                    f_st->hw_ref_count--;
                }
            }

        }
    }
#endif


#if defined(BCM_TOMAHAWK_SUPPORT)
    if ((f_ent->flags & _FP_ENTRY_INSTALLED) &&
         ((_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id) ||
          (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id))&&
         (soc_feature(unit, soc_feature_advanced_flex_counter)) &&
         (soc_feature(unit, soc_feature_field_multi_pipe_support))) {

        f_ent_st = &(f_ent->statistic);
        if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {

            soc_mem_t tcam_mem = INVALIDm;
            soc_mem_t policy_mem = INVALIDm;

            /* Read stat entity configuration. */
            rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
            BCM_IF_ERROR_RETURN(rv);

            if (f_st->hw_ref_count > 0) {

                int policy_idx;

               /* If this is the only entry using this stat, store the stat
                * values to retain on next attach.
                */

                if (0 == (f_st->hw_ref_count - 1)) {
                    for (idx= 0; idx < f_st->nstat; idx++) {
                        rv = _field_stat_value_get(unit, 0, f_st,
                                                   f_st->stat_arr[idx],
                                                   f_st->stat_values + idx);
                        BCM_IF_ERROR_RETURN(rv);
                    }
                }

                /* (Intra Slice) Double Wide/ Triple wide modes, IFP_TCAM_WIDE
                 * have 256 entries but IFP_POLICY_TABLE will have 512 entries.
                 */
                if ((SOC_IS_TOMAHAWKX(unit)) &&
                    (f_ent->fs->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                    (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
                     (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE))) {
                     policy_idx = tcam_idx[0] + (f_ent->fs->slice_number * 256);
                } else {
                     policy_idx = tcam_idx[0];
                }

                rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                                       &tcam_mem, &policy_mem);
                BCM_IF_ERROR_RETURN(rv);


                /* Stats are attached to only first part of multiwide group.
                 * So in calling stat detach for tcam_idx[0] is enough.
                 */
                rv = _bcm_esw_stat_flex_detach_ingress_table_counters(unit,
                                                                    policy_mem,
                                                                    policy_idx);
                BCM_IF_ERROR_RETURN(rv);
                f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                f_st->hw_ref_count--;
            }
        }
    }
#endif

    /* Remove deleted actions. */
    rv = _field_invalid_actions_remove(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate hw resources required for entry installation. */
    rv = _field_hw_resources_alloc(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Move  all actions to the slice where meter resides. */
    rv = _field_entry_actions_meter_slice_move(unit, f_ent, TRUE);
    if (BCM_FAILURE(rv)) {
        BCM_IF_ERROR_RETURN
           (_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE));
        return (rv);
    }

    /*
     * For stages that support global meter pools, meters must be in
     * same slice as counters. Move policer to counter slice if
     * counters are in secondary slice.
     */
    rv = _field_entry_policer_stat_slice_move(unit, f_ent, TRUE);
    if (BCM_FAILURE(rv)) {
        BCM_IF_ERROR_RETURN
            (_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE));
        return (rv);
    }

    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        rv = _field_tcam_policy_external_reinstall(unit, f_ent);
    }  else {
        for (idx = parts_count - 1; idx >=0; idx--) {

            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                       "FP(unit %d) vverb: Part:%x EntryDirty:%x"
                       " ActionOnlyDirty:%x\n"), unit, idx,
                       (f_ent[idx].flags & _FP_ENTRY_DIRTY),
                       (f_ent[idx].flags & _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY)));

            /*
             * For Trident FP_GM_FIELDS.VALID = 1 when used in paired mode
             */
            if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
                && (!soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
                SOC_IS_TD_TT(unit) && (idx == 1) &&
                (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
                f_ent[idx].flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
            }

            /* Get entry tcam key/mask. */
            rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent + idx);
            if (BCM_FAILURE(rv)) {
                break;
            }

            /* Install physical entry into primary slice */
            rv = fc->functions.fp_tcam_policy_reinstall(unit, f_ent + idx,
                                                      tcam_idx[idx]);
            if (BCM_FAILURE(rv)) {
                break;
            }

            f_ent[idx].flags &= ~_FP_ENTRY_DIRTY;
            f_ent[idx].flags &= ~(_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY);

            if(NULL != f_ent[idx].tcam.key) {
                sal_free(f_ent[idx].tcam.key);
            }

            if(NULL != f_ent[idx].tcam.mask) {
                sal_free(f_ent[idx].tcam.mask);
            }

            f_ent[idx].tcam.key = f_ent[idx].tcam.mask = NULL;
        }
    }

    if (BCM_FAILURE(rv)) {
        (void)_field_entry_actions_meter_slice_move(unit, f_ent, FALSE);
        (void)_field_entry_policer_stat_slice_move(unit, f_ent, FALSE);
        (void)_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        return (rv);
    }

    /* Move  all actions back to the primary slice . */
    rv = _field_entry_actions_meter_slice_move(unit, f_ent, FALSE);
    if (BCM_FAILURE(rv)) {
        BCM_IF_ERROR_RETURN
            (_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE));
        return (rv);
    }

    /* Move policers to primary slice. */
    rv = _field_entry_policer_stat_slice_move(unit, f_ent, FALSE);
    if (BCM_FAILURE(rv)) {
        BCM_IF_ERROR_RETURN
            (_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE));
        return (rv);
    }


    /* Remove stale deleted actions. */
    rv = _field_invalid_actions_remove(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* In case of entry reinstall free previous installation hw resources. */
    rv = _field_hw_resources_free(unit, f_ent, _FP_ACTION_OLD_RESOURCE_FREE);
    if (BCM_FAILURE(rv)) {
        BCM_IF_ERROR_RETURN
            (_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE));
        return (rv);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_field_find_free_index_in_slice
 *
 * Purpose:
 *     Find free index near by current entry
 *
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     f_ent_orig     - (IN) Current Entry
 *     direction      - (OUT) Direction in which free index found
 *     free_idx       - (OUT) Found free index
 *
 * Returns:
 *     BCM_E_INTERNAL -> If free count in slice is zero
 *     BCM_E_XXX
 */

STATIC int
_bcm_field_find_free_index_in_slice(int unit, _field_entry_t *f_ent_orig,
        int *direction, uint32 *free_idx)
{
    int iter = 0;
    int idx = 0;

    idx =  f_ent_orig->slice_idx;

    if (0 == f_ent_orig->fs->free_count) {
        return BCM_E_INTERNAL;
    }

    for (iter = 0; iter < f_ent_orig->fs->entry_count; iter++) {
        if (((idx + iter) <=  f_ent_orig->fs->entry_count) &&
                (NULL == f_ent_orig->fs->entries[idx + iter])) {
            *direction = _FP_ENTRY_MOVE_DOWN; /* Found Down side */
            *free_idx = idx + iter;
            break;
        }
        if (((idx - iter) >=  0) &&
                (NULL == f_ent_orig->fs->entries[idx - iter])) {
            *direction = _FP_ENTRY_MOVE_UP; /* Found Up side */
            *free_idx = idx - iter;
            break;
        }
        if (((idx + iter) >=  f_ent_orig->fs->entry_count) && ((idx - iter) <=  0)) {
            break;
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *    _bcm_field_slice_entry_compress
 *
 * Purpose:
 *    Compress slice between Start and End TCAM indices
 *
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     stage_fc       - (IN) Field Stage control structure
 *     fg             - (IN) Field Group structure
 *     start_tcam_idx - (IN) Index with hole towards which
 *                           compress will be done
 *     end_tcam_idx   - (IN) End Index for slice compress
 *     direction      - (IN) direction(UP/DOWN) towards
 *                           which compression will be done
 *     first_free_idx - (OUT) Writes the first found free index
 *                            after compression
 *                            if first_free_idx is not NULL.
 *
 * Returns:
 *     BCM_E_INTERNAL -> If start index is not NULL or end index is NULL
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_slice_entry_compress(int unit, _field_stage_t *stage_fc, _field_group_t *fg,
        int start_tcam_idx, int end_tcam_idx, int direction,
        int *first_free_idx)
{
    int               from_idx = 0;
    int               to_idx = 0;
    int               rv = BCM_E_NONE;
    int               start_idx = 0;
    int               end_idx = 0;
    int               start_slice_numb = 0;
    int               end_slice_numb = 0;
    int               slice_numb = 0;
    int               slice_idx = 0;
    _field_slice_t    *fs = NULL;
    _field_slice_t    *start_fs =  NULL;
    _field_slice_t    *end_fs = NULL;

    if ((NULL == stage_fc) || (NULL == fg)) {
        return BCM_E_PARAM;
    }

    /* Getting starting slice number and starting slice offset */
    rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, fg->instance,
            start_tcam_idx, &start_slice_numb,
            &start_idx);
    BCM_IF_ERROR_RETURN(rv);
    /* Getting end slice number and ending slice offset */
    rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, fg->instance,
            end_tcam_idx, &end_slice_numb,
            &end_idx);
    BCM_IF_ERROR_RETURN(rv);

    start_fs = stage_fc->slices[fg->instance] + start_slice_numb;
    end_fs = stage_fc->slices[fg->instance] + end_slice_numb;

    fs = start_fs;

    /*
     * Entry present in Start index is expected to be NULL as compression
     * may overwrite the existing entry.
     * Entry present in End index is expected to be not NULL as compression
     * ends with end index compressing NULL entry can't be done.
     */
    if ((start_fs->entries[start_idx] != NULL) || (end_fs->entries[end_idx] == NULL)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Wrong index provided to compress \n"),
                 unit));
        return BCM_E_INTERNAL;
    }

    /*************************************************************************************************
      Compression logic explained
      ---------------------------
Direction         :  _FP_ENTRY_MOVE_DOWN
Start TCAm index  :  7
End TCAM idx      :  2

1.
______
|______|1
|______|2 ==> End TCAM index
|______|3
|______|4
|______|5
|______|6
|_NULL_|7 ==> Start TCAM index
|______|8

Entry@6 will be copied to 7.
then entry@5 will be copied to 6.......
and ends with entry@2 copy to 3.
______                ______
|______|1             |______|1
|______|2             |_NULL_|2 ==> first found free index
|______|3             |______|3
|______|4     ....>   |______|4
|______|5     ....>   |______|5
|_NULL_|6             |______|6
|______|7 <--         |______|7
|______|8             |______|8

and first free index will be assigned to 2
if first_free_idx is not NULL ptr.

2.
______
|______|1
|______|2 ==> End TCAM index
|______|3
|_NULL_|4
|_NULL_|5
|______|6
|_NULL_|7 ==> Start TCAM index
|______|8


Entry@6 will be copied to 7.
Entry@5 is NULL and entry@4 is also NULL
so entry@3 will be copied to 6
and then entry@2 is copied to 5.

______                ______
|______|1             |______|1
|______|2             |_NULL_|2
|______|3             |_NULL_|3
|_NULL_|4     ....>   |_NULL_|4 ==> first found free index
|_NULL_|5     ....>   |______|5
|_NULL_|6             |______|6
|______|7 <--         |______|7
|______|8             |______|8

and first free index will be assigned to 4
if first_free_idx is not NULL ptr.

     */
    if (direction == _FP_ENTRY_MOVE_DOWN) {
        /* free index found in down direction slice has to be compressed towards down */
        for (slice_idx = start_idx, to_idx = start_tcam_idx, from_idx = start_tcam_idx - 1;
                from_idx >= end_tcam_idx; from_idx--, slice_idx-- ) {
            if (-1 == slice_idx) {
                rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, fg->instance,
                        from_idx, &slice_numb,
                        &slice_idx);
                BCM_IF_ERROR_RETURN(rv);
                if (slice_numb != fs->slice_number) {
                    /* if compression is across slices end TCAM index will be in previous slice */
                    fs = fs->prev;
                }
            }
            if (NULL == fs->entries[slice_idx]) {
                /* Ignore holes*/
                continue;
            }
            rv = _field_entry_move(unit, fs->entries[slice_idx], (to_idx - from_idx));
            BCM_IF_ERROR_RETURN(rv);
            to_idx--;
        }   /*End of For*/
        if (NULL != first_free_idx) {
            *first_free_idx= to_idx;
        }
    }    else if (direction & _FP_ENTRY_MOVE_UP) {
        /* free index found in up direction slice has to be compressed towards up */
        for (slice_idx = start_idx, to_idx = start_tcam_idx, from_idx = start_tcam_idx + 1;
                from_idx <= end_tcam_idx; from_idx++, slice_idx++ ) {
            if (fs->entry_count == slice_idx) {
                rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, fg->instance,
                        from_idx, &slice_numb,
                        &slice_idx);
                BCM_IF_ERROR_RETURN(rv);
                if (slice_numb != fs->slice_number) {
                    /* if compression is across slices end TCAM index will be in next slice */
                    fs = fs->next;
                }
            }
            if (NULL == fs->entries[slice_idx]) {
                /* Ignore holes*/
                continue;
            }
            rv = _field_entry_move(unit, fs->entries[slice_idx], (to_idx - from_idx));
            BCM_IF_ERROR_RETURN(rv);
            to_idx++;
        }/*End of For*/
        if (NULL != first_free_idx) {
            *first_free_idx= to_idx;
        }
    } else {
        return BCM_E_INTERNAL;
    }
    return BCM_E_NONE;
}
/*
 * Function:
 *     _field_internal_backup_entry_create
 *
 * Purpose:
 *     To achieve hitless update by
 *     creating a temporary entry during
 *     current entry modification.
 *     TCAM and FP_POLICY_TABLEs will be
 *     copied from orginal entry to the
 *     temperary entry and
 *     New Hardware won't be allocated for
 *     Temperary entry.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     entry - (IN) Current Entry
 *     temp_entry - (OUT) Entry to be installed.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_internal_backup_entry_create(int unit, bcm_field_entry_t entry,
                                    bcm_field_entry_t *temp_entry)
{
    int                 rv = BCM_E_NONE;            /* Return Variable */
    int  tcam_idx_orig[_FP_MAX_ENTRY_WIDTH] = {0};  /* Original entry tcam index. */
    int  tcam_idx_temp[_FP_MAX_ENTRY_WIDTH] = {0};  /* temp tcam index for the entry.*/
    int                 idx;
    int                 parts_count = 0;            /* Field entry parts count.  */
    int                 direction = 0;
    int                 free_idx_after_compress = 0;
    int                 start_tcam_idx = 0;
    int                 end_tcam_idx = 0;
    uint32              free_idx = 0;
    uint32              start_idx = 0;
    uint32              end_idx = 0;
    _field_stage_t      *stage_fc = NULL;        /* Stage field control structure */
    _field_control_t    *fc = NULL;              /* Field control structure.      */
    _field_entry_t      *f_ent_temp = NULL;
    _field_entry_t      *f_ent_copy_temp = NULL;
    _field_entry_t      *f_ent_orig = NULL;

    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                        "FP(unit %d) vverb: _field_internal_backup_entry_create (%d)\n"),
             unit, entry));
    /* Check whether entry with INTERNAL_RESERVED_ID is  already present */
    if (BCM_SUCCESS(_field_entry_get(unit, (_FP_INTERNAL_RESERVED_ID),
                    _FP_ENTRY_PRIMARY,
                    &f_ent_temp))) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "Entry _FP_INTERNAL_RESERVED_ID already present"
                            "Unable to create backup entry for entry (%d)\n"),
                 unit, entry));
        return BCM_E_EXISTS;
    }

    /* Get the original entry */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                _FP_ENTRY_PRIMARY,
                &f_ent_orig));

    /* Get field and stage control structures. */
    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_ent_orig->group->stage_id, &stage_fc));

    *temp_entry = (_FP_INTERNAL_RESERVED_ID);
    /* Create backup entry sharing
       the same group with original entry */
    rv = _field_entry_create_id (unit,
            f_ent_orig->group->gid,
            *temp_entry);
    /* Fall back to old method if new entry has no space */
    if (BCM_FAILURE(rv)) {
        if ((rv == BCM_E_RESOURCE) && ((soc_property_get(unit,
                            spn_FIELD_ATOMIC_UPDATE, FALSE) == TRUE))) {
            return rv;
        }
        goto fallback;
    }

    rv = _field_entry_prio_set(unit, *temp_entry, f_ent_orig->prio);
    if (BCM_FAILURE(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "Unable to create backup entry for entry (%d)"
                            "Entry prio set failed with error %d \n"),
                 unit, entry, rv));
        goto fallback;
    }
    /* Get created backup entry*/
    rv =  _field_entry_get(unit, *temp_entry,
            _FP_ENTRY_PRIMARY,
            &f_ent_temp);
    if (BCM_FAILURE(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "Unable to create backup entry for entry (%d)"
                            "backup entry get failed with error %d \n"),
                 unit, entry, rv));
        rv = BCM_E_INTERNAL;
        goto fallback;
    }
    /* Get number of parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent_orig->group->stage_id,
            f_ent_orig->group->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "Unable to create backup entry for entry (%d)"
                            "Getting Parts count for original entry failed with error : %d"),
                 unit, entry, rv));
        rv = BCM_E_INTERNAL;
        goto fallback;
    }
    /* backup entry and original entry entry are not in same slice*/
    if (f_ent_orig->fs->slice_number != f_ent_temp->fs->slice_number) {
        /* Check for the global Policers and Statistics associated with the entry. */
        /* Global policer and Installed ||  Global Stats and installed */
        if(((0 == (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) &&
                    ((f_ent_orig->policer[0].flags & _FP_POLICER_INSTALLED) ||
                     (f_ent_orig->policer[1].flags & _FP_POLICER_INSTALLED))) ||
                ((0 == ((stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS) ||
                        (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS))) &&
                 (f_ent_orig->statistic.flags & _FP_ENTRY_STAT_INSTALLED))) {
            if (0 == f_ent_orig->fs->free_count) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "No free space in original entry slice\n"),
                         unit, entry));
                rv = BCM_E_CONFIG;
                goto fallback;
            }

            /* Find the nearest free index to the original entry and direction */
            rv = _bcm_field_find_free_index_in_slice (unit, f_ent_orig, &direction, &free_idx);
            if (BCM_FAILURE(rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "Finding free idx failed with error : %d\n"),
                         unit, entry, rv));
                rv = BCM_E_INTERNAL;
                goto fallback;
            }

            start_idx = free_idx;
            /*
             * keep the orginal entry stable and move in between entries
             * from free index and original entry index
             */
            end_idx = (_FP_ENTRY_MOVE_UP == direction) ?
                (f_ent_orig->slice_idx - 1) :
                (f_ent_orig->slice_idx + 1);
            /* Get Start TCAM index based on start slice offset */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                    f_ent_orig->group->instance,
                    f_ent_orig->fs->slice_number,
                    start_idx, &start_tcam_idx);
            if (BCM_FAILURE(rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "slice compress failed with error %d \n"),
                         unit, entry, rv));
                rv = BCM_E_INTERNAL;
                goto fallback;
            }
            /* Get end TCAM index based on end slice offset */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                    f_ent_orig->group->instance,
                    f_ent_orig->fs->slice_number,
                    end_idx, &end_tcam_idx);
            if (BCM_FAILURE(rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "slice compress failed with error %d \n"),
                         unit, entry, rv));
                rv = BCM_E_INTERNAL;
                goto fallback;
            }
            /* Compress slice towards the free index and make hole near by original entry*/
            rv = _bcm_field_slice_entry_compress (unit, stage_fc, f_ent_orig->group,
                    start_tcam_idx, end_tcam_idx, direction,
                    &free_idx_after_compress);
            if (BCM_FAILURE(rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "slice compress failed with error %d \n"),
                         unit, entry, rv));
                rv = BCM_E_INTERNAL;
                goto fallback;
            }
            /* change slice index of backup entry to the free slice index after compress */
            rv = _field_entry_slice_idx_change (unit, f_ent_temp, parts_count,
                    &free_idx_after_compress);
            if (BCM_FAILURE(rv)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: "
                                    "Unable to create backup entry for entry (%d)"
                                    "backup entry slice idx change to the found "
                                    "free idx failed with error %d \n"),
                         unit, entry, rv));
                rv = BCM_E_INTERNAL;
                goto fallback;
            }
        }
    }
    /* Calculate the new and old TCAM indexes. */
    for (idx = 0; idx < parts_count; idx++) {
        /* Calculate the new and old TCAM indexes. */
        rv = _bcm_field_entry_tcam_idx_get(unit, f_ent_orig + idx,
                &tcam_idx_orig[idx]);
        if (BCM_FAILURE(rv)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: "
                                "Unable to create backup entry for entry (%d)"
                                "TCAM index get for orig entry failed with error %d \n"),
                     unit, entry, rv));
            rv = BCM_E_INTERNAL;
            goto fallback;
        }
        rv = _bcm_field_entry_tcam_idx_get(unit, f_ent_temp + idx,
                &tcam_idx_temp[idx]);
        if (BCM_FAILURE(rv)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: "
                                "Unable to create backup entry for entry (%d)"
                                "TCAM index get for backup entry failed with error %d \n"),
                     unit, entry, rv));
            rv = BCM_E_INTERNAL;
            goto fallback;
        }
    }
    /* store orginal entry's ent_copy*/
    f_ent_copy_temp = f_ent_orig->ent_copy;
    /*
     * Assign backup entry to the ent_copy as fp_entry_move
     * should not clear FP_TCAM and FP_POLICY_TABLE of original entry
     */
    f_ent_orig->ent_copy = f_ent_temp;

    rv = fc->functions.fp_entry_move(unit, f_ent_orig, parts_count,
            tcam_idx_orig, tcam_idx_temp);
    if (BCM_FAILURE(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "Unable to create backup entry for entry (%d)"
                            "hw entry move failed with error %d \n"),
                 unit, entry, rv));
        rv = BCM_E_INTERNAL;
    }

    f_ent_temp->flags |= _FP_ENTRY_INSTALLED;
    f_ent_temp->flags |= _FP_ENTRY_ENABLED;
    f_ent_orig->ent_copy = f_ent_copy_temp;

fallback:
    /*Common cleanup for the method */
    if (BCM_FAILURE(rv)) {
        /* Remove the created backup entry upon failure */
        BCM_IF_ERROR_RETURN(_field_internal_backup_entry_delete(unit, *temp_entry));

        if (BCM_E_INTERNAL == rv) {
            return rv;
        }

        /* Fall back to old method */
        if (soc_property_get(unit,
                    spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: "
                                "Unable to create backup entry for entry (%d)"
                                "Falling back to old method \n"),
                     unit, entry));
            rv = BCM_E_NONE;
            *temp_entry = _FP_INVALID_INDEX;
        }
        return rv;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_internal_backup_entry_delete
 *
 * Purpose:
 *     Delete temporary entry created during
 *     current entry modification
 *     to achieve hitless update.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     temp_entry - (IN) Entry to be installed.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_internal_backup_entry_delete(int unit, bcm_field_entry_t temp_entry)
{
    int                 rv = BCM_E_NONE;        /* Return Variable */
    _field_entry_t      *f_ent_check = NULL ;   /* Field entry pointer */

    if (BCM_SUCCESS(_field_entry_get(unit, temp_entry, _FP_ENTRY_PRIMARY,
                    &f_ent_check))) {
        rv = bcm_esw_field_entry_destroy(unit, temp_entry);
    }
    return (rv);
}

/*
 * Function:
 *  _bcm_field_meter_rate_burst_calculate
 *
 * Purpose:
 *  Calculate rate and burst of the meter based on
 *  granularity, refresh_rate and bucket size.
 *
 * Parameters:
 *  unit  - (IN) BCM device number.
 *  meter_mem - (IN) Meter table to read
 *  meter_hw_idx - (IN) Index in the meter table
 *  flags - (IN) Policer flags.
 *  prate - (OUT) Policer rate calculated
 *  pburst - (OUT) Policer burst calculated
 *
 * Returns:
 * BCM_E_XXX
 */
STATIC int
_bcm_field_meter_rate_burst_calculate (uint32 unit,
        soc_mem_t meter_mem,
        uint32 meter_hw_idx,
        uint32 *prate,
        uint32 *pburst,
        uint32 flags
        )
{
    uint32 ent[SOC_MAX_MEM_FIELD_WORDS];    /* HW entry buffer.         */
    uint32 refresh_rate = 0;                /* Policer refresh rate.    */
    uint32 granularity = 0;                 /* Policer granularity.     */
    uint32 bucket_max = 0;                  /* Bucket size.             */

    BCM_IF_ERROR_RETURN(soc_mem_read(unit, meter_mem, MEM_BLOCK_ANY,
                meter_hw_idx, ent));

    refresh_rate = soc_mem_field32_get(unit, meter_mem, ent, REFRESHCOUNTf);
    granularity = soc_mem_field32_get(unit, meter_mem, ent, METER_GRANf);
    bucket_max = soc_mem_field32_get(unit, meter_mem, ent, BUCKETSIZEf);

    BCM_IF_ERROR_RETURN(_bcm_xgs_bucket_encoding_to_kbits
            (refresh_rate, bucket_max, granularity, flags,
             prate, pburst));

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_entry_policer_update_actual_hw_rates
 *
 * Purpose:
 *     Update actual hardware rates for committed packet rate
 *     and burst size and peak packet rate and burst size in
 *     the internal policer structure.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     policer_mem - (IN) Meter table name.
 *     instance - (IN) FP instance
 *     f_ent   - (IN) Entry policer belongs to.
 *     f_pl - (IN) Field policer descriptor.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_policer_update_actual_hw_rates(int unit, soc_mem_t policer_mem,
        int instance, _field_entry_t *f_ent, _field_policer_t *f_pl)
{
    uint32  flags;                          /* Policer flags.           */
    _field_stage_t *stage_fc;               /* Field stage information. */
    int meter_hw_idx;                       /* Meter table index.       */
    int rv = BCM_E_NONE;                    /* Operation return status. */
    soc_mem_t   meter_mem = policer_mem;    /* Meter table name.        */
    int meter_offset = 0;                   /* Odd or even meter.       */
    _field_stage_id_t      stage_id;        /* StageId used for metering*/

    if ((f_pl == NULL) || (f_ent == NULL)) {
        return BCM_E_PARAM;
    }

    if (meter_mem == INVALIDm) {
        return BCM_E_PARAM;
    }

    stage_id = ((_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ||
                (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id)) ? \
               _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

    /* Get stage control */
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (f_pl->cfg.mode == bcmPolicerModeCommitted) {
        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            meter_offset = 0;
        }
        else {
            meter_offset = 1;
        }
    }

    /* Calculate hardware meter index. */
    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /*
         * Hw index is:
         * ((Pool number * pool_size) + (2 * pair number)
         */
        meter_hw_idx = (f_pl->pool_index *
                stage_fc->meter_pool[instance][f_pl->pool_index]->size)
            + (2 * f_pl->hw_index) + meter_offset;
    } else {
        /*
         * Hw index is:
         * (slice index) + (2 * pair number)
         */
        meter_hw_idx =
            stage_fc->slices[instance][f_pl->pool_index].start_tcam_idx
            + (2 * f_pl->hw_index) + meter_offset;
    }

    /* lookup bucket size from tables */
    flags = _BCM_XGS_METER_FLAG_GRANULARITY | _BCM_XGS_METER_FLAG_FP_POLICER;

    /* TD2 has change in granularity calculation */
    if ((SOC_IS_TD2_TT2(unit)) &&
        (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS)) {
        flags = flags | _BCM_XGS_METER_FLAG_FP_TD2_POLICER;
    }

    /* Set packet mode flags setting */
    if (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) {
        flags |= _BCM_XGS_METER_FLAG_PACKET_MODE;
    } else {
        flags &= ~_BCM_XGS_METER_FLAG_PACKET_MODE;
    }

    f_pl->cfg.actual_ckbits_sec = 0;
    f_pl->cfg.actual_ckbits_burst = 0;
    f_pl->cfg.actual_pkbits_sec = 0;
    f_pl->cfg.actual_pkbits_burst = 0;

    if ((f_pl->cfg.mode == bcmPolicerModeTrTcmDs) ||
        (f_pl->cfg.mode == bcmPolicerModeTrTcm) ||
        (f_pl->cfg.mode == bcmPolicerModeSrTcm) ||
        (f_pl->cfg.mode == bcmPolicerModeSrTcmTsn) ||
        (f_pl->cfg.mode == bcmPolicerModeSrTcmModified) ||
        (f_pl->cfg.mode == bcmPolicerModeCoupledTrTcmDs)){
        _bcm_field_meter_rate_burst_calculate(unit, meter_mem,
                meter_hw_idx, &f_pl->cfg.actual_pkbits_sec,
                &f_pl->cfg.actual_pkbits_burst, flags);
        _bcm_field_meter_rate_burst_calculate(unit, meter_mem,
                meter_hw_idx + 1, &f_pl->cfg.actual_ckbits_sec,
                &f_pl->cfg.actual_ckbits_burst, flags);
    }
    else {
        _bcm_field_meter_rate_burst_calculate(unit, meter_mem,
                meter_hw_idx, &f_pl->cfg.actual_ckbits_sec,
                &f_pl->cfg.actual_ckbits_burst, flags);
    }

    /* In Tomahawk EFP metering, Refresh tick duration has changed from
     * 7.8125us to 15.625us ,but the RTL does not double the REFRESHCOUNT
     * while putting the tokens into the bucket which is causing 50% lesser
     * traffic rate than expected. So the work around is the value programmed
     * from software in EFP meters needs to be doubled.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id)) {
        f_pl->cfg.actual_ckbits_sec = (f_pl->cfg.actual_ckbits_sec / 2) ;
        f_pl->cfg.actual_pkbits_sec = (f_pl->cfg.actual_pkbits_sec / 2) ;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_tcam_policy_install
 *
 * Purpose:
 *     Install a combined TCAM and POLICY_TABLE entry. This writes the
 *     qualifiers and actions to the hardware.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     entry - (IN) Entry to be installed.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_tcam_policy_install(int unit, bcm_field_entry_t entry)
{
    int                 tcam_idx[_FP_MAX_ENTRY_WIDTH]; /* Entry tcam index. */
    int                 parts_count = 0;       /* Field entry parts count.  */
    _field_entry_t      *f_ent;                /* Field entry pointer.      */
    _field_control_t    *fc;                   /* Field control structure.  */
    int                 idx;                   /* Iteration index.          */
    int                 rv;                    /* Operation return status.  */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
    _field_entry_stat_t  *f_ent_st=NULL; /* Field entry statistics structure. */
    _field_stat_t        *f_st=NULL;     /* Statistics entity descriptor.     */
#endif
    bcm_field_entry_t    temp_entry = _FP_INVALID_INDEX;
                                         /* Entry id for internal backup entry*/
    int slice_count = 0;                 /* count of slices attached to group */
    int slice_count_updated = 0;         /* count of slices attached to group
                                            after internal backup entry */
    _field_slice_t *fs = NULL;           /* Field Slice Structure */

    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                        "FP(unit %d) vverb: bcm_field_policy_install (%d)\n"),
             unit, entry));

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Installing the entry. */
    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRX_SUPPORT)
    if (BCM_FIELD_QSET_TEST(f_ent->group->qset, bcmFieldQualifyInPorts) &&
            (!soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
            (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {

        /*
         * Re-Check whether InPorts has ports other than fg->pbmp
         * To confirm existing ports from fg->pbmp were not removed
         * using bcm_field_group_ports_remove.
         */
        bcm_pbmp_t temp_pbm;

        BCM_PBMP_ASSIGN(temp_pbm, f_ent->pbmp.data);
        BCM_PBMP_OR(temp_pbm, f_ent->group->pbmp);
        if (BCM_PBMP_NEQ(temp_pbm, f_ent->group->pbmp)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Field qualifier InPorts "
                              "in an entry with eid :%d "
                              "has been qualified with the ports which are not"
                              " part of its group pbmp with gid : %d \n"),
                               unit, f_ent->eid, f_ent->group->gid));
            return BCM_E_CONFIG;
        }
    }
#endif

    /* Get number of parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
            f_ent->group->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize tcam_idx array. */
    sal_memset(tcam_idx, 0, sizeof(tcam_idx));

    /* Get tcam indexes for installed entry. */
    if ((f_ent->group->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
            (f_ent->group->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {
        for (idx = parts_count - 1; idx >=0; idx--) {
            rv = _bcm_field_entry_tcam_idx_get(unit, f_ent + idx,
                    tcam_idx + idx);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    /* If entry was previously installed, we better disable it temporarily,
     * to avoid intermittent actions.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if ((f_ent->flags & _FP_ENTRY_INSTALLED) &&
            ((_BCM_FIELD_STAGE_INGRESS == f_ent->fs->stage_id) ||
             (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id) ||
             (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->fs->stage_id)) &&
            (soc_feature(unit, soc_feature_advanced_flex_counter)) &&
            (soc_feature(unit, soc_feature_field_multi_pipe_support))) {

        f_ent_st = &(f_ent->statistic);
        if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {

            soc_mem_t tcam_mem = INVALIDm;
            soc_mem_t policy_mem = INVALIDm;

            /* Read stat entity configuration. */
            rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
            BCM_IF_ERROR_RETURN(rv);

            if (f_st->hw_ref_count > 0) {

                int policy_idx;

                /* If this is the only entry using this stat, store the stat
                 * values to retain on next attach.
                 */

                if (0 == (f_st->hw_ref_count - 1)) {
                    for (idx= 0; idx < f_st->nstat; idx++) {
                        rv = _field_stat_value_get(unit, 0, f_st,
                                f_st->stat_arr[idx],
                                f_st->stat_values + idx);
                        BCM_IF_ERROR_RETURN(rv);
                    }
                }

                /* (Intra Slice) Double Wide/ Triple wide modes,
                 * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE
                 * will have 512 entries.
                 */

                if (!soc_feature(unit, soc_feature_td3_style_fp) && 
                        (f_ent->fs->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                        (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
                         (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE))) {
                    policy_idx = tcam_idx[0] + (f_ent->fs->slice_number * 256);
                } else {
                    policy_idx = tcam_idx[0];
                }

                rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                        &tcam_mem, &policy_mem);
                BCM_IF_ERROR_RETURN(rv);
                /* Stats are attached to only first part of multiwide group.
                 * So in calling stat detach for tcam_idx[0] is enough.
                 */
                if (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->fs->stage_id) {
                    rv = _bcm_esw_stat_flex_detach_ingress_table_counters_sw(
                            unit,
                            tcam_mem, 0,
                            f_st->hw_mode,
                            f_st->hw_index,
                            f_st->pool_index);
                } else {
                    rv = _bcm_esw_stat_flex_detach_ingress_table_counters(unit,
                            policy_mem,
                            policy_idx);
                }
                BCM_IF_ERROR_RETURN(rv);
                f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                f_st->hw_ref_count--;
            }
        }
    }
#endif

    /* If entry was previously installed, we better disable it temporarily,
     * to avoid intermittent actions.
     */
    if (f_ent->flags & _FP_ENTRY_INSTALLED) {
        int temp_entry_set = 0;
        for (idx = 0; idx < parts_count; idx++) {
            /* Read existing entry qualifiers from the HW. */
            rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent + idx);
            if (BCM_FAILURE(rv)) {
                goto backup_clean;
            }
            /* internal backup entry installed temporarily */
            if ((soc_feature(unit,
                            soc_feature_field_tcam_hitless_update_on_modify)) &&
                    (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
                    (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {

                fs = f_ent->group->slices;
                while(fs->next != NULL) {
                    slice_count++;
                    fs = fs->next;
                }

                if (idx == 0) {
                    rv = _field_internal_backup_entry_create(unit,f_ent->eid,
                            &temp_entry);
                    BCM_IF_ERROR_RETURN(rv);
                    temp_entry_set = 1;
                }
                /* Prio set may change the TCAM idx of f_ent
                   Getting new TCAM idx after bacup entry create*/
                if (temp_entry_set == 1) {
                    rv = _bcm_field_entry_tcam_idx_get(unit, f_ent + idx,
                            tcam_idx + idx);
                    if (BCM_FAILURE(rv)) {
                        goto backup_clean;
                    }
                }

                fs = f_ent->group->slices;
                while(fs->next != NULL) {
                    slice_count_updated++;
                    fs = fs->next;
                }
            }
#if ((defined(BCM_KATANA_SUPPORT)) || (defined(BCM_TRIUMPH3_SUPPORT)))
            if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
                int sid = -1;

                f_ent_st = &((f_ent + idx)->statistic);
                if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {
                    if (f_ent->fs->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
                        sid = f_ent_st->sid;
                    }
                } else if(f_ent_st->flags & _FP_ENTRY_EXTENDED_STAT_INSTALLED) {
                    sid = f_ent_st->extended_sid;
                }

                if (sid != -1) {
                    /* Read stat entity configuration. */
                    rv = _bcm_field_stat_get(unit, sid, &f_st);
                    if (BCM_FAILURE(rv)) {
                        goto backup_clean;
                    }
                    if (f_st->hw_ref_count > 0) {
                        soc_mem_t policy_mem = INVALIDm;
                        /*
                         * If this is the only entry using this stat, store the stat
                         * values to retain on next attach.
                         */
                        if (1 == f_st->hw_ref_count) {
                            int  i;
                            for (i= 0; i < f_st->nstat; i++) {
                                rv = _field_stat_value_get(unit, 0, f_st,
                                        f_st->stat_arr[i],
                                        f_st->stat_values + i);
                                if (BCM_FAILURE(rv)) {
                                    goto backup_clean;
                                }
                            }
                        }
                        switch (f_ent->fs->stage_id) {
                            case _BCM_FIELD_STAGE_LOOKUP:
                            case _BCM_FIELD_STAGE_INGRESS:
                                policy_mem =
                                    (f_ent->fs->stage_id == _BCM_FIELD_STAGE_LOOKUP)
                                    ? VFP_POLICY_TABLEm : FP_POLICY_TABLEm;
                                rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                                    (unit, policy_mem, tcam_idx[idx]);
                                if (BCM_FAILURE(rv)) {
                                    goto backup_clean;
                                }
                                break;
                            case _BCM_FIELD_STAGE_EGRESS:
                                policy_mem = EFP_POLICY_TABLEm;
                                rv = _bcm_esw_stat_flex_detach_egress_table_counters
                                    (unit, 0, policy_mem, tcam_idx[idx]);
                                if (BCM_FAILURE(rv)) {
                                    goto backup_clean;
                                }
                                break;
                            default:
                                rv = BCM_E_INTERNAL;
                                goto backup_clean;
                                break;
                        }

                        if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {
                            f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                        } else {
                            f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_INSTALLED;
                            f_ent_st->flags &= ~_FP_ENTRY_EXTENDED_STAT_RESERVED;
                        }
                        f_st->hw_ref_count--;
                    }
                }
            }
#endif


#if defined(BCM_HURRICANE3_SUPPORT)
            if (soc_feature(unit, soc_feature_flowcnt)) {
                if (_BCM_FIELD_STAGE_LOOKUP == f_ent->fs->stage_id) {
                    f_ent_st = &((f_ent + idx)->statistic);
                    if (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED) {
                        /* Read stat entity configuration. */
                        rv = _bcm_field_stat_get(unit, f_ent_st->sid, &f_st);
                        if (BCM_FAILURE(rv)) {
                            goto backup_clean;
                        }
                        if (f_st->hw_ref_count > 0) {
                            /* Disable VLAN Flow counter */
                            rv = _bcm_esw_flowcnt_object_table_detach(unit,
                                    VFP_POLICY_TABLEm, tcam_idx[idx]);
                            if (BCM_FAILURE(rv)) {
                                goto backup_clean;
                            }
                            f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;
                            f_st->hw_ref_count--;
                        }
                    }
                }
            }
#endif /* BCM_HURRICANE3_SUPPORT */
            /* Disable installed entry. */
            rv = _field_entry_tcam_remove(unit, fc, f_ent + idx, tcam_idx[idx]);
            if (BCM_FAILURE(rv)) {
                goto backup_clean;
            }
        }
    }

    /* Remove deleted actions. */
    rv = _field_invalid_actions_remove(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        goto backup_clean;
    }

    /* Allocate hw resources required for entry installation. */
    rv = _field_hw_resources_alloc(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        goto backup_clean;
    }

    /* Move  all actions to the slice where meter resides. */
    rv = _field_entry_actions_meter_slice_move(unit, f_ent, TRUE);
    if (BCM_FAILURE(rv)) {
        (void) _field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        goto backup_clean;
    }

    /*
     * For stages that support global meter pools, meters must be in
     * same slice as counters. Move policer to counter slice if
     * counters are in secondary slice.
     */
    rv = _field_entry_policer_stat_slice_move(unit, f_ent, TRUE);
    if (BCM_FAILURE(rv)) {
        (void) _field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        goto backup_clean;
    }

    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        rv = _field_tcam_policy_external_install(unit, f_ent);
    } else if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
#if defined (BCM_TOMAHAWK_SUPPORT)
        rv = _field_th_em_entry_install(unit, f_ent);
#endif
    } else {
        for (idx = parts_count - 1; idx >=0; idx--) {
            /*
             * For Trident FP_GM_FIELDS.VALID = 1 when used in paired mode
             */
            if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
                    && (!soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
                    SOC_IS_TD_TT(unit) && (idx == 1) &&
                    (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
                f_ent[idx].flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
            }

            /* Get entry tcam key/mask. */
            rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent + idx);
            if (BCM_FAILURE(rv)) {
                break;
            }

#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TD2_TT2(unit) &&
                    (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
                rv = fc->functions.fp_egress_key_match_type_set(unit,
                        f_ent + idx);
                if (BCM_FAILURE(rv)) {
                    break;
                }
            }
#endif

            /* Install physical entry into primary slice */
            rv = fc->functions.fp_tcam_policy_install(unit, f_ent + idx,
                    tcam_idx[idx]);
            if (BCM_FAILURE(rv)) {
                break;
            }
            f_ent[idx].flags &= ~_FP_ENTRY_DIRTY;
            f_ent[idx].flags |= _FP_ENTRY_INSTALLED;
            f_ent[idx].flags |= _FP_ENTRY_ENABLED;
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TD2_TT2(unit) &&
                    (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)){
                if (NULL != f_ent[idx].key_match_tcam.key) {
                    sal_free(f_ent[idx].key_match_tcam.key);
                }
                if (NULL != f_ent[idx].key_match_tcam.mask) {
                    sal_free(f_ent[idx].key_match_tcam.mask);
                }
                f_ent[idx].key_match_tcam.key = f_ent[idx].key_match_tcam.mask = NULL;
            }
#endif
            {
                if(NULL != f_ent[idx].tcam.key) sal_free(f_ent[idx].tcam.key);
                if(NULL != f_ent[idx].tcam.mask) sal_free(f_ent[idx].tcam.mask);
                f_ent[idx].tcam.key = f_ent[idx].tcam.mask = NULL;
            }
        }
    }

    if (BCM_FAILURE(rv)) {
        (void)_field_entry_actions_meter_slice_move(unit, f_ent, FALSE);
        (void)_field_entry_policer_stat_slice_move(unit, f_ent, FALSE);
        (void)_field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        /*  internal backup entry removed */
        goto backup_clean;
    }

    /*  internal backup entry removed */
    if ((soc_feature(unit, soc_feature_field_tcam_hitless_update_on_modify)) &&
            (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
            (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {
        rv = _field_internal_backup_entry_delete(unit, temp_entry);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Move  all actions back to the primary slice . */
    rv = _field_entry_actions_meter_slice_move(unit, f_ent, FALSE);
    if (BCM_FAILURE(rv)) {
        (void) _field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        goto backup_clean;
    }

    /* Move policers to primary slice. */
    rv = _field_entry_policer_stat_slice_move(unit, f_ent, FALSE);
    if (BCM_FAILURE(rv)) {
        (void) _field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        goto backup_clean;
    }


    /* Remove stale deleted actions. */
    rv = _field_invalid_actions_remove(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        goto backup_clean;
    }
    BCM_IF_ERROR_RETURN(rv);

    /* In case of entry reinstall free previous installation hw resources. */
    rv = _field_hw_resources_free(unit, f_ent, _FP_ACTION_OLD_RESOURCE_FREE);
    if (BCM_FAILURE(rv)) {
        (void) _field_hw_resources_free(unit, f_ent, _FP_ACTION_HW_FREE);
        goto backup_clean;
    }

backup_clean:
    if (BCM_FAILURE(rv)) {
        if ((soc_feature(unit, soc_feature_field_tcam_hitless_update_on_modify)) &&
                (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXTERNAL) &&
                (f_ent->fs->stage_id != _BCM_FIELD_STAGE_EXACTMATCH)) {
            BCM_IF_ERROR_RETURN(_field_internal_backup_entry_delete(unit, temp_entry));
        }
        /* Returning failure error */
        return (rv);
    }
    return (BCM_E_NONE);
}




/*
 * Function: _field_entry_remove
 *
 * Purpose:
 *     Remove an entry from the hardware tables.
 *
 * Parameters:
 *     unit  - (IN) BCM device number
 *     fc    - (IN) Field control structure.
 *     entry - (IN) Entry to remove.
 *
 * Returns:
 *     BCM_E_XXX
 */
    int
_field_entry_remove(int unit, _field_control_t *fc, bcm_field_entry_t entry)
{
    _field_entry_t      *f_ent;      /* Field entry pointer.     */
    int                 tcam_idx;    /* Entry tcam index.        */
    int                 parts_count = 0; /* Entry parts count.       */
    int                 idx;         /* Iteration index.         */
    int                 rv;          /* Operation return status. */
    _field_action_t     *fa;

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                (_BCM_FIELD_STAGE_CLASS == f_ent->group->stage_id)) {
        rv = _bcm_field_th_class_entry_remove(unit, entry);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
        /* Entry not installed in hardware to perform remove operation. */
        return (BCM_E_NONE);
    }

    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
        /* Disable the Entry. */
        BCM_IF_ERROR_RETURN(bcm_esw_field_entry_enable_set(unit, entry, 0));
    }

    /* Free hw resources allocated during entry installation. */
    rv = _field_resources_free(unit, f_ent,
            _FP_ACTION_RESOURCE_FREE | _FP_ACTION_POLICER_SW_UPDATE);
    BCM_IF_ERROR_RETURN(rv);

    /* Get number of parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                            f_ent->group->flags, &parts_count);

    for (idx = 0; idx < parts_count; idx++) {
        /* Store entry in S/W before removing from H/W */
        rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent + idx);
        BCM_IF_ERROR_RETURN(rv);

        /* Get entry tcam index. */
        rv = _bcm_field_entry_tcam_idx_get(unit, f_ent + idx, &tcam_idx);
        BCM_IF_ERROR_RETURN(rv);

        /* Remove entry in slice. */

        rv = _field_entry_tcam_remove(unit, fc, f_ent + idx, tcam_idx);
        BCM_IF_ERROR_RETURN(rv);

        f_ent[idx].flags |= _FP_ENTRY_DIRTY;
        f_ent[idx].flags &= ~_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        f_ent[idx].flags &= ~_FP_ENTRY_INSTALLED;
        f_ent[idx].flags &= ~_FP_ENTRY_ENABLED;
    }

    /* Free policers. */
    rv = _field_policers_hw_free(unit, f_ent,
			_FP_ACTION_RESOURCE_FREE|_FP_ACTION_POLICER_SW_UPDATE);
    BCM_IF_ERROR_RETURN(rv);

    /* Remove deleted actions. */
    rv = _field_invalid_actions_remove(unit, f_ent);
    BCM_IF_ERROR_RETURN(rv);
    for (fa = f_ent->actions; (NULL != fa) && (fa->flags & _FP_ACTION_VALID); fa = fa->next) {
        fa->flags |= _FP_ACTION_DIRTY;
    }
    return (BCM_E_NONE);
}


/* Function: _field_reqd_prio_set_move
 *
 * Purpose: Checks if the entry needs to be moved due to prio set
 *
 * Parameters:
 *   unit -
 *   f_ent - Entry whose priority is being set
 *   prio - The new priority for f_ent
 *
 * Returns:
 *   TRUE/FALSE
 */
int
_field_reqd_prio_set_move(int unit, _field_entry_t *f_ent, int prio)
{
    _field_group_t *fg;
    _field_slice_t *fs;
    _field_stage_t *stage_fc;
    int slice_sz;

    int i, flag; /* flag denotes is we are before OR after f_ent */

    fg = f_ent->group;

    /* Get stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, fg->stage_id, &stage_fc));

    fs = &fg->slices[0];
    flag = -1; /* We are before f_ent */
    while (fs != NULL) {
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        for (i = 0; i < slice_sz; i++) {
            if (fs->entries[i] == f_ent) {
                flag = 1; /* Now, we are after f_ent */
                continue;
            }
            if (fs->entries[i] == NULL) {
                continue;
            }
            if (flag == -1) {
                if (_field_entry_prio_cmp(fs->entries[i]->prio, prio) < 0) {
                    /*
                     * An entry before f_ent has lower priority than prio
                     *     Movement is required
                     */
                    return TRUE;
                }
            } else {
                if (_field_entry_prio_cmp(fs->entries[i]->prio, prio) > 0) {
                    /*
                     * An entry after f_ent has higher priority than prio
                     *     Movement is required
                     */
                    return TRUE;
                }
            }
        }
        fs = fs->next;
    }
    return FALSE; /* f_ent with new prio is in proper location */
}

/*
 * Function: _field_entry_multiple_slice_move_check
 *
 * Purpose: Checks if a series of entries can be shifted to the
 *          nearest hole and returns how many entries would end up
 *          being shifted.
 *
 *          This function is called recursively for each slice in
 *          which entries need to be shifted.
 *
 * Parameters:
 *   unit - unit
 *   fg - The group to which the slices belong
 *   entry - Pointer to the entry which is being moved
 *   null_index - Index of the next empty slot within its slice, in the
 *                specified direction
 *   null_fs - Pointer to the next slice with an empty slot, in the
 *             specified direction
 *   target_index - Index of the slot in which we want to insert the entry
 *   target_fs - Pointer to the slice in which we want to insert the entry
 *   direction - The direction in which we're checking entry shifting
 *               feasibility; -1 for up or 1 for down
 *   shifted_entry_count (IN/OUT) - The number of entries that would be shifted
 *                               to make the move possible
 *   freed_counter_count (IN/OUT) - The number of counters that would be freed
 *                               by the shift
 *
 * Returs:
 *   BCM_E_NONE if the move can be done
 */

STATIC int _field_entry_multiple_slice_move_check(int unit,
    _field_group_t *fg, _field_entry_t *entry, int null_index,
    _field_slice_t *null_fs, int target_index, _field_slice_t *target_fs,
    int direction, int *shifted_entry_count, int *freed_meter_count,
    int *freed_counter_count)
{
    int rv = BCM_E_NONE;
    _field_stage_t *stage_fc;
    _field_slice_t *adjacent_fs;
    int adjacent_index;
    int slice_entry_count;
    int adjacent_slice_entry_count;
    _field_entry_t *entry_to_move;

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, target_fs->stage_id, &stage_fc));

    _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, target_fs, slice_entry_count);

    if (target_fs != null_fs)
    {
        if (direction < 0)
        {
            /* Shift up */

            adjacent_fs = target_fs->prev;

            _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, adjacent_fs,
                adjacent_slice_entry_count);

            adjacent_index = adjacent_slice_entry_count - 1;
            entry_to_move = target_fs->entries[0];
            *shifted_entry_count += target_index;
        }
        else
        {
            /* Shift down */

            adjacent_fs = target_fs->next;
            adjacent_index = 0;
            entry_to_move = target_fs->entries[slice_entry_count - 1];
            *shifted_entry_count += slice_entry_count - target_index;
        }

        rv = _field_entry_multiple_slice_move_check(unit, fg,
            entry_to_move, null_index, null_fs, adjacent_index,
            adjacent_fs, direction, shifted_entry_count, freed_meter_count,
            freed_counter_count);

        BCM_IF_ERROR_RETURN(rv);
    }
    else
    {
        *shifted_entry_count += direction * (null_index - target_index);
    }

    if (entry->fs != target_fs)
    {
        rv = _field_entry_move_slice_fit(unit, stage_fc, entry, target_fs,
            freed_meter_count, freed_counter_count);
    }

    return rv;
}

/*
 * Function: _field_validate_prio_set
 *
 * Purpose: Checks if the prio_set can be successful.
 *     Meaningful only when entries need to be moved across slices
 *     1. Check that entries moving across slices don't have shared
 *        meters/counters
 *     2. For entries moving across slices, and having meters/counters,
 *        check if there are resources in the new slice
 *
 * Parameters:
 *   unit - unit
 *   fg - group the entry whose prio is being set belongs to
 *   f_ent_pri - primary entry whose priorty is to be changed
 *   prev_null_index - index with no entry just before target_index
 *   prev_null_fs - corresponding slice
 *   target_index - the target index where f_ent is supposed to go
 *   target_fs - the slice where index resides
 *   next_null_index - index with no entry just after target_index
 *   next_null_fs - corresponding slice
 *   dir (OUT) - shift up (-1) or down (+1)
 *
 * Returs:
 *   TRUE/FALSE
 *
 * Notes:
 *     Check both up and down movement. If both feasible, take the one
 *     which leads to lesser moves.
 *     Note the slice_sz for intraslice-double wide (FB2). Also shift_up_amount
 *     and shift_down_amount are not absolute amounts, but # entries which
 *     need to be shifted (each entry moves by 1 unit UP/DOWN).
 */
STATIC int
_field_validate_prio_set(int unit,
                         _field_group_t *fg, _field_entry_t *f_ent_pri,
                         int prev_null_index, _field_slice_t *prev_null_fs,
                         int target_index, _field_slice_t *target_fs,
                         int next_null_index, _field_slice_t *next_null_fs,
                         int *dir)
{
    _field_stage_t *stage_fc;
    int rv;
    int shift_up = FALSE, shift_down = FALSE;
    int shift_up_amount = 0, shift_down_amount = 0;
    int up_meters_freed = 0, down_meters_freed = 0;
    int up_counters_freed = 0, down_counters_freed = 0;

    /* Input parameter check. */
    if ((NULL == f_ent_pri) || (NULL == target_fs)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, target_fs->stage_id, &stage_fc));

    /*
     * STEP-1
     * Check the shift operation for UP movement
     * Entries from target_index up till entry after prev_null_index
     * need to move one entry up
     */

    if (prev_null_fs != NULL)
    {
        rv = _field_entry_multiple_slice_move_check(unit, fg, f_ent_pri,
            prev_null_index, prev_null_fs, target_index, target_fs, -1,
            &shift_up_amount, &up_meters_freed, &up_counters_freed);

        shift_up = BCM_SUCCESS(rv);
    }
    else
    {
        shift_up = FALSE;
    }

    /*
     * Step-2
     * Check the shift operation for DOWN movement
     * Entries from target_index till entry before next_null_index
     * need to move one entry down
     */

    if (next_null_fs != NULL)
    {
        rv = _field_entry_multiple_slice_move_check(unit, fg, f_ent_pri,
            next_null_index, next_null_fs, target_index, target_fs, 1,
            &shift_down_amount, &down_meters_freed, &down_counters_freed);

        shift_down = BCM_SUCCESS(rv);
    }
    else
    {
        shift_down = FALSE;
    }

    if (shift_up == TRUE)
    {
        if (shift_down == TRUE)
        {
            if (shift_up_amount < shift_down_amount)
            {
                *dir = -1;
            }
            else
            {
                *dir = 1;
            }
        }
        else
        {
            *dir = -1;
        }
    }
    else
    {
        if (shift_down == TRUE)
        {
            *dir = 1;
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
 * Function: _field_no_free_entries
 *
 * Purpose:
 *     To see if the any of the slices allocated to this
 *     group has any free entries
 *
 * Parameters:
 *     unit - BCM device number
 *     fg - group
 *
 * Returns:
 *     FALSE: Atleast 1 free entry
 *     TRUE: No free entries
 *
 * Notes:
 */
int
_field_no_free_entries(int unit, _field_group_t *fg)
{
    _field_slice_t *fs;
    int free_entry_cnt;

    fs = &fg->slices[0];

    while (fs != NULL) {
        _bcm_field_entries_free_get(unit, fs, fg, &free_entry_cnt);
        if (free_entry_cnt) {
            return FALSE;
        }
        fs = fs->next;
    }

    return TRUE;
}

/*
 * Function:
 *     _field_entry_prio_cmp
 * Purpose:
 *     Compare two entry priorities
 * Parameters:
 * Returns:
 *     -1 if prio_first <  prio_second
 *      0 if prio_first == prio_second
 *      1 if prio_first >  prio_second
 */
int
_field_entry_prio_cmp(int prio_first, int prio_second)
{
    int retval;

    if (prio_first == prio_second) {
        retval = 0;
    } else if (prio_first < prio_second) {
        retval = -1;
    } else {
        retval = 1;
    }
    return retval;
}


/*
 * Function:
 *     _field_entry_move
 * Purpose:
 *     Move an entry within a slice by "amount" indexes
 *
 * Parameters:
 *     unit     - BCM device number
 *     f_ent    - entry to be moved
 *     amount   - number of indexes to move + or -
 * Returns:
 *     BCM_E_NONE   - Success
 */
STATIC int
_field_entry_move(int unit, _field_entry_t *f_ent, int amount)
{
    int  tcam_idx_old[_FP_MAX_ENTRY_WIDTH];/* Original entry tcam index.    */
    int  tcam_idx_new[_FP_MAX_ENTRY_WIDTH];/* Next tcam index for the entry.*/
    _field_entry_policer_t *f_ent_pl;   /* Field entry policer structure.*/
    _field_entry_stat_t    *f_ent_st;   /* Field entry stat structure.   */
    _field_control_t       *fc;         /* Field control structure.      */
    _field_stage_t         *stage_fc;   /* Stage field control.          */
    _field_group_t         *fg;         /* Field entry group.            */
    _field_slice_t         *fs;         /* Field slice control.          */
    _field_policer_t       *f_pl = NULL;/* Field policer info.           */
    _field_stat_t          *f_st = NULL;/* Field statatistics entity.    */
    int                    parts_count = 0; /* Field entry parts count.      */
    int                     idx;
    int                    rv;          /* Operation return status.      */
    int counter_movement = 0;           /* Boolean which tells if entry moved
                                           across slice, and if so, did it
                                           have a counter */
    uint8 entry_part;                    /* Field entry parts iterator.  */
    int meter_movement   = 0;            /* For meter                      */
    int meter_index      = 0;            /* Meter hardware index.          */
    int meter_pool_index = 0;            /* Meter pool value.              */
    int stat_index       = 0;            /* STAT hardware index.           */
    int stat_slice       = 0;            /* STAT slice value.              */
    int new_offset;                      /* Entry offset in slice.         */
    int new_slice_numb   = 0;            /* New slice number.              */
    _field_stat_t        f_st_old;       /* Old Field statatistics entity. */
    uint64               value;          /* STAT value.                    */
    int                  nstat;          /* STAT array index.              */
    int                  instance;       /* Pipe Instance.                 */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
               "FP(unit %d) vverb: BEGIN _field_entry_move(entry=%d,"
               " amount=%d)\n"), unit, f_ent->eid, amount));

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->fs) || (NULL == f_ent->group)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(tcam_idx_old, 0,  (_FP_MAX_ENTRY_WIDTH * sizeof(int)));
    sal_memset(tcam_idx_new, 0, (_FP_MAX_ENTRY_WIDTH * sizeof(int)));
    fg = f_ent->group;

    if (amount == 0) {
        LOG_WARN(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                  "Warning: moving entry=%d, same slice_idx=%d(%#x)\n"),
                  f_ent->eid, f_ent->slice_idx, f_ent->slice_idx));
        return (BCM_E_NONE);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN (_field_control_get(unit, &fc));

    /* Get stage field control structure. */
    rv =  _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get number of parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Retrieve the pipe instance */
    instance = fg->instance;

    /* Calculate the new and old TCAM indexes. */
    for (idx = 0; idx < parts_count; idx++) {
        /* Calculate the new and old TCAM indexes. */
        rv = _bcm_field_entry_tcam_idx_get(unit, f_ent + idx,
                                           &tcam_idx_old[idx]);
        BCM_IF_ERROR_RETURN(rv);

        /* Calculate entry part tcam offset. */
        rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                tcam_idx_old[0] + amount,
                                                idx, &tcam_idx_new[idx]);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get secondary slice entry pointer. */
    if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
        rv = _bcm_field_entry_flags_to_tcam_part (unit, _FP_ENTRY_SECONDARY,
                                                  fg, &entry_part);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Calculate entry new slice number. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
        rv = _bcm_field_th_tcam_idx_to_slice_offset(unit, stage_fc, f_ent,
                                              tcam_idx_new[0], &new_slice_numb,
                                              &new_offset);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc, instance,
                                              tcam_idx_new[0], &new_slice_numb,
                                              &new_offset);
    }
    BCM_IF_ERROR_RETURN(rv);

    if ((f_ent->fs->slice_number != new_slice_numb) &&
        (f_ent->flags  & _FP_ENTRY_INSTALLED)) {

        fs = stage_fc->slices[instance] + new_slice_numb;

        /*
         * If global meter pools are not present, AND
         *     current entry has a meter, allocate one in new slice
         */
        f_ent_pl = f_ent->policer;
        if ((0 == (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) &&
            (f_ent_pl->flags & _FP_POLICER_INSTALLED))  {
            meter_movement = 1;

            /* Read policer configuration.*/
            rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
            BCM_IF_ERROR_RETURN(rv);

            /* Preserve original policer hw index. */
            meter_pool_index = f_pl->pool_index;
            meter_index = f_pl->hw_index;

            /* Deallocate policer from original entry slice. */
            BCM_IF_ERROR_RETURN(_field_meter_hw_free(unit, f_ent));

            /* Allocate policer in a new slice. */
            rv = _field_meter_hw_alloc(unit, f_ent, fs);
            if (BCM_FAILURE(rv)) {
                if (rv == BCM_E_RESOURCE) {
                    /*
                     * Re-allocate policer resource in original slice
                     * and re-install the entry in hardware.
                     */
                    BCM_IF_ERROR_RETURN(_field_meter_hw_alloc(unit, f_ent,
                                                              f_ent->fs));
                    f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
                    f_ent->flags  |= _FP_ENTRY_DIRTY;
                    BCM_IF_ERROR_RETURN
                        (bcm_esw_field_entry_reinstall(unit, f_ent->eid));
                }
               return rv;
            }
        }

        /*
         * If global counters are not present, AND
         *     current entry has a counter, allocate one in new slice
         *  NOTE: Must be after policer allocation in order to
         *  determine counter slice.
         */
        f_ent_st = &f_ent->statistic;
        if ((0 == (stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS)) &&
            (0 == (stage_fc->flags & _FP_STAGE_GLOBAL_CNTR_POOLS)) &&
            (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED))  {
            counter_movement = 1;

            /* Read statistics entity configuration.*/
            BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
            f_st_old = *f_st;

            /* Preserve original policer hw index. */
            stat_slice = f_st->pool_index;
            stat_index = f_st->hw_index;

            /* Deallocate statistics entity from original entry slice. */
            BCM_IF_ERROR_RETURN(_field_slice_counter_free(unit, f_ent, f_st));

            /* Allocate statistics entity in a new slice. */
            BCM_IF_ERROR_RETURN(_field_counter_hw_alloc(unit, f_ent, fs));

            /* Clear allocated new hardware counters */
            for (nstat = 0; nstat < f_st->nstat; nstat++) {
                COMPILER_64_ZERO(value);
                rv = _field_stat_value_set(unit,
                                           f_st,
                                           f_st->stat_arr[nstat],
                                           value);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
    }

    /* Move the hardware entry.*/
    if (f_ent->flags  & _FP_ENTRY_INSTALLED) {
        rv = fc->functions.fp_entry_move(unit, f_ent, parts_count,
                                         tcam_idx_old, tcam_idx_new);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Move the software entry.*/
    rv = _field_entry_slice_idx_change(unit, f_ent, parts_count, tcam_idx_new);
    BCM_IF_ERROR_RETURN(rv);

    if (meter_movement) {
        f_ent_pl = f_ent->policer;
        /* Read policer configuration. */
        rv = _bcm_field_policer_get (unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);

        rv = _field_entry_meter_move(unit, stage_fc, instance,
                                     meter_pool_index,
                                     meter_index, f_pl);
        BCM_IF_ERROR_RETURN(rv);
    }

    if (counter_movement) {
        f_ent_st = &f_ent->statistic;
        BCM_IF_ERROR_RETURN (_bcm_field_stat_get (unit, f_ent_st->sid, &f_st));
        rv = _bcm_field_entry_counter_move(unit, stage_fc, stat_slice,
                                           stat_index, &f_st_old, f_st);
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}
/*
 * Function:
 *      _field_efp_entry_qual_value_qualify
 *
 * Purpose:
 *      Utility routine check encoding of a qualifier and decide that qualifier
 *      can be part of key_match_tcam of an entry.
 *
 * Parameters:
 *      unit  - (IN) BCM device number
 *      entry - (IN) Entry ID
 *      qual_id - (IN) Qualifier Id
 *      can_qualify - (IN/OUT) Status of the qualifier
 *      data - (IN) Data to qualify with.
 *      mask - (IN) Mask to qualify with.
 *
 * Returns:
 *     BCM_E_XXX     - BCM device number
 */
int
_field_efp_entry_qual_value_qualify(int unit,
                            bcm_field_entry_t entry,
                            uint32  qual_id,
                            uint32 *data, uint32 *mask,
                            uint8   *can_qualify)
{
    int    rv;                 /* Operation return stauts.        */
    uint8  slice_mode;         /* Slice Mode of the group         */
    bcm_field_IpType_t ipType; /* Ip type encoding                */
    _field_group_t *fg;        /* FP group info structure.        */
    _field_entry_t *f_ent;     /* Pointer to field entry          */

    /* Input parameters checks. */
    if ((NULL == data) || (NULL == mask) || (NULL == can_qualify)) {
        return (BCM_E_PARAM);
    }

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    *can_qualify = 1;
    slice_mode = 0;

#if defined(BCM_TRX_SUPPORT)
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       rv = _bcm_field_th_egress_mode_get(unit, fg, &slice_mode);
    } else
#endif
    {
       rv = _bcm_field_trx_egress_mode_get(unit, fg, &slice_mode);
    }
    BCM_IF_ERROR_RETURN(rv);
#endif

    switch (qual_id){
        case bcmFieldQualifyIpType:
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TD2_TT2(unit)) {
                rv = _bcm_field_td2_qualify_ip_type_encode_get(unit, *data,
                                                               *mask, &ipType);
            } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TRX(unit)) {
                rv = _bcm_field_trx_qualify_ip_type_encode_get(unit, *data,
                                                               *mask, &ipType);
            } else
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_FIREBOLT_SUPPORT)
            if (SOC_IS_FIREBOLT(unit)) {
                rv = _bcm_field_fb_qualify_ip_type_encode_get(unit, fg,
                                                              *data, *mask,
                                                              &ipType);
            } else
#endif /* BCM_FIREBOLT_SUPPORT */
#if defined(BCM_RAPTOR1_SUPPORT)
            if (SOC_IS_RAPTOR(unit)) {
                rv = _bcm_field_raptor_qualify_ip_type_get(unit, entry,
                                                           &ipType, qual_id);
            } else
#endif /* BCM_RAPTOR1_SUPPORT */
            {
                rv = BCM_E_INTERNAL;
            }

            BCM_IF_ERROR_RETURN(rv);


            switch(slice_mode) {
                case 1:
                case 3:
                    switch(ipType) {
                        case bcmFieldIpTypeIp:
                        case bcmFieldIpTypeIpv4NoOpts:
                        case bcmFieldIpTypeIpv4Any:
                        case bcmFieldIpTypeIpv6NoExtHdr:
                        case bcmFieldIpTypeIpv6OneExtHdr:
                        case bcmFieldIpTypeIpv6TwoExtHdr:
                        case bcmFieldIpTypeIpv6:
                            *can_qualify = 0;
                            break;
                        default :
                            break;
                    }
                    break;
                case 2:
                case 5:
                    switch(ipType) {
                        case bcmFieldIpTypeIpv6NoExtHdr:
                        case bcmFieldIpTypeIpv6OneExtHdr:
                        case bcmFieldIpTypeIpv6TwoExtHdr:
                        case bcmFieldIpTypeIpv6:
                            *can_qualify = 0;
                            break;
#if defined(BCM_TOMAHAWK_SUPPORT)
                        case bcmFieldIpTypeIp:
                        case bcmFieldIpTypeIpv4NoOpts:
                        case bcmFieldIpTypeIpv4Any:
                            if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
                                *can_qualify = 0;
                            }
                            break;
#endif
                        default :
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    return BCM_E_NONE;
}
/*
 * Function:
 *      _field_efp_key_match_type_set_on_qual_delete
 *
 * Purpose:
 *      Utility routine for setting efp key match type of an entry
 *      when qualifier is deleted from the entry.
 *
 * Parameters:
 *      unit  - (IN) BCM device number
 *      entry - (IN) Entry ID
 * Returns:
 *     BCM_E_XXX     - BCM device number
 */
int
_field_efp_key_match_type_set_on_qual_delete(int unit, bcm_field_entry_t entry)
{
    int             parts_count = 0;    /* Number of entry parts.          */
    int             part_idx;           /* Entry parts iteration index.    */
    int             qual_idx;           /* Part qualifiers iteration index.*/
    int             rv;                 /* Operation return stauts.        */
    int             idx;
    int             found;
    int             idx_max;
    int             index;
    uint32          width;
    uint8           can_qualify = 1;
    _field_group_t           *fg;       /* FP group info structure.        */
    _field_entry_t           *f_ent;    /* Pointer to field entry          */
    _bcm_field_qual_offset_t *q_offset; /* Qualifier offset structure      */
    _bcm_field_group_qual_t  *q_arr;    /* Qualifiers array.               */
    _bcm_field_group_qual_t  *q_arr_1;  /* Qualifiers array.               */
    _bcm_field_qual_data_t    q_data;
    _bcm_field_qual_data_t    q_mask;
    /* Search the entry by eid. */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry, _FP_ENTRY_PRIMARY,
                                         &f_ent));

    fg = f_ent->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        q_arr = &(fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][part_idx]);
        for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
            idx_max = -1;
            q_offset = q_arr->offset_arr + qual_idx;

            /* There is no value associated with zero
             * width qualifiers (Stage, Ip4 etc)
             */
             _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, width);
            if (0 == width) {
                continue;
            }

            _FP_QUAL_DATA_CLEAR(q_data);
            _FP_QUAL_DATA_CLEAR(q_mask);


            /* Read qualifier match value and mask. */
            rv = _bcm_field_qual_value_get(unit, q_offset,
                                           f_ent + part_idx,
                                           q_data, q_mask);
            if (BCM_FAILURE(rv)) {
                return rv;
            }

            /* Check if qualifier was installed. */
            for (idx = 3; idx >= 0; idx--) {
                if (q_mask[idx] != 0)  {
                    idx_max = idx;
                    break;
                }
            }

            if (idx_max >= 0) {
                found = FALSE;
                for (idx = 0; idx < parts_count; idx++) {
                    q_arr_1 = &(fg->qual_arr[_FP_ENTRY_TYPE_1][idx]);
                    for (index = 0; index < q_arr_1->size; index++) {
                        if (q_arr->qid_arr[qual_idx] ==
                            q_arr_1->qid_arr[index]) {
                            found = TRUE;
                            break;
                        }
                    }
                    if (TRUE == found) {
                        rv = _field_efp_entry_qual_value_qualify(unit, entry,
                                                     q_arr->qid_arr[qual_idx],
                                                     q_data, q_mask,
                                                     &can_qualify);
                        BCM_IF_ERROR_RETURN(rv);
                        if (!can_qualify) {
                            found = FALSE;
                        } else {
                           break;
                        }
                    }
                }
                if (FALSE == found) {
                    f_ent->efp_key_match_type = _FP_ENTRY_TYPE_0;
                    if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                        (f_ent + 1)->efp_key_match_type = _FP_ENTRY_TYPE_0;
                    }
                    return BCM_E_NONE;
                }
            }
        }
    }

    f_ent->efp_key_match_type = _FP_ENTRY_TYPE_1;
    if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        (f_ent + 1)->efp_key_match_type = _FP_ENTRY_TYPE_1;
    }
    return BCM_E_NONE;
}
/*
 * Function:
 *      _field_efp_key_match_type_set
 *
 * Purpose:
 *      Utility routine for setting efp key match type of an entry
 *
 * Parameters:
 *      unit     - (IN) BCM device number
 *      qual_add - (IN) Flag to indicate qualifier is added/deleted
 *      entry    - (IN) Entry ID
 *      per_ent_key_type - (IN) Flag to indicate entry can fit in default key
 *      grp_def_key_type - (IN) Flag to indicate entry can fit in original key
 * Returns:
 *     BCM_E_XXX     - BCM device number
 */
int
_field_efp_key_match_type_set(int unit,
                              uint8 qual_add,
                              bcm_field_entry_t entry,
                              uint8 per_ent_key_type,
                              uint8 grp_def_key_type)
{
    _field_group_t  *fg;  /* FP group info structure. */
    _field_entry_t  *f_ent; /* Field entry info structure */
    int8            use_per_ent_key_type;
    int             rv;                 /* Operation return stauts.        */

    /* Search the entry by eid. */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry, _FP_ENTRY_PRIMARY,
                                         &f_ent));

    fg = f_ent->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }

    use_per_ent_key_type = 0;
    if (qual_add) {
        /* When qualifier is added to the field entry */
        if (grp_def_key_type) {
            if (per_ent_key_type && f_ent->efp_key_match_type) {
                use_per_ent_key_type = 1;
            }
        } else {
            return BCM_E_INTERNAL;
        }

        f_ent->efp_key_match_type = use_per_ent_key_type;

        if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
            (f_ent + 1)->efp_key_match_type = use_per_ent_key_type;
        }
    } else {
        /* When qualifier is deleted from the field entry */
        if (_FP_ENTRY_TYPE_0 == f_ent->efp_key_match_type) {
            rv = _field_efp_key_match_type_set_on_qual_delete(unit, entry);
            if (BCM_FAILURE(rv)) {
                return rv;
            }
        }
    }
    return BCM_E_NONE;
}
/*
 * Function:
 *      _field_efp_qualify32
 *
 * Purpose:
 *      Utility routine for qualify APIs taking 32 bits or less.
 *      This routine applies to only EGRESS stage.
 *
 * Parameters:
 *      unit  - (IN)BCM device number
 *      entry - (IN)Entry ID
 *      qual  - (IN) Qualifier field
 *      data  - (IN)Matching data
 *      mask  - (IN)Bit mask for data
 *
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 *     BCM_E_INTERNAL - Entry doesnot belong to any group
 */
int
_field_efp_qualify32(int unit, bcm_field_entry_t entry,
                 int qual, uint32 *data, uint32 *mask)
{
    _bcm_field_qual_offset_t *q_offset; /* Qualifier offset structure      */
    _field_entry_t           *f_ent;    /* Field entry structure           */
    _bcm_field_group_qual_t  *q_arr;    /* Qualifiers array.               */
    int             parts_count = 0;    /* Number of entry parts.          */
    int             part_idx;           /* Entry parts iteration index.    */
    int             qual_idx;           /* Part qualifiers iteration index.*/
    uint8           per_ent_key_type;   /* Entry lookup flags.             */
    uint8           grp_def_key_type;   /* Entry lookup flags.             */
    _field_group_t  *fg;                /* FP group info structure.        */
    int             rv;                 /* Operation return stauts.        */
    int             entry_type;         /* Type of an entry                */
    uint8           can_qualify = 1;
    uint32          multi_width;

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }
    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* update the EFP tcam.key and key_match_tcam.key */
    if (f_ent->flags & _FP_ENTRY_INSTALLED &&
        f_ent->flags != _FP_ENTRY_DIRTY) {
        for (part_idx = 0; part_idx < parts_count; part_idx++) {
            rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent+part_idx);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);


    /* Exact match requested, make maximum mask value */
    _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, multi_width);
    if ((32 >= multi_width) &&
        (*mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK)) {

        *mask = ((32 == q_offset->width[0]) || (32 == multi_width))
                  ? ~0 : ((1 << multi_width) - 1);

    }

    if (bcmFieldQualifyIpType == qual) {
        rv = bcm_esw_field_qualifier_delete(unit, entry, qual);
        BCM_IF_ERROR_RETURN(rv);
    }

    grp_def_key_type = FALSE;
    per_ent_key_type  = FALSE;

    for (entry_type = 0; entry_type < _FP_MAX_ENTRY_TYPES; entry_type++) {

        /* Search the entry by eid. */
        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        BCM_IF_ERROR_RETURN(rv);

        fg = f_ent->group;
        if (NULL == fg) {
            return (BCM_E_INTERNAL);
        }


        /* Iterate over all entry parts. */
        for (part_idx = 0; part_idx < parts_count; part_idx++) {
            /* Get part qualifiers array. */
            q_arr = &(fg->qual_arr[entry_type][part_idx]);
            /* Search array by qualifier id. */
            for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
                if ((uint16)qual == q_arr->qid_arr[qual_idx]) {
                    if (_FP_ENTRY_TYPE_1 == entry_type) {
                        q_offset = q_arr->offset_arr + qual_idx;
                        per_ent_key_type = TRUE;
                        /* Program data/mask pair to tcam buffer. */

                        /*
                         * COVERITY
                         *
                         * This flow takes care of the  Out-of-bounds access
                         * issue for data and mask.
                         */

                        /* coverity[callee_ptr_arith : FALSE] */
                        rv = _bcm_field_qual_value_set_by_entry_type(unit,
                                                               q_offset,
                                                               f_ent + part_idx,
                                                               data, mask, 1);
                        BCM_IF_ERROR_RETURN(rv);

                        /* When qualifier is found dont go for next qualifier
                         *  in q_arr
                         */
                        break;

                    } else if (_FP_ENTRY_TYPE_0 == entry_type) {
                        q_offset = q_arr->offset_arr + qual_idx;
                        grp_def_key_type = TRUE;
                        /* Program data/mask pair to tcam buffer. */

                        /*
                         * COVERITY
                         *
                         * This flow takes care of the  Out-of-bounds access
                         * issue for data and mask.
                         */

                        /* coverity[callee_ptr_arith : FALSE] */

                        rv = _bcm_field_qual_value_set_by_entry_type(unit,
                                                              q_offset,
                                                              f_ent + part_idx,
                                                              data, mask, 0);
                        BCM_IF_ERROR_RETURN(rv);

                        /* When qualifier is found dont go for next qualifier
                         *  in q_arr
                         */
                        break;
                    }
                }
            }

            /* When qualifier is found dont go for next partition */
            if (((_FP_ENTRY_TYPE_0 == entry_type) && grp_def_key_type) ||
                ((_FP_ENTRY_TYPE_1 == entry_type) && per_ent_key_type)) {
                break;
            }
        }

        /* Qualifier must found in select code types populated
         * by group create logic
         */
        if (FALSE == grp_def_key_type && (_FP_ENTRY_TYPE_0 == entry_type)) {
            return (BCM_E_NOT_FOUND);
        }

    }

    if (per_ent_key_type) {
        rv = _field_efp_entry_qual_value_qualify(unit, entry, qual,
                                             data, mask, &can_qualify);
        BCM_IF_ERROR_RETURN(rv);
        if (!can_qualify) {
            per_ent_key_type = FALSE;
        }
    }

    rv = _field_efp_key_match_type_set(unit, TRUE, entry,
                                       per_ent_key_type,
                                       grp_def_key_type);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _field_qualify_macaddr_get
 * Purpose:
 *     Get qualifier Source or Destination mac address.
 *
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field entry to qualify on
 *     qual     - (IN) Field qualifier id.
 *     data     - (OUT)Data to qualify with (type varies)
 *     mask     - (OUT)Mask to qualify with (type is same as for data)
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized.
 *     BCM_E_XXX       - Other errors
 */
int
_field_qualify_macaddr_get(int unit, bcm_field_entry_t entry,
                           bcm_field_qualify_t qual,
                           bcm_mac_t *data, bcm_mac_t *mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Read qualifier match value and mask. */
       rv = _field_entry_qualifier_key_get(unit, entry, qual,
                                           ref_data, ref_mask);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Get qualifier offsets in the tcam. */
       rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
       BCM_IF_ERROR_RETURN(rv);

       /* Read qualifier match value and mask. */
       rv = _bcm_field_qual_value_get(unit, q_offset, f_ent,
                                      ref_data, ref_mask);
    }
    BCM_IF_ERROR_RETURN(rv);

    SAL_MAC_ADDR_FROM_UINT32((*data), ref_data);
    SAL_MAC_ADDR_FROM_UINT32((*mask), ref_mask);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_qualify_macaddr
 * Purpose:
 *     Qualify on a Source or Destination mac address.
 *
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field entry to qualify on
 *     qual     - (IN) Field qualifier id.
 *     data     - (IN) Data to qualify with (type varies)
 *     mask     - (IN) Mask to qualify with (type is same as for data)
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized.
 *     BCM_E_XXX       - Other errors
 */
int
_field_qualify_macaddr(int unit, bcm_field_entry_t entry,
                    bcm_field_qualify_t qual,
                    bcm_mac_t data, bcm_mac_t mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;

    SAL_MAC_ADDR_TO_UINT32(data, ref_data);
    SAL_MAC_ADDR_TO_UINT32(mask, ref_mask);

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, entry, qual,
                                          ref_data, ref_mask,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, entry, qual,
                                                ref_data, ref_mask));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        /* Redirect to _field_efp_qualify32 for egress stage */
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
            return _field_efp_qualify32(unit, entry, qual, ref_data, ref_mask);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Program data/mask pair to tcam buffer. */
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for ref_data and ref_mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, ref_data, ref_mask);
    return (rv);
}

/*
 * Function:
 *     _field_qualify_Port
 * Purpose:
 *     Qualify on a Source or Destination Port.
 *
 * Parameters:
 *     unit       - BCM device number
 *     entry      - Field entry to qualify on
 *     data_modid - Data to qualify with (type varies)
 *     mask_modid - Mask to qualify with (type is same as for data)
 *     data_port  - Data to qualify with (type varies)
 *     mask_port  - Mask to qualify with (type is same as for data)
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized.
 *     BCM_E_INTERNAL  - qual neither SrcPort or DstPort
 *     BCM_E_NOT_FOUND - Entry ID not found in unit.
 *     BCM_E_PARAM     - port data out of range
 *     BCM_E_XXX       - Other errors
 */
int
_field_qualify_Port(int unit, bcm_field_entry_t entry,
                    bcm_module_t data_modid, bcm_module_t mask_modid,
                    bcm_port_t   data_port,  bcm_port_t   mask_port,
                    bcm_field_qualify_t qual)
{
    uint32 mod_port_data = 0;   /* concatenated modid and port */
    uint32 mod_port_mask = 0;   /* concatenated modid and port */

    if (qual != bcmFieldQualifySrcPort
        && qual != bcmFieldQualifyDstPort
        && qual != bcmFieldQualifySrcGport
        && qual != bcmFieldQualifyDstGport) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: _field_qualify_Port() only works with"
                               "SrcPort or DstPort \n"), unit));
        return (BCM_E_INTERNAL);
    }

    /* Range check data port */
    if (!SOC_PORT_ADDRESSABLE(unit, data_port)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data_port=%#x too large\n"),
                   unit, data_port));
        return (BCM_E_PARAM);
    }

    /* Set masks to all ones if exact match is specified. */
    if (mask_modid == BCM_FIELD_EXACT_MATCH_MASK) {
        mask_modid = SOC_MODID_MAX(unit);
    }
    if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
        /* Trunk Bit (Tf) is not with Trunk/Port ID */
        int num_bits_for_port;
        if (mask_port == BCM_FIELD_EXACT_MATCH_MASK) {
            mask_port = SOC_PORT_ADDR_MAX(unit);
        }
        num_bits_for_port = _shr_popcount((unsigned int)SOC_PORT_ADDR_MAX(unit));
        /* SrcPort and DstPort are programmed as 0 - 7 bits are used to store port and 7 - 14 are for Module ID
           num_bits_for_port is increased by 2 as SOC_PORT_ADDR_MAX returns 5 for Metrolite.
        */
#if defined(BCM_METROLITE_SUPPORT)
        if (SOC_IS_METROLITE(unit)) {
            num_bits_for_port += 2;
        }
#endif

        mod_port_data = (data_modid << num_bits_for_port) | data_port;
        mod_port_mask = (mask_modid << num_bits_for_port) | mask_port;
           /* Clear the trunk ID bit. */
           mod_port_data &= ~(1 << SOC_TRUNK_BIT_POS(unit));
           /* Must match on the T bit (which should be 0) */
           mod_port_mask |= (1 << SOC_TRUNK_BIT_POS(unit));

        if (bcmFieldQualifyDstPort == qual || bcmFieldQualifyDstGport == qual) {
            BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit,
                                entry, qual, &mod_port_data, &mod_port_mask,
                                _bcmFieldDestTypeDglp));
        }

        return _field_qualify32(unit, entry, qual, mod_port_data, mod_port_mask);
    }

    /* Note: Trunk bit is the MSB in PORT_TGID */
    if (mask_port == BCM_FIELD_EXACT_MATCH_MASK) {
        mask_port = (1 << (SOC_TRUNK_BIT_POS(unit) + 1)) - 1;
    }

    /* Combine module IDs and ports */
    mod_port_data = (data_modid << (SOC_TRUNK_BIT_POS(unit) + 1)) | data_port;
    mod_port_mask = (mask_modid << (SOC_TRUNK_BIT_POS(unit) + 1)) | mask_port;

    /* Clear the trunk ID bit. */
    mod_port_data &= ~(1 << SOC_TRUNK_BIT_POS(unit));
    /* Must match on the T bit (which should be 0) */
    mod_port_mask |= (1 << SOC_TRUNK_BIT_POS(unit));

    if (bcmFieldQualifyDstPort == qual || bcmFieldQualifyDstGport == qual) {
        BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit,
                            entry, qual, &mod_port_data, &mod_port_mask,
                            _bcmFieldDestTypeDglp));
    }

    return _field_qualify32(unit, entry, qual, mod_port_data, mod_port_mask);
}


/*
 * Function:
 *     _field_qualify_Port_get
 * Purpose:
 *     Qualify on a Source or Destination Port.
 *
 * Parameters:
 *     unit       - BCM device number
 *     entry      - Field entry to qualify on
 *     data_modid - Data to qualify with (type varies)
 *     mask_modid - Mask to qualify with (type is same as for data)
 *     data_port  - Data to qualify with (type varies)
 *     mask_port  - Mask to qualify with (type is same as for data)
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized.
 *     BCM_E_INTERNAL  - qual neither SrcPort or DstPort
 *     BCM_E_NOT_FOUND - Entry ID not found in unit.
 *     BCM_E_PARAM     - port data out of range
 *     BCM_E_XXX       - Other errors
 */
int
_field_qualify_Port_get(int unit, bcm_field_entry_t entry,
                        bcm_module_t *data_modid,
                        bcm_module_t *mask_modid,
                        bcm_port_t   *data_port,
                        bcm_port_t   *mask_port,
                        bcm_field_qualify_t qual)
{
    uint32    mod_port_data = 0; /* Concatenated modid and port */
    uint32    mod_port_mask = 0; /* Concatenated modid and port */
    int       rv;                /* Operation return stauts.    */
    int       num_bits_for_port; /* Port field size.            */
    int       trunk_bit_pos = 0;

    /* Input parameter check. */
    if ((NULL == data_modid) || (NULL == mask_modid) ||
        (NULL == data_port) || (NULL == mask_port)) {
        return (BCM_E_PARAM);
    }
    /* Internal sanity check. */
    if (qual != bcmFieldQualifySrcPort
        && qual != bcmFieldQualifyDstPort
        && qual != bcmFieldQualifySrcGport) {
        return (BCM_E_INTERNAL);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, qual,
                                           (uint32 *)&mod_port_data,
                                           (uint32 *)&mod_port_mask);
    BCM_IF_ERROR_RETURN(rv);

    if (qual == bcmFieldQualifyDstPort) {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, qual, (uint32 *) &mod_port_data, (uint32 *) &mod_port_mask));
    }

    num_bits_for_port = _shr_popcount((unsigned int)SOC_PORT_ADDR_MAX(unit));
    /* SrcPort and DstPort are programmed as 0 - 7 bits are used to store port and 7 - 14 are for Module ID
       num_bits_for_port is increased by 2 as SOC_PORT_ADDR_MAX returns 5 for Metrolite.
    */

#if defined(BCM_METROLITE_SUPPORT)
    if (SOC_IS_METROLITE(unit)) {
        num_bits_for_port += 2;
    }
#endif
    /* Get the trunk bit position */
    trunk_bit_pos = SOC_TRUNK_BIT_POS(unit);

    /* Clear the overlaid trunk bit from the modid mask. */
    if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
    /* Get the trunk bit position */
        mod_port_mask = mod_port_mask & ~(1 << trunk_bit_pos);
       *data_modid =  mod_port_data >> num_bits_for_port;
       *mask_modid =  mod_port_mask >> num_bits_for_port;

       *data_port = mod_port_data & ((1 << num_bits_for_port) - 1);
       *mask_port = mod_port_mask & ((1 << num_bits_for_port) - 1);
       return (rv);
    }

    /* Get Modid Info */
    *data_modid =  mod_port_data >> (trunk_bit_pos + 1);
    *mask_modid =  mod_port_mask >> (trunk_bit_pos + 1);

    /* Get Port Info */
    *data_port = mod_port_data & ((1 << trunk_bit_pos) - 1);
    *mask_port = mod_port_mask & ((1 << trunk_bit_pos) - 1);
    return (rv);
}

#define _FIELD_TRUNK_BIT_INSERT(_u_, _t_)                       \
    ((((_t_) & BCM_TGID_PORT_TRUNK_MASK_HI(_u_)) << 1) |        \
     BCM_TGID_TRUNK_INDICATOR(_u_) | ((_t_) & BCM_TGID_PORT_TRUNK_MASK(_u_)))

#define _FIELD_TRUNK_BIT_RESET(_u_, _t_)                        \
    ((((_t_) - ((_t_) & BCM_TGID_PORT_TRUNK_MASK(_u_))) >> 1) | \
     ((_t_) & BCM_TGID_PORT_TRUNK_MASK(_u_)))


/*
 * Function:
 *     _bcm_field_qualify_trunk
 * Purpose:
 *     Qualify on a Source or Destination Trunk ID.
 *
 * Parameters:
 *     unit       - BCM device number
 *     entry      - Field entry to qualify on
 *     qual       - Field qualifier of type bcmFieldQualifyXXX.
 *     data       - Trunk ID to qualify
 *     mask       - Trunk mask to qualify
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized.
 *     BCM_E_INTERNAL  - qual neither SrcPort or DstPort
 *     BCM_E_NOT_FOUND - Entry ID not found in unit.
 *     BCM_E_PARAM     - Trunk ID or mask out of range
 *     BCM_E_XXX       - Other errors
 */
int
_bcm_field_qualify_trunk(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_qualify_t qual,
                         bcm_trunk_t data,
                         bcm_trunk_t mask)
{
    bcm_trunk_t               q_mask;
    _field_entry_t            *f_ent;
    _bcm_field_qual_offset_t  *q_offset;
    uint32                    q_width;
    int                       rv;
    uint32 trunk_bit_pos = SOC_TRUNK_BIT_POS(unit);

    if (qual != bcmFieldQualifySrcTrunk && qual != bcmFieldQualifyDstTrunk
       && qual != bcmFieldQualifySrcGport && qual != bcmFieldQualifyDstGport) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: _bcm_field_qualify_trunk() only works with"
                               "SrcTrunk or DstTrunk or SrcGport\n"), unit));
        return (BCM_E_INTERNAL);
    }

    /*
     * Validate Trunk ID value. spn_TRUNK_EXTEND is TRUE when device
     * supports more than 32 FP trunk groups.
     */
    if (soc_property_get(unit, spn_TRUNK_EXTEND, 1)
        || soc_feature(unit, soc_feature_trunk_extended_only)) {
        TRUNK_CHK_TGID_EXTENDED(unit, data);
    } else {
        TRUNK_CHK_TGID32(unit, data);
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
        /* Trunk Bit (Tf) is not with Trunk/Port ID */
           data = data | (1 << trunk_bit_pos);
           mask = mask | (1 << trunk_bit_pos);
    } else {
        data = _FIELD_TRUNK_BIT_INSERT(unit, data);
        mask = _FIELD_TRUNK_BIT_INSERT(unit, mask);
    }

    if (bcmFieldQualifyDstTrunk == qual || bcmFieldQualifyDstGport == qual) {
        BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit,
                            entry, qual, (uint32 *)&data, (uint32 *)&mask,
                            _bcmFieldDestTypeDglp));
    }

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * srcTrunk Qualifier contains TrunkBit + Module ID + Port ID
     * MSB bit of Module ID indicates Remote trunk identifier
     * Ignoring the remote trunk identifier bit.
     * MSB bit position for MOD ID is TrunkBit position - 1
     */
    q_mask = ~(1 << (trunk_bit_pos-1));

    if (mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK) {
        /* Exact match requested, make maximum mask value */
        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, q_width);
        mask =  (1 << q_width) - 1;
    }
    mask &= q_mask;

    return _field_qualify32(unit, entry, qual, data, mask);
}

/*
 * Function:
 *     _bcm_field_qualify_trunk_get
 * Purpose:
 *     Get qualifiers  Trunk ID and mask.
 *
 * Parameters:
 *     unit       - (IN)  BCM device number
 *     entry      - (IN)  Field entry to qualify on
 *     qual       - (IN)  Field Qualifier of type bcmFieldQualifyXXX.
 *     data       - (OUT) Trunk ID to qualify
 *     mask       - (OUT) Trunk mask to qualify
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qualify_trunk_get(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_qualify_t qual,
                             bcm_trunk_t *data,
                             bcm_trunk_t *mask)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    if ((qual != bcmFieldQualifySrcTrunk) && (qual != bcmFieldQualifyDstTrunk)) {
        return (BCM_E_INTERNAL);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, qual,
                                           &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    if (qual == bcmFieldQualifyDstTrunk) {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, qual, &hw_data, &hw_mask));
    }

    if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
        /* Trunk Bit (Tf) is not with Trunk/Port ID */
           *data = hw_data & ~(1 << SOC_TRUNK_BIT_POS(unit));
           *mask = hw_mask & ~(1 << SOC_TRUNK_BIT_POS(unit));
    } else {
        *data = _FIELD_TRUNK_BIT_RESET(unit, hw_data);
        *mask = _FIELD_TRUNK_BIT_RESET(unit, hw_mask);
    }
    return (BCM_E_NONE);
}
#undef _FIELD_TRUNK_BIT_INSERT
#undef _FIELD_TRUNK_BIT_RESET

/*
 * Function:
 *      _field_qualify_source_virtual_port
 *
 * Purpose:
 *      Utility routine to qualify MPLS/MIM Source Virtual Port.
 * Parameters:
 *      unit            - BCM device number
 *      entry           - Entry ID
 *      qual            - Qualifier field
 *      data            - Matching data
 *      mask            - Bit mask for data
 *      ingress_entity  - Ingress entity type selector status
 *
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 */

int
_field_qualify_source_virtual_port(int unit, bcm_field_entry_t entry,
                 int qual, uint32 data, uint32 mask, int ingress_entity)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t *f_ent;
    int rv;

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
        && (q_offset->secondary)) {
        f_ent->flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
    }

    if (mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK) {
        /* Exact match requested, make maximum mask value */
        mask = ((1 << q_offset->width[0]) - 1);
        if ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) &&
                (SOC_IS_KATANAX(unit))) {
            /*
             * Setting Mask for SVP_VALID.
             * In KT2, SB2 and ML SVP_VALID and S_FIELD are not sequent.
             * Hence program mask with two different widths
             */
            mask |= (((1 << q_offset->width[1]) - 1) << q_offset->width[0]);
        }
    }

    if ((_BCM_FIELD_STAGE_EXTERNAL != f_ent->group->stage_id)
        && (0 == ingress_entity)) {
        /* Set SVP valid bit to TRUE */
        data |= ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) &&
                (SOC_IS_KATANAX(unit))) ? (1 << (q_offset->width[0])) :
                (1 << (q_offset->width[0] - 1));
    }

    /* Program data/mask pair to tcam buffer. */
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualifier32_input_range_check
 *
 * Purpose:
 *      Utility routine for qualfiers input param check for
 *      qualifiers whose h/w width is less than the bcm api data
 *      width
 * Parameters:
 *     unit    - BCM device number
 *     entry   - Entry Id
 *     qual_id - Qualifier field
 *     data    - Matching data
 *     size    - size of data
 * Return
 *      BCM_E_NONE
 *      BCM_E_PARAM
 *
 */
int _field_qualifier32_input_range_check (int unit, int qual, bcm_field_entry_t entry,
                                     uint8 *data, int size)
{
    int width = 0;
    int rv = 0;
    uint32 max_allowed_data = 0;
    _field_entry_t *f_ent = NULL;
    _bcm_field_qual_offset_t *q_offset;
    int bitpos = 0;

    if ((data == NULL) || (size == 0)) {
        return BCM_E_PARAM;
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, width);

    for (bitpos = 0; bitpos < width; bitpos++) {
        max_allowed_data |= (1 << bitpos);
    }

    switch (size) {
        case 1:
            if (max_allowed_data < (*data)) {
                return BCM_E_PARAM;
            }
            break;
        case 2:
            if (max_allowed_data < *((uint16 *)data)) {
                return BCM_E_PARAM;
            }
            break;
        case 4:
            if (max_allowed_data < *((uint32 *)data)) {
                return BCM_E_PARAM;
            }
            break;
        default :
            return BCM_E_PARAM;
            break;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _field_qualify32
 *
 * Purpose:
 *      Utility routine for qualify APIs taking 32 bits or less
 *
 * Parameters:
 *      unit - BCM device number
 *      entry - Entry ID
 *      qual  - Qualifier field
 *      data  - Matching data
 *      mask  - Bit mask for data
 *
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 */

int
_field_qualify32(int unit, bcm_field_entry_t entry,
                 int qual, uint32 data, uint32 mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    int                      rv;
#if defined(BCM_TRIUMPH3_SUPPORT)
    esm_l3_protocol_fn_entry_t  l3_proto_fn_entry;
    uint32                      ip_proto, index = data;
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        return _bcm_field_presel_qualify_set(unit, entry, qual, &data, &mask);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Search the entry by eid. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if (NULL == f_ent->group) {
        return (BCM_E_INTERNAL);
    }
#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        /* Redirect to _field_efp_qualify32 for egress stage */
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
           /*
            * COVERITY
            *
            * This flow takes care of the Out-of-bounds access
            * issue for data and mask.
            */

            /* coverity[callee_ptr_arith : FALSE] */
            return _field_efp_qualify32(unit, entry, qual, &data, &mask);
        }
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, entry, qual,
                                          &data, &mask,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, entry, qual,
                                                &data, &mask));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
        && (q_offset->secondary))
    {
        f_ent->flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
    }

    if (mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK) {
        int multi_width;

        /* Exact match requested, make maximum mask value */
        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, multi_width);
        mask = (32 == q_offset->width[0]) ? ~0 : ((1 << multi_width) - 1);
    }

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) &&
                (qual == bcmFieldQualifyIpProtocol) &&
                ((q_offset->offset[0] == 132) || (q_offset->offset[0] == 4)) &&
                (q_offset->width[0] == 4)) {
            /* For EXT_IP4 EXT_L2IP4 and EXT_IP6S ACL, L3_PROTOCOL_FN value from
               ESM_L3_PROTOCOL_FN table is treated as data to send it to
               external TCAM as key */
            BCM_IF_ERROR_RETURN(soc_mem_read(unit, ESM_L3_PROTOCOL_FNm,
                                    MEM_BLOCK_ANY, index, &l3_proto_fn_entry));
            soc_mem_field_get(unit, ESM_L3_PROTOCOL_FNm,
                                    l3_proto_fn_entry.entry_data,
                                    L3_PROTOCOL_FNf, &ip_proto);
            data = ip_proto;
            mask = 0xf;
        }
    }
#endif

    /* Program data/mask pair to tcam buffer. */
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualify_cpu_queue
 *
 * Purpose:
 *      Utility routine to qualify cos queue.
 * Parameters:
 *      unit            - BCM device number
 *      entry           - Entry ID
 *      qual            - Qualifier field
 *      data            - Matching data
 *      mask            - Bit mask for data
 *
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 */
int
_field_qualify_cpu_queue(int unit, bcm_field_entry_t entry,
                         int qual, uint32 data, uint32 mask)
{
    int rv = BCM_E_NONE;         /* return value of this function */
    uint32 cos_queue_data = 0;   /* concatenated modified cpu queue and MSB 2
                                    bits with 0 */
    uint32 cos_queue_mask = 0;   /* concatenated modified cpu queue mask and
                                    MSB 2 bits of original cpu queue mask */
#if defined(BCM_TRIDENT2_SUPPORT)
    char nm = 0x0, nv = 0x0;     /* New mask and New value*/
    char om = 0x0, ov = 0x0;     /* Original mask and original value */
#endif

    _field_entry_t *f_ent;
    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    cos_queue_data = data;
    cos_queue_mask = mask;

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TRIDENT2(unit) || SOC_IS_TITAN2(unit)) {
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {

            /* On Trident2 the CPU cos which ranges from 0~47, is shown as
             * value=16~63 in EFP logic, basically the H/W adds 16 to the cos
             * value in the key.So in S/W, 16 has to be added to actual data
             * value and adjust the mask accordingly passed by application code.
             * Since all the manipulation required to bit 5 and 6 of 6 bit wide
             * CpuCosQNew, we will generate new mask and new data as in table
             * below.We also save the MSB two bits of the mask into SPARE_DVP
             * field in the EFP entry.
             * So the cpuCosQNew is an 8 bit qualifier now.
             *  --------------------------------------------------------------
             * |Application calls API with  |   SDK writes S-CHAN with        |
             * |----------------------------|---------------------------------|
             * |             |              |   CPUCOS[5:4] | SPARE_DVP[1:0]  |
             * |             |              |---------------|-----------------|
             * |   MASK[5:4] |   DATA[5:4]  |   MASK | KEY  |   MASK | KEY    |
             * |-------------|--------------|--------|------|--------|--------|
             * |   00        |   xx         |    00  | 00   |   00   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   01        |   x0         |    01  | 01   |   01   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   01        |   x1         |    11  | 10   |   01   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   10        |   0x         |    11  | 01   |   10   | 00     |
             * |             |              |    ----|------|--------|--------|
             * |             |              |    11  | 10   |   10   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   10        |   10         |    11  | 10   |   10   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   11        |   00         |    11  | 01   |   11   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   11        |   01         |    11  | 10   |   11   | 00     |
             * |-------------|--------------|--------|------|--------|--------|
             * |   11        |   10         |    11  | 11   |   11   | 00     |
             * |-------------|--------------|---------------------------------|
             * |   11(or xx) |   11         |    Wrong Value from API,        |
             * |             |              |    cpu only has 48 queues       |
             *  --------------------------------------------------------------
             */
            cos_queue_data = 0;
            cos_queue_mask = 0;
            ov = (data >> 4) & 0x3;
            om = (mask >> 4) & 0x3;
            switch(om) {
                case 0x0:
                case 0x3:
                    nm = om;
                    nv = ov + 1;
                    break;
                case 0x1:
                    switch(ov) {
                        case 0x0:
                        case 0x2:
                            nm = 0x1;
                            nv = 0x1;
                            break;
                        case 0x1:
                            nm = 0x3;
                            nv = 0x2;
                            break;
                    }
                    break;
                case 0x2:
                    switch (ov) {
                        case 0x0:
                        case 0x1:
                            /* Invalid DATA & MASK */
                            rv = BCM_E_PARAM;
                            break;
                        case 0x2:
                            nm = 0x3;
                            nv = 0x2;
                            break;
                        case 0x3:
                            /* Invalid DATA & MASK */
                            rv = BCM_E_PARAM;
                            break;
                    }
                    break;
                    /* coverity[dead_error_begin] */
                default:
                    /* Invalid DATA & MASK */
                    rv = BCM_E_PARAM;
            }

            if (BCM_E_NONE == rv) {

                /* Building new mask and new data */

                cos_queue_data = (data & ~(0x3 << 4)) | (nv << 0x4);
                cos_queue_mask = (mask & ~(0x3 << 4)) | (nm << 0x4);

                /* copying upper most two bits[5:4] of riginal mask and 00 into
                   MSB two bits[7:6] of new mask and new data respectively */

                cos_queue_data = (cos_queue_data & ~(0x3 << 6));
                cos_queue_mask  = (cos_queue_mask & ~(0x3 << 6)) | (om << 0x6);
            } else {
               return rv;
            }
        }
    }
#endif

    rv = _field_qualify32(unit, entry, qual, cos_queue_data, cos_queue_mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}
/*
 * Function:
 *      _field_qualify_cpu_queue_get
 *
 * Purpose:
 *      Utility routine to extract qualifier cos queue data and mask.
 * Parameters:
 *      unit            - (IN) BCM device number
 *      entry           - (IN) Entry ID
 *      qual            - (IN) Qualifier field
 *      data            - (OUT) Qualifier data
 *      mask            - (OUT) Qualifier mask
 *
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 */
int
_field_qualify_cpu_queue_get(int unit, bcm_field_entry_t entry,
                         int qual, uint8 *data, uint8 *mask)
{
    int rv = BCM_E_NONE;

#if defined(BCM_TRIDENT2_SUPPORT)
    _field_entry_t *f_ent;
    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);
#endif

    if (NULL == data || NULL == mask) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry,
                       bcmFieldQualifyCpuQueue, data, mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TRIDENT2(unit) || SOC_IS_TITAN2(unit)) {
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {

            *mask = ((*mask & 0xf) | ((*mask & 0xc0) >> 0x2));
            if (*mask & 0x10) {
                *data = *data - 0x10;
            } else {
                *data = *data & *mask;
            }
        }
    }
#endif

    return rv;
}
/*
 * Function:
 *      _field_qualify_ip6_get
 *
 * Purpose:
 *      Utility routine to extract qualifier IPv6 data and mask.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     entry  - (IN) BCM field entry id.
 *     qual   - (IN) Qualifier id.
 *     flags  - (IN) Part of IPv6 address specification.
 *     data   - (OUT) Qualifier data.
 *     mask   - (OUT) Qualifier mask.
 * Returns:
 *     BCM_E_XXX
 */

int
_field_qualify_ip6_get(int unit, bcm_field_entry_t entry,
                   bcm_field_qualify_t qual,
                   bcm_ip6_t *data, bcm_ip6_t *mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    uint8                    ref_offset;
    int                      rv;
    int                      i;

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(ref_data, 0, 4 * sizeof(uint32));
    sal_memset(ref_mask, 0, 4 * sizeof(uint32));
    switch(qual) {
      case bcmFieldQualifySrcIp6High:
      case bcmFieldQualifyDstIp6High:
      case bcmFieldQualifyInnerSrcIp6High:
      case bcmFieldQualifyInnerDstIp6High:
          ref_offset = 2;
          break;
      default:
          ref_offset = 0;
    }

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_th_entry_qualifier_key_get(unit, entry, qual,
                                                  ref_data, ref_mask);
       BCM_IF_ERROR_RETURN(rv);
    } else if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {

        /* Read qualifier match value and mask. */
        rv = _bcm_field_th_class_entry_qualifier_key_get(unit, entry, qual,
                                                         ref_data, ref_mask);
        BCM_IF_ERROR_RETURN(rv);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Get qualifier offsets in the tcam. */
       rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
       BCM_IF_ERROR_RETURN(rv);

       /* Read qualifier match value and mask. */
       rv = _bcm_field_qual_value_get(unit, q_offset, f_ent,
                                      ref_data, ref_mask);
       BCM_IF_ERROR_RETURN(rv);
    }

    /* Rearrange data and mask according to reference offset */
    for (i = (_FP_QUAL_DATA_WORDS - 1); i >= ref_offset ; i--) {
         ref_data[i] = ref_data[i - ref_offset];
         ref_mask[i] = ref_mask[i - ref_offset];
    }
    for (i = 0; i < ref_offset; i++) {
         ref_data[i] = 0x0;
         ref_mask[i] = 0x0;
    }

    SAL_IP6_ADDR_FROM_UINT32((*data), ref_data);
    SAL_IP6_ADDR_FROM_UINT32((*mask), ref_mask);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualify_ip6
 *
 * Purpose:
 *      Utility routine for qualify APIs taking IPv6 data and mask.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     entry  - (IN) BCM field entry id.
 *     qual   - (IN) Qualifier id.
 *     data   - (IN) Qualifier data.
 *     mask   - (IN) Qualifier mask.
 * Returns:
 *     BCM_E_XXX
 */

int
_field_qualify_ip6(int unit, bcm_field_entry_t entry,
                   bcm_field_qualify_t qual,
                   bcm_ip6_t data, bcm_ip6_t mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    uint8                    ref_offset;
    int                      rv;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qualify_ip6\n")));

    /* Initialization. */
    switch(qual) {
      case bcmFieldQualifySrcIp6High:
      case bcmFieldQualifyDstIp6High:
      case bcmFieldQualifyInnerSrcIp6High:
      case bcmFieldQualifyInnerDstIp6High:
          ref_offset = 2;
          break;
      default:
          ref_offset = 0;
    }

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    SAL_IP6_ADDR_TO_UINT32(data, ref_data);
    SAL_IP6_ADDR_TO_UINT32(mask, ref_mask);

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, entry, qual,
                                          ref_data + ref_offset,
                                          ref_mask + ref_offset,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, entry, qual,
                                                ref_data + ref_offset,
                                                ref_mask + ref_offset));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        /* Redirect to _field_efp_qualify32 for egress stage */
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
            return _field_efp_qualify32(unit, entry, qual,
                                        ref_data + ref_offset,
                                        ref_mask + ref_offset);
        }
    }
#endif

    /* Program data/mask pair to tcam buffer. */
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for ref_data and ref_mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent,
                                   ref_data + ref_offset,
                                   ref_mask + ref_offset);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualify_L2PayloadFirstEightBytes_get
 *
 * Purpose:
 *      Utility routine to extract qualifier L2PayloadFirstEightBytes
 *      data and mask.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     entry  - (IN) BCM field entry id.
 *     qual   - (IN) Qualifier id.
 *     data1   - (OUT) Qualifier first four bytes of match data.
 *     data2   - (OUT) Qualifier last four bytes of match data.
 *     mask1   - (OUT) Qualifier first four bytes of match mask.
 *     mask2   - (OUT) Qualifier last four bytes of match mask.
 * Returns:
 *     BCM_E_XXX
 */

int
_field_qualify_L2PayloadFirstEightBytes_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_field_qualify_t qual,
                                            uint32 *data1, uint32 *data2,
                                            uint32 *mask1, uint32 *mask2)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;

    /* Input parameters check. */
    if ((NULL == data1) || (NULL == data2) ||
        (NULL == mask1) || (NULL == mask2)) {
        return (BCM_E_PARAM);
    }

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_th_entry_qualifier_key_get(unit, entry, qual,
                                                  ref_data, ref_mask);
       BCM_IF_ERROR_RETURN(rv);
    } else if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {

        /* Read qualifier match value and mask. */
        rv = _bcm_field_th_class_entry_qualifier_key_get(unit, entry, qual,
                                                         ref_data, ref_mask);
        BCM_IF_ERROR_RETURN(rv);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Get qualifier offsets in the tcam. */
       rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
       BCM_IF_ERROR_RETURN(rv);

       /* Read qualifier match value and mask. */
       rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, ref_data,
                                      ref_mask);
       BCM_IF_ERROR_RETURN(rv);
    }

    _FP_UNPACK_L2_EIGHT_BYTES_PAYLOAD(ref_data, data1, data2);
    _FP_UNPACK_L2_EIGHT_BYTES_PAYLOAD(ref_mask, mask1, mask2);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualify_L2PayloadFirstEightBytes
 *
 * Purpose:
 *      Utility routine for qualify L2PayloadFirstEightBytes
 *      data and mask.
 *
 * Parameters:
 *     unit   - (IN) BCM device number
 *     entry  - (IN) BCM field entry id.
 *     qual   - (IN) Qualifier id.
 *     data1  - (IN) Qualifier first four bytes of match data.
 *     data2  - (IN) Qualifier last four bytes of match data.
 *     mask1  - (IN) Qualifier first four bytes of match mask.
 *     mask2  - (IN) Qualifier last four bytes of match mask.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_field_qualify_L2PayloadFirstEightBytes(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t qual,
                                        uint32 data1, uint32 data2,
                                        uint32 mask1, uint32 mask2)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_qualify_L2PayloadFirstEightBytes\n")));

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    _FP_PACK_L2_EIGHT_BYTES_PAYLOAD(data1, data2, ref_data);
    _FP_PACK_L2_EIGHT_BYTES_PAYLOAD(mask1, mask2, ref_mask);

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, entry, qual,
                                          ref_data, ref_mask,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, entry, qual,
                                                ref_data, ref_mask));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Program data/mask pair to tcam buffer. */
   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for ref_data and ref_mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, ref_data,
                                   ref_mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_shift_down
 * Purpose:
 *
 * Parameters:
 *     unit     - BCM device number
 *     target_fs - slice where the entry in prio_set should go
 *     target_index - corresponding index
 *     next_null_fs - slice which contains a NULL entry after target_index
 *     next_null_index - corresponding index
 * Returns:
 *     BCM_E_NONE   - Success
 */
STATIC int
_field_entry_shift_down(int unit, _field_group_t *fg,
                        _field_slice_t *target_fs, uint16 target_index,
                        _field_slice_t *next_null_fs, uint16 next_null_index)
{
    uint16              slice_idx_empty;
    _field_stage_t      *stage_fc;
    int                 slice_sz;
    int                 tmp_idx1;
    int                 tmp_idx2;
    _field_slice_t      *fs;
    int                 rv;

    /* Input parameter check. */
    if ((NULL == target_fs) || (NULL == fg) || (NULL == next_null_fs))  {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, target_fs->stage_id,
                                                 &stage_fc));

    slice_idx_empty = next_null_index;
    fs = next_null_fs;

    /*
     * Move entries one step down
     *     starting from the last entry
     * IDEA:
     *     when in different slices, target_fs != fs
     *     when in same slice, move till slice_idx_empty > target_index
     */
    while ((slice_idx_empty > target_index) || (target_fs != fs)) {
        /* Move the entry at the previous index to the empty index. */
        if (slice_idx_empty == 0) {
            /* Get number of entries in slice. */
            _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs->prev, slice_sz);

            /* Get higher slice first entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number, 0,
                                                     &tmp_idx1);
            BCM_IF_ERROR_RETURN(rv);

            /* Get lower slice last entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->prev->slice_number,
                                                     slice_sz - 1, &tmp_idx2);
            BCM_IF_ERROR_RETURN(rv);

            /* Perform entry move. */
            rv = _field_entry_move(unit, fs->prev->entries[slice_sz-1],
                                   (tmp_idx1 - tmp_idx2));
            BCM_IF_ERROR_RETURN(rv);

            slice_idx_empty = slice_sz - 1;
            fs = fs->prev;
        } else {
            /* Get higher entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number,
                                                     slice_idx_empty,
                                                     &tmp_idx1);
            BCM_IF_ERROR_RETURN(rv);

            /* Get lower entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number,
                                                     slice_idx_empty - 1,
                                                     &tmp_idx2);
            BCM_IF_ERROR_RETURN(rv);

            /* Perform entry move. */
            rv = _field_entry_move(unit, fs->entries[slice_idx_empty - 1],
                                   (tmp_idx1 - tmp_idx2));
            BCM_IF_ERROR_RETURN(rv);

            slice_idx_empty--;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_entry_shift_up
 * Purpose:
 *
 * Parameters:
 *     unit     - BCM device number
 *     target_fs - slice where the entry in prio_set should go
 *     target_index - corresponding index
 *     prev_null_fs - slice which contains a NULL entry before target_index
 *     prev_null_index - corresponding index
 * Returns:
 *     BCM_E_NONE   - Success
 */
STATIC int
_field_entry_shift_up(int unit, _field_group_t *fg,
                      _field_slice_t *target_fs, uint16 target_index,
                      _field_slice_t *prev_null_fs, uint16 prev_null_index)
{
    uint16              slice_idx_empty;
    _field_stage_t      *stage_fc;
    int                 slice_sz;
    int                 tmp_idx1;
    int                 tmp_idx2;
    _field_slice_t      *fs;
    int                 rv;

    /* Input parameter check. */
    if ((NULL == target_fs) || (NULL == fg) || (NULL == prev_null_fs))  {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, target_fs->stage_id,
                                                 &stage_fc));

    slice_idx_empty = prev_null_index;
    fs = prev_null_fs;

    while ((slice_idx_empty < target_index) || (fs != target_fs)) {
        /* Move the entry at the next index to the prev. empty index. */
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        if (slice_idx_empty == (slice_sz - 1)) {
            /* Get lower slice last entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number,
                                                     slice_sz - 1, &tmp_idx1);
            BCM_IF_ERROR_RETURN(rv);

            /* Get upper slice first entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->next->slice_number,
                                                     0, &tmp_idx2);
            BCM_IF_ERROR_RETURN(rv);

            /* Perform entry move. */
            rv = _field_entry_move(unit, fs->next->entries[0],
                                   (tmp_idx1 - tmp_idx2));
            BCM_IF_ERROR_RETURN(rv);

            fs = fs->next;
            slice_idx_empty = 0;
        } else {
            /* Get lower entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number,
                                                     slice_idx_empty,
                                                     &tmp_idx1);
            BCM_IF_ERROR_RETURN(rv);

            /* Get higher entry tcam index. */
            rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                                     fg->instance,
                                                     fs->slice_number,
                                                     slice_idx_empty + 1,
                                                     &tmp_idx2);
            BCM_IF_ERROR_RETURN(rv);

            /* Perform entry move. */
            rv = _field_entry_move(unit, fs->entries[slice_idx_empty + 1],
                                   (tmp_idx1 - tmp_idx2));
            BCM_IF_ERROR_RETURN(rv);

            slice_idx_empty++;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function: _field_entry_prio_set
 *
 * Purpose:
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Field entry to operate on
 *
 * Returns:
 *     BCM_E_NONE       Success
 *
 * Notes:
 *     The earlier checks guarantee that there is a free slot somewhere
 *     i.e. in one of the alloted slices for the group.
 */
int
_field_entry_prio_set(int unit, bcm_field_entry_t entry, int prio)
{
    int                 slice_idx_target = 0;
    int                 temp;
    int                 temp1;
    int                 slice_idx_old;
    int                 idx;
    _field_control_t    *fc;
    _field_group_t      *fg;
    _field_slice_t      *fs;
    _field_stage_t      *stage_fc;
    _field_entry_t      *f_ent;
    int parts_count = 0;
    int rv;
    int slice_sz;
    _field_slice_t  *prev_null_fs = NULL;
                        /* The last NULL entry b4 target loc */
    _field_slice_t  *target_fs = NULL;
                        /* The target slice */
    _field_slice_t  *next_null_fs = NULL;
                        /* The next NULL entry after target loc */
    _field_slice_t  *first_null_fs = NULL;
    int prev_null_index = -1;
    int next_null_index = -1;
    int first_null_index = -1;
    int first_null_flag = 0;
    int dir = -1; /* Direction of shift: -1 = UP, 1 = DOWN */
    int decr_on_shift_up = TRUE;
    int flag_no_free_entries = FALSE;

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    fg = f_ent->group;
    fs = f_ent->fs;

    if (fg->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        rv = fc->functions.fp_external_entry_prio_set(unit, f_ent, prio);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Priority cannot be set for exact match entries. */
    if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        rv = BCM_E_UNAVAIL;
        return (rv);
    }
    /* Priority set for class entries. */
    if (fg->stage_id == _BCM_FIELD_STAGE_CLASS) {
        rv = _bcm_field_th_class_entry_prio_set(unit, f_ent, prio);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    prio_set_with_no_free_entries = FALSE; /* Global variable */

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * If priority is changing, but still in proper place,
     * just goto end (change the f_ent->prio to prio)
     */
    if (_field_reqd_prio_set_move(unit, f_ent, prio) == FALSE) {
        goto end;
    }

    _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);

    slice_idx_old = f_ent->slice_idx;
    if (slice_idx_old >= slice_sz) {
        return (BCM_E_INTERNAL);
    }

    if (_field_no_free_entries(unit, fg) == TRUE) {
        if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
            /*
             * As there are no free entries in any of the slices belonging to
             * this group, and this entry is NOT installed,
             *     fake that it does not exist.
             */
            f_ent->fs->entries[f_ent->slice_idx] = NULL;
            flag_no_free_entries = TRUE;
        } else {
            return BCM_E_CONFIG;
        }
    }

    /* Find the target slice index. That is the one with the highest index
     * for this priority class. */
    fs = &fg->slices[0];
    while (fs != NULL) {
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        for (slice_idx_target = 0;
             slice_idx_target < slice_sz;
             slice_idx_target++) {

            /* Skip the f_ent itself */
            if (f_ent == fs->entries[slice_idx_target]) {
                continue;
            }
            if (fs->entries[slice_idx_target] == NULL) {
                prev_null_fs = fs;
                prev_null_index = slice_idx_target;
                if (first_null_flag == 0) {
                   first_null_fs = fs;
                   first_null_index = slice_idx_target;
                   first_null_flag = 1;
                }
                continue;
            } else {
                first_null_flag = 0;
            }

            if (_field_entry_prio_cmp(prio, fs->entries[slice_idx_target]->prio)
                > 0) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "FP(unit %d) vverb: Found target slice_idx=%d\n"),
                           unit, slice_idx_target));
                target_fs = fs;
                break;
            }

        }
        if (slice_idx_target < slice_sz) {
            break;
        }
        fs = fs->next;
    }
    temp = slice_idx_target;
    while (fs != NULL) {
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        for (; temp < slice_sz; temp++) {
            if (fs->entries[temp] == NULL) {
                next_null_fs = fs;
                next_null_index = temp;
                break;
            }
        }
        if (next_null_fs != NULL) {
            break;
        }
        fs = fs->next;
        temp = 0;
    }

    /*
     * Put the entry back,
     *     in case there is a context switch, AND
     *     another thread calls entry_create
     */
    if (flag_no_free_entries == TRUE) {
        f_ent->fs->entries[f_ent->slice_idx] = f_ent;
    }

    if ((prev_null_fs == NULL) && (next_null_fs == NULL)) {
        return BCM_E_CONFIG; /* No free entries to move */
    }

    if (target_fs == NULL) {
        /*
         * target_fs will be NULL when the target location is after
         * the last entry in slice.
         * Now,
         *   1. There may be NULL entries after last entry
         *       Insert entry there
         *   2. The last entry is at last location in (last) slice
         *       Need to do a shift_up to free-up the last location.
         */
/*
 *  Case 1:
 *  |-------------|
 *  |       6     |
 *  |-------------|
 *  |       5     |
 *  |-------------|
 *  |       4     |<--- change priority to 1
 *  |-------------|
 *  |       3     |
 *  |-------------|
 *  |       2     |
 *  |-------------|
 *  |     .       |
 *  |NULL .entries|
 *  |     .       |
 *  |-------------|
 *
 *  becomes                  |-------------|
 *                           |       6     |
 *                           |-------------|
 *                           |       5     |
 *                           |-------------|
 *                           |    NULL     |
 *                           |-------------|
 *                           |       3     |
 *                           |-------------|
 *                           |       2     |
 *                           |-------------|
 *                           |     .       |
 *                           |NULL .entries|
 *                           |     1       |<--- comes to the end.
 *                           |-------------|
 *
 *  Case 2:
 *  |-------------|
 *  |     .       |
 *  |NULL .entries|
 *  |     .       |
 *  |-------------|
 *  |       6     |
 *  |-------------|
 *  |       5     |
 *  |-------------|
 *  |       4     |<--- change priority to 1
 *  |-------------|
 *  |       3     |
 *  |-------------|
 *  |       2     |
 *  |-------------|
 *
 *  becomes                  |-------------|
 *                           |     .       |
 *                           |NULL .entries|
 *                           |       6     |
 *                           |-------------|
 *                           |       5     |
 *                           |-------------|
 *                           |     NULL    |
 *                           |-------------|
 *                           |       3     |
 *                           |-------------|
 *                           |       2     |
 *                           |-------------|
 *                           |       1     |<--- comes to the end,
 *                           |-------------|           others shift UP
 *
 */
        fs = &fg->slices[0];
        while (fs->next != NULL) {
            fs = fs->next;
        }
        _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, fs, slice_sz);
        if ((fs == prev_null_fs) &&
            (prev_null_index == slice_sz - 1) &&
            (first_null_flag == 1)) {
            target_fs = first_null_fs;
            slice_idx_target = first_null_index;
            goto only_move;
        } else {
            target_fs = fs;
            slice_idx_target = slice_sz - 1;
            decr_on_shift_up = FALSE;
        }
    }


    /*
     * Check if the movement is feasible
     * If group spans across slices, need to verify that
     * entries moving across slices do not have shared meters, counters
     * AND that new slice has meter, counter available, if required
     */
    if (_field_validate_prio_set(unit, fg, f_ent,
                                 prev_null_index, prev_null_fs,
                                 slice_idx_target, target_fs,
                                 next_null_index, next_null_fs,
                                 &dir) == FALSE) {
        return (BCM_E_PARAM);
    }

    if (dir == 1) {
        /*
         * Move the entry at the target index to target_index+1. This may
         * mean shifting more entries down to make room. In other words,
         * shift the target index and any that follow it down 1 as far as the
         * next empty index.
         */
        if (target_fs->entries[slice_idx_target] != NULL) {
            rv = _field_entry_shift_down(unit, fg,
                                         target_fs, slice_idx_target,
                                         next_null_fs, next_null_index);
            BCM_IF_ERROR_RETURN(rv);
        }
    } else {
        /*
         * Similar thing for Shifting UP
         *     Depends on if this falls into Case-2 in the fig. above.
         */
        if (decr_on_shift_up == TRUE) {
            slice_idx_target--;
            if (slice_idx_target == -1) {
                target_fs = target_fs->prev;
                /*
                 * Certain devices have physical slices of different sizes.
                 * So, determine the target index based on the new target slice.
                 */
                _BCM_FIELD_ENTRIES_IN_SLICE(unit, fg, target_fs, slice_sz);
                slice_idx_target = slice_sz - 1;
            }
        }
        if (target_fs->entries[slice_idx_target] != NULL) {
            rv = _field_entry_shift_up(unit, fg,
                                       target_fs, slice_idx_target,
                                       prev_null_fs, prev_null_index);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    /* Move the entry from its old slice index to the target slice index. */
only_move:
    rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                             fg->instance,
                                             target_fs->slice_number,
                                             slice_idx_target, &temp);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                                             fg->instance,
                                             f_ent->fs->slice_number,
                                             f_ent->slice_idx, &temp1);
    BCM_IF_ERROR_RETURN(rv);

    if ((temp - temp1) != 0) {
        if (flag_no_free_entries) {
            prio_set_with_no_free_entries = TRUE;
        }

        rv = _field_entry_move(unit, f_ent, (temp - temp1));
        if (BCM_FAILURE(rv)) {
            prio_set_with_no_free_entries = FALSE;
            return rv;
        }

        /* in case _field_entry_move is called from some other function */
        prio_set_with_no_free_entries = FALSE;
    }

end:
    /* Assign the requested priority to the entry. */
    for (idx = 0; idx < parts_count; idx++) {
        f_ent[idx].prio = prio;
    }

    if (fg->group_status.prio_max < prio) {
        fg->group_status.prio_max = prio;
    }
    if (0 <= prio &&
        (prio < fg->group_status.prio_min || fg->group_status.prio_min < 0)) {
        fg->group_status.prio_min = prio;
    }

    return (BCM_E_NONE);
}

#ifdef BCM_WARM_BOOT_SUPPORT
int _field_table_read(int unit, soc_mem_t mem, char **buffer_p,
    const char *buffer_name_p)
{
    int index_min;
    int index_max;
    int rv;

    *buffer_p = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES(unit, mem),
        buffer_name_p);

    if (*buffer_p == NULL)
    {
        return BCM_E_MEMORY;
    }

    index_min = soc_mem_index_min(unit, mem);
    index_max = soc_mem_index_max(unit, mem);

    rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY, index_min, index_max,
        *buffer_p);

    return rv;
}
#endif /* BCM_WARM_BOOT_SUPPORT */

/*
 * Function: _bcm_field_valid_pbmp_get
 *
 * Purpose:
 *     Returns valid PBMP
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     pbm  - (OUT) Pbmp structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_valid_pbmp_get(int unit, bcm_pbmp_t *pbm)
{
    bcm_pbmp_t         valid_pbm;    /* Holds valid pbm supported */
    bcm_port_config_t  port_config;  /* Device port config structure. */

    /* Retrieve valid ports */
    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
    BCM_PBMP_CLEAR(valid_pbm);
    BCM_PBMP_ASSIGN(valid_pbm, port_config.all);

#ifdef BCM_KATANA2_SUPPORT
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &valid_pbm);
    }
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &valid_pbm));
    }
#endif /* BCM_KATANA2_SUPPORT */

    BCM_PBMP_ASSIGN(*pbm, valid_pbm);
    return BCM_E_NONE;
}

/*
 * Function: _bcm_field_qualify_InPorts
 *
 * Purpose:
 *     Initialize entry qualifiers for all ports
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     entry - (IN) Field entry structure.
 *     data - (IN) Field pbmp structure.
 *     mask - (IN) Field pbmp structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qualify_InPorts(int unit,
                           bcm_field_entry_t entry,
                           bcm_field_qualify_t qual,
                           bcm_pbmp_t data,
                           bcm_pbmp_t mask)
{
    int                rv;
    bcm_pbmp_t         temp_pbm;     /* Holds temp pbmp */
    bcm_pbmp_t         valid_pbm;    /* Holds valid pbm supported */
    _field_group_t     *fg;
    _field_entry_t     *f_ent;

    rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifyInPorts, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Confirm that InPorts is in group's Qset. */
    fg = f_ent->group;
    if (!BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInPorts)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "Error: InPorts part of entry group's[%d] QSET.\n\r"),
                  fg->gid));
        return (BCM_E_PARAM);
    }

    /*
     * Validate InPorts data PBMP with group's PBMP.
     * Ports in InPorts pbmp should be part of group's PBMP.
     */
    BCM_PBMP_ASSIGN(temp_pbm, data);
    BCM_PBMP_OR(temp_pbm, fg->pbmp);
    if (BCM_PBMP_NEQ(temp_pbm, fg->pbmp)) {
        return BCM_E_PARAM;
    }

    rv = _bcm_field_valid_pbmp_get(unit, &valid_pbm);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }
    /* Check and clear invalid ports in the mask. */
   BCM_PBMP_AND(mask, valid_pbm);

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_ingress_ipbm)) {
        bcm_pbmp_t          lb_pbm;

        /* Add data & mask to entry. */
        BCM_PBMP_ASSIGN(f_ent->pbmp.data, data);
        BCM_PBMP_ASSIGN(f_ent->pbmp.mask, mask);

        /* Add loopback port to ipbm mask to avoid false ingress port match */
        BCM_PBMP_ASSIGN(lb_pbm, PBMP_LB(unit));
        if (BCM_PBMP_NOT_NULL(lb_pbm)) {
            BCM_PBMP_OR(f_ent->pbmp.mask, PBMP_LB(unit));
        }
        f_ent->flags |= _FP_ENTRY_DIRTY;
        f_ent->flags &= ~(_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY);

        return (BCM_E_NONE);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInPorts,
                          SOC_PBMP_WORD_GET(data, 0),
                          SOC_PBMP_WORD_GET(mask, 0));
    return (rv);
}

/*
 * Function: _field_entry_qualifiers_init
 *
 * Purpose:
 *     Initialize entry qualifiers based on a group qset.
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     f_ent - (IN/OUT) Field entry structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_entry_qualifiers_init(int unit, _field_entry_t *f_ent)
{
    int                 count;        /* Number of ports.             */
    bcm_port_t          port;         /* Port iterator.               */
    _field_group_t      *fg;          /* Field group info.            */
    int                 rv;           /* Operation return status.     */
    _field_control_t    *fc;          /* Field control structure.     */
    _field_stage_t      *stage_fc;    /* Stage field control info.    */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    int                 parts_count = 0;  /* Field entry parts count.     */
    int                 idx;          /* Parts iteration index.       */
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    bcm_port_config_t  port_config;   /* Device port config structure.*/
    bcm_pbmp_t all_pbmp;
    bcm_pbmp_t data_pbmp;
    bcm_pbmp_t valid_mask;

    fg = f_ent->group;

    /* Read device port configuration. */
    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * If the group has bcmFieldQualifyInPorts in its Qset, qualify the entry
     * on the group's port bitmap.
     */
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInPorts)) {
        if (fg->flags & _FP_GROUP_PER_PORT_OR_PBMP) {
            BCM_PBMP_ASSIGN(data_pbmp, fg->pbmp);
            BCM_PBMP_ASSIGN(valid_mask, all_pbmp);
        } else {
            BCM_PBMP_CLEAR(data_pbmp);
            BCM_PBMP_CLEAR(valid_mask);
        }
        BCM_PBMP_OR(valid_mask, PBMP_LB(unit));
        rv = fc->functions.fp_qualify_inports(unit,
                f_ent->eid,
                bcmFieldQualifyInPorts,
                data_pbmp,
                valid_mask);
        BCM_IF_ERROR_RETURN(rv);
    }
    /*
     * If the group has bcmFieldQualifyOutPorts in its Qset, qualify the entry
     * on the group's port bitmap.
     */
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyOutPorts)) {
        rv = bcm_esw_field_qualify_OutPorts(unit, f_ent->eid, fg->pbmp,
                                            all_pbmp);
        BCM_IF_ERROR_RETURN(rv);
    }
    /*
     * If the group has bcmFieldQualifyInPort in its Qset, and there is only
     * one port in the group's pbmp, then qualify on that port.
     */
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInPort)) {
        BCM_PBMP_COUNT(fg->pbmp, count);
        if (count == 1) {
            BCM_PBMP_ITER(fg->pbmp, port) {
                rv = bcm_esw_field_qualify_InPort(unit, f_ent->eid, port,
                                                  BCM_FIELD_EXACT_MATCH_MASK);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
    }

    /*
     *  If the group has bcmFieldQualifyIp4/6 in Qset add IpType
     * default value to the entry.
     */
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4) &&
        (fg->stage_id != _BCM_FIELD_STAGE_EXTERNAL)) {
        rv = bcm_esw_field_qualify_IpType(unit, f_ent->eid, bcmFieldIpTypeIpv4Any);
        BCM_IF_ERROR_RETURN(rv);
    }

    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp6) &&
        (fg->stage_id != _BCM_FIELD_STAGE_EXTERNAL)) {
        rv = bcm_esw_field_qualify_IpType(unit, f_ent->eid, bcmFieldIpTypeIpv6);
        BCM_IF_ERROR_RETURN(rv);
    }

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDstGport) ||
        BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcGport)) {
        f_ent->dvp_type = f_ent->svp_type = _bcmVpTypeAny;
    }
#endif

    /*
     *  Set key match type for egress FP.
     */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (_BCM_FIELD_STAGE_EGRESS == fg->stage_id) {

        /* Get number of parts in field entry based on group flags. */
        rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                                fg->flags, &parts_count);
        BCM_IF_ERROR_RETURN(rv);

        for (idx = 0; idx < parts_count; idx++) {
            rv = fc->functions.fp_egress_key_match_type_set(unit, f_ent + idx);
            BCM_IF_ERROR_RETURN(rv);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT  */

    /*
     * If the group supports Preselector, qualify the entry on the
     * Preselector logical table Id.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (fg->flags & _FP_GROUP_PRESELECTOR_SUPPORT) {
       if (BCM_FIELD_QSET_TEST(fg->qset, _bcmFieldQualifyPreLogicalTableId) &&
           (fg->lt_id != -1)) {
           uint32   data, mask;

           data = fg->lt_id;
           mask = BCM_FIELD_EXACT_MATCH_MASK;
           /* coverity[address_of : FALSE] */
           /* coverity[callee_ptr_arith : FALSE] */
           rv = _bcm_field_th_qualify_set(unit, f_ent->eid,
                                          _bcmFieldQualifyPreLogicalTableId,
                                          &data, &mask, _FP_QUALIFIER_ADD);
           BCM_IF_ERROR_RETURN(rv);
       } else {
           return BCM_E_INTERNAL;
       }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
    f_ent->eth_oam_ctrl_mep_type = 0;
    f_ent->eth_oam_data_mep_type = 0;
    f_ent->mpls_oam_ctrl_mep_type = 0;
    f_ent->mpls_oam_data_mep_type = 0;
#endif
    return (BCM_E_NONE);
}

/*
 * Function: _field_entry_create_id
 *
 * Purpose:
 *     Create a blank entry group based on a group;
 *     allows selection of a specific slot in a slice
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry - (IN) Requested entry ID; must be in the range prio_min through
 *             prio_max as returned by bcm_field_group_status_get().
 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_EXISTS    - Entry ID already in use
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_MEMORY    - allocation failure
 *     BCM_E_NONE      - Success
 */
int
_field_entry_create_id(int unit, bcm_field_group_t group,
                       bcm_field_entry_t entry)
{
    _field_stage_t      *stage_fc;    /* Stage field control info.    */
    _field_group_t      *fg;          /* Field group info.            */
    _field_slice_t      *fs_pri = NULL; /* Primary slice pointer.       */
    _field_entry_t      *f_ent;       /* Allocated entry buffer.      */
    int                 rv;           /* Operation return status.     */

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "FP(unit %d) vverb: bcm_esw_field_entry_create_id(group=%d,"
              " entry=%d)\n"), unit, group, entry));

    /* Confirm that 'entry' is not already used on unit */
    if (BCM_SUCCESS(_field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent))) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "FP(unit %d) Error: entry=(%d) already exists.\n"),
                   unit, entry));
        return (BCM_E_EXISTS);
    }

    /* Get group control structure. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "FP(unit %d) Error: group=(%d) group get failure.\n"),
                   unit, group));
        return (rv);
    }


    /* Get group stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                   "FP(unit %d) Error: Stage (%d) control get failure.\n"),
                   unit, fg->stage_id));
        return (rv);
    }

    /* Reserve a slice with room for new entry. */
    rv = _field_group_slice_entry_reserve(unit, fg, &fs_pri);
    if (BCM_FAILURE(rv)) {
        if(entry != _FP_INTERNAL_RESERVED_ID) {
           LOG_ERROR(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "FP(unit %d) Error: Group (%d) no room.\n"),
                      unit, group));
        } else {
           LOG_VERBOSE(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "FP(unit %d) Warning: Group (%d) no room."
                                 " Hitless update cannot be done due to "
                                 "resource constraints\n"),
                      unit, group));
        }
        return (rv);
    }

    /* Create entry in primary slice. */
    rv = _field_entry_phys_create(unit, stage_fc, entry,
                                  BCM_FIELD_ENTRY_PRIO_LOWEST,
                                  fs_pri, fg, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Initialize entry qualifiers based on group qset. */
    rv = _field_entry_qualifiers_init(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        _field_entry_phys_destroy(unit, f_ent);
        return (rv);
    }
    return (BCM_E_NONE);
}

/* Function    : _field_tpid_hw_decode
 * Description : Encode tpid value to hw specific value.
 * Parameters  : (IN) unit   BCM driver unit
 *               (IN) hw_code HW code.
 *               (OUT) tpid  decoded TPID
 * Returns     : BCM_E_XXX
 */
int
_field_tpid_hw_decode(int unit, uint32 hw_code, uint16 *tpid)
{
    switch (hw_code) {
      case 0x0:
          *tpid = 0x8100;
          break;
      case 0x1:
          *tpid = 0x9100;
          break;
      case 0x2:
          *tpid = 0x88a8;
          break;
      default:
          return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}

/* Function    : _bcm_field_tpid_hw_encode
 * Description : Encode tpid value to hw specific value.
 * Parameters  : (IN) unit   BCM driver unit
 *               (IN) tpid   TPID to encode
 *               (OUT) hw_code HW code.
 * Returns     : BCM_E_XXX
 */
int
_bcm_field_tpid_hw_encode(int unit, uint16 tpid, uint32 *hw_code)
{
    switch (tpid) {
      case 0x8100:
          *hw_code = 0x00;
          break;
      case 0x9100:
          *hw_code = 0x01;
          break;
      case 0x88a8:
          *hw_code = 0x02;
          break;
      default:
          *hw_code = 0x03;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_action_alloc
 * Purpose:
 *     Allocate and initialize an action structure.
 * Parameters:
 *     unit     - BCM device number.
 *     action   - Action to perform (bcmFieldActionXXX)
 *     param0   - Action parameter (use 0 if not required)
 *     param1   - Action parameter (use 0 if not required)
 *     param2   - Action parameter (use 0 if not required)
 *     param3   - Action parameter (use 0 if not required)
 *     param4   - Action parameter (use 0 if not required)
 *     param5   - Action parameter (use 0 if not required)
 *     fa (OUT) - pointer to field action structure
 * Returns:
 *     BCM_E_MEMORY - allocation failure
 *     BCM_E_NONE   - Success
 */
int
_field_action_alloc(int unit, bcm_field_action_t action,
                    uint32 param0, uint32 param1,
                    uint32 param2, uint32 param3,
                    uint32 param4, uint32 param5,
                    _field_action_t **fa)
{
    *fa = sal_alloc(sizeof (_field_action_t), "field_action");
    if (*fa == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: allocation failure for field_action\n"),
                   unit));
        return (BCM_E_MEMORY);
    }
    sal_memset(*fa, 0, sizeof (_field_action_t));

    (*fa)->action = action;
    (*fa)->param[0] = param0;
    (*fa)->param[1] = param1;
    (*fa)->param[2] = param2;
    (*fa)->param[3] = param3;
    (*fa)->param[4] = param4;
    (*fa)->param[5] = param5;
    (*fa)->hw_index = _FP_INVALID_INDEX;
    (*fa)->old_index = _FP_INVALID_INDEX;
    /* mark new action as not yet installed */
    (*fa)->flags |= (_FP_ACTION_VALID | _FP_ACTION_DIRTY);


    return (BCM_E_NONE);
}

/*
 * Function: _field_action_add
 *
 * Purpose:
 *     Add action performed when entry rule is matched for a packet
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     fc    - (IN) Field control structure.
 *     f_ent - (IN) Field entry id.
 *     fa    - (IN) Field action structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_action_add(int unit, _field_control_t *fc,
                  bcm_field_entry_t entry, _field_action_t *fa)
{
    _field_entry_t   *f_ent;            /* Field entry structure.       */
    _field_action_t  *fa_iter;          /* Field entry actions iterator.*/
    int               rv;               /* Operation return status.     */
#if defined(BCM_TRIDENT_SUPPORT)
    uint8                  idx;             /* entry pard Id  */
    bcm_field_action_t     action, action1;          /* Action type    */
    uint32                 entry_flags = 0; /* Entry flags    */
#endif
#if defined (BCM_TRIUMPH3_SUPPORT)
    uint32 bitIndex;
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    int supported = 0;                  /* Action Supported flag.     */
    int action_size = 0;                /* Action Size.               */
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        return _bcm_field_presel_action_add(unit, fc, entry, fa);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Confirm that action is in aset. */
    /* coverity[ptr_arith] */
    if (SHR_BITGET(f_ent->group->aset.w, fa->action) == 0) {
        if(f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
            if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
#if defined(BCM_TOMAHAWK_SUPPORT)
                BCM_IF_ERROR_RETURN(
                        _bcm_field_th_action_support_check(unit, f_ent,
                                                fa->action, &supported));
                if (!supported) {
#ifdef BROADCOM_DEBUG
                    LOG_ERROR(BSL_LS_BCM_FP,
                       (BSL_META_U(unit,
                        "FP(unit %d) Error: action=%s not supported\n"),
                         unit,_field_action_name(fa->action)));
#endif
                    return (BCM_E_UNAVAIL);
                }
#endif /* BCM_TOMAHAWK_SUPPORT */
            } else {
#ifdef BROADCOM_DEBUG
                LOG_ERROR(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                         "FP(unit %d) Error: action=%s not supported\n"),
                         unit,_field_action_name(fa->action)));
#endif
                    return (BCM_E_UNAVAIL);
            }
        } else {
#ifdef BROADCOM_DEBUG
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                     "FP(unit %d) Error: action=%s not supported\n"),
                     unit,_field_action_name(fa->action)));
#endif
            return (BCM_E_UNAVAIL);
        }
    }

#if defined BCM_TRIDENT2_SUPPORT || defined BCM_TOMAHAWK_SUPPORT
    /* Check if actions conflict with Statistics action */
    BCM_IF_ERROR_RETURN (_bcm_field_action_stat_conflict_check(unit, f_ent, fa));
#endif

    /* Oam Actions conflict with Nat actions */
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        if ((fa->action == bcmFieldActionNatEgressOverride)
                || (fa->action == bcmFieldActionNat)
                || (fa->action == bcmFieldActionNatCancel)) {
            if (f_ent->flags & _FP_ENTRY_OAM_STAT_VALID) {
#ifdef BROADCOM_DEBUG
                LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: action=%s conflicts with"
                                    " oam stat action in entry=%d\n"), unit,
                         _field_action_name(fa->action), entry ));
#endif
                return BCM_E_CONFIG;
            }
        }
    }

    /* Check for existing actions that conflict with the new action. */
    fa_iter = f_ent->actions;
    while (fa_iter != NULL) {
        if (0 == (fa_iter->flags & _FP_ACTION_VALID)) {
            fa_iter = fa_iter->next;
            continue;
        }
        rv = fc->functions.fp_action_conflict_check(unit,
                                                    f_ent,
                                                    fa_iter->action,
                                                    fa->action);
        if (BCM_FAILURE(rv)) {
#ifdef BROADCOM_DEBUG
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: action=%s conflicts with  "
                                  "existing action in entry=%d\n"), unit,
                       _field_action_name(fa->action), entry ));
#endif
            return (rv);
        }
        fa_iter = fa_iter->next;
    }
#if defined (BCM_TRIUMPH3_SUPPORT)
    if(SOC_IS_TRIUMPH3(unit)) {
        if(fa->action ==  bcmFieldActionReplaceSrcMac ||
           fa->action == bcmFieldActionReplaceDstMac ||
           fa->action == bcmFieldActionReplaceInnerVlan ||
           fa->action == bcmFieldActionReplaceOuterVlan ||
           fa->action == bcmFieldActionReplaceInnerVlanPriority  ||
           fa->action == bcmFieldActionReplaceOuterVlanPriority)  {
            fa_iter = f_ent->actions;
            fa->hw_index = -1;
            while (fa_iter != NULL) {
                if(fa_iter->action ==  bcmFieldActionReplaceSrcMac ||
                        fa_iter->action == bcmFieldActionReplaceDstMac ||
                        fa_iter->action == bcmFieldActionReplaceInnerVlan ||
                        fa_iter->action == bcmFieldActionReplaceOuterVlan ||
                        fa_iter->action == bcmFieldActionReplaceInnerVlanPriority  ||
                        fa_iter->action == bcmFieldActionReplaceOuterVlanPriority) {
                    fa->hw_index = fa_iter->hw_index;
                    break;
                }
                fa_iter = fa_iter->next;
            }

            if(fa->hw_index < 0) {
                bitIndex = 0;
                for (bitIndex=0; bitIndex < fc->_fp_egr_ifp_mod_fields_size;bitIndex++) {
                    if(SHR_BITGET(fc->field_action_l2mod_index_bmp.w,bitIndex) == 0) {
                        break;
                    }
                }
                SHR_BITSET(fc->field_action_l2mod_index_bmp.w,bitIndex);
                fa->hw_index = bitIndex;
            }
        }
    }
#endif

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) &&
        !soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if ((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            if (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                entry_flags = (_FP_ENTRY_PRIMARY | _FP_ENTRY_SECOND_HALF);
            } else {
                entry_flags = _FP_ENTRY_SECONDARY;
            }
            rv = _bcm_field_entry_flags_to_tcam_part(unit, entry_flags,
                                                     f_ent->group,
                                                     &idx);
            BCM_IF_ERROR_RETURN(rv);
            fa_iter = f_ent[idx].actions;
            while (fa_iter != NULL) {
                if (0 == (fa_iter->flags & _FP_ACTION_VALID)) {
                    fa_iter = fa_iter->next;
                    continue;
                }
                rv = fc->functions.fp_action_conflict_check(unit,
                                                            f_ent,
                                                            fa_iter->action,
                                                            fa->action);
                if (BCM_FAILURE(rv)) {
#ifdef BROADCOM_DEBUG
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "FP(unit %d) Error: action=%s conflicts with  "
                                          "existing action in entry=%d\n"), unit,
                               _field_action_name(fa->action), entry ));
#endif
                    return (rv);
                }
                fa_iter = fa_iter->next;
            }
        }
    }
#endif
    /* Check action parameters. */
    rv = fc->functions.fp_action_params_check(unit, f_ent, fa);
    if (BCM_FAILURE(rv)) {
#ifdef BROADCOM_DEBUG
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: action=%s parameters check failed (%d)\n"),
                   unit, _field_action_name(fa->action), rv));
#endif
        return (rv);
    }

    /* Check dependency(s) of action */
    if (fc->functions.fp_action_depends_check) {
        rv = (*fc->functions.fp_action_depends_check)(unit, f_ent, fa);
        if (BCM_FAILURE(rv)) {
#ifdef BROADCOM_DEBUG
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: action=%s dependency check failed (%d)\n"),
                       unit, _field_action_name(fa->action), rv));
#endif
            return (rv);
        }
    }


#if defined(BCM_TOMAHAWK_SUPPORT)
    if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
        rv = _field_th_em_entry_action_size_get(unit, f_ent,
                                                &action_size, NULL);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }

        if (action_size > EM_DEFAULT_POLICY_ACTION_DATA_SIZE) {
            return (BCM_E_RESOURCE);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (fa->action == bcmFieldActionColorIndependent) {
        if (fa->param[0])  {
            f_ent->flags |= _FP_ENTRY_COLOR_INDEPENDENT;
        } else {
            f_ent->flags &= ~_FP_ENTRY_COLOR_INDEPENDENT;
        }
        if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
            f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        }
        f_ent->flags  |= _FP_ENTRY_DIRTY;
        sal_free(fa);
        return (BCM_E_NONE);
    }

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) && !SOC_IS_TOMAHAWKX(unit)) {
        if ((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            switch(fa->action) {
                case bcmFieldActionCosQCpuNew:
                    action = bcmFieldActionServicePoolIdNew;
                    action1 = bcmFieldActionServicePoolIdPrecedenceNew;
                    break;
                case bcmFieldActionServicePoolIdNew:
                case bcmFieldActionServicePoolIdPrecedenceNew:
                    action = bcmFieldActionCosQCpuNew;
                    action1 = -1;
                    break;
                default:
                    action = bcmFieldActionCount;
                    break;
            }
            if (action != bcmFieldActionCount) {
                for (fa_iter = f_ent->actions;
                     fa_iter != NULL;
                     fa_iter = fa_iter->next) {
                    if (((fa_iter->action == action) ||
                         (fa_iter->action == action1)) &&
                        (fa_iter->flags & _FP_ACTION_VALID)) {
                        rv = _bcm_field_entry_flags_to_tcam_part(
                                                            unit,
                                                            entry_flags,
                                                            f_ent->group,
                                                            &idx);
                        BCM_IF_ERROR_RETURN(rv);
                        fa->next = f_ent[idx].actions;
                        f_ent[idx].actions  = fa;
                        if (0 == (f_ent[idx].flags & _FP_ENTRY_DIRTY)) {
                            f_ent[idx].flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
                        }
                        f_ent[idx].flags    |= _FP_ENTRY_DIRTY;
                        return (BCM_E_NONE);
                    }
                }
            }
        }
    }
#endif

#if defined BCM_TRIDENT2_SUPPORT
    BCM_IF_ERROR_RETURN(_bcm_field_action_stat_flag_update(unit, f_ent, fa, TRUE));
#endif

    /* Oam Actions conflict with Nat actions */
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        if ((fa->action == bcmFieldActionNatEgressOverride)
                || (fa->action == bcmFieldActionNat)
                || (fa->action == bcmFieldActionNatCancel)) {
            f_ent->flags |= _FP_ENTRY_OAM_STAT_NOT_ALLOWED;
        }
    }

    /* Add action to front of entry's linked-list. */
    fa->next = f_ent->actions;
    f_ent->actions  = fa;
    /*
     * Do not set action only dirty flag if qualifier parameter has
     * been modified for this entry.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }
    f_ent->flags    |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_action_ports_add
 *
 * Purpose:
 *     Add action performed when entry rule is matched for a packet
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - entry ID
 *     action - Action to perform (bcmFieldActionXXX)
 *     param0 - Action parameter (use 0 if not required)
 *     param1 - Action parameter (use 0 if not required)
 *     param2 - Action parameter (use 0 if not required)
 *     param3 - Action parameter (use 0 if not required)
 *     param4   - Action parameter (use 0 if not required)
 *     param5   - Action parameter (use 0 if not required)
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_ports_add(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 param0, uint32 param1,
                         uint32 param2, uint32 param3,
                         uint32 param4, uint32 param5)
{
    _field_control_t    *fc;           /* Field control structure. */
    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    int                 rv;            /* Operation return status. */

#ifdef BROADCOM_DEBUG
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_action_add(entry=%d, action=%s, "
                          "p0=%d, p1=%d, p2=%d, p3=%d, p4=%d, p5=%d)\n"), unit, entry,
               _field_action_name(action),
               param0, param1, param2, param3, param4, param5));
#endif


    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Allocate the action  descriptor.
     */
    rv = _field_action_alloc(unit, action,
             param0, param1, param2, param3, param4, param5, &fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                   unit));
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Add action to entry actions list.
     */
    rv = _field_action_add(unit, fc, entry, fa);
    FP_UNLOCK(unit);
    if (BCM_FAILURE(rv)) {
        sal_free(fa);
        return rv;
    }
    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_action_ports_get
 *
 * Purpose:
 *     Get parameters associated with an entry action
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry ID
 *     action - Action to perform (bcmFieldActionXXX)
 *     param0 - (OUT) Action parameter
 *     param1 - (OUT) Action parameter
 *     param2 - (OUT) Action parameter
 *     param3 - (OUT) Action parameter
 *     param4 - (OUT) Action parameter
 *     param5 - (OUT) Action parameter
 **
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_NOT_FOUND - No matching Action for entry
 *     BCM_E_PARAM     - paramX is NULL
 *     BCM_E_NONE      - Success
 */

int
_bcm_field_action_ports_get(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 *param0, uint32 *param1,
                         uint32 *param2, uint32 *param3,
                         uint32 *param4, uint32 *param5)
{
    _field_entry_t      *f_ent;
    _field_action_t     *fa;
    int                 rv;

    /* Input parameters check. */
    if ((NULL == param0) || (NULL == param1) ||
        (NULL == param2) || (NULL == param3) ||
        (NULL == param4) || (NULL == param5)) {
            return (BCM_E_PARAM);
    }

    /* Lock the module. */

    FP_LOCK(unit);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Find matching action in the entry */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if (fa->action == action) {
            break;
        }
    }

    if (fa == NULL) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action not in entry=%d\n"),
                     unit, entry));
        return (BCM_E_NOT_FOUND);
    }

    *param0 = fa->param[0];
    *param1 = fa->param[1];
    *param2 = fa->param[2];
    *param3 = fa->param[3];
    *param4 = fa->param[4];
    *param5 = fa->param[5];

    /* Unlock the module. */
    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function:
 *     _bcm_field_slice_offset_to_tcam_idx
 *
 * Purpose:
 *     Given stage and tcam_index,
 *     calculate slice and entry offset in the
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Pointer to field entry structure.
 *     instance  - (IN) Instance of the pipe, the slice belongs to.
 *     slice     - (IN) Entry slice number.
 *     slice_idx - (IN) Entry offset in the slice.
 *     tcam_idx  - (OUT) Entry tcam index.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_slice_offset_to_tcam_idx(int unit, _field_stage_t *stage_fc,
                                    int instance, int slice, int slice_idx,
                                    int *tcam_idx)
{
    _field_slice_t  *fs;          /* Field slice number. */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == tcam_idx))  {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
       return _bcm_field_th_slice_offset_to_tcam_idx(unit, stage_fc, instance,
                                                  slice, slice_idx, tcam_idx);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Given stage flags slice number and slice index, calculate tcam index. */
    fs = stage_fc->slices[instance] + slice;

    if ((stage_fc->flags & _FP_STAGE_HALF_SLICE) &&
        (slice_idx >= (fs->entry_count >> 1)) &&
        ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id))) {
        if ((soc_feature(unit,
                        soc_feature_field_half_slice_single_tcam))
               && (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            /* Currently Half Slice with Single Tcam in a
             * Slice is supported only in IFP Stage in Ranger2Plus .*/
            *tcam_idx = fs->start_tcam_idx + slice_idx;
        } else {
            /*
             * Entry in the second quater of the sw slice
             * maps to the hw entry in the first quater
             * of the secondary tcam.
             */
            *tcam_idx = fs->start_tcam_idx + slice_idx + (fs->entry_count >> 1);
        }
    }  else if ((stage_fc->flags & _FP_STAGE_QUARTER_SLICE) &&
                (slice_idx >= (fs->entry_count >> 1)) &&
                ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
                (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id))) {
        if ((soc_feature(unit,
                        soc_feature_field_quarter_slice_single_tcam))
               && (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            /* Currently Quarter Slice with Single Tcam in a
             * Slice is supported only in IFP Stage in Td2Plus.*/
            *tcam_idx = fs->start_tcam_idx + slice_idx;
        } else {
        /*
         * Entry in the second quater of the sw slice
         * maps to the hw entry in the first quater
         * of the secondary tcam.
         */

        *tcam_idx = fs->start_tcam_idx + slice_idx +
                    ((fs->entry_count >> 1 )* 3);
        }
    } else {
        *tcam_idx = fs->start_tcam_idx + slice_idx;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_tcam_idx_to_slice_offset
 *
 * Purpose:
 *     Given stage and tcam_index,
 *     calculate slice and entry offset in the
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Pointer to field entry structure.
 *     instance  - (IN) Instance of the pipe, the slice belongs to.
 *     tcam_idx  - (IN) Entry tcam index.
 *     slice     - (OUT) Entry slice number.
 *     slice_idx - (OUT) Entry offset in the slice.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_tcam_idx_to_slice_offset(int unit, _field_stage_t *stage_fc,
                                    int instance, int tcam_idx,
                                    int *slice, int *slice_idx)
{
    _field_slice_t  *fs;          /* Field slice number.         */
    int idx;                      /* Slices iteration index.     */

    /* Input parameters check. */
    if ((NULL == stage_fc) || (NULL == slice) ||
        (NULL == slice_idx) || (tcam_idx < 0))  {
        return (BCM_E_PARAM);
    }


    for (idx = 0; idx < stage_fc->tcam_slices; idx++) {
        fs = stage_fc->slices[instance] + idx;
        if (tcam_idx < (fs->start_tcam_idx + fs->entry_count)) {
            *slice = idx;
            *slice_idx = tcam_idx - fs->start_tcam_idx;
            break;
        }

        if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
            if (tcam_idx < (fs->start_tcam_idx + (fs->entry_count << 1))) {
                *slice = idx;
                *slice_idx = tcam_idx - fs->start_tcam_idx -  \
                          (fs->entry_count >> 1);
                break;
            }
        }

       if (stage_fc->flags & _FP_STAGE_QUARTER_SLICE) {
           if (tcam_idx < (fs->start_tcam_idx + (fs->entry_count << 2))) {
               *slice = idx;
               *slice_idx = tcam_idx - fs->start_tcam_idx -  \
                            ((fs->entry_count >> 1) * 3);
               break;
           }
       }
    }

    /* Tcam idx sanity check. */
    if (idx == stage_fc->tcam_slices) {
        return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_entry_tcam_idx_get
 *
 * Purpose:
 *     Get the TCAM index of an entry ID.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Pointer to field entry structure.
 *     tcam_idx - (OUT) Entry tcam index.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_entry_tcam_idx_get(int unit,_field_entry_t *f_ent, int *tcam_idx)
{
    _field_stage_t  *stage_fc;    /* Stage field control structure. */
    _field_slice_t  *fs;          /* Field slice number.            */
    int             rv;           /* Operation return status.       */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == tcam_idx))  {
        return (BCM_E_PARAM);
    }

    /* Requested entry structure sanity check. */
    if ((NULL == f_ent->group) || (NULL == f_ent->fs)) {
        return (BCM_E_PARAM);
    }

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Given entry and stage flags calculate tcam index. */
    fs = f_ent->fs;
    if ((stage_fc->flags & _FP_STAGE_HALF_SLICE) &&
        ((f_ent->flags & _FP_ENTRY_SECOND_HALF) ||
         (f_ent->slice_idx >= (fs->entry_count >> 1))) &&
        ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id))) {
        if ((soc_feature(unit,
                        soc_feature_field_half_slice_single_tcam))
               && (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            /* Currently half Slice with Single Tcam in a
             * Slice is supported only in IFP Stage in Ranger2Plus.*/
            *tcam_idx = fs->start_tcam_idx + f_ent->slice_idx;
        } else {
            /*
             * Entry in the second quater of the sw slice
             * maps to the hw entry in the first quater
             * of the secondary tcam.
             */
            *tcam_idx = fs->start_tcam_idx + f_ent->slice_idx +
                (fs->entry_count >> 1);
        }
    } else if ((stage_fc->flags & _FP_STAGE_QUARTER_SLICE) &&
            (f_ent->slice_idx >= (fs->entry_count >> 1))) {
        if ((soc_feature(unit,
                        soc_feature_field_quarter_slice_single_tcam))
               && (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            /* Currently Quarter Slice with Single Tcam in a
             * Slice is supported only in IFP Stage in Td2Plus.*/
            *tcam_idx = fs->start_tcam_idx + f_ent->slice_idx;
        } else {
            *tcam_idx = fs->start_tcam_idx + f_ent->slice_idx +
                ((fs->entry_count >> 1) * 3);
        }
    } else {
        *tcam_idx = fs->start_tcam_idx + f_ent->slice_idx;
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *      _field_action_delete
 * Purpose:
 *      Delete field action from a field entry.
 * Parameters:
 *      unit   - (IN) BCM device number
 *      entry  - (IN) Entry ID
 *      action - (IN) Action to remove (bcmFieldActionXXX)
 *      param0 - (IN) Action parameter (use 0 if not required)
 *      param1 - (IN) Action parameter (use 0 if not required)
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_action_delete(int unit, bcm_field_entry_t entry,
                        bcm_field_action_t action,
                        uint32 param0, uint32 param1)
{
    _field_control_t       *fc;            /* Field control structure.     */
    _field_entry_t      *f_ent;
    _field_action_t     *fa;
    _field_action_t     *fa_prev = NULL;
    int                 rv;                /* Operation return status. */
#if defined(BCM_TRIDENT_SUPPORT)
    uint8               idx;               /* Entry array action index.    */
    uint32              entry_flags;       /* Entry flags                  */
#endif
    _field_action_t     *fa_cnt = NULL;
    int8 nat_action_count = 0;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       return _bcm_field_presel_action_delete
                    (unit, entry, action, param0, param1);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get field entry descriptor. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv = _bcm_field_th_class_action_delete(unit, entry, action);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Special treatment for pre-historic actions. */
    switch (action) {
      case  bcmFieldActionColorIndependent:

          BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

          if(fc->flags & _FP_COLOR_INDEPENDENT) {
              f_ent->flags |= _FP_ENTRY_COLOR_INDEPENDENT;
          } else {
              f_ent->flags &= ~_FP_ENTRY_COLOR_INDEPENDENT;
          }
          if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
              f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
          }
          f_ent->flags |= _FP_ENTRY_DIRTY;
          return (BCM_E_NONE);
      default:
          break;
    }


    /* Find the action in the entry */
    fa = f_ent->actions; /* start at head */

    while (fa != NULL) {
        if (fa->action != action) {
            fa_prev = fa;
            fa      = fa->next;
            continue;
        }

        /* Some actions might be applied multiple times.*/
        if (((action == bcmFieldActionMirrorIngress) ||
             (action == bcmFieldActionMirrorEgress)) &&
            (((uint32)_FP_INVALID_INDEX != param0) &&
             ((uint32)_FP_INVALID_INDEX != param1)))  {
            if ((fa->param[0] != param0)  || (fa->param[1] != param1)) {
                fa_prev = fa;
                fa      = fa->next;
                continue;
            }
        }
        break;
    }

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit)) {
        if ((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            if (NULL == fa) {
                if (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                    entry_flags = (_FP_ENTRY_PRIMARY | _FP_ENTRY_SECOND_HALF);
                } else {
                    entry_flags = _FP_ENTRY_SECONDARY;
                }

                rv = _bcm_field_entry_flags_to_tcam_part(unit, entry_flags,
                                                     f_ent->group,
                                                     &idx);

                BCM_IF_ERROR_RETURN(rv);
                /* Find the action in the entry */
                fa = f_ent[idx].actions; /* start at head */
                fa_prev = NULL;
                while (fa != NULL) {
                    if (fa->action != action) {
                        fa_prev = fa;
                        fa      = fa->next;
                        continue;
                    }
                    f_ent = &f_ent[idx];
                    break;
                }
            }
        }
    }
#endif

    if (NULL == fa) {
        return (BCM_E_NOT_FOUND);
    }

#if defined(BCM_TRIDENT2_SUPPORT)
    BCM_IF_ERROR_RETURN(_bcm_field_action_stat_flag_update
                             (unit, f_ent, fa, FALSE));
#endif
     /* Nat Actions Conflict with Oam Actions */
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        if ((fa->action == bcmFieldActionNatCancel)
                || (fa->action == bcmFieldActionNatEgressOverride)
                || (fa->action == bcmFieldActionNat)) {
            fa_cnt = f_ent->actions; /* start at head */
            while (fa_cnt != NULL) {
                if ((fa_cnt->action == bcmFieldActionNatCancel)
                        || (fa_cnt->action == bcmFieldActionNatEgressOverride)
                        || (fa_cnt->action == bcmFieldActionNat)) {
                    if (fa_cnt->flags & _FP_ACTION_VALID) {
                        nat_action_count++;
                    }
                }
                fa_cnt = fa_cnt->next;
            }
            if (nat_action_count == 1) {
                f_ent->flags &= ~_FP_ENTRY_OAM_STAT_NOT_ALLOWED;
            }
        }
    }

    /* If entry is installed mark action as invalid.
     * Invalid actions will be removed during entry remove/reinstall.
     */
    if (f_ent->flags & _FP_ENTRY_INSTALLED) {
        fa->flags  &= ~_FP_ACTION_VALID;
        fa->flags |= _FP_ACTION_MODIFY;
        /*
         * Do not set action only dirty flag if qualifier parameter has
         * been modified for this entry.
         */
        if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
            f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        }
        f_ent->flags |= _FP_ENTRY_DIRTY;
        return (BCM_E_NONE);
    }

    if (fa_prev != NULL) {
        fa_prev->next = fa->next;
    } else { /* matched head of list */
        f_ent->actions = fa->next;
    }

    /* okay to free action */
    sal_free(fa);
    fa = NULL;

   /*
    * Do not set action only dirty flag if qualifier parameter has
    * been modified for this entry.
    */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }
    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}
#if defined(BCM_TOMAHAWK_SUPPORT)
/*
 * Function:
 *     _bcm_field_34bit_counter_update
 * Description:
 *     Service routine used to update 64-bit software accumulated 34 bit counters.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     new_val  - (IN) New hw counter value from.
 *     result   - (IN/OUT) Operation result.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     This is for Tomahawk Devices
 */
int
_bcm_field_34bit_counter_update(int unit, uint32 *new_val,
                        _field_counter64_collect_t *result)
{
    uint64 hw_val;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    /* Compose H/W counter value. */
    COMPILER_64_SET(hw_val, new_val[1], new_val[0]);

    if (COMPILER_64_LE(result->last_hw_value, hw_val)) {
        /* diff = hw_val - result->last_hw_value */
        COMPILER_64_ZERO(diff64);
        COMPILER_64_OR(diff64, hw_val);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
    } else {
        /*
         * diff = 0x3ffffffff - (result->last_hw_value - hw_val) + 1
         *      = 0x400000000 - result->last_hw_value + hw_val
         */
        COMPILER_64_SET(diff64, 0x4, 0);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
        COMPILER_64_ADD_64(diff64, hw_val);
    }

    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    COMPILER_64_ZERO(result->last_hw_value);
    COMPILER_64_OR(result->last_hw_value, hw_val);

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _bcm_field_26bit_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated 26 bit counter.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   new_val  - (IN) New hw counter value from.
 *   result   - (IN/OUT) Operation result.
 * Returns:
 *   BCM_E_XXX
 */
int
_bcm_field_26bit_counter_update(int unit, uint32 *new_val,
                        _field_counter32_collect_t *result)
{
    uint32 diff;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    if (result->last_hw_value <= new_val[0]) {
        diff = new_val[0] - result->last_hw_value;
    } else {
        diff = ((1 << 26) - 1) - (result->last_hw_value - new_val[0]) + 1;
    }

    COMPILER_64_SET(diff64, 0, diff);
    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    result->last_hw_value = new_val[0];

    return (BCM_E_NONE);
}
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)

/*
 * Function:
 *     _bcm_field_36bit_counter_update
 * Description:
 *     Service routine used to update 64-bit software accumulated 36 bit counters.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     new_val  - (IN) New hw counter value from.
 *     result   - (IN/OUT) Operation result.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     This is for Bradley
 */
int
_bcm_field_36bit_counter_update(int unit, uint32 *new_val,
                        _field_counter64_collect_t *result)
{
    uint64 hw_val;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    /* Compose H/W counter value. */
    COMPILER_64_SET(hw_val, new_val[1], new_val[0]);

    if (COMPILER_64_LE(result->last_hw_value, hw_val)) {
        /* diff = hw_val - result->last_hw_value */
        COMPILER_64_ZERO(diff64);
        COMPILER_64_OR(diff64, hw_val);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
    } else {
        /*
         * diff = 0xfffffffff - (result->last_hw_value - hw_val) + 1
         *      = 0x1000000000 - result->last_hw_value + hw_val
         */
        COMPILER_64_SET(diff64, 0x10, 0);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
        COMPILER_64_ADD_64(diff64, hw_val);
    }

    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    COMPILER_64_ZERO(result->last_hw_value);
    COMPILER_64_OR(result->last_hw_value, hw_val);

    return (BCM_E_NONE);
}
#endif /* BCM_BRADLEY_SUPPORT  || BCM_TRIUMPH3_SUPPORT */
/*
 * Function:
 *  _bcm_field_32bit_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated 32 bit counter.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   new_val  - (IN) New hw counter value from.
 *   result   - (IN/OUT) Operation result.
 * Returns:
 *   BCM_E_XXX
 */
int
_bcm_field_32bit_counter_update(int unit, uint32 *new_val,
                        _field_counter32_collect_t *result)
{
    uint32 diff;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    if (result->last_hw_value <= new_val[0]) {
        diff = new_val[0] - result->last_hw_value;
    } else {
        diff = ((0xFFFFFFFFL) - result->last_hw_value) + new_val[0] + 1;
    }

    COMPILER_64_SET(diff64, 0, diff);
    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    result->last_hw_value = new_val[0];

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _bcm_field_29bit_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated 29 bit counter.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   new_val  - (IN) New hw counter value from.
 *   result   - (IN/OUT) Operation result.
 * Returns:
 *   BCM_E_XXX
 */
int
_bcm_field_29bit_counter_update(int unit, uint32 *new_val,
                        _field_counter32_collect_t *result)
{
    uint32 diff;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    if (result->last_hw_value <= new_val[0]) {
        diff = new_val[0] - result->last_hw_value;
    } else {
        diff = ((1 << 29) - 1) - (result->last_hw_value - new_val[0]) + 1;
    }

    COMPILER_64_SET(diff64, 0, diff);
    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    result->last_hw_value = new_val[0];

    return (BCM_E_NONE);
}
#if defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *     _bcm_field_35bit_counter_update
 * Description:
 *     Service routine used to update 64-bit software accumulated 35 bit counters.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     new_val  - (IN) New hw counter value from.
 *     result   - (IN/OUT) Operation result.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     This is for BYTE_COUNTER field
 */
int
_bcm_field_35bit_counter_update(int unit, uint32 *new_val,
                        _field_counter64_collect_t *result)
{
    uint64 hw_val;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    /* Compose H/W counter value. */
    COMPILER_64_SET(hw_val, new_val[1], new_val[0]);

    if (COMPILER_64_LE(result->last_hw_value, hw_val)) {
        /* diff = hw_val - result->last_hw_value */
        COMPILER_64_ZERO(diff64);
        COMPILER_64_OR(diff64, hw_val);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
    } else {
        /*
         * diff = 0x7ffffffff - (result->last_hw_value - hw_val) + 1
         *      = 0x800000000 - result->last_hw_value + hw_val
         */
        COMPILER_64_SET(diff64, 0x8, 0);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
        COMPILER_64_ADD_64(diff64, hw_val);
    }

    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    COMPILER_64_ZERO(result->last_hw_value);
    COMPILER_64_OR(result->last_hw_value, hw_val);

    return (BCM_E_NONE);
}
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_TRIDENT_SUPPORT
/*
 * Function:
 *     _bcm_field_37bit_counter_update
 * Description:
 *     Service routine used to update 64-bit software accumulated 37 bit counters.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     new_val  - (IN) New hw counter value from.
 *     result   - (IN/OUT) Operation result.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     This is for Trident2
 */
int
_bcm_field_37bit_counter_update(int unit, uint32 *new_val,
                        _field_counter64_collect_t *result)
{
    uint64 hw_val;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    /* Compose H/W counter value. */
    COMPILER_64_SET(hw_val, new_val[1], new_val[0]);

    if (COMPILER_64_LE(result->last_hw_value, hw_val)) {
        /* diff = hw_val - result->last_hw_value */
        COMPILER_64_ZERO(diff64);
        COMPILER_64_OR(diff64, hw_val);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
    } else {
        /*
         * diff = 0x1FFFFFFFFF - (result->last_hw_value - hw_val) + 1
         *      = 0x2000000000 - result->last_hw_value + hw_val
         */
        COMPILER_64_SET(diff64, 0x20, 0);
        COMPILER_64_SUB_64(diff64, result->last_hw_value);
        COMPILER_64_ADD_64(diff64, hw_val);
    }

    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    COMPILER_64_ZERO(result->last_hw_value);
    COMPILER_64_OR(result->last_hw_value, hw_val);

    return (BCM_E_NONE);
}
#endif /* BCM_TRIDENT_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *  _bcm_field_30bit_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated 30 bit counter.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   new_val  - (IN) New hw counter value from.
 *   result   - (IN/OUT) Operation result.
 * Returns:
 *   BCM_E_XXX
 */
int
_bcm_field_30bit_counter_update(int unit, uint32 *new_val,
                        _field_counter32_collect_t *result)
{
    uint32 diff;
    uint64 diff64;

    /* Input parameters check. */
    if ((NULL == new_val) || (NULL == result)) {
        return (BCM_E_PARAM);
    }

    if (result->last_hw_value <= new_val[0]) {
        diff = new_val[0] - result->last_hw_value;
    } else {
        diff = ((1 << 30) - 1) - (result->last_hw_value - new_val[0]) + 1;
    }

    COMPILER_64_SET(diff64, 0, diff);
    COMPILER_64_ADD_64(result->accumulated_counter, diff64);

    result->last_hw_value = new_val[0];

    return (BCM_E_NONE);
}
#endif /* (BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) */

/*
 * Function:
 *  _bcm_field_sw_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated counters.
 *  based on hw memory block.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   stage_fc - (IN/OUT) Stage field control structure.
 *   mem      - (IN) Counters memory.
 *   idx_min  - (IN) First counter index in the buffer.
 *   idx_max  - (IN) Last counter index in the buffer.
 *   buf      - (IN) Counters buffer.
 *   flags    - (IN) Device counters flags.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_sw_counter_update(int unit, _field_stage_t *stage_fc, soc_mem_t mem,
                         int idx_min, int idx_max, char *buf, int flags)
{
    _field_control_t       *fc;        /* Field control structure.         */
    uint32                 *entry_p;   /* HW entry pointer.                */
    int                    buf_offset; /* Offset into counters buffer.     */
    int                    idx;        /* Iteration index.                 */
    int                    rv;         /* Operartion return status.        */


    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (idx = idx_min, buf_offset = 0; idx <= idx_max; idx++, buf_offset++) {
        /* Read counter value from the first memory. */
        entry_p = soc_mem_table_idx_to_pointer(unit, mem, uint32 *,
                                               buf, buf_offset);

        /* Process accumulated counter value. */
        if (flags & _FIELD_FIRST_MEMORY_COUNTERS) {
            rv = fc->functions.fp_counter_get(unit, stage_fc, mem,
                                              entry_p, INVALIDm,
                                              NULL, idx, NULL, NULL);
        } else {
            rv = fc->functions.fp_counter_get(unit, stage_fc, INVALIDm,
                                              NULL, mem, entry_p, idx,
                                              NULL, NULL);
        }
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_mem_counters_read
 * Description:
 *    Service routine used to coolect 64-bit software accumulated counters.
 *    for a specific stage.
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *    mem      - (IN) Counters memory.
 * Returns:
 *  BCM_E_XXX
 */

STATIC int
_field_mem_counters_read(int unit, _field_stage_t *stage_fc,
                              soc_mem_t mem, int flags)
{
    int       buf_end_idx;           /* Buffer end index.         */
    int       alloc_size;            /* DMA buffer size.          */
    int       max_idx;               /* Counter memory index max. */
    int       min_idx;               /* Counter memory index min. */
    char      *buf;                  /* Buffer to read the table. */
    int       idx = 0;               /* Table iteration index.    */
    int       rv = BCM_E_NONE;       /* Operation return value.   */
    int       slice_index = 0;       /* Slice index               */
    int       slice_size = 0;        /* Size of each slice        */
    int       entry_ratio = 0;       /* entries per slice         */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Make sure memory is valid */
    if (INVALIDm == mem) {
        return (BCM_E_NONE);
    }

    /* Get table boundaries. */
    min_idx = soc_mem_index_min(unit, mem);
    max_idx = soc_mem_index_max(unit, mem);


    /* Dma part of the table & update software counters. */
    soc_mem_lock(unit, mem);
    if ((soc_feature(unit,
                    soc_feature_field_quarter_slice_single_tcam) ||
          soc_feature(unit,
                    soc_feature_field_half_slice_single_tcam))
            && (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
        entry_ratio = (stage_fc->flags & _FP_STAGE_QUARTER_SLICE) ? 4:
                            ((stage_fc->flags & _FP_STAGE_HALF_SLICE) ? 2 : 1);
        idx = min_idx;
        for (slice_index = 0;
                slice_index < stage_fc->tcam_slices; slice_index++) {
            slice_size = stage_fc->slices[_FP_DEF_INST][slice_index].entry_count;

            /* Allocate memory buffer. */
            alloc_size = ((slice_size) * sizeof(fp_counter_table_entry_t));
            buf = soc_cm_salloc(unit, alloc_size, "fp_64_bit_counter");
            if (buf == NULL) {
                return (BCM_E_MEMORY);
            }
            buf_end_idx = idx + (slice_size - 1);

            /* Dma range of entries in counter table. */
            rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY, idx,
                    buf_end_idx, buf);
            if (BCM_FAILURE(rv)) {
                break;
            }

            rv = _bcm_field_sw_counter_update(unit, stage_fc, mem, idx,
                    buf_end_idx, buf, flags);
            if (BCM_FAILURE(rv)) {
                break;
            }

            idx += stage_fc->slices[_FP_DEF_INST][slice_index].entry_count * entry_ratio;
            soc_cm_sfree(unit, buf);
            buf = NULL;
        }
    } else {
        /* Allocate memory buffer. */
        alloc_size = (_FP_64_COUNTER_BUCKET * sizeof(fp_counter_table_entry_t));
        buf = soc_cm_salloc(unit, alloc_size, "fp_64_bit_counter");
        if (buf == NULL) {
            return (BCM_E_MEMORY);
        }
        for (idx = min_idx; idx <= max_idx; idx += _FP_64_COUNTER_BUCKET) {
            buf_end_idx = MIN(max_idx, (idx + _FP_64_COUNTER_BUCKET - 1));
            if (soc_feature(unit, soc_feature_field_stage_quarter_slice) &&
                    (SOC_IS_TRIUMPH3(unit))) {
                /* Do not access h/w for tcam index mapping to the holes */
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS)  {
                    buf_end_idx = MIN(max_idx, (idx + 128 - 1));
                }
            }


            /* Dma range of entries in counter table. */
            rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY, idx,
                    buf_end_idx, buf);
            if (BCM_FAILURE(rv)) {
                break;
            }

            rv = _bcm_field_sw_counter_update(unit, stage_fc, mem, idx,
                    buf_end_idx, buf, flags);
            if (BCM_FAILURE(rv)) {
                break;
            }
        }
        soc_cm_sfree(unit, buf);
    }
    soc_mem_unlock(unit, mem);
    return (rv);
}


/*
 * Function:
 *     _field_stage_external_counters_collect
 * Description:
 *     Service routine used to coolect  64-bit software accumulated counters.
 *          For the External-FP (Triumph).
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fc       - (IN) Field control structure.
 *     stage_fc - (IN/OUT) Stage field control structure.
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_stage_external_counters_collect (int unit, _field_control_t *fc,
                                        _field_stage_t *stage_fc)
{
    if ((stage_fc->_field_x32_counters == NULL)
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
        && (stage_fc->_field_x64_counters == NULL)
#endif /* BCM_BRADLEY_SUPPORT || BCM_TRX_SUPPORT */
        )
    {
        return (BCM_E_UNAVAIL);
    }

#ifdef BCM_TRIUMPH_SUPPORT
    BCM_IF_ERROR_RETURN
        (_bcm_field_tr_external_counters_collect(unit, stage_fc));
#endif /* BCM_TRIUMPH_SUPPORT */

    return (BCM_E_NONE);
}
/*
 * Function:
 *  _field_stage_counters_collect
 * Description:
 *  Service routine used to coolect  64-bit software accumulated counters.
 *  for a specific stage.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   fc       - (IN) Field control structure.
 *   stage_fc - (IN/OUT) Stage field control structure.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 *  None.
 */

STATIC int
_field_stage_counters_collect (int unit, _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    soc_mem_t  counter_x_mem;        /* First counters memory.    */
    soc_mem_t  counter_y_mem;        /* Second counters memory    */
                                     /* for dual pipeline devices.*/

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (stage_fc->flags & _FP_STAGE_MULTI_PIPE_COUNTERS) {
        return BCM_E_NONE;
    }
#endif

    /*  Check if counters are available at this stage. */
    if ((stage_fc->_field_x32_counters == NULL)
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
        && (stage_fc->_field_x64_counters == NULL)
#endif /* BCM_BRADLEY_SUPPORT || BCM_TRX_SUPPORT */
        )
    {
        return (BCM_E_UNAVAIL);
    }

    /* Get counters memory for the stage. */
    BCM_IF_ERROR_RETURN(_field_counter_mem_get(unit, stage_fc,
                                               &counter_x_mem, &counter_y_mem));

    /* If stage doesn't have counters - we are done. */
    if ((INVALIDm == counter_x_mem) && (INVALIDm == counter_y_mem)) {
        return (BCM_E_NONE);
    }

    if (INVALIDm != counter_x_mem) {
        BCM_IF_ERROR_RETURN
            (_field_mem_counters_read(unit, stage_fc, counter_x_mem,
                                      _FIELD_FIRST_MEMORY_COUNTERS));
    }

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_SCORPION_SUPPORT)
    if (INVALIDm != counter_y_mem) {
        BCM_IF_ERROR_RETURN
            (_field_mem_counters_read(unit, stage_fc, counter_y_mem,
                                      _FIELD_SECOND_MEMORY_COUNTERS));
    }
#endif /* BCM_BRADLEY_SUPPORT || BCM_SCORPION_SUPPORT */
    return (BCM_E_NONE);
}


/*
 * Function:
 *  _bcm_esw_fp_counters_collect
 * Description:
 *  Callback routine executed each counter cycle to add up the
 *  64-bit software accumulated counter values.
 * Parameters:
 *  unit -  (IN) BCM device number.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 *  None.
 */

void
_bcm_esw_fp_counters_collect(int unit)
{
   _field_control_t  *fc = NULL;           /* Field control structure.      */
   _field_stage_t    *stage_fc;     /* Stage field control iterator. */


   FP_LOCK(unit);
   if (BCM_FAILURE(_field_control_get(unit, &fc))) {
       FP_UNLOCK(unit);
       return;
   }

   /* Collect  counters from each fp pipeline stage. */
   stage_fc = fc->stages;
   while (NULL != stage_fc) {
        if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
           _field_stage_external_counters_collect(unit, fc, stage_fc);
        } else {
           _field_stage_counters_collect(unit, fc, stage_fc);
        }
       stage_fc = stage_fc->next;
   }

   FP_UNLOCK(unit);
   return;
}

/* Function    :
 *           _field_qualify_IpProtocolCommon_get
 * Description :
 *           Get qualifier common L3 protocol ID
 * Parameters  :
 *   unit     (IN) BCM device number
 *   entry    (IN) Field entry to qualify
 *   qual_id  (IN) Field qualifier id.
 *   protocol (OUT) Protocol name to qualify
 * Returns:
 *   BCM_E_XXX
 */
int
_field_qualify_IpProtocolCommon_get(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_qualify_t qual_id,
                                    bcm_field_IpProtocolCommon_t *protocol)
{
    uint8  data;              /* HW encoded data.         */
    uint8  mask;              /* HW encoded mask.         */
    int    rv;                /* Operation return status. */

    if (NULL == protocol) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                       qual_id, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if ((0 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonTcp;
    } else  if ((1 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonUdp;
    } else  if ((2 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonIgmp;
    } else  if ((3 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonIcmp;
    } else  if ((4 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonIp6Icmp;
    } else  if ((5 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonIp6HopByHop;
    } else  if ((6 == data)  && (0x7 == mask)) {
       *protocol = bcmFieldIpProtocolCommonIpInIp;
    } else  if ((0 == data)  && (0x6 == mask)) {
       *protocol = bcmFieldIpProtocolCommonTcpUdp;
    } else {
        return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/* Function    :
 *           _field_qualify_IpProtocolCommon
 * Description :
 *           Qualify common L3 protocol ID
 * Parameters  :
 *   unit     (IN) BCM device number
 *   entry    (IN) Field entry to qualify
 *   qual_id  (IN) Field qualifier id.
 *   protocol (IN) Protocol name to qualify
 * Returns:
 *   BCM_E_XXX
 */
int
_field_qualify_IpProtocolCommon(int unit, bcm_field_entry_t entry,
                                bcm_field_qualify_t qual_id,
                                bcm_field_IpProtocolCommon_t protocol)
{
    uint32   data;
    uint32   mask;

    if (protocol >= bcmFieldIpProtocolCommonCount) {
        return (BCM_E_PARAM);
    }

    switch (protocol) {
      case bcmFieldIpProtocolCommonTcp:
          data = 0x00;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonUdp:
          data = 0x01;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonIgmp:
          data = 0x02;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonIcmp:
          data = 0x03;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonIp6Icmp:
          data = 0x04;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonIp6HopByHop:
          /* TRX  devices do not use extension headers
           * for packet ip protocol is determination.
           * Please use  bcm_esw_field_qualify_ExtensionHeaderType */
          if (SOC_IS_TRX(unit)) {
              return (BCM_E_UNAVAIL);
          }
          data = 0x05;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonIpInIp:
          data = 0x06;
          mask = 0x07;
          break;
      case bcmFieldIpProtocolCommonTcpUdp:
          data = 0x00;
          mask = 0x06;
          break;
      default:
          return (BCM_E_UNAVAIL);
    }
    return  _field_qualify32(unit, entry, qual_id, data, mask);
}

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAPTOR_SUPPORT)

/* Function    : _field_qualify_IpFrag
 * Description : qualify on Ip Frag Info.
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (IN) qual_id    Field qualifier id.
 *               (IN) frag_info  bcm_field_IpFrag_t to qualify
 * Returns     : BCM_E_XXX
 */
int
_field_qualify_IpFrag(int unit, bcm_field_entry_t entry,
                      bcm_field_qualify_t qual_id,
                      bcm_field_IpFrag_t frag_info)
{
    int             rv;
    _field_entry_t *f_ent;
    uint32          data;
    uint32          mask;

    if (frag_info >= bcmFieldIpFragCount) {
        return (BCM_E_PARAM);
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ||
#if defined (BCM_TRX_SUPPORT)
        (SOC_IS_TRX(unit) &&
         (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
#endif /* BCM_TRX_SUPPORT */
        (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id)) {
        /*
         * IP_FRAG_INFO[1] = (IP_OFFSET == 0) & !MoreFragmentlifyIpFragNonOrFirstbcmFieldQualifyIpFragNonOrFirst
         * IP_FRAG_INFO[0] = (IP_OFFSET == 0)
         */
        switch(frag_info) {
          case bcmFieldIpFragAny:
              /* Any fragment of fragmented packet */
              data = 0x00;
              mask = 0x02;
              break;
          case bcmFieldIpFragNon:
              /* Non-fragmented packet */
              data = 0x02;
              mask = 0x02;
              break;
          case bcmFieldIpFragFirst:
              /* First fragment of fragmented packet*/
              data = 0x01;
              mask = 0x03;
              break;
          case bcmFieldIpFragNonOrFirst:
              /* Non-fragmented or first fragment */
              data = 0x01;
              mask = 0x01;
              break;
          case bcmFieldIpFragNotFirst:
              /* Not the first fragment */
              data = 0x00;
              mask = 0x03;
              break;
          default:
              return (BCM_E_PARAM);
        }
    }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    else if((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) ||
            (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) {
        /*
         * 00 : Not a fragment
         * 10 : First fragment
         * 11 : Non-first fragment
         * 01 : Reserved
         */
        switch(frag_info) {
          case bcmFieldIpFragAny:
              /* Any fragment of fragmented packet */
              data = 0x02;
              mask = 0x02;
              break;
          case bcmFieldIpFragNon:
              /* Non-fragmented packet */
              data = 0x00;
              mask = 0x03;
              break;
          case bcmFieldIpFragFirst:
              /* First fragment of fragmented packet*/
              data = 0x02;
              mask = 0x03;
              break;
          case bcmFieldIpFragNonOrFirst:
              /* Non-fragmented or first fragment */
              data = 0x00;
              mask = 0x01;
              break;
          case bcmFieldIpFragNotFirst:
              /* Not the first fragment */
              data = 0x03;
              mask = 0x03;
              break;
          default:
              return (BCM_E_PARAM);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    else {
        return (BCM_E_INTERNAL);
    }
    rv = _field_qualify32(unit, entry, qual_id, data, mask);
    return (rv);
}


/* Function    : _field_qualify_IpFrag_get
 * Description : qualify on Ip Frag Info.
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (IN) qual_id    Field qualifier id.
 *               (OUT) frag_info  bcm_field_IpFrag_t to qualify
 * Returns     : BCM_E_XXX
 */
int
_field_qualify_IpFrag_get(int unit, bcm_field_entry_t entry,
                          bcm_field_qualify_t qual_id,
                          bcm_field_IpFrag_t *frag_info)
{
    _field_entry_t *f_ent;       /* Field entry structure.      */
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if (NULL == frag_info) {
        return (BCM_E_PARAM);
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               qual_id,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ||
#if defined (BCM_TRX_SUPPORT)
        (SOC_IS_TRX(unit) &&
         (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
#endif /* BCM_TRX_SUPPORT */
        (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id)) {
        /*
         * IP_FRAG_INFO[1] = (IP_OFFSET == 0) & !MoreFragment
         * IP_FRAG_INFO[0] = (IP_OFFSET == 0)
         */

        if ((hw_data == 0x2) && (hw_mask == 0x2)) {
            *frag_info = bcmFieldIpFragNon;
        } else  if ((hw_data == 0x1) && (hw_mask == 0x3)) {
            *frag_info = bcmFieldIpFragFirst;
        } else  if ((hw_data == 0x1) && (hw_mask == 0x1)) {
            *frag_info = bcmFieldIpFragNonOrFirst;
        } else  if ((hw_data == 0x0) && (hw_mask == 0x3)) {
            *frag_info = bcmFieldIpFragNotFirst;
        } else  if ((hw_data == 0x0) && (hw_mask == 0x2)) {
            *frag_info = bcmFieldIpFragAny;
        } else {
            return (BCM_E_INTERNAL);
        }
    }
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    else if((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) ||
            (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) {
        /*
         * 00 : Not a fragment
         * 10 : First fragment
         * 11 : Non-first fragment
         * 01 : Reserved
         */
        if ((hw_data == 0x0) && (hw_mask == 0x3)) {
            *frag_info = bcmFieldIpFragNon;
        } else  if ((hw_data == 0x2) && (hw_mask == 0x3)) {
            *frag_info = bcmFieldIpFragFirst;
        } else  if ((hw_data == 0x0) && (hw_mask == 0x1)) {
            *frag_info = bcmFieldIpFragNonOrFirst;
        } else  if ((hw_data == 0x3) && (hw_mask == 0x3)) {
            *frag_info = bcmFieldIpFragNotFirst;
        } else  if ((hw_data == 0x2) && (hw_mask == 0x2)) {
            *frag_info = bcmFieldIpFragAny;
        } else {
            return (BCM_E_INTERNAL);
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    else {
        return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}


#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT || BCM_RAPTOR_SUPPORT */

/*
 * Function:
 *     _field_qual_selectors_insert
 * Purpose:
 *     Initialize field group select codes.
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     candidate   - (IN) Inserted selector set.
 *     parts_count - (IN) Number of tcam parts.
 *     selector    - (IN/OUT) Result selector set.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_qual_selectors_insert (int unit, _field_sel_t *candidate,
                              uint8 parts_count,
                              _bcm_field_selector_t *selector)
{
    int8 idx;                       /* Tcam parts iterator.            */
    uint8 selected_part;            /* Tcam part selected for
                                       qualifier installation.         */
    uint8 update_count_min;         /* Minimum selectors update count. */
    uint8 update_count;             /* Number of updates required
                                       to accommodate qualifier.       */
    int rv;                         /* Operation return status.        */

    /* Input parameters check. */
    if ((NULL == candidate) || (NULL == selector)) {
        return (BCM_E_PARAM);
    }

    update_count_min = _FP_INVALID_INDEX;
    selected_part = _FP_INVALID_INDEX;

    if (soc_feature(unit, soc_feature_td2p_fp_sw_war)) {
        for (idx = (parts_count -1); idx >= 0; idx--) {
            update_count = 0;

            /* Test if selector can be inserted in a specific tcam part. */
            rv = _field_selector_diff(unit, candidate, idx, selector, &update_count);
            if (BCM_FAILURE(rv)) {
                continue;
            }

            if (update_count < update_count_min) {
                update_count_min = update_count;
                selected_part = idx;
            }
        }
    } else {
        for (idx = 0; idx < parts_count; idx++) {
            update_count = 0;

            /* Test if selector can be inserted in a specific tcam part. */
            rv = _field_selector_diff(unit, candidate, idx, selector, &update_count);
            if (BCM_FAILURE(rv)) {
                continue;
            }

            if (update_count < update_count_min) {
                update_count_min = update_count;
                selected_part = idx;
            }
        }
    }

    /* Check if any tcam part can accommodate all the required selectors. */
    if ((uint8)_FP_INVALID_INDEX == selected_part) {
        return (BCM_E_RESOURCE);
    }

    /* Insert selector configuration. */
    rv = _field_selector_insert(candidate, selected_part, selector);
    return (rv);
}

/*
 * Function:
 *     _field_qual_selectors_sort
 * Purpose:
 *     Sorf field qualifiers select codes.
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     candidate   - (IN) Inserted selector set.
 *     parts_count - (IN) Number of tcam parts.
 *     f_qual_arr  - (IN/OUT) Result selector set.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_qual_selectors_sort (int unit,
                            _field_sel_t *candidate,
                            uint8 parts_count,
                            _bcm_field_qual_info_t *f_qual)
{
    uint8 idx;                      /* Tcam parts iterator.               */
    uint8 conf_idx;                 /* Configurations iterator.           */
    uint8 update_count_min;         /* Minimum selectors update count.    */
    uint8 update_count;             /* Number of updates required
                                       to accommodate qualifier.          */
    int rv;                         /* Operation return status.           */
    _bcm_field_selector_t *selector;/* Qualifier select codes config.     */

    /* Input parameters check. */
    if ((NULL == candidate) || (NULL == f_qual)) {
        return (BCM_E_PARAM);
    }

    /* Don't sort if only one configuration is available. */
    if (f_qual->conf_sz <= 1) {
        return (BCM_E_NONE);
    }

    /* Get number of updates required for each qualifier configuration. */
    for (conf_idx = 0; conf_idx < f_qual->conf_sz; conf_idx++) {
        update_count_min = _FP_INVALID_INDEX;
        selector = &((f_qual->conf_arr[conf_idx]).selector);

        for (idx = 0; idx < parts_count; idx++) {
            update_count = 0;

            /* Test if selector can be inserted in a specific tcam part. */
            rv = _field_selector_diff(unit, candidate, idx,
                                      selector, &update_count);
            if (BCM_FAILURE(rv)) {
                continue;
            }

            if (update_count < update_count_min) {
                update_count_min = update_count;
            }
        }
        /* Keep minimum number of required updates. */
        selector->update_count  =  update_count_min;
    }

    /* Qualifier configurations sort based on number of updates required.  */
    _shr_sort(f_qual->conf_arr, f_qual->conf_sz,
               sizeof(_bcm_field_qual_conf_t), _field_selector_update_cmp);
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_selectors_init
 * Purpose:
 *     Initialize field group select codes.
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     fg     - (IN/OUT) Field group structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_group_selectors_init(int unit, _field_group_t *fg)
{
    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    fg->sel_codes[0].intraslice = _FP_SELCODE_DONT_USE;
    if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            fg->sel_codes[2].intraslice = _FP_SELCODE_DONT_USE;
        } else {
            fg->sel_codes[1].intraslice = _FP_SELCODE_DONT_USE;
        }
    } else if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        fg->sel_codes[1].intraslice = _FP_SELCODE_DONT_USE;
        fg->sel_codes[2].intraslice = _FP_SELCODE_DONT_USE;
    }

    fg->sel_codes[0].secondary = _FP_SELCODE_DONT_USE;
    if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            fg->sel_codes[1].secondary = _FP_SELCODE_DONT_USE;
            fg->sel_codes[2].secondary = _FP_SELCODE_DONT_USE;
        }
    } else if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        fg->sel_codes[1].secondary = _FP_SELCODE_DONT_USE;
        fg->sel_codes[2].secondary = _FP_SELCODE_DONT_USE;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_selcode_qual_arr_free
 * Purpose:
 *     Free memory allocated for the temporary qual array used during group creation.
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_qual_arr    - (INOUT)Qualifiers information array.
 *     qual_count    - (IN)Qualifiers information array size.
 *
 */
void _bcm_field_selcode_qual_arr_free(int unit,
        _bcm_field_qual_info_t ***f_qual_arr, uint16 qual_count)
{
    int   qual_idx = 0;

    if (NULL == f_qual_arr) {
        return;
    }

    if (*f_qual_arr) {
        for (qual_idx = 0; qual_idx < qual_count ; qual_idx++) {
            if ((*f_qual_arr)[qual_idx]) {
                if ((*f_qual_arr)[qual_idx]->conf_arr) {
                    sal_free((*f_qual_arr)[qual_idx]->conf_arr);
                    (*f_qual_arr)[qual_idx]->conf_arr = NULL;
                }
                sal_free((*f_qual_arr)[qual_idx]);
                (*f_qual_arr)[qual_idx] = NULL;
            }
        }
        sal_free(*f_qual_arr);
        *f_qual_arr = NULL;
    }
}

/*
 * Function:
 *     _bcm_field_qualifiers_info_get
 * Purpose:
 *     Copy qualifiers configuration for a given qualifiers set.
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     stage_fc      - (IN) Stage Field control structure.
 *     qset_req      - (IN) Client qualifier set.
 *     f_qual_arr    - (OUT)Qualifiers information array.
 *     qual_arr_size - (OUT)Qualifiers information array size.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qualifiers_info_get(int unit, _field_stage_t *stage_fc,
                               bcm_field_qset_t *qset_req,
                               _bcm_field_qual_info_t ***f_qual_arr,
                               uint16 *qual_arr_size)
{
    uint16 idx;              /* Qualifier set iterator.   */
    uint16 arr_idx;          /* Qualifiers array index.   */

    /* Input parameters check. */
    if ((NULL == f_qual_arr) || (NULL == qset_req) ||
        (NULL == qual_arr_size) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* Get number of qualifiers in requested qualifier set. */
    *qual_arr_size = 0;
    for(idx = 0; idx < _SHR_BITDCLSIZE(BCM_FIELD_QUALIFY_MAX); idx++) {
        *qual_arr_size += _shr_popcount(qset_req->w[idx]);
    }


    /* Allocate & initialize group select codes array. */
    _FP_XGS3_ALLOC((*f_qual_arr),
                   (*qual_arr_size * sizeof(_bcm_field_qual_info_t *)),
                   "Field qualifiers");
    if (NULL == (*f_qual_arr)) {
        return (BCM_E_MEMORY);
    }

    /* Copy individual qualifiers information from the requested qset */
    arr_idx = 0;
    for (idx = 0; idx < _bcmFieldQualifyCount; idx++) {
        /* Skip unused qualifiers. */
        if (0 == BCM_FIELD_QSET_TEST((*qset_req), idx)) {
            continue;
        }

        /* Qualifiers support check. */
        if (NULL == stage_fc->f_qual_arr[idx]) {
            sal_free (*f_qual_arr);
            return (BCM_E_RESOURCE);
        }

        /* Make a copy of the qualifier combination for sorting
         * instead of using pointer to the data in stage_fc
         * this will avoid sorting of qualifiers in stage_fc
         * and make group create independent of previously
         * created groups.
         */
        _FP_XGS3_ALLOC(((*f_qual_arr)[arr_idx]),
                      (sizeof(_bcm_field_qual_info_t)),
                      "Field qualifiers");
        if (NULL == (*f_qual_arr)[arr_idx]) {
            _bcm_field_selcode_qual_arr_free(unit, f_qual_arr, arr_idx);
            return (BCM_E_MEMORY);
        }

        (*f_qual_arr)[arr_idx]->qid = stage_fc->f_qual_arr[idx]->qid;
        (*f_qual_arr)[arr_idx]->conf_sz = stage_fc->f_qual_arr[idx]->conf_sz;

        /* Allocate memory for qualifer config array */
        _FP_XGS3_ALLOC(((*f_qual_arr)[arr_idx]->conf_arr),
                      (stage_fc->f_qual_arr[idx]->conf_sz * sizeof(_bcm_field_qual_conf_t)),
                      "Field qualifiers");
        if (NULL == (*f_qual_arr)[arr_idx]->conf_arr) {
            sal_free((*f_qual_arr)[arr_idx]);
            (*f_qual_arr)[arr_idx] = NULL;
            _bcm_field_selcode_qual_arr_free(unit, f_qual_arr, arr_idx);
            return (BCM_E_MEMORY);
        }

        /* Copy qual info from stage fc to new memory allocated */
        memcpy((*f_qual_arr)[arr_idx]->conf_arr, stage_fc->f_qual_arr[idx]->conf_arr,
                (stage_fc->f_qual_arr[idx]->conf_sz * sizeof(_bcm_field_qual_conf_t)));

        arr_idx++;
        if (arr_idx == (*qual_arr_size)) {
            break;
        }
    }

    /* Qualifier array elements are sorted so less frequently present
       qualifiers appear first. */
    _shr_sort((*f_qual_arr), *qual_arr_size, sizeof(_bcm_field_qual_info_t *),
              _field_qual_info_cmp);

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _field_qual_offsets_copy
 * Purpose:
 *     Copy group qualifiers offsets.
 * Parameters:
 *     unit       - (IN) BCM unit number.
 *     fg         - (IN) Field group.
 *     qual_count - (IN) Number of qualifiers on group qset.
 *     f_qual_arr - (IN) Qualifier descriptors array.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_qual_offsets_copy(int unit, _field_group_t *fg, uint16 qual_count,
                         _bcm_field_qual_info_t **f_qual_arr,
                         uint8 *qual_conf_idx)
{
    _bcm_field_qual_conf_t *qual_config; /* Qualifier configuration.       */
    _bcm_field_group_qual_t *q_arr;      /* Qualifiers array.              */
    bcm_field_qset_t qset_assigned;      /* Assigned to a specific         */
                                         /* entry part qualifiers.         */
    int    qual_idx;                     /* Qualifiers iteration index.    */
    int    part_idx;                     /* Tcam parts iteration index.    */
    int    parts_count = 0;              /* Number of entry parts.         */
    uint8  conf_idx;                     /* Qualifiers configuration index.*/
    uint8  diff;                         /* Selector diff .                */
    uint16 *qid_arr;                     /* New qualifiers array.          */
    _bcm_field_qual_offset_t *offset_arr;/* New qualifier offsets array.   */
    uint16 size = 0;                     /* Qualifiers array size.         */
    int   rv;                            /* Operation return status.       */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == f_qual_arr) || (NULL == qual_conf_idx)) {
        return (BCM_E_PARAM);
    }

    BCM_FIELD_QSET_INIT(qset_assigned);
    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Get currently assigned qualifiers. */
    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        q_arr = &(fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][part_idx]);
        for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
            BCM_FIELD_QSET_ADD (qset_assigned, q_arr->qid_arr[qual_idx]);
        }
    }

    for (part_idx = 0; part_idx < parts_count; part_idx++) {
        /* Initialization. */
        offset_arr = NULL;
        qid_arr = NULL;

        /* Get qualifiers array pointer. */
        q_arr = &(fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][part_idx]);
        size = q_arr->size;

        for (qual_idx = 0; qual_idx < qual_count; qual_idx++) {
            /* Check if qualifier was already assigned. */
            if (BCM_FIELD_QSET_TEST (qset_assigned, f_qual_arr[qual_idx]->qid)) {
                continue;
            }

            /* Get qualifier configuration index. */
            conf_idx = qual_conf_idx[qual_idx];
            /* Get qualifier configuration for the index. */
            qual_config = f_qual_arr[qual_idx]->conf_arr + conf_idx;
            /* Test if selector was inserted in a specific tcam part. */
            rv = _field_selector_diff(unit, fg->sel_codes, part_idx,
                                      &qual_config->selector,
                                      &diff);
            if (BCM_FAILURE(rv) || diff) {
                continue;
            }
            size++;
        }

        /* Allocate qualifiers id and offsets array. */
        _FP_XGS3_ALLOC(qid_arr, (size * sizeof (uint16)), "Group qual id");
        if (NULL == qid_arr) {
            return (BCM_E_MEMORY);
        }
        _FP_XGS3_ALLOC(offset_arr, (size *
                       sizeof (_bcm_field_qual_offset_t)), "Group qual offset");
        if (NULL == offset_arr) {
            sal_free (qid_arr);
            return (BCM_E_MEMORY);
        }

        /* Copy whatever qualifiers the group already have into the new array */
        if (q_arr->size) {
            sal_memcpy(qid_arr, q_arr->qid_arr,
                       q_arr->size * sizeof (uint16));
            sal_memcpy(offset_arr, q_arr->offset_arr,
                       q_arr->size * sizeof(_bcm_field_qual_offset_t));
        }
        size = q_arr->size;

        /* Free old group qualifiers. */
        rv = _bcm_field_group_qualifiers_free(fg, part_idx);
        if (BCM_FAILURE(rv)) {
            sal_free(qid_arr);
            sal_free(offset_arr);
            return (rv);
        }

        /* Now let the group point to the new and bigger array */
        q_arr->qid_arr = qid_arr;
        q_arr->offset_arr = offset_arr;
        q_arr->size = size;

        for (qual_idx = 0; qual_idx < qual_count; qual_idx++) {
            /* Check if qualifier was already assigned. */
            if (BCM_FIELD_QSET_TEST (qset_assigned, f_qual_arr[qual_idx]->qid)) {
                continue;
            }

            /* Get qualifier configuration index. */
            conf_idx = qual_conf_idx[qual_idx];
            /* Get qualifier configuration for the index. */
            qual_config = f_qual_arr[qual_idx]->conf_arr + conf_idx;
            /* Test if selector was inserted in a specific tcam part. */
            rv = _field_selector_diff(unit, fg->sel_codes, part_idx,
                                      &qual_config->selector,
                                      &diff);
            if (BCM_FAILURE(rv) || diff) {
                continue;
            }
            q_arr->qid_arr[q_arr->size] = f_qual_arr[qual_idx]->qid;
            q_arr->offset_arr[q_arr->size] = qual_config->offset;
            q_arr->size++;
            BCM_FIELD_QSET_ADD (qset_assigned, f_qual_arr[qual_idx]->qid);
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_qual_lists_get
 * Purpose:
 *     Build a group's qual_info_t linked list by assembling
 *     linked-lists from each select code.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control structure.
 *     fg        - (IN) Group control structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qual_lists_get(int unit, _field_stage_t *stage_fc,
                             _field_group_t *fg)
{
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_selcode_to_qset
 * Purpose:
 *     Find the qset that corresponds to all the possible qualifiers
 *     supported by the field selection codes (FPF1, FPF2, FPF3).
 * Parameters:
 *     unit      - (IN)  unit
 *     stage_fc  - (IN)  Stage Field control structure.
 *     fg        - (IN)  Field group control structure.
 *     code_id   - (IN)  Entry part.
 *     qset      - (OUT) Client qualifier set.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_selcode_to_qset(int unit, _field_stage_t *stage_fc,
                              _field_group_t *fg, int code_id,
                              bcm_field_qset_t *qset)
{
                                /* selectors value.              */
    int idx;                    /* Qualifiers array iterator.    */

    /* Input parameters check. */
    if ((NULL == qset) || (NULL == stage_fc) ||
        (NULL == fg)   || (code_id < 0) || (code_id >= _FP_MAX_ENTRY_WIDTH)) {
        return (BCM_E_PARAM);
    }

    BCM_FIELD_QSET_INIT(*qset);

    for(idx = 0; idx < fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][code_id].size; idx++) {
        BCM_FIELD_QSET_ADD(*qset, fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][code_id].qid_arr[idx]);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_selcode_get
 * Purpose:
 *     Finds a 4-tuple of select encodings that will satisfy the
 *     requested qualifier set (Qset).
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_selcode_get(int unit, _field_stage_t *stage_fc,
                           bcm_field_qset_t *qset_req,
                           _field_group_t *fg)
{
    _bcm_field_qual_info_t **f_qual_arr; /* Qualifiers information.         */
    _bcm_field_qual_conf_t *qual_config; /* Qualifier configuration.        */
    uint8 *qual_conf_idx;                /* Array of iterators over each    */
                                         /* individual qual configurations. */
    _field_sel_t *sel_arr;               /* Selectors status before each    */
                                         /* individual qualifier            */
                                         /* configuration was added.        */
    _field_sel_t *candidate;             /* Candidate select codes set.     */
    uint8  conf_idx = 0;                 /* Qualifiers configuration index. */
    uint16 qual_count = 0;               /* Number of qualifiers in         */
                                         /* the requested qset.             */
    int   parts_count = 0;               /* Number of tcam parts.           */
    int   qual_idx = 0;                  /* Qualifiers iteration index.     */
    int   sel_entry_sz = 0;              /* Byte size of sel_arr entity.    */
    int   rv = BCM_E_NONE;               /* Operation return status.        */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    f_qual_arr = NULL;
    qual_config = NULL;
    qual_conf_idx = NULL;
    sel_arr = NULL;
    candidate = NULL;

    /* Update group selectors based on group flags. */
    rv = _field_group_selectors_init(unit, fg);
    BCM_IF_ERROR_RETURN(rv);

    /* Get qualifiers configuration.          */
    /* NOTE: Must free f_qual_arr at the end. */
    rv = _bcm_field_qualifiers_info_get (unit, stage_fc, qset_req,
                                         &f_qual_arr, &qual_count);
    BCM_IF_ERROR_RETURN(rv);

    /* Allocate and initialize qualifier configurations iterators. */
    _FP_XGS3_ALLOC(qual_conf_idx, (qual_count * sizeof(uint8)),
                   "Field qualifier configuration");
    if (NULL == qual_conf_idx) {
        _bcm_field_selcode_qual_arr_free(unit, &f_qual_arr, qual_count);
        return (BCM_E_MEMORY);
    }

    /* Get number of entry parts. */
    rv  = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                             fg->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        sal_free(qual_conf_idx);
        qual_conf_idx = NULL;
        _bcm_field_selcode_qual_arr_free(unit, &f_qual_arr, qual_count);
        return (rv);
    }

    /* Allocate and initialize select codes status before           */
    /* individual qualifier configuration was applied.              */
    /* Candidate select codes are in the last element of the array. */
    sel_entry_sz = parts_count * sizeof(_field_sel_t);
    _FP_XGS3_ALLOC(sel_arr, ((1 + qual_count) * sel_entry_sz), \
                   "Field group select codes");
    if (NULL == sel_arr) {
        sal_free(qual_conf_idx);
        _bcm_field_selcode_qual_arr_free(unit, &f_qual_arr, qual_count);
        return (BCM_E_MEMORY);
    }

    /* Initialize first qualifier select codes to group select codes. */
    candidate = sel_arr + (qual_count * parts_count);
    sal_memcpy(candidate, fg->sel_codes, sel_entry_sz);

    /* Initialize first qualifier select codes to a group defaults */
    sal_memcpy(sel_arr, candidate, sel_entry_sz);

    /* Main select codes selection loop over caller requested qualifier set. */
    for (qual_idx = 0; qual_idx < qual_count;) {

        /* Get qualifier selcodes configuration index. */
        conf_idx = qual_conf_idx[qual_idx];

        /*
         * Sort qualifier configurations so minimum
         * change configuration attempted first.
         */
        if (0 == conf_idx) {
            rv = _field_qual_selectors_sort(unit, candidate,
                    parts_count, f_qual_arr[qual_idx]);
            if (BCM_FAILURE(rv)) {
                sal_free(sel_arr);
                sal_free(qual_conf_idx);
                _bcm_field_selcode_qual_arr_free(unit, &f_qual_arr, qual_count);
                return (rv);
            }
        }

        /*
         * Set default return value, in case all configuration
         * options were exhausted.
         */
        rv = BCM_E_RESOURCE;

        /* Loop over possible qualifier configurations. */
        for (;conf_idx < f_qual_arr[qual_idx]->conf_sz; conf_idx++)  {

            /* Get qualifier configuration for the index. */
            qual_config = f_qual_arr[qual_idx]->conf_arr + conf_idx;

            /* Skip conflicting configurations. */
            if ((uint8) _FP_INVALID_INDEX ==
                qual_config->selector.update_count) {
               continue;
            }

            /*
             *  Attempt to accommodate specific qualifier
             *  configuration into candidate select codes.
             */
            rv = _field_qual_selectors_insert(unit, candidate,
                                              parts_count,
                                              &qual_config->selector);

            if (BCM_SUCCESS(rv) || (BCM_E_RESOURCE != rv)) {
                break;
            }
        }

        /*
         * If code failed to insert qualifier configuration
         * attempt a previous qualifier in the list using alternative
         * configuration.
         */
        if (BCM_FAILURE(rv)) {
            if ((qual_idx == 0) || (BCM_E_RESOURCE != rv)) {
                break;
            }
            /* Previous qualifier has to use next available configuration. */
            while (qual_idx > 0) {
                /* This qualifier configuration will be re-selected. */
                qual_conf_idx[qual_idx] = 0;
                /* Back to the previous qualifier. */
                qual_idx--;
                /* Check select codes were modified by qualifier. */
                qual_config = f_qual_arr[qual_idx]->conf_arr +
                              qual_conf_idx[qual_idx];
                /* If modified -> reverse changes and proceed to next config.*/
                if ((0 == qual_idx) ||
                    (0 != qual_config->selector.update_count)) {
                    /* Go to the next configuration */
                    qual_conf_idx[qual_idx]++;
                    /* Restore original select codes state. */
                    sal_memcpy(candidate,
                        sel_arr + (qual_idx * parts_count),
                        sel_entry_sz);
                    break;
                }
            }
        } else {
            /* Preserve current qualifier configuration index. */
            qual_conf_idx[qual_idx] = conf_idx;
            /* Proceed to the next qualifier. */
            qual_idx++;
            /* Set selection base line for the next qualifier */
            if (qual_idx < qual_count) {
                sal_memcpy(sel_arr + (qual_idx * parts_count),
                           candidate, sel_entry_sz);
            }
        }
    }
    if (BCM_SUCCESS(rv)) {
        /* Copy selected codes to the group configuration. */
        sal_memcpy(fg->sel_codes, candidate, sel_entry_sz);
        /* Copy qualifiers offset to group tcam parts. */
        rv = _field_qual_offsets_copy(unit, fg, qual_count,
                                      f_qual_arr, qual_conf_idx);
    }
    sal_free(sel_arr);
    sal_free(qual_conf_idx);
    _bcm_field_selcode_qual_arr_free(unit, &f_qual_arr, qual_count);
    return (rv);
}
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *     _field_egress_key_attempt
 * Purpose:
 *     Verify if specific key can satisfy user requested qset.
 *
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     key_pri   - (IN) Primary key id.
 *     key_sec   - (IN) Secondary key id.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_egress_key_attempt(int unit, _field_stage_t *stage_fc,
                              bcm_field_qset_t *qset_req,
                              uint8 key_pri, uint8 key_sec,
                              _field_group_t *fg)
{
    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }
    fg->sel_codes[0].fpf3= key_pri;
    if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        fg->sel_codes[1].fpf3= key_sec;
    }
    /* Verify that each requested qualifier present in the key. */
    return _bcm_field_selcode_get(unit, stage_fc, qset_req, fg);
}
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

/*
 * Function: _field_qualify_VlanFormat
 *
 * Purpose:
 *     Add qualification data to an entry for Vlan Tag Format.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry ID.
 *     qual_id  - (IN) Qualifier id.
 *     data     - (IN) Outer & Inner tag presence info.
 *     mask     - (IN) Data mask.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qualify_VlanFormat(int unit, bcm_field_entry_t entry,
                          bcm_field_qualify_t qual_id,
                          uint8 data, uint8 mask)
{
    _field_entry_t      *f_ent;  /* Field entry structure.   */
    int                 rv;      /* Operation return status. */

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_qual_vlanformat_reverse) ||
        soc_feature(unit, soc_feature_field_multi_stage)) {
        if ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) ||
            (SOC_IS_TRX(unit))) {
            data = (((data & 0x2) >> 1) | ((data & 0x1) << 1));
            mask = (((mask & 0x2) >> 1) | ((mask & 0x1) << 1));
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    rv = _field_qualify32(unit, entry, qual_id, data, mask);
    return (rv);
}

/*
 * Function: _field_qualify_VlanFormat_get
 *
 * Purpose:
 *     Get qualification match criteria from an entry for Vlan Tag Format.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry ID.
 *     qual_id  - (IN) Qualifier id.
 *     data     - (OUT) Outer & Inner tag presence info.
 *     mask     - (OUT) Data mask.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_qualify_VlanFormat_get(int unit, bcm_field_entry_t entry,
                          bcm_field_qualify_t qual_id,
                          uint8 *data, uint8 *mask)
{
    uint8            hw_data;   /* HW encoded data.         */
    uint8            hw_mask;   /* HW encoded mask.         */
    int              rv;        /* Operation return status. */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    _field_entry_t   *f_ent;    /* Field entry structure.   */
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */


    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, qual_id,
                                              &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if (((soc_feature(unit, soc_feature_field_qual_vlanformat_reverse)) ||
        (soc_feature(unit, soc_feature_field_multi_stage))) &&
         ((_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) ||
         (SOC_IS_TRX(unit)))) {
            *data = (((hw_data & 0x2) >> 1) | ((hw_data & 0x1) << 1));
            *mask = (((hw_mask & 0x2) >> 1) | ((hw_mask & 0x1) << 1));
    } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    {
        *data = hw_data;
        *mask = hw_mask;
    }
    return (rv);
}

/*
 * Function:
 *     _field_range_dump
 *
 * Purpose:
 *     Show contents of a range checker
 *
 * Parameters:
 *     fr - range checker structure pointer
 *
 * Returns:
 *     Nothing.
 */
void
_field_range_dump(const char *pfx, _field_range_t *fr)
{
    LOG_CLI((BSL_META("%s: Range ID=%d, flag=%#x, min=%d, max=%d, hw_index=%d(%#x), "),
             pfx, fr->rid, fr->flags, fr->min, fr->max, fr->hw_index,
             fr->hw_index));
    LOG_CLI((BSL_META("style=BCM56504\n")));
}

/*
 * Function:
 *     _field_entry_phys_dump
 *
 * Purpose:
 *     Show contents of a physical entry structure
 *
 * Parameters:
 *     unit       - BCM device number
 *     f_ent      - Physical entry to dump
 *     entry_part - Field entry part.
 * Returns:
 *     Nothing.
 */
void
_field_entry_phys_dump(int unit, _field_entry_t *f_ent, uint8 entry_part)
{
    _bcm_field_group_qual_t   *q_arr;  /* Qualifiers array.    */
    int                       idx;
    int                       idx_max;
    int                       qual_idx;
    int                       free_tcam = FALSE;
    uint32                    width;
    _field_group_t            *fg;
    _bcm_field_qual_data_t    q_data;
    _bcm_field_qual_data_t    q_mask;
    _bcm_field_qual_offset_t  *q_offset;
    char                      *ip_type_str[] = BCM_FIELD_IPTYPE_STRINGS;
    int                       rv;
#if defined(BCM_TRX_SUPPORT)
    int                       range_check_valid = 0;
#endif /* !BCM_TRX_SUPPORT */

    LOG_CLI((BSL_META_U(unit,
                        "         slice=%d, slice_idx=%#x, part =%d prio=%#x, flags=%#x, "),
             f_ent->fs->slice_number, f_ent->slice_idx, entry_part,
             f_ent->prio, f_ent->flags));
    if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
        LOG_CLI((BSL_META_U(unit,
                            "Not installed\n")));
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "Installed, ")));

        if (!(f_ent->flags & _FP_ENTRY_ENABLED)) {
            LOG_CLI((BSL_META_U(unit,
                                "Disabled")));
        }
        else {
            LOG_CLI((BSL_META_U(unit,
                                "Enabled")));
        }
        if (f_ent->flags & _FP_ENTRY_DIRTY) {
            LOG_CLI((BSL_META_U(unit,
                                ", Dirty")));
        }
        if (f_ent->flags & _FP_ENTRY_OAM_STAT_VALID) {
            LOG_CLI((BSL_META_U(unit,
                                ", OamStatValid")));
        }
        else {
             LOG_CLI((BSL_META_U(unit,
                                 "\n")));
        }
    }

    if ((NULL == f_ent->tcam.key)) {
        free_tcam = TRUE;
    }

    rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "\nUnit (%d) Entry (%d) tcam key read failure.\n"),
                 unit, f_ent->eid));
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "              tcam: color_indep=%d, "),
             ((f_ent->flags & _FP_ENTRY_COLOR_INDEPENDENT) ? 1 : 0)));



    fg = f_ent->group;
    idx = _FP_ENTRY_TYPE_DEFAULT;

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) ||
        soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            if (f_ent->efp_key_match_type) {
                idx = _FP_ENTRY_TYPE_1;
            } else {
                idx = _FP_ENTRY_TYPE_0;
            }
        }
    }
#endif

    q_arr = &(fg->qual_arr[idx][entry_part]);
    for (qual_idx = 0; qual_idx < q_arr->size; qual_idx++) {
        idx_max = -1;
        q_offset = q_arr->offset_arr + qual_idx;

        /*
         * There is no value associated with zero width qualifiers
         * (Stage, Ip4 etc) just print the name.
         */
        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, width);
        if (0 == width) {
            switch (q_arr->qid_arr[qual_idx]) {
                case bcmFieldQualifyInPorts:
                case bcmFieldQualifyInPort:
#if defined(BCM_RAPTOR_SUPPORT) || defined(BCM_TRX_SUPPORT)
                    if (BCM_PBMP_NOT_NULL(f_ent->pbmp.mask)) {
                        char pfmt[SOC_PBMP_FMT_LEN];
                        bcm_pbmp_t lb_pbm;
                        bcm_pbmp_t mask_pbm;
                        /* Remove loopback port from ipbm mask */
                        BCM_PBMP_CLEAR(lb_pbm);
                        BCM_PBMP_ASSIGN(mask_pbm, f_ent->pbmp.mask);
                        BCM_PBMP_OR(lb_pbm, PBMP_LB(unit));
                        if (BCM_PBMP_NOT_NULL(lb_pbm)) {
                            BCM_PBMP_REMOVE(mask_pbm, PBMP_LB(unit));
                        }


                        LOG_CLI((BSL_META_U(unit,
                                            "\n %s "),
                                 _field_qual_name(q_arr->qid_arr[qual_idx])));
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    DATA=")));
                        LOG_CLI((BSL_META_U(unit,
                                            "%s"),
                                 SOC_PBMP_FMT(f_ent->pbmp.data, pfmt)));
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    MASK=")));
                        LOG_CLI((BSL_META_U(unit,
                                            "%s"),
                                 SOC_PBMP_FMT(mask_pbm, pfmt)));
                    }
#endif
                    break;
                case bcmFieldQualifyHiGig:
                    if (f_ent->tcam.higig_mask) {
                        LOG_CLI((BSL_META_U(unit,
                                            "\n %s "),
                                 _field_qual_name(q_arr->qid_arr[qual_idx])));
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    DATA= %d"),
                                 f_ent->tcam.higig));
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    MASK= %d"),
                                 f_ent->tcam.higig_mask));
                    }
                    break;
                case bcmFieldQualifyIpType:
                    if ((bcmFieldIpTypeAny != f_ent->tcam.ip_type) &&
                            (bcmFieldIpTypeCount > f_ent->tcam.ip_type)) {
                        LOG_CLI((BSL_META_U(unit,
                                            "\n %s "),
                                 _field_qual_name(q_arr->qid_arr[qual_idx])));
                        LOG_CLI((BSL_META_U(unit,
                                            "\n    DATA= %s"),
                                 ip_type_str[f_ent->tcam.ip_type]));
                    }
                    break;
                default:
                    LOG_CLI((BSL_META_U(unit,
                                        "\n %s "),
                             _field_qual_name(q_arr->qid_arr[qual_idx])));
            }
            continue;
        } else {
#if defined(BCM_FIREBOLT2_SUPPORT)
            /*
             * Although FB2 has drop qualifier -
             * Drop bit is always present in the tcam
             * ancestor of the fixed key.
             */
            if ((bcmFieldQualifyDrop == q_arr->qid_arr[qual_idx]) &&
                (SOC_IS_FIREBOLT2(unit))) {
                if (f_ent->tcam.drop_mask) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n %s "),
                             _field_qual_name(q_arr->qid_arr[qual_idx])));
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    DATA= %d"),
                             f_ent->tcam.drop));
                    LOG_CLI((BSL_META_U(unit,
                                        "\n    MASK= %d"),
                             f_ent->tcam.drop_mask));
                }
                continue;
            }
#endif /* BCM_FIREBOLT2_SUPPORT */
        }

        _FP_QUAL_DATA_CLEAR(q_data);
        _FP_QUAL_DATA_CLEAR(q_mask);
        /* Read qualifier match value and mask. */
        rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, q_data, q_mask);
        if (BCM_FAILURE(rv)) {
            return;
        }

        /* Check if qualifier was installed. */
        for (idx = 7; idx >= 0; idx--) {
            if (q_mask[idx] != 0)  {
                idx_max = idx;
                break;
            }
        }

#if defined(BCM_TRX_SUPPORT)
        if ((bcmFieldQualifyRangeCheck == q_arr->qid_arr[qual_idx]) &&
            (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassPort) ||
             BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassL3) ||
             BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassVPort) ||
             BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInterfaceClassL2))) {
            for (idx = idx_max; idx >= 0; idx--) {
                if (0 != (q_mask[idx] & 0xffffff)) {
                    range_check_valid = 1;
                }
            }
            if (0 == range_check_valid) {
                continue;
            }
        }
#endif /* !BCM_TRX_SUPPORT */

        if (idx_max >= 0) {
            int i;
            LOG_CLI((BSL_META_U(unit,
                                "\n %s "),
                     _field_qual_name(q_arr->qid_arr[qual_idx])));
            for (i = 0; i < q_offset->num_offsets; i++) {
               if (0 != q_offset->width[i]) {
                  LOG_CLI((BSL_META_U(unit,
                                "\n    Offset%d: %d Width%d: %d "),
                                i, q_offset->offset[i], i, q_offset->width[i]));
               }
            }

            LOG_CLI((BSL_META_U(unit,
                                "\n    DATA=0x")));
            if (SOC_IS_TRX(unit)
                && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && (bcmFieldQualifyInnerVlan == q_arr->qid_arr[qual_idx])) {
                /* EFP InnerVlan hardware format is different from IFP.
                 */
                int32 data = 0;
                for (idx = 0; idx <= idx_max; idx++) {
                    data = ((q_data[idx] & 0xfff0) >> 4) |
                            ((q_data[idx] & 0xf) << 12);
                    LOG_CLI((BSL_META_U(unit,
                                        "%08x "), data));
                }
            } else {
                uint32 data = 0;
                uint32 mask = 0;
                for (idx = idx_max; idx >= 0; idx--) {
                    data = q_data[idx];
                    mask = q_mask[idx];

                    if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                        /* Check if HW packet_res must be remmaped for API use */
                        if (bcmFieldQualifyPacketRes == q_arr->qid_arr[qual_idx]) {
                            int (*func)(int, bcm_field_entry_t, uint32 *, uint32 *)
                               = _field_qualify_PacketRes_get;

#if defined(BCM_TRIDENT2_SUPPORT)
                            if (SOC_IS_TD2_TT2(unit)) {
                                func = _bcm_field_td2_qualify_PacketRes_get;
                            } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
                            if (SOC_IS_TRIUMPH3(unit)) {
                                func = _bcm_field_tr3_qualify_PacketRes_get;
                            } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
                            if (SOC_IS_KATANA(unit)) {
                                func = _bcm_field_kt_qualify_PacketRes_get;
                            } else
#endif /* BCM_KATANA_SUPPORT */
                            {
#if defined (BCM_KATANA2_SUPPORT)
                                if (SOC_IS_KATANA2(unit)) {
                                   func = _bcm_field_kt2_qualify_PacketRes_get;
                                }
#endif /* BCM_KATANA2_SUPPORT */
                            }

                            (*func)(unit, f_ent->eid, &data, &mask);
                            q_mask[idx] = mask;
                        }
                    }
                    LOG_CLI((BSL_META_U(unit,
                                        "%08x "), data));
                }
            }

            LOG_CLI((BSL_META_U(unit,
                                "\n    MASK=0x")));
            if (SOC_IS_TRX(unit)
                && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && (bcmFieldQualifyInnerVlan == q_arr->qid_arr[qual_idx])) {
                /* EFP InnerVlan hardware format is different from IFP.
                 */
                int32 mask = 0;
                for (idx = 0; idx <= idx_max; idx++) {
                    mask = ((q_mask[idx] & 0xfff0) >> 4) |
                            ((q_mask[idx] & 0xf) << 12);
                    LOG_CLI((BSL_META_U(unit,
                                        "%08x "), mask));
                }
            } else {
                for (idx = idx_max; idx >= 0; idx--) {
                    LOG_CLI((BSL_META_U(unit,
                                        "%08x "), q_mask[idx]));
                }
            }
        }
    }

    if (free_tcam) {
        if (NULL != f_ent->tcam.key) {
            sal_free(f_ent->tcam.key);
            sal_free(f_ent->tcam.mask);
        }
        if (f_ent->flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
            if (NULL != f_ent->extra_tcam.key) {
                sal_free(f_ent->extra_tcam.key);
                sal_free(f_ent->extra_tcam.mask);
            }
        }
        f_ent->tcam.key = f_ent->tcam.mask =
            f_ent->extra_tcam.key = f_ent->extra_tcam.mask = NULL;
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {

            if (NULL != f_ent->key_match_tcam.key) {
                sal_free(f_ent->key_match_tcam.key);
                sal_free(f_ent->key_match_tcam.mask);
            }
            f_ent->key_match_tcam.key = f_ent->key_match_tcam.mask = NULL;
        }
#endif
        free_tcam = FALSE;
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));
}


/*
 * Function:
 *     _field_selcode_dump
 * Purpose:
 *     Output a set of field selects code.
 */
void
_field_selcode_dump(int unit, char *prefix, _field_sel_t *sel_codes,
                    char *suffix, _field_stage_id_t stage_id)
{
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    char                      *efp_key_type_str[] = _BCM_EFP_FIELD_KEY_STRINGS;
#endif
    if (NULL == sel_codes) {
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "%s{"), (prefix == NULL) ? "" : prefix));
    if (_FP_SELCODE_DONT_CARE != sel_codes->fpf1) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         FPF1=%d"), sel_codes->fpf1));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->fpf2) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         FPF2=%d"), sel_codes->fpf2));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->fpf3) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (_BCM_FIELD_STAGE_EGRESS == stage_id) {
            LOG_CLI((BSL_META_U(unit,
                            "\n         FPF3=%s"), efp_key_type_str[sel_codes->fpf3]));
        } else
#endif
        {
            LOG_CLI((BSL_META_U(unit,
                            "\n         FPF3=%d"), sel_codes->fpf3));
        }
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->fpf4) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         FPF4=%d"), sel_codes->fpf4));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->src_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         SourceClassSelect=%d"),
                 sel_codes->src_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->dst_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         DestinationClassSelect=%d"),
                 sel_codes->dst_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->intf_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         InterfaceClassSelect=%d"),
                 sel_codes->intf_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->loopback_type_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         LoopbackTypeSelect=%d"),
                 sel_codes->loopback_type_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->ingress_entity_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         IngressEntitySelect=%d"),
                 sel_codes->ingress_entity_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->src_entity_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         SrcEntitySelect=%d"),
                 sel_codes->src_entity_sel));    }

    if (_FP_SELCODE_DONT_CARE != sel_codes->dst_fwd_entity_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         DestinationEntitySelect=%d"),
                 sel_codes->dst_fwd_entity_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->fwd_field_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         ForwardingFieldSelect=%d"),
                 sel_codes->fwd_field_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->ttl_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         TtlClassSelect=%d"),
                 sel_codes->ttl_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->tos_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         TosClassSelect=%d"),
                 sel_codes->tos_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->tcp_class_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         TcpClassSelect=%d"),
                 sel_codes->tcp_class_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->ip_header_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         IpHeaderSelect=%s"),
                 (sel_codes->ip_header_sel) ? "Inner" : "Outer"));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->inner_vlan_overlay) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         InnerVlanOverlaySelect=%d"),
                 sel_codes->inner_vlan_overlay));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->aux_tag_1_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         AuxTag1Select=%d"),
                 sel_codes->aux_tag_1_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->aux_tag_2_sel) {
        LOG_CLI((BSL_META_U(unit,
                            "\n         AuxTag2Select=%d"),
                 sel_codes->aux_tag_2_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->oam_overlay_sel) {
        LOG_CLI((BSL_META_U(unit,
		                     "\n         OamOverlaySelect=%d"),
                   sel_codes->oam_overlay_sel));
    }
    if (_FP_SELCODE_DONT_CARE != sel_codes->intraslice) {
        if (_FP_SELCODE_DONT_USE == sel_codes->intraslice) {
            LOG_CLI((BSL_META_U(unit,
                                "\n         Intraslice=%s\n"),
                     "Primary slice."));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "\n         Intraslice=%d\n"),
                     sel_codes->intraslice));
        }
    }
    return;
}


/*
 * Function:
 *     _field_slice_dump
 * Purpose:
 *     Output a slice worth of data, including any entries in the slice.
 */
void
_field_slice_dump(int unit, char *prefix, _field_group_t *fg,
                  _field_slice_t *fs, char *suffix)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) {
        _field_stage_t *stage_fc;     /* Stage field control structure.*/
        int slice = 0;                /* Slice Count Iterator. */
        _field_slice_t *fslice;       /*slice structure */
        int free_entries_count = 0;   /*free entry count */
        int total_entries_count = 0;  /* total entry count */
        int rv;
         /* Get field group stage control structure. */
        rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
        if (BCM_FAILURE(rv)) {
            return;
        }
         /* Retreive Slice Instance. */
        fslice = stage_fc->slices[fg->instance];
        /* Calculate free entry count. */
        for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
            free_entries_count += fslice[slice].free_count;
            total_entries_count += fslice[slice].entry_count;
        }

        LOG_CLI((BSL_META_U(unit,
                        "%s{"), (prefix == NULL) ? "" : prefix));
        LOG_CLI((BSL_META_U(unit,
                        "slice_number=%d, "), fs->slice_number));
        LOG_CLI((BSL_META_U(unit,
                        "Entry count=%d(%#x), "),
                    total_entries_count, total_entries_count));
        LOG_CLI((BSL_META_U(unit,
                        "Entry free=%d(%#x)"),
                    free_entries_count, free_entries_count));
        LOG_CLI((BSL_META_U(unit,
                        "},%s"), (suffix == NULL) ? "" : suffix));
    } else
#endif
    {
        while (fs != NULL) {
            LOG_CLI((BSL_META_U(unit,
                        "%s{"), (prefix == NULL) ? "" : prefix));
            LOG_CLI((BSL_META_U(unit,
                        "slice_number=%d, "), fs->slice_number));
            LOG_CLI((BSL_META_U(unit,
                        "Entry count=%d(%#x), "),
                        fs->entry_count, fs->entry_count));
            LOG_CLI((BSL_META_U(unit,
                        "Entry free=%d(%#x)"),
                        fs->free_count, fs->free_count));
            LOG_CLI((BSL_META_U(unit,
                        "},%s"), (suffix == NULL) ? "" : suffix));
            fs = fs->next;
        }
    }
}

/*
 * Function:
 *     _field_qual_list_dump
 * Purpose:
 *     Output qualiers set in 'qset'.
 */
void
_field_qual_list_dump(char *prefix, _field_group_t *fg, uint8 entry_part, char *suffix)
{

    _bcm_field_group_qual_t *q_arr;   /* Qualifiers array.        */
    int first_print = 1;
    int idx;

    LOG_CLI((BSL_META("%s{"), (prefix == NULL) ? "" : prefix));
    q_arr = &(fg->qual_arr[_FP_ENTRY_TYPE_DEFAULT][entry_part]);
    /* Output the qualifier info list*/
    for (idx = 0; idx < q_arr->size; idx++) {
        LOG_CLI((BSL_META("%s%s"),
                    (first_print ? "" : "->"),
                    _field_qual_name(q_arr->qid_arr[idx])));
        first_print = 0;
    }
    LOG_CLI((BSL_META("}%s"), (suffix == NULL) ? "" : suffix));
}

/*
 * Function:
 *     _field_qset_dump
 * Purpose:
 *     Output qualiers set in 'qset'.
 */
void
_field_qset_dump(char *prefix, bcm_field_qset_t qset, char *suffix)
{
    int                 qual;
    int                 idx;
    int first_qual = 1, first_udf_id = 1;

    if (prefix == NULL) {
        prefix = "";
    }
    if (suffix == NULL) {
        suffix = "";
    }

    LOG_CLI((BSL_META("%s{"), prefix));
    for (qual = 0; qual < _bcmFieldQualifyCount; qual++) {
        if (BCM_FIELD_QSET_TEST(qset, qual)) {
            LOG_CLI((BSL_META("%s%s"),
                        (first_qual ? "" : ", "), _field_qual_name(qual)));
            first_qual = 0;
        }
    }

    for (idx = 0; idx < BCM_FIELD_USER_NUM_UDFS; idx++) {
        if (!SHR_BITGET(qset.udf_map, idx)) {
            continue;
        }
        LOG_CLI((BSL_META("%s%d"),
(first_udf_id ? " : udf_id={" : ", "), idx));
        first_udf_id = 0;
    }
    if (first_udf_id == 0) {
        LOG_CLI((BSL_META("}")));
    }

    LOG_CLI((BSL_META("}%s"), suffix));
}

/*
 * Function:
 *     _field_qset_debug
 * Purpose:
 *     Output qualier set in 'qset' for debug mode only.
 */
void
_field_qset_debug(bcm_field_qset_t qset)
{
    int qual;
    int first_qual = 1;

    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META("{")));
    for (qual = 0; qual < _bcmFieldQualifyCount; qual++) {
        if (BCM_FIELD_QSET_TEST(qset, qual)) {
            LOG_VERBOSE(BSL_LS_BCM_FP,
                        (BSL_META("%s%s"),
                         (first_qual ? "" : "), "),
                         _field_qual_name(qual)));
            first_qual = 0;
        }
    }
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META("}")));
}

/*
 * Function:
 *     _field_aset_dump
 * Purpose:
 *     Output qualiers set in 'aset'.
 */
void
_field_aset_dump(char *prefix, bcm_field_aset_t aset, char *suffix)
{
    int action;
    int first_action = 1;

    if (prefix == NULL) {
        prefix = "";
    }
    if (suffix == NULL) {
        suffix = "";
    }

    LOG_CLI((BSL_META("%s{"), prefix));
    for (action = 0; action < bcmFieldActionCount; action++) {
        if (BCM_FIELD_ASET_TEST(aset, action)) {
            LOG_CLI((BSL_META("%s%s"),
                        (first_action ? "" : ", "), _field_action_name(action)));
            first_action = 0;
        }
    }

    LOG_CLI((BSL_META("}%s"), suffix));
}


/*
 * Function:
 *     _field_counter_dump
 * Purpose:
 *     Output fields in a _field_counter_s struct.
 */
int
_field_stat_dump(int unit, const _field_entry_t *f_ent)
{
    _field_stat_t        *f_st;
    int                  idx;
    int                  rv = BCM_E_NONE;
    char                 *sname[] = BCM_FIELD_STAT;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    char                 *aname[] = BCM_FIELD_STAT_ACTION;
#endif

    /* Input parameters check. */
    if (f_ent == NULL) {
        return (BCM_E_PARAM);
    }

    if (f_ent->statistic.flags  & _FP_ENTRY_STAT_VALID) {
        rv = _bcm_field_stat_get (unit, f_ent->statistic.sid, &f_st);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }


        LOG_CLI((BSL_META_U(unit,
                            "{stat id %d  slice = %d idx=%d entries=%d}"),
                 f_st->sid, f_st->pool_index, f_st->hw_index,
                                           f_st->hw_entry_count));
        for (idx = 0; idx < f_st->nstat; idx++) {
            /* coverity[mixed_enums] */
            if (f_st->stat_arr[idx] < (bcm_field_stat_t)_bcmFieldStatCount) {
                LOG_CLI((BSL_META_U(unit,
                                    "{%s}"), sname[f_st->stat_arr[idx]]));
            }
        }
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "NULL")));
    }

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) {
        LOG_CLI((BSL_META_U(unit, "\r\n")));
        LOG_CLI((BSL_META_U(unit,
                        "         Extended statistics=")));
        if (f_ent->statistic.flags  & _FP_ENTRY_EXTENDED_STAT_VALID) {
            rv = _bcm_field_stat_get (unit,
                          f_ent->statistic.extended_sid, &f_st);
            if (BCM_FAILURE(rv)) {
                return (rv);
            }

            LOG_CLI((BSL_META_U(unit,
                            "\r\n                    {stat id %d action = %s"
                            " slice = %d idx=%d entries=%d}"),
                        f_st->sid, aname[f_ent->statistic.stat_action],
                        f_st->pool_index, f_st->hw_index,
                        f_st->hw_entry_count));
            for (idx = 0; idx < f_st->nstat; idx++) {
                /* coverity[mixed_enums] */
                if (f_st->stat_arr[idx] < (bcm_field_stat_t)_bcmFieldStatCount){
                    LOG_CLI((BSL_META_U(unit,
                                    "{%s}"), sname[f_st->stat_arr[idx]]));
                }
            }
        } else {
            LOG_CLI((BSL_META_U(unit,
                            "NULL")));
        }
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    return (rv);
}

/*
 * Function:
 *     _field_policers_dump
 * Purpose:

 *     Output meter data for given entry.
 */
void
_field_policers_dump(int unit, _field_entry_t *f_ent)
{
    bcm_policer_t     policer_id;     /* Policer id.                  */
    _field_policer_t  *f_pl;          /* Internal policer descriptor. */
    int               idx;            /* Policers levels iterator.    */
    int               rv;             /* Operation return status.     */
    uint8             isPolicerDirty; /* Verify if policer Dirty      */

    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        /* Read policer id from entry. */
        rv = bcm_esw_field_entry_policer_get(unit, f_ent->eid,
                                             idx, &policer_id);
        if (BCM_E_NOT_FOUND == rv) {
            continue;
        }
        if (BCM_FAILURE(rv)) {
            return;
        }

        /* Get policer reference count. */
        rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
        if (BCM_FAILURE(rv)) {
            return;
        }

        if ((f_pl->hw_flags & _FP_POLICER_DIRTY)
                    || (f_ent->flags & _FP_ENTRY_DIRTY)) {
            isPolicerDirty = TRUE;
        } else {
            isPolicerDirty = FALSE;
        }

        LOG_CLI((BSL_META_U(unit,
                            "{pid=%#x, level=%#x, "), f_pl->pid, f_pl->level));

        if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
            LOG_CLI((BSL_META_U(unit,
                                "peak_kbits_sec=%#x, peak_kbits_burst=%#x,"),
                     f_pl->cfg.pkbits_sec, f_pl->cfg.pkbits_burst));
        }

        if ((bcmPolicerModePeak != f_pl->cfg.mode)) {
            LOG_CLI((BSL_META_U(unit,
                                " commit_kbits_sec=%#x, commit_kbits_burst=%#x, "),
                     f_pl->cfg.ckbits_sec, f_pl->cfg.ckbits_burst));
        }

        LOG_CLI((BSL_META_U(unit,
                            "PacketBased=%#x,"),
                 (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) ? 1 : 0));

        LOG_CLI((BSL_META_U(unit,
                            " mode=%#x, entries=%d, %s}"),
                 f_pl->cfg.mode, f_pl->sw_ref_count,
                 (isPolicerDirty) ? "Dirty" : "Clean"));
    }
}

/*
 * Function:
 *     _field_action_dump
 * Purpose:
 *     Output fields in a _field_action_s struct.
 */
void
_field_action_dump(const _field_action_t *fa)
{
    if (fa == NULL) {
        LOG_CLI((BSL_META("NULL")));
    } else {
#if defined(BCM_TOMAHAWK_SUPPORT)
       /*
        * Manuplate EgressMirror to CopyToCpu Action for CTC WAR.
        */
        if ((fa->action == bcmFieldActionMirrorEgress) &&
            (fa->flags & _BCM_FIELD_ACTION_CTC_MANIPULATE_FLAG)) {
            LOG_CLI((BSL_META("{act=%s, param0=%d(%#x), param1=%d(%#x),"
                 " param2=%d(%#x), param3=%d(%#x)}"),
                 _field_action_name(bcmFieldActionCopyToCpu), fa->param[2],
                 fa->param[2], fa->param[3], fa->param[3], 0, 0, 0, 0));
            return;
        }
#endif
        LOG_CLI((BSL_META("{act=%s, param0=%d(%#x), param1=%d(%#x), param2=%d(%#x), param3=%d(%#x)%s"),
                 _field_action_name(fa->action), fa->param[0], fa->param[0],
                 fa->param[1], fa->param[1], fa->param[2], fa->param[2],
                 fa->param[3], fa->param[3], (fa->flags & _FP_ACTION_VALID) ? "" : ", Dirty"));
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (bcmFieldActionFabricEHAddOrUpdate == fa->action) {
            LOG_CLI((BSL_META("Extended_Header_Mask_Profile=%d,"), fa->hw_index));
        }
#endif
        LOG_CLI((BSL_META("}")));

        }
}

/*
 * Function:
 *     _field_group_status_dump
 * Purpose:
 *     Output the fields in a bcm_field_group_status_s struct.
 */
void
_field_group_status_dump(const bcm_field_group_status_t *gstat)
{
    LOG_CLI((BSL_META("{prio_min=%d,"),       gstat->prio_min));
    LOG_CLI((BSL_META(" prio_max=%d,"),       gstat->prio_max));
    LOG_CLI((BSL_META(" entries_total=%d,"),  gstat->entries_total));
    LOG_CLI((BSL_META(" entries_free=%d,"),   gstat->entries_free));
    LOG_CLI((BSL_META("\n                      ")));
    LOG_CLI((BSL_META(" counters_total=%d,"), gstat->counters_total));
    LOG_CLI((BSL_META(" counters_free=%d,"),  gstat->counters_free));
    LOG_CLI((BSL_META(" meters_total=%d,"),   gstat->meters_total));
    LOG_CLI((BSL_META(" meters_free=%d}"),    gstat->meters_free));
}




int
_field_is_inited(int unit)
{
    /* Make sure system was initialized. */
    FIELD_IS_INIT(unit); 
    return BCM_E_NONE;
}

/*
 * Function: _bcm_field_linkscan_update
 *
 * Purpose:
 *    Register with link scan thread to get port updates.
 *
 * Parameters:
 *     unit     - (IN) BCM device numberi
 *     port     - (OUT) Port
 *    *portInfo - (OUT) Port Info Data Structure
 *
 * Returns:
 *     BCM_E_NONE    - Success
 */
void _bcm_field_linkscan_update(int unit,
                                  bcm_port_t port,
                                  bcm_port_info_t *portInfo)
{
    int                               rc = 0;
    int                               isEntryDirty = 0;
    bcm_pbmp_t                        egrPortPbmp;
    _field_entry_t                   *f_ent;
    _field_control_t                 *fc;
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;

    rc = _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    if (rc != BCM_E_NONE) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP (%d) RECOVERY_DB() not initialized\r\n"),unit));
        return;
    }

    if (f_egr_recovery == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP (%d) RECOVERY_DB() Internal Error\r\n"),unit));
        return;
    }

    head = f_egr_recovery->entry_recover_egr_ports[port];

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "FP (%d) Received update on port = %d en = %d linstat = %d\r\n"),
                    unit, (int)port,portInfo->enable,portInfo->linkstatus));

     BCM_PBMP_CLEAR(egrPortPbmp);

    /* Using the port (which the linkscan notified) as index, loop
     * through all the entries in the redirect_pbm_recovery database,
     * retrieve the egrPortPbmp configured in that entry and update the
     * pbmp based on the port's link status and then reinstall the
     * FP entry.
     */
    FP_LOCK(unit);
    if (NULL != head) {
        rc = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rc)) {
            FP_UNLOCK(unit);
            return;
        }


        egrPortDbEntry = head;
        while (egrPortDbEntry != NULL) {
            /* Set Global variable to inform that FP action is updated due
               to Link Scan Update and hence redirect_pbm_recovery database
               should not be modified */
            _field_egr_ports_recovery_lock[unit] = 1;
            rc = bcm_esw_field_action_ports_get (unit, egrPortDbEntry->eid,
                    bcmFieldActionEgressPortsAdd, &egrPortPbmp);
            if (rc != BCM_E_NONE) {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "FP (%d) RECOVERY_DB() bcm_field_action_ports_get failed \r\n"),unit));
                _field_egr_ports_recovery_lock[unit] = 0;
                FP_UNLOCK(unit);
                return;
            }

            if (portInfo->linkstatus == BCM_PORT_LINK_STATUS_UP) {
                BCM_PBMP_PORT_ADD (egrPortPbmp, port);
            } else {
                BCM_PBMP_PORT_REMOVE (egrPortPbmp, port);
            }

            /* Get field control structure. Check if entry already installed
             * If so, reinstall the entry, else just update the fp entry action
             */
            rc = _field_entry_get(unit, egrPortDbEntry->eid,
                    _FP_ENTRY_PRIMARY, &f_ent);
            if (BCM_FAILURE(rc)) {
                _field_egr_ports_recovery_lock[unit] = 0;
                FP_UNLOCK(unit);
                return;
            }

            isEntryDirty = (f_ent->flags & _FP_ENTRY_DIRTY);

            rc = bcm_esw_field_action_remove (unit, egrPortDbEntry->eid,
                                    bcmFieldActionEgressPortsAdd);
            if (BCM_FAILURE(rc)) {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                   "FP (%d) RECOVERY_DB() bcm_field_action_remove failed"),
                                                                        unit));
                _field_egr_ports_recovery_lock[unit] = 0;
                FP_UNLOCK(unit);
                return;
            }
            rc = bcm_esw_field_action_ports_add (unit, egrPortDbEntry->eid,
                                    bcmFieldActionEgressPortsAdd, egrPortPbmp);
            if (BCM_FAILURE(rc)) {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "FP (%d) RECOVERY_DB() bcm_field_action_ports_add failed"),
                                                                      unit));
                _field_egr_ports_recovery_lock[unit] = 0;
                FP_UNLOCK(unit);
                return;
            }

            /* Re-install Entry only when Entry is not Dirty*/
            if (!isEntryDirty) {
                rc = bcm_esw_field_entry_reinstall (unit, egrPortDbEntry->eid);
                if (BCM_FAILURE(rc)) {
                    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                     "FP (%d) RECOVERY_DB() bcm_field_entry_reinstall failed"),
                                                                         unit));
                    _field_egr_ports_recovery_lock[unit] = 0;
                    FP_UNLOCK(unit);
                    return;
                }
            }
             egrPortDbEntry = egrPortDbEntry->next;
        }
        _field_egr_ports_recovery_lock[unit] = 0;

    }
    FP_UNLOCK(unit);
    return;
}

/*
 * Function: _bcm_field_control_get
 *
 * Purpose:
 *     Get control status info.
 *
 * Parameters:
 *     unit     - (IN)  BCM device number.
 *     fc       - (IN)  Field Control Structure.
 *     control  - (IN)  Control element to get.
 *     status   - (OUT) Status of field element.
 *
 * Returns:
 *     BCM_E_INIT    - BCM unit not initialized
 *     BCM_E_PARAM   - *state pointing to NULL
 *     BCM_E_NONE    - Success
 */
int
_bcm_field_control_get(int unit, _field_control_t *fc,
                       bcm_field_control_t control, uint32 *state)
{
    int                 rv = BCM_E_NONE; /* Operation return status.      */
    uint32              val1;
    uint32              val2;
    uint32              reg_val;         /* Register value buffer.        */
#if defined (BCM_TRX_SUPPORT)
    uint64              val64;           /* Register 64bitvalue buffer.   */
#endif /* BCM_TRX_SUPPORT */

    if (NULL == fc || NULL == state) {
        return BCM_E_PARAM;
    }

    switch (control) {
      case bcmFieldControlIntraDoubleEnable:
          *state = (fc->flags & _FP_INTRASLICE_ENABLE) ? TRUE : FALSE;
          break;
      case bcmFieldControlColorIndependent:
          *state = (fc->flags & _FP_COLOR_INDEPENDENT) ? TRUE : FALSE;
          break;
      case bcmFieldControlStage:
          rv = (BCM_E_UNAVAIL);
          break;

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH_SUPPORT)
      case bcmFieldControlExternalUdfEnable:
          if (SOC_REG_IS_VALID(unit, ESM_KEYGEN_CTLr)) {
              rv = READ_ESM_KEYGEN_CTLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, ESM_KEYGEN_CTLr, reg_val,
                                             L2_ACL_PAYLOAD_MODEf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#endif /* !(BCM_TRIUMPH2_SUPPORT || BCM_TRIUMPH_SUPPORT) */

      case bcmFieldControlSharedVlanFieldSet:
          if (SOC_IS_TRX(unit)) {
              rv = (BCM_E_UNAVAIL);
              break;
          }
          if (SOC_REG_FIELD_VALID(unit, ING_CONFIGr, MAP_FID_ID_TO_INNER_TAGf)) {
              rv = READ_ING_CONFIGr(unit, &reg_val);
              val1 = soc_reg_field_get(unit, ING_CONFIGr, reg_val, MAP_FID_ID_TO_INNER_TAGf);
              val2 = soc_reg_field_get(unit, ING_CONFIGr, reg_val, MAP_FID_ID_TO_OUTER_TAGf);
              if ((0 == val1) && (0 == val2)) {
                  *state = BCM_FIELD_SHARED_VLAN_NONE;
              }
              if ((0 == val1) && (1 == val2)) {
                  *state = BCM_FIELD_SHARED_VLAN_OUTER;
              }
              if ((1 == val1) && (0 == val2)) {
                  *state = BCM_FIELD_SHARED_VLAN_INNER;
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#if defined(BCM_TRX_SUPPORT)
      case bcmFieldControlArpAsIp:
          if (SOC_REG_FIELD_VALID(unit, ING_CONFIG_64r, ARP_RARP_TO_FPf)) {
              rv = READ_ING_CONFIG_64r(unit, &val64);
              if (BCM_SUCCESS(rv)) {
                  reg_val = soc_reg64_field32_get(unit, ING_CONFIG_64r,
                                                  val64, ARP_RARP_TO_FPf);
                  *state = (0x1 & reg_val) ? TRUE : FALSE;
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRarpAsIp:
          if (SOC_REG_FIELD_VALID(unit, ING_CONFIG_64r, ARP_RARP_TO_FPf)) {
              rv = READ_ING_CONFIG_64r(unit, &val64);
              if (BCM_SUCCESS(rv)) {
                  reg_val = soc_reg64_field32_get(unit, ING_CONFIG_64r,
                                                  val64, ARP_RARP_TO_FPf);
                  *state = (0x2 & reg_val) ? TRUE : FALSE;
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectIngressVlanCheck:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, VLAN_CHECK_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectNonUcastTrunkResolve:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, LAG_RES_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectNonUcastEtherTrunkResolve:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, LAG_RES_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectNonUcastFabricTrunkResolve:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, HGTRUNK_RES_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectExcludeSrcPort:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, SRC_REMOVAL_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectPortFloodBlock:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, PORT_BLOCK_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case  bcmFieldControlRedirectVlanFloodBlock:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, VLAN_BLOCK_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectExcludeEtherSrcPort:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                          reg_val, SRC_REMOVAL_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectExcludeHiGigSrcPort:
          if (SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                             reg_val, HG_SRC_REMOVAL_ENf);
              }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#endif /* BCM_TRX_SUPPORT */
      case bcmFieldControlStatSyncEnable:
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
          if (SOC_IS_TRX(unit) || SOC_IS_BRADLEY(unit)) {
              *state = (fc->flags & _FP_STAT_SYNC_ENABLE) ? TRUE : FALSE;
          } else
#endif
          {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlPolicerGroupSharingEnable:
          *state = (fc->flags & _FP_POLICER_GROUP_SHARE_ENABLE) ? TRUE : FALSE;
          break;
      case  bcmFieldControlRedirectNextHopExcludeSrcPort:
          if (0 == soc_reg_field_valid(unit,SW2_FP_DST_ACTION_CONTROLr,
              SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              rv = READ_SW2_FP_DST_ACTION_CONTROLr(unit, &reg_val);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg_field_get(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           reg_val,
                                           SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf);
              }

          }
          break;
#ifdef BCM_TRIUMPH3_SUPPORT
      case bcmFieldControlIngressLogicalPolicerPoolsMode:
          if (SOC_IS_TRIUMPH3(unit)) {
              *state = fc->ingress_logical_policer_pools_mode;
          }else {
              *state = -1;
              rv = BCM_E_UNAVAIL;
          }
          break;
#endif

#if defined(BCM_METROLITE_SUPPORT)
      case bcmFieldControlReplacementTtl:
          if (SOC_REG_IS_VALID(unit, EGR_REPLACEMENT_TTLr)) {
              rv = READ_EGR_REPLACEMENT_TTLr(unit, &reg_val);
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit, EGR_REPLACEMENT_TTLr,
                    reg_val, REPLACEMENT_TTLf);
            } else {
                rv = (BCM_E_UNAVAIL);
            }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#endif

      case bcmFieldControlOverrideStageLookupPhb:
#if defined (BCM_TRX_SUPPORT)
          if ((SOC_REG_IS_VALID(unit, ING_CONFIG_64r)) &&
              (SOC_REG_FIELD_VALID(unit, ING_CONFIG_64r,
                                    VFP_PRI_ACTION_FB2_MODEf))) {
              rv = READ_ING_CONFIG_64r(unit, &val64);
              if (BCM_SUCCESS(rv)) {
                  *state = soc_reg64_field32_get(unit, ING_CONFIG_64r,
                                          val64, VFP_PRI_ACTION_FB2_MODEf);
              }
          } else {
               rv = BCM_E_UNAVAIL;
          }
#endif
          break;
      default:
          rv = (BCM_E_UNAVAIL);
    }

    return rv;
}

/*
 * Function: _bcm_field_control_set
 *
 * Purpose:
 *     Set control status.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fc       - (IN/OUT) Field Control Structure.
 *     control  - (IN) Control element to set.
 *     state    - (IN) State (0/1).
 *
 * Returns:
 *     BCM_E_NONE    - Success
 *     BCM_E_INIT    - BCM unit not initialized
 *     BCM_E_PARAM   - Flag state not valid on device
 */
int
_bcm_field_control_set(int unit,  _field_control_t *fc,
                       bcm_field_control_t control, uint32 state)
{
    int                 rv = BCM_E_NONE;  /* Operation return status.   */
    uint32              reg_values[2];    /* Register value buffer.     */
    soc_field_t         reg_fields[2];    /* Register fields to modify. */
    int                 field_count = 2;  /* Number of updated fields.  */
    reg_values[0] = reg_values[1] = (state == TRUE) ? 1: 0;

    if (NULL == fc) {
        return BCM_E_PARAM;
    }

    switch (control) {
      case bcmFieldControlIntraDoubleEnable:
          if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
              if (state == 0) {
                  fc->flags &= ~_FP_INTRASLICE_ENABLE;
              } else {
                  fc->flags |= _FP_INTRASLICE_ENABLE;
              }
          } else if (state == 0) {
              fc->flags &= ~_FP_INTRASLICE_ENABLE;
          } else {
              LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: Device doesn't support intraslice\n"),
                         unit));
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlColorIndependent:
          if (soc_feature(unit, soc_feature_field_color_indep)) {
              if (state == 0) {
                  fc->flags &= ~_FP_COLOR_INDEPENDENT;
              } else {
                  fc->flags |= _FP_COLOR_INDEPENDENT;
              }
          } else if (state == 0) {
              fc->flags &= ~_FP_COLOR_INDEPENDENT;
          } else {
              LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: Color Independence unsupported on this unit\n"),
                         unit));
              rv = BCM_E_UNAVAIL;
          }
          break;
      case bcmFieldControlStage:
          rv = (BCM_E_UNAVAIL);
          break;
      case bcmFieldControlSharedVlanFieldSet:
          if (SOC_IS_TRX(unit)) {
              rv = (BCM_E_UNAVAIL);
              break;
          }
          if (SOC_REG_FIELD_VALID(unit, ING_CONFIGr, MAP_FID_ID_TO_INNER_TAGf)) {
              reg_fields[0] = MAP_FID_ID_TO_INNER_TAGf;
              reg_fields[1] = MAP_FID_ID_TO_OUTER_TAGf;
              if (BCM_FIELD_SHARED_VLAN_NONE == state) {
                  reg_values[0] = 0;
                  reg_values[1] = 0;
              } else if (BCM_FIELD_SHARED_VLAN_INNER == state) {
                  reg_values[0] = 1;
                  reg_values[1] = 0;
              } else if (BCM_FIELD_SHARED_VLAN_OUTER == state) {
                  reg_values[0] = 0;
                  reg_values[1] = 1;
              } else {
                  rv = (BCM_E_PARAM);
                  break;
              }
              rv =  soc_reg_fields32_modify(unit, ING_CONFIGr, REG_PORT_ANY,
                                            field_count, reg_fields, reg_values);
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#if defined(BCM_TRX_SUPPORT)
      case bcmFieldControlArpAsIp:
      case bcmFieldControlRarpAsIp:
          if (SOC_REG_FIELD_VALID(unit, ING_CONFIG_64r, ARP_RARP_TO_FPf)) {
              rv = _bcm_field_trx_control_arp_set(unit, control, state);
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlRedirectIngressVlanCheck:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = VLAN_CHECK_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                          REG_PORT_ANY, field_count,
                                          reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectNonUcastTrunkResolve:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = LAG_RES_ENf;
              reg_fields[1] = HGTRUNK_RES_ENf;
              field_count = 2;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectNonUcastEtherTrunkResolve:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = LAG_RES_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectNonUcastFabricTrunkResolve:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = HGTRUNK_RES_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectExcludeSrcPort:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = HG_SRC_REMOVAL_ENf;
              reg_fields[1] = SRC_REMOVAL_ENf;
              field_count = 2;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectExcludeEtherSrcPort:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = SRC_REMOVAL_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectExcludeHiGigSrcPort:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = HG_SRC_REMOVAL_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case bcmFieldControlRedirectPortFloodBlock:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = PORT_BLOCK_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
      case  bcmFieldControlRedirectVlanFloodBlock:
          if (!SOC_REG_IS_VALID(unit, SW2_FP_DST_ACTION_CONTROLr)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = VLAN_BLOCK_ENf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH_SUPPORT)
      case bcmFieldControlExternalUdfEnable:
          if (SOC_REG_IS_VALID(unit, ESM_KEYGEN_CTLr)) {
              rv = soc_reg_field32_modify(unit, ESM_KEYGEN_CTLr, REG_PORT_ANY,
                                          L2_ACL_PAYLOAD_MODEf, state);
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#endif /* !(BCM_TRIUMPH2_SUPPORT || BCM_TRIUMPH_SUPPORT) */
      case bcmFieldControlStatSyncEnable:
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
          if (SOC_IS_TRX(unit) || SOC_IS_BRADLEY(unit)) {
              if (state == 0) {
                  fc->flags &= ~_FP_STAT_SYNC_ENABLE;
              } else {
                  fc->flags |= _FP_STAT_SYNC_ENABLE;
              }
          } else
#endif
          {
              rv = (BCM_E_UNAVAIL);
          }
          break;
      case bcmFieldControlPolicerGroupSharingEnable:
          if (fc->groups) {
              rv = BCM_E_CONFIG;
          } else if (state == 0) {
              fc->flags &= ~_FP_POLICER_GROUP_SHARE_ENABLE;
          } else {
              fc->flags |= _FP_POLICER_GROUP_SHARE_ENABLE;
          }
          break;
      case  bcmFieldControlRedirectNextHopExcludeSrcPort:
          if (0 == soc_reg_field_valid(unit,SW2_FP_DST_ACTION_CONTROLr,
              SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf)) {
              rv = (BCM_E_UNAVAIL);
          } else {
              reg_fields[0] = SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf;
              field_count = 1;
              rv = soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                           REG_PORT_ANY, field_count,
                                           reg_fields, reg_values);
          }
          break;
#ifdef BCM_TRIUMPH3_SUPPORT
      case bcmFieldControlIngressLogicalPolicerPoolsMode:
          if (SOC_IS_TRIUMPH3(unit)) {
              switch (state) {
                  case bcmFieldIngressLogicalPolicerPools16x512Split:
                      fc->ingress_logical_policer_pools_mode =
                                 bcmFieldIngressLogicalPolicerPools16x512Split;
                      break;
                  case bcmFieldIngressLogicalPolicerPools16x512Contiguous:
                      fc->ingress_logical_policer_pools_mode =
                            bcmFieldIngressLogicalPolicerPools16x512Contiguous;
                      break;
                  case bcmFieldIngressLogicalPolicerPools8x1024:
                      fc->ingress_logical_policer_pools_mode =
                                      bcmFieldIngressLogicalPolicerPools8x1024;
                      break;
                  default:
                      fc->ingress_logical_policer_pools_mode =
                                      bcmFieldIngressLogicalPolicerPools8x1024;
                      rv = BCM_E_CONFIG;
              }
          }else {
              fc->ingress_logical_policer_pools_mode = -1;
              rv = BCM_E_UNAVAIL;
          }
          break;
#endif

#if defined(BCM_METROLITE_SUPPORT)
      case bcmFieldControlReplacementTtl:
          if (SOC_REG_IS_VALID(unit, EGR_REPLACEMENT_TTLr)) {
              if (255 >= state ) {
                  rv = soc_reg_field32_modify(unit, EGR_REPLACEMENT_TTLr,
                                                    REG_PORT_ANY,
                                                    REPLACEMENT_TTLf, state);
            } else {
                rv = (BCM_E_PARAM);
            }
          } else {
              rv = (BCM_E_UNAVAIL);
          }
          break;
#endif /* (BCM_METROLITE_SUPPORT) */

      case bcmFieldControlOverrideStageLookupPhb:
          if ((SOC_REG_IS_VALID(unit, ING_CONFIG_64r)) &&
              (SOC_REG_FIELD_VALID(unit, ING_CONFIG_64r,
                                    VFP_PRI_ACTION_FB2_MODEf))) {
              if (state) {
                 rv = soc_reg_field32_modify(unit, ING_CONFIG_64r,
                         REG_PORT_ANY, VFP_PRI_ACTION_FB2_MODEf, 1);
              } else {
                  rv = soc_reg_field32_modify(unit, ING_CONFIG_64r,
                          REG_PORT_ANY, VFP_PRI_ACTION_FB2_MODEf, 0);
              }
          } else {
              rv = BCM_E_UNAVAIL;
          }
          break;
      default:
          rv = (BCM_E_UNAVAIL);
    }

    return rv;
}


/* Function: _field_hints_control_get
 *
 * Purpose:
 *        Get Field Hints Control
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     hint_id   - (IN) Hint Id.
 *        f_ht   - (OUT) hints_control_structure
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _field_hints_control_get(int unit,
                             bcm_field_hintid_t hint_id,
                             _field_hints_t **f_ht)
{
    uint32             hash_index = 0; /* Hash index */
    _field_hints_t    *f_ht_tmp;       /* field hints */
    _field_control_t  *fc;             /* Field control structure. */

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    hash_index = hint_id & _FP_HASH_INDEX_MASK(fc);
    f_ht_tmp = fc->hints_hash[hash_index];

    while (NULL != f_ht_tmp) {
        /* Match Hint id. */
        if (f_ht_tmp->hintid == hint_id) {
            *f_ht = f_ht_tmp;
            break;
        }
        f_ht_tmp = f_ht_tmp->next;
    }

    return BCM_E_NONE;

}

#ifdef BCM_WARM_BOOT_SUPPORT
/* Function: _bcm_field_hints_scache_sync
 *
 * Purpose:
 *        Sync hints Hash table information into scache
 * Parameters:
 *         unit      - (IN)    BCM device number.
 *           fc      - (IN)    Field Control.
 *     stage_fc      - (IN)    Stage Control.
 *     scache_ptr    - (INOUT) Scache Pointer.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_scache_sync (int unit,
                                  _field_control_t *fc,
                                  _field_stage_t   *stage_fc,
                                  uint8 *scache_ptr)
{
    bcm_field_hintid_t     hint_id = 0;       /* Hint Id */
    _field_hints_t        *f_ht = NULL;       /* Field hints Structure */
    _field_hint_t         *hints_dump = NULL; /* Field hints Structure */
    bcm_field_hint_t      *hint_entry;        /* Hint Entry */
    uint32                 hint_count = 0;    /* Hint count */
    uint8 *curr_scache_ptr = scache_ptr;      /* Scache Pointer */

    if ((fc == NULL) || (stage_fc == NULL) || (scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
        return BCM_E_NONE;
    }

    /* Sync hintid bitmap into scache */
    sal_memcpy (curr_scache_ptr, ((fc->hintid_bmp).w),
            SHR_BITALLOCSIZE(_FP_HINT_ID_MAX));
    fc->scache_pos += SHR_BITALLOCSIZE(_FP_HINT_ID_MAX);
    curr_scache_ptr += SHR_BITALLOCSIZE(_FP_HINT_ID_MAX);

    for (hint_id = _FP_HINT_ID_BASE; hint_id < _FP_HINT_ID_MAX; hint_id++) {
        if (_FP_HINTID_BMP_TEST(fc->hintid_bmp, hint_id)) {
            hint_count = 0;

            BCM_IF_ERROR_RETURN(_field_hints_control_get(unit, hint_id, &f_ht));
            if (f_ht == NULL) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"FP (unit %d) HintId %d not present"
                                   " in Hint Hash table\r\n"), unit, hint_id));
                continue;
            }

            /* Sync Hint Id */
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"@Pos(%d) Syncing hints information"
                           " for Hint ID (%d)\r\n"), fc->scache_pos, hint_id));
            sal_memcpy (curr_scache_ptr, &(f_ht->hintid),
                                        sizeof(bcm_field_hintid_t));
            fc->scache_pos += sizeof (bcm_field_hintid_t);
            curr_scache_ptr += sizeof (bcm_field_hintid_t);

            /* Sync Hints Count */
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"@Pos(%d) Syncing number of Hints"
                                "present = %d\r\n"),
                                 fc->scache_pos, f_ht->hint_count));
            sal_memcpy (curr_scache_ptr, &(f_ht->hint_count), sizeof(uint16));
            fc->scache_pos += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);

            /* Group ref Count will be updated when group is recovered.
             * Hence no need to sync group refCount */

            hints_dump = f_ht->hints;

            while (hints_dump != NULL) {
                hint_entry = hints_dump->hint;
                if (hint_entry != NULL) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"@Pos(%d) HintId(%d) Syncing"
                                      "HintType = %d\r\n"), fc->scache_pos,
                                            hint_id, hint_entry->hint_type));
                    sal_memcpy (curr_scache_ptr, &(hint_entry->hint_type),
                                              sizeof(bcm_field_hint_type_t));
                    fc->scache_pos += sizeof (bcm_field_hint_type_t);
                    curr_scache_ptr += sizeof (bcm_field_hint_type_t);

                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"@Pos(%d) HintId(%d) Syncing"
                                        " Flags = %d\r\n"), fc->scache_pos,
                                                hint_id, hint_entry->flags));
                    sal_memcpy (curr_scache_ptr, &(hint_entry->flags),
                                              sizeof(uint32));
                    fc->scache_pos += sizeof (uint32);
                    curr_scache_ptr += sizeof (uint32);

                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"@Pos(%d) HintId(%d) Sync Max"
                                        " Group Size = %d\r\n"), fc->scache_pos,
                             hint_id, hint_entry->max_group_size));
                    sal_memcpy (curr_scache_ptr, &(hint_entry->max_group_size),
                                              sizeof(uint32));
                    fc->scache_pos += sizeof (uint32);
                    curr_scache_ptr += sizeof (uint32);
                }
                hint_count++;
                hints_dump = hints_dump->next;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintId(%d) Number of hints synced (%d)"
                                " and Number of hints present (%d)\r\n"),
                                       hint_id, hint_count,f_ht->hint_count));
        }
    }
    return BCM_E_NONE;
}

/* Function: _bcm_field_hints_scache_recover
 *
 * Purpose:
 *        Recover hints Hash table information from scache
 * Parameters:
 *         unit      - (IN)    BCM device number.
 *           fc      - (IN)    Field Control.
 *     stage_fc      - (IN)    Stage Control.
 *     scache_ptr    - (INOUT) Scache Pointer.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_scache_recover (int unit,
                                     _field_control_t *fc,
                                     _field_stage_t   *stage_fc,
                                     uint8 *scache_ptr)
{
    bcm_field_hintid_t     hint_id = 0;    /* Hint Id */
    bcm_field_hint_t       hint_entry;     /* Hint Entry */
    uint16                 hint_count = 0; /* Hint Count */
    int                    count = 0;      /* Counter */
    uint8 *curr_scache_ptr = scache_ptr;

    if ((fc == NULL) || (stage_fc == NULL) || (scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    /* Sync hintid bitmap into scache */
    sal_memcpy (fc->hintid_bmp.w, curr_scache_ptr,
                    SHR_BITALLOCSIZE(_FP_HINT_ID_MAX));
    fc->scache_pos += SHR_BITALLOCSIZE(_FP_HINT_ID_MAX);
    curr_scache_ptr += SHR_BITALLOCSIZE(_FP_HINT_ID_MAX);

    for (hint_id = _FP_HINT_ID_BASE; hint_id < _FP_HINT_ID_MAX; hint_id++) {
        if (_FP_HINTID_BMP_TEST(fc->hintid_bmp, hint_id)) {
            /* Recover Hint Id */
            sal_memcpy (&hint_id, curr_scache_ptr,
                                     sizeof(bcm_field_hintid_t));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"@Pos(%d) Recovered hints information"
                                " for Hint ID (%d)\r\n"),
                                      fc->scache_pos, hint_id));
            fc->scache_pos += sizeof (bcm_field_hintid_t);
            curr_scache_ptr += sizeof (bcm_field_hintid_t);

            /* Recover Hints Count */
            sal_memcpy (&hint_count, curr_scache_ptr, sizeof(uint16));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"@Pos(%d) Recovered number of Hints"
                           " present = %d\r\n"), fc->scache_pos, hint_count));
            fc->scache_pos += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);

            for (count = 0; count < hint_count; count++) {
                sal_memset (&hint_entry, 0, sizeof (bcm_field_hint_t));
                sal_memcpy (&(hint_entry.hint_type), curr_scache_ptr,
                        sizeof(bcm_field_hint_type_t));
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"@Pos(%d) HintId(%d) Recovered"
                                    " HintType = %d\r\n"), fc->scache_pos,
                                             hint_id, hint_entry.hint_type));
                fc->scache_pos += sizeof (bcm_field_hint_type_t);
                curr_scache_ptr += sizeof (bcm_field_hint_type_t);

                sal_memcpy (&(hint_entry.flags), curr_scache_ptr,
                        sizeof(uint32));
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"@Pos(%d) HintId(%d) Recovered"
                                    " Flags = %d\r\n"), fc->scache_pos,
                                              hint_id, hint_entry.flags));
                fc->scache_pos += sizeof (uint32);
                curr_scache_ptr += sizeof (uint32);

                sal_memcpy (&(hint_entry.max_group_size), curr_scache_ptr,
                        sizeof(uint32));
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"@Pos(%d) HintId(%d) Recovered"
                                   " Max Group Size = %d\r\n"), fc->scache_pos,
                                    hint_id, hint_entry.max_group_size));
                fc->scache_pos += sizeof (uint32);
                curr_scache_ptr += sizeof (uint32);

                BCM_IF_ERROR_RETURN (bcm_esw_field_hints_add (unit, hint_id,
                            &hint_entry));
            }
        }
    }
    return BCM_E_NONE;
}

/* Function: _bcm_hints_scache_hintid_sync
 *
 * Purpose:
 *        Sync the hint id associated with the group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     uint8     - (IN) Scache_ptr
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_hints_scache_hintid_sync (int unit, _field_stage_t *stage_fc,
                                      uint8 *scache_ptr)
{
    _field_control_t    *fc;             /* Field control structure. */
    _field_group_t      *fg;             /* Field group info.        */
    uint8 *curr_scache_ptr = scache_ptr; /* Scache Pointer */

    if (scache_ptr == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    fg = fc->groups;
    if (NULL == fg) {
        return (BCM_E_NONE);
    }

    for (; fg != NULL; fg = fg->next) {
        if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS ||
              fg->stage_id == _BCM_FIELD_STAGE_EGRESS ||
              fg->stage_id == _BCM_FIELD_STAGE_LOOKUP) {

            if(stage_fc->stage_id == fg->stage_id) {
                sal_memcpy (curr_scache_ptr, &(fg->gid),
                        sizeof(bcm_field_group_t));
                fc->scache_pos += sizeof (bcm_field_group_t);
                curr_scache_ptr += sizeof (bcm_field_group_t);

                sal_memcpy (curr_scache_ptr, &(fg->hintid),
                        sizeof(bcm_field_hintid_t));
                fc->scache_pos += sizeof (bcm_field_hintid_t);
                curr_scache_ptr += sizeof (bcm_field_hintid_t);
            }
        }
    }

    return BCM_E_NONE;
}

/* Function: _bcm_hints_scache_hintid_recover
 *
 * Purpose:
 *        Recover the hint id associated with the group.
 * Parameters:
 *         unit - (IN) BCM device number.
 *           fc - (IN) Field Control.
 *   scache_ptr - (IN) Scache Pointer.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_hints_scache_hintid_recover (int unit,
                                      _field_stage_t *stage_fc,
                                      _field_control_t *fc,
                                      uint8 *scache_ptr)
{
    uint8 *curr_scache_ptr = scache_ptr; /* Scache Pointer */
    _field_group_t *fg_entry = NULL;     /* Field Group Entry */
    _field_group_t *fg = NULL;           /* Field Group Entry */
    bcm_field_group_t gid = 0;           /* Group Id */

    if ((scache_ptr == NULL) || (fc == NULL)) {
        return BCM_E_PARAM;
    }

    fg = fc->groups;

    while (fg != NULL) {
        if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS ||
               fg->stage_id == _BCM_FIELD_STAGE_EGRESS ||
               fg->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
            if(stage_fc->stage_id == fg->stage_id) {

                 sal_memcpy (&gid, curr_scache_ptr,
                        sizeof (bcm_field_group_t));
                fc->scache_pos += sizeof (bcm_field_group_t);
                curr_scache_ptr += sizeof (bcm_field_group_t);

                BCM_IF_ERROR_RETURN(_field_group_get(unit, gid, &fg_entry));
                if (!(fg_entry->stage_id == _BCM_FIELD_STAGE_INGRESS ||
                        fg_entry->stage_id == _BCM_FIELD_STAGE_EGRESS ||
                        fg_entry->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
                    return BCM_E_INTERNAL;
                }

                sal_memcpy ( &(fg_entry->hintid),curr_scache_ptr,
                        sizeof(bcm_field_hintid_t));
                fc->scache_pos += sizeof (bcm_field_hintid_t);
                curr_scache_ptr += sizeof (bcm_field_hintid_t);

                /* Group has been created, Increment group ref count in
                 * corresponding hintid in hints hash lookup table */
                BCM_IF_ERROR_RETURN(_bcm_field_hints_group_count_update
                        (unit, fg_entry->hintid, 1));
                BCM_IF_ERROR_RETURN(_bcm_field_hints_group_info_update(
                                         unit, fg_entry));
            }

        }
        fg = fg->next;
    }

    return BCM_E_NONE;
}

#endif /* BCM_WARM_BOOT_SUPPORT */
/* Function: _bcm_field_hints_group_info_update
 *
 * Purpose:
 *       During Group creation, update group structure with the
 *       data from the hintid
 * Parameters:
 *     unit      - (IN) BCM device number.
 *       fg      - (INOUT) Field Group Structure.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_group_info_update (int unit,
                                        _field_group_t *fg)
{
    _field_hints_t     *f_ht = NULL;      /* Field hints Structure. */
    bcm_field_hint_t   *hint_entry;       /* Hint Entry. */
    _field_hint_t      *hint_list = NULL; /* Field Hints Structure. */

    if (NULL == fg) {
        return BCM_E_PARAM;
    }

    if (fg->hintid == 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"Hints not configured. Hence no need"
                            " to update\r\n")));
        return BCM_E_NONE;
    }



    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, fg->hintid, &f_ht));
    if (f_ht == NULL) {
        return (BCM_E_NOT_FOUND);
    }

    hint_list = f_ht->hints;

    while (hint_list != NULL) {
        hint_entry = hint_list->hint;
        if (hint_entry != NULL) {
            /* Hint Found */
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Updating Group"
                       " Structure from hints in hintid %d\r\n"), fg->hintid));
            switch (hint_entry->hint_type) {
                case bcmFieldHintTypeCompression:
                    /* Fill Flags, max_values, start_bit, end_bit */
                    break;
                case bcmFieldHintTypeExtraction:
                    /* Fill Flags, max_values, start_bit, end_bit */
                    break;
                case bcmFieldHintTypeGroupAutoExpansion:
                    /* Fill Flags, max_group_size */
                    if (hint_entry->flags &
                            BCM_FIELD_GROUP_AUTO_EXPANSION_SMALL) {
                        fg->flags |= _FP_GROUP_AUTO_EXPAND_SMALL_SLICE;
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                (BSL_META_U(unit,
                                      "Updating Group(%d) Structure flag with "
                                        "AutoExpandSmall \r\n"),fg->gid));
                    }
                    if (hint_entry->flags &
                            BCM_FIELD_GROUP_AUTO_EXPANSION_LARGE) {
                        fg->flags |= _FP_GROUP_AUTO_EXPAND_LARGE_SLICE;
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                (BSL_META_U(unit,"Updating"
                                        " Group(%d) Structure flag with "
                                            "AutoExpandLarge\r\n"), fg->gid));
                    }
                    if (hint_entry->flags &
                            BCM_FIELD_GROUP_MAX_SIZE_HARD_LIMIT) {
                        fg->flags |= _FP_GROUP_MAX_SIZE_HARD_LIMIT;
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                (BSL_META_U(unit, "Updating Group(%d) "
                                            " Structure flag with MaxGroupSize"
                                            " hardLimit \r\n"),fg->gid));
                    }
                    fg->max_group_size = hint_entry->max_group_size;

                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Updating Group(%d) Structure"
                                        " flag with MaxGroupSize %u \r\n"),
                             fg->gid, fg->max_group_size));
                    break;
                case bcmFieldHintTypeExactMatch:
#ifdef BCM_TOMAHAWK_SUPPORT
                    if (hint_entry->flags &
                        BCM_FIELD_HINT_EXACT_MATCH_GROUP_PRIORITY) {
                        if (soc_feature(unit,
                                soc_feature_field_exact_match_support)) {
                            _field_th_em_group_priority_hintbased_qset_update(
                                                         unit, fg, hint_entry);
                        }
                    }
#endif
                    break;
                default:
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Unknown Hint Type\r\n")));
                    return BCM_E_PARAM;
                    break;
            }
        }
        hint_list = hint_list->next;
    }

    return BCM_E_NONE;
}

/* Function: _bcm_field_hints_group_count_update
 *
 * Purpose:
 *          When a group is created associating with a hint_id,
 *          increment the refCount in the hint_id for the group.
 *          Similary decrement the refCount when a group is destroyed.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     hint_id    - (IN) Hint Id.
 *     action    - (IN) Increment/Decrement.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_group_count_update (int unit,
                                     bcm_field_hintid_t hint_id,
                                     uint8 action)
{
    _field_hints_t  *f_ht = NULL; /* Field hints Structure. */

    if (hint_id == 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"Hints not configured. Hence no need"
                            " to update\r\n")));
        return BCM_E_NONE;
    }



    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));
    if (f_ht == NULL) {
        return (BCM_E_NOT_FOUND);
    }

    if (action) {
        f_ht->grp_ref_count++;
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"New Group Attached to hintid %d,"
                           " Group cnt %d\r\n"), hint_id,f_ht->grp_ref_count));
    } else {
        if (f_ht->grp_ref_count > 0) {
            f_ht->grp_ref_count--;
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Group detached from hintid %d,"
                           " Group cnt %d\r\n"), hint_id,f_ht->grp_ref_count));
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_hints_id_alloc
 * Purpose:
 *      Allocate a hint id.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      hint_id - (OUT) Hint id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int _field_hints_id_alloc (int unit, bcm_field_hintid_t *hint_id)
{
    _field_control_t *fc;   /* Field control structure.*/
    uint32  hint_iter = 0;  /* Hint Id */

    /* Input parameters check. */
    if (NULL == hint_id) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (hint_iter = _FP_HINT_ID_BASE;
            hint_iter < _FP_HINT_ID_MAX; hint_iter++) {
        if (_FP_HINTID_BMP_TEST((fc->hintid_bmp), hint_iter) == 0) {
            *hint_id = hint_iter;
            return (BCM_E_NONE);
        }
    }
    return (BCM_E_RESOURCE);
}


/* Function: _bcm_field_hints_add
 *
 * Purpose:
 *     Associate hint to hint id.
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 *     hint    - (IN) bcm_field_hint_t structure
 * Returns:
 *     BCM_E_XXXX.
 *
 */
 int _bcm_field_hints_add (int unit,
                        bcm_field_hintid_t hint_id,
                        bcm_field_hint_t *hint)
{
    _field_hints_t    *f_ht = NULL;        /* Field hints Structure. */
    _field_hints_t    *f_ht_new = NULL;    /* Field hints Structure. */
    _field_hint_t     *hint_entry = NULL;  /* Field hints Structure. */
    _field_hint_t     *hint_node = NULL;   /* Field hints Structure. */
    bcm_field_hint_t  tmp_hint;            /* Hint Node */
    _field_control_t  *fc;                 /* Field control structure. */
    int                rv = BCM_E_NONE;    /* Return Value */

    /* Input parameters check. */
    if (hint == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Check if the hint_id is already present in the hash table,
     * if so, see if a group is attached to the hintid or the hint
     * is already present in the hintid. */
    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));

    /* Hint id already present in Hints hash table */
    if (f_ht != NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"FP(unit %d) hint id %d already present in"
                            " hash table\r\n"), unit, hint_id));
        /* Check if hint_id is already associated with a group */
        if (f_ht->grp_ref_count != 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"FP(unit %d) hint id %d already"
                             " associated with a group \r\n"), unit, hint_id));
            return BCM_E_BUSY;
        }

        /* Check if max hint count per hintid reached */
        if (f_ht->hint_count >= _FP_MAX_HINTS_PER_HINTID) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "FP(unit %d) Maximum hints limit reached"
                                " for hintid %d\r\n"), unit, hint_id));
            return BCM_E_FULL;
        }

        /* Check if duplicate hint exists */
        sal_memcpy (&tmp_hint, hint, sizeof (bcm_field_hint_t));
        rv = _bcm_field_hints_node_get (unit, f_ht->hints,
                                            &tmp_hint, &hint_node);

        if ((rv == BCM_E_NONE) && (hint_node != NULL)) {
            if (bcmFieldHintTypeExtraction != hint_node->hint->hint_type) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "FP(unit %d) Duplicate hint addition to "
                                "hint id %d\r\n"), unit, hint_id));
                return BCM_E_EXISTS;
            }
        }
    } else {
        _FP_XGS3_ALLOC (f_ht_new, sizeof (_field_hints_t), "Field Hints");
        if (NULL == f_ht_new) {
            return BCM_E_MEMORY;
        }
        f_ht_new->hintid = hint_id;
        f_ht_new->grp_ref_count = 0;
        f_ht_new->next = NULL;
    }

    /* Allocate a Hint Entry and add the hint into hint_entry */
    _FP_XGS3_ALLOC (hint_entry, sizeof (_field_hint_t),
            "Field Hint Entry Structure");
    if (NULL == hint_entry) {
        sal_free (f_ht_new);
        return BCM_E_MEMORY;
    }

    /* Allocate a Hint Entry and add the hint into hint_entry */
    _FP_XGS3_ALLOC (hint_entry->hint, sizeof (bcm_field_hint_t),
            "Field Hint Entry");
    if (NULL == hint_entry->hint) {
        sal_free (hint_entry);
        sal_free (f_ht_new);
        return BCM_E_MEMORY;
    }

    sal_memcpy (hint_entry->hint, hint, sizeof (bcm_field_hint_t));
    hint_entry->next = NULL;

    /* If entry is newly allocated add it to hash database */
    if (f_ht_new != NULL) {
        /* Insert hint_id into Hash table. */
        _FP_HASH_INSERT(fc->hints_hash, f_ht_new,
                (hint_id & _FP_HASH_INDEX_MASK(fc)));

        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"FP(unit %d) HintId added to hash"
                            " table %d\r\n"), unit, hint_id));
        f_ht = f_ht_new;
    }

    _FP_HINTS_LINKLIST_INSERT(&(f_ht->hints),hint_entry);
    LOG_DEBUG(BSL_LS_BCM_FP,
                                (BSL_META_U(unit, "FP(unit %d) Hint added to"
                                            " hint id %d\r\n"), unit, hint_id));
    f_ht->hint_count++;

    return BCM_E_NONE;
}


/* Function: _bcm_field_hints_node_get
 *
 * Purpose:
 *    Return complete hint structure after passing partial structure
 *    and return the hint_node present in the hint list.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     hint_list - (IN) Linked List of hints attached to a hint id.
 *     hint      - (INOUT) bcm_field_hint_t structure
 *     hint_node - (OUT) Node that matches the hint structure.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_node_get (int unit,
                            _field_hint_t *hint_list,
                            bcm_field_hint_t *hint,
                            _field_hint_t **hint_node)
{
    bcm_field_hint_t       *hint_entry; /* Hint Entry */

    /* Input Parameter Check */
    if ((hint_list == NULL) || (hint == NULL)) {
        return BCM_E_PARAM;
    }

    /* Loop through the hints and search for a match,
     * if found, fill the entire hint and also return the hint_node
     * that matched */
    while (hint_list != NULL) {
        hint_entry = hint_list->hint;
        if (hint_entry != NULL) {
            if (hint_entry->hint_type == hint->hint_type) {
                /* Hint Found */
                switch (hint_entry->hint_type) {
                    case bcmFieldHintTypeCompression:
                        if (hint_entry->qual == hint->qual) {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                    (BSL_META_U(unit, "FP(unit %d) Hint with"
                                                " type = Compression and "
                                                " qual_id %d found\r\n"),
                                     unit, hint->qual));
                            *hint_node = hint_list;
                            /* Fill Flags, max_values, start_bit, end_bit */
                            hint->flags = hint_entry->flags;
                            hint->max_values = hint_entry->max_values;
                            hint->start_bit = hint_entry->start_bit;
                            hint->end_bit = hint_entry->end_bit;
                            return BCM_E_NONE;
                        }
                        break;
                    case bcmFieldHintTypeExtraction:
                        if (hint_entry->qual == hint->qual) {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                    (BSL_META_U(unit, "FP(unit %d) Hint with"
                                                " type = Extraction and "
                                                " qual_id %d found\r\n"),
                                     unit, hint->qual));
                            *hint_node = hint_list;
                            /* Fill Flags, max_values, start_bit, end_bit */
                            hint->flags = hint_entry->flags;
                            hint->max_values = hint_entry->max_values;
                            hint->start_bit = hint_entry->start_bit;
                            hint->end_bit = hint_entry->end_bit;
                            return BCM_E_NONE;
                        }
                        break;
                    case bcmFieldHintTypeGroupAutoExpansion:
                        {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                    (BSL_META_U(unit, "FP(unit %d) Hint with"
                                                " type = GroupAutoExpansion "
                                                " found\r\n"), unit));
                            *hint_node = hint_list;
                            /* Fill Flags, max_group_size */
                            hint->flags = hint_entry->flags;
                            hint->max_group_size = hint_entry->max_group_size;
                            return BCM_E_NONE;
                        }
                        break;
                    case bcmFieldHintTypeExactMatch:
                        if (hint_entry->qual == hint->qual) {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                    (BSL_META_U(unit, "FP(unit %d) Hint with"
                                                " type = Exact Match and "
                                                " found\r\n"), unit));
                            *hint_node = hint_list;
                            /* Fill Flags, Priority and Qualifier details. */
                            hint->flags = hint_entry->flags;
                            hint->priority = hint_entry->priority;
                            return BCM_E_NONE;
                        }
                        break;
                    default:
                        {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                    (BSL_META_U(unit, "Unknown Hint Type\r\n")));
                            return BCM_E_PARAM;
                        }
                        break;
                }
            }
        }
        hint_list = hint_list->next;
    }
    return BCM_E_NOT_FOUND;
}

/* Function: _bcm_field_hints_get
 *
 * Purpose:
 *    Return complete hint structure after passing partial structure
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 *     hint    - (INOUT) bcm_field_hint_t structure
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _bcm_field_hints_get(int unit,
                         bcm_field_hintid_t hint_id,
                         bcm_field_hint_t *hint)
{
    _field_hints_t        *f_ht = NULL;      /* Field hints Structure. */
    _field_hint_t         *hint_node = NULL; /* Field hints Structure. */


    /* Input parameters check. */
    if (hint == NULL) {
        return BCM_E_PARAM;
    }



    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));
    if (f_ht == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"FP(unit %d) Hint id %d not present "
                            "in Hints Hash table.\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    /* Hints corresponding to hint_id not found */
    if (f_ht->hints == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) No Hints are associated with "
                            "hint id %d\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    return _bcm_field_hints_node_get (unit, f_ht->hints, hint, &hint_node);
}


/* Function: _bcm_field_hints_delete
 *
 * Purpose:
 *     Delete bcm_field_hint_t structure from a hint_id
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     hint_id   - (IN) Hint Id.
 *     hint      - (IN) Hint to delete.
 * Returns:
 *      BCM_E_XXXX.
 *
 */

int _bcm_field_hints_delete (int unit,
                             bcm_field_hintid_t hint_id,
                             bcm_field_hint_t *hint)
{
    _field_hints_t        *f_ht = NULL;      /* Field hints Structure. */
    _field_hint_t         *hint_node = NULL; /* Field hints Structure. */
    _field_control_t      *fc;               /* Field control structure. */

    /* Input parameters check. */
    if (hint == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));
    if (f_ht == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) HintId %d not present in"
                            " hints hash table\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    /* HintId is attached to a group. Hence deletion not allowed */
    if (f_ht->grp_ref_count != 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) Group is associated "
                            " with HintId %d\r\n"), unit, hint_id));
        return BCM_E_BUSY;
    }

    /* Hints corresponding to hint_id not found */
    if (f_ht->hints == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) No hints are present in"
                            " HintId %d\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_hints_node_get (unit, f_ht->hints,
                       hint, &hint_node));

    _FP_HINTS_LINKLIST_DELETE (&(f_ht->hints), _field_hint_t, hint_node);

    if (f_ht->hint_count > 0) {
        f_ht->hint_count--;
    }

    if (f_ht->hint_count == 0) {
        /* Remove hints for lookup hash. */
        _FP_HASH_REMOVE(fc->hints_hash, _field_hints_t, f_ht,
                (hint_id & _FP_HASH_INDEX_MASK(fc)));
        sal_free (f_ht);
        f_ht = NULL;
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) HintId %d destroyed from Hint "
                            "hash table\r\n"), unit, hint_id));
    }

    return BCM_E_NONE;
}


/* Function: _bcm_field_hints_delete_all
 *
 * Purpose:
 *     Delete all hints from a hint_id
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 * Returns:
 *     BCM_E_XXXX.
 */
int _bcm_field_hints_delete_all (int unit,
                             bcm_field_hintid_t hint_id)
{
    _field_hints_t        *f_ht = NULL; /* Field hints Structure.   */
    _field_control_t      *fc;          /* Field control structure. */

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));
    if (f_ht == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) HintId %d not present in "
                            "Hint Hash table\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    /* HintId is attached to a group. Hence deletion not allowed */
    if (f_ht->grp_ref_count != 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) Group is associated with "
                            " HintId %d\r\n"), unit, hint_id));
        return BCM_E_BUSY;
    }

    /* Hints corresponding to hint_id not found.
     * delete_all should return BCM_E_NONE
     * */
    if (f_ht->hints == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) No Hints present "
                            " in a hintid %d\r\n"), unit, hint_id));
        return (BCM_E_NONE);
    }

    _FP_HINTS_LINKLIST_DELETE_ALL (&(f_ht->hints), _field_hint_t);

    f_ht->hint_count = 0;

    /* Remove hints for lookup hash. */
    _FP_HASH_REMOVE(fc->hints_hash, _field_hints_t, f_ht,
            (hint_id & _FP_HASH_INDEX_MASK(fc)));
    sal_free (f_ht);
    f_ht = NULL;
    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit, "FP (unit %d) HintId %d destroyed from Hint "
                        " hash table\r\n"), unit, hint_id));

    return BCM_E_NONE;
}

/* Function: _bcm_field_hints_dump
 *
 * Purpose:
 *    Dump the hints database.
 * Parameters:
 *     unit - (IN) BCM device number.
 * Returns:
 *     BCM_E_XXXX.
 */
int _bcm_field_hints_dump (int unit)
{
    bcm_field_hintid_t id = 0; /* Hint Id */
    _field_control_t    *fc;   /* Field control structure.*/

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (id = _FP_HINT_ID_BASE; id < _FP_HINT_ID_MAX; id++) {
        if (_FP_HINTID_BMP_TEST(fc->hintid_bmp, id)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HINTID %d \r\n"), id));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"=========\r\n")));
            _bcm_field_hints_display (unit, id);
        }
    }

    return BCM_E_NONE;
}

/* Function: _bcm_field_hints_display
 *
 * Purpose:
 *    Dump the hints database.
 * Parameters:
 *     unit -    (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated.
 * Returns:
 *     BCM_E_XXXX.
 */
int _bcm_field_hints_display (int unit, bcm_field_hintid_t hint_id)
{
    _field_hints_t        *f_ht = NULL;       /* Field hints Structure. */
    _field_hint_t         *hints_dump = NULL; /* Field hints Structure. */
    bcm_field_hint_t      *hint_entry;        /* Hint Entry */
    uint32                 hint_count = 1;    /* Hint Count */



    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hint_id, &f_ht));
    if (f_ht == NULL) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,"FP (unit %d) HintId %d not present in "
                            "Hint Hash table\r\n"), unit, hint_id));
        return (BCM_E_NOT_FOUND);
    }

    hints_dump = f_ht->hints;

    LOG_DEBUG(BSL_LS_BCM_FP,
          (BSL_META_U(unit,"Hints information for Hint ID (%d)\r\n"),hint_id));
    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,"==================================\r\n")));
    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,"Number of Groups Attached  = %d\r\n"),
                                                     f_ht->grp_ref_count));
    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit, "Number of Hints present    = %d\r\n"),
                                                     f_ht->hint_count));

    while (hints_dump != NULL) {
        hint_entry = hints_dump->hint;
        if (hint_entry != NULL) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Hint %d\r\n"), hint_count));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "=======\r\n")));
            if (hint_entry->hint_type == bcmFieldHintTypeGroupAutoExpansion) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Hint Type      = AutoExpansion\r\n")));
            } else if (hint_entry->hint_type == bcmFieldHintTypeCompression) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintType       = Compression\r\n")));
            } else if (hint_entry->hint_type == bcmFieldHintTypeExtraction) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintType       = Extraction\r\n")));
            } else if (hint_entry->hint_type == bcmFieldHintTypeExactMatch) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintType       = Exact Match\r\n")));
            } else {
                LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintType       = Unknown\r\n")));
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Qual           = %u\r\n"),
                                                  hint_entry->qual));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Max Values     = %u\r\n"),
                                                  hint_entry->max_values));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Start Bit      = %u\r\n"),
                                                  hint_entry->start_bit));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "End Bit        = %u\r\n"),
                                                  hint_entry->end_bit));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Flags          = %u\r\n"),
                                                  hint_entry->flags));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Max Group Size = %u\r\n"),
                                                  hint_entry->max_group_size));
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Exact Match Group Priority = %u\r\n"),
                                                  hint_entry->priority));
        }
        hint_count++;
        hints_dump = hints_dump->next;
    }

    return BCM_E_NONE;
}

int
_field_aset_install(int unit, _field_group_t *fg)
{
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_aset_install(unit, fg));
    }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_group_status_calc
 * Purpose:
 *     Fill in the values of a group status struct.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fg       - (OUT)Group with up-to-date status structure
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_status_calc(int unit, _field_group_t *fg)
{
    bcm_field_group_status_t    *status;
    _field_stage_t              *stage_fc; /* Stage field control structure. */
    _field_slice_t              *fs;       /* Field slice control structure. */
    int                         count=0;   /* Generic purposes counter.      */
    int                         rv;        /* Operation return status. */
    int slice_index;
    bcm_port_config_t  port_config;
    bcm_pbmp_t all_pbmp;
    int ratio = 0;

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, fg->stage_id, &stage_fc));

    status = &fg->group_status;

    /* Calculate total number of entries slices in group slices. */

    status->entries_total = 0;
    fs = &fg->slices[0];

    if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
        ratio = 2;
    } else {
        ratio = 1;
    }

    while (fs != NULL)
    {
        status->entries_total += fs->entry_count/ratio;
        fs = fs->next;
    }

    status->entries_free = 0;
    fs = &fg->slices[0];

    while (fs != NULL)
    {
        _bcm_field_entries_free_get(unit, fs, fg, &count);
        status->entries_free += count;
        fs = fs->next;
    }

    fs = fg->slices;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id)) {
        rv = _bcm_field_th_flex_counter_status_get(unit, fg,
                                                   &(status->counters_total),
                                                   &(status->counters_free));
        BCM_IF_ERROR_RETURN(rv);

    } else
#endif
    {

        status->counters_total = _bcm_field_counters_total_get(stage_fc, fs);
        status->counters_free  = _bcm_field_counter_free_get(stage_fc, fs);
    }

    status->meters_total  = _bcm_field_meters_total_get(stage_fc, fg->instance, fs);
    status->meters_free   = _bcm_field_meter_free_get(stage_fc, fg, fs);

    if (!(fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE))
    {
        fs += 1;

        /* If device supports Per Slice Counters, need to account the counters
         * associated to the secondary slice.
         */
        if (!(stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS)) {
            status->counters_total += fs->counters_count;
            status->counters_free  += _bcm_field_counter_free_get(stage_fc, fs);
        }

        /*
         * If device stage supports global meter pools, then
         * meter information is already updated.
         */
        if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) {
            status->meters_total  += fs->meters_count;
            status->meters_free   += _bcm_field_meter_free_get(stage_fc,
                                                     fg, fs);
        }
    }

    if (stage_fc->flags & _FP_STAGE_AUTO_EXPANSION)
    {
        /* For expandable groups, find free slices and add the info */

        BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));
        BCM_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

        for (slice_index = 0; slice_index < stage_fc->tcam_slices;
            ++slice_index)
        {
            /* Ignore the secondary and tertiary slices */
            if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
                    (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
                if (fg->slices[1].slice_number == slice_index) {
                    continue;
                }
            }
            if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
                if (fg->slices[2].slice_number == slice_index) {
                    continue;
                }
            }
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                _BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {

               rv = _bcm_field_th_group_add_slice_validate(unit, stage_fc, fg,
                                                           slice_index);
            } else
#endif /* BCM_TOMAHAWK_SUPPORT */
            {
               rv = _field_group_ports_validate(unit, stage_fc, fg->instance,
                                              slice_index, fg->flags, all_pbmp);
            }

            if (BCM_SUCCESS(rv)) {
                fs = stage_fc->slices[fg->instance] + slice_index;

                status->entries_total += fs->entry_count/ratio;
                status->entries_free += fs->entry_count/ratio;

                /* If device supports Per Slice Counters, need to account the counters
                 * associated to the secondary slice.
                 */
                if (!(stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS)) {
                    status->counters_total += fs->counters_count;
                    status->counters_free += fs->counters_count;
                }

                /*
                 * If device stage supports global meter pools, then
                 * meter information is already updated.
                 */
                if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) {
                    status->meters_total += fs->meters_count;
                    status->meters_free += fs->meters_count;
                }
            }
        }

        /* Go through used slice list except first slice for expandable groups */
        fs = &fg->slices[0];
        while (fs != NULL) {
            fs = fs->next;
            if (fs != NULL) {
                status->counters_total += fs->counters_count;
                status->counters_free  += _bcm_field_counter_free_get(stage_fc, fs);

                if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) {
                    status->meters_total  += fs->meters_count;
                    status->meters_free   += _bcm_field_meter_free_get(stage_fc,
                                                             fg, fs);
                }
            }
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function :
 *          _bcm_field_is_stage_range_check_exist(unit, stage) (internal)
 * Purpose  :
 *          Checks whether the field stage has existing range checkers
 * Parameters :
 *          unit        - (IN) BCM device number
 *          stage       - (IN) Pipeline stage id number
 * Return Values:
 *          BCM_E_EXISTS - There are existing range checkers.
 *          BCM_E_NONE  - No Existing range checkers.
 */
int _bcm_field_is_stage_range_check_exist (int unit,
        _field_stage_id_t stage)
{
    _field_stage_t      *stage_fc;      /* Stage field control info.*/
    _field_control_t    *fc;            /* Field control structure. */
    int                 rv;             /* Operation return status. */

    rv = _field_control_get(unit, &fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _field_stage_control_get(unit, stage, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (stage_fc->ranges != NULL) {
        return BCM_E_EXISTS;
    }
    return BCM_E_NONE;
}


/*
 * Function: _bcm_field_entry_create_id
 *
 * Purpose:
 *     Create a blank entry group based on a group;
 *     allows selection of a specific slot in a slice
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry - (IN) Requested entry ID; must be in the range prio_min through
 *             prio_max as returned by bcm_field_group_status_get().
 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_EXISTS    - Entry ID already in use
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_MEMORY    - allocation failure
 *     BCM_E_NONE      - Success
 */
int
_bcm_field_entry_create_id(int unit,
                              bcm_field_group_t group,
                              bcm_field_entry_t entry)
{
    _field_group_t      *fg;           /* Field group structure.      */
    int                 rv;

    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* When MaxGroupSizeHardLimit is set and limit is reached
     * return BCM_E_FULL */
    if (fg->flags & _FP_GROUP_MAX_SIZE_HARD_LIMIT) {
        if (fg->max_group_size -
                (fg->group_status.entry_count) <= 0) {
            FP_UNLOCK(unit);
            return BCM_E_FULL;
        }
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv = _bcm_field_th_class_entry_create(unit, group, entry);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_entry_create_id(unit, group, entry);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: _bcm_field_entry_copy_id
 *
 * Purpose:
 *     Create a copy of an existing entry with a requested ID
 *
 * Parameters:
 *     unit      - BCM device number
 *     src_entry - Source entry to copy
 *     dst_entry - Destination entry for copy
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Source Entry ID not found
 *     BCM_E_XXX       - Error code from bcm_field_entry_create_id()
 *     BCM_E_NONE      - Success
 */

int
_bcm_field_entry_copy_id(int unit,
                            bcm_field_entry_t src_entry,
                            bcm_field_entry_t dst_entry)
{
    _field_entry_t      *f_ent_src, *f_ent_dst;
    int                 parts_count = 0;
    _field_action_t     *fa_src;
    int                 free_tcam = FALSE;
    int                 rv;
    int                 i;
    bcm_pbmp_t          pbmp;
    _field_stage_t      *stage_fc;


    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit, src_entry, &f_ent_src);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _field_stage_control_get(unit, f_ent_src->group->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get number of entry parts . */
    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent_src->group->stage_id,
                                            f_ent_src->group->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
    	return (rv);
    }


    /* Creating a new destination entry sets the unit, eid, gid, slice_idx,
     * ext, dirty, fs and next fields. Also, it correctly creates multiple
     * physical entry structures for wide-mode groups.
     */

    rv = _bcm_field_entry_create_id(unit, f_ent_src->group->gid,
                                       dst_entry);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_get_by_id(unit, dst_entry, &f_ent_dst);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy(unit, dst_entry));
        return (rv);
    }

    for (i = 0; i < parts_count; i++) {
        if (NULL == f_ent_src[i].tcam.key) {
            free_tcam = TRUE;
        }

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) &&
        (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
        (f_ent_dst+i)->efp_key_match_type = (f_ent_src+i)->efp_key_match_type;
    }
#endif

        rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent_src + i);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy(unit, dst_entry));
            return (rv);
        }

        /* Entry create id might allocated tcam already. */
        rv = _bcm_field_qual_tcam_key_mask_free(unit, f_ent_dst + i);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy(unit, dst_entry));
            return (rv);
        }

        /* Copy qualification data. */
        sal_memcpy(&f_ent_dst[i].tcam, &f_ent_src[i].tcam,
                   sizeof(_field_tcam_t));
        sal_memcpy(&f_ent_dst[i].extra_tcam, &f_ent_src[i].extra_tcam,
                   sizeof(_field_tcam_t));

#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            sal_memcpy(&f_ent_dst[i].key_match_tcam,
                       &f_ent_src[i].key_match_tcam,
                       sizeof(_field_tcam_t));
        }
#endif
        f_ent_dst[i].tcam.key  = NULL;/* Do not copy allocated part.*/
        f_ent_dst[i].tcam.mask = NULL;/* Do not copy allocated part.*/
        f_ent_dst[i].extra_tcam.key  = NULL;/* Do not copy allocated part.*/
        f_ent_dst[i].extra_tcam.mask = NULL;/* Do not copy allocated part.*/
        if (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            f_ent_dst[i].tcam.key_hw = NULL;
            f_ent_dst[i].tcam.mask_hw = NULL;
        }

#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            f_ent_dst[i].key_match_tcam.key  = NULL;/* Do not copy
                                                       allocated part.*/
            f_ent_dst[i].key_match_tcam.mask = NULL;/* Do not copy
                                                       allocated part.*/
        }
#endif

        if (f_ent_src[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
            f_ent_dst[i].flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
        }

        /* Allocate tcam key and mask for destination entry. */
        rv = _bcm_field_qual_tcam_key_mask_get(unit,  f_ent_dst + i);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy(unit, dst_entry));
            return (rv);
        }

        /* Copy key and mask information. */
        sal_memcpy(f_ent_dst[i].tcam.key, f_ent_src[i].tcam.key,
                   f_ent_src[i].tcam.key_size);
        sal_memcpy(f_ent_dst[i].tcam.mask, f_ent_src[i].tcam.mask,
                   f_ent_src[i].tcam.key_size);

        if (f_ent_src[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
            sal_memcpy(f_ent_dst[i].extra_tcam.key,
                f_ent_src[i].extra_tcam.key,
                f_ent_src[i].extra_tcam.key_size);

            sal_memcpy(f_ent_dst[i].extra_tcam.mask,
                f_ent_src[i].extra_tcam.mask,
                f_ent_src[i].extra_tcam.key_size);
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            /* Copy key and mask information. */
            sal_memcpy(f_ent_dst[i].key_match_tcam.key,
                       f_ent_src[i].key_match_tcam.key,
                       f_ent_dst[i].key_match_tcam.key_size);
            sal_memcpy(f_ent_dst[i].key_match_tcam.mask,
                       f_ent_src[i].key_match_tcam.mask,
                       f_ent_dst[i].key_match_tcam.key_size);

        }
#endif
        if (f_ent_dst[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            sal_memcpy(f_ent_dst[i].tcam.key_hw,
                       f_ent_src[i].tcam.key_hw,
                       f_ent_src[i].tcam.key_size);
            sal_memcpy(f_ent_dst[i].tcam.mask_hw,
                       f_ent_src[i].tcam.mask_hw,
                       f_ent_src[i].tcam.key_size);
        }

        if (free_tcam) {
            if (NULL != f_ent_src[i].tcam.key) {
                sal_free(f_ent_src[i].tcam.key);
                sal_free(f_ent_src[i].tcam.mask);
            }
            if (f_ent_src[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
                if (NULL != f_ent_src[i].extra_tcam.key) {
                    sal_free(f_ent_src[i].extra_tcam.key);
                    sal_free(f_ent_src[i].extra_tcam.mask);
                }
            }
            f_ent_src[i].tcam.key = f_ent_src[i].tcam.mask =
                f_ent_src[i].extra_tcam.key = f_ent_src[i].extra_tcam.mask =
                    NULL;
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_src[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            if (NULL != f_ent_src[i].key_match_tcam.key) {
                sal_free(f_ent_src[i].key_match_tcam.key);
                sal_free(f_ent_src[i].key_match_tcam.mask);
            }
            f_ent_src[i].key_match_tcam.key = NULL;
            f_ent_src[i].key_match_tcam.mask = NULL;
        }
#endif
            free_tcam = FALSE;
        }
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    if ((soc_feature(unit, soc_feature_field_ingress_ipbm))
              || (soc_feature(unit, soc_feature_field_multi_pipe_support))) {
        BCM_PBMP_ASSIGN(f_ent_dst->pbmp.data, f_ent_src->pbmp.data);
        BCM_PBMP_ASSIGN(f_ent_dst->pbmp.mask, f_ent_src->pbmp.mask);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    /* Copy counter, if it exists. */
    /* In case of internal backup entry, copy only for
     * devices that have global/flex counter pools
     */
    if (f_ent_src->statistic.flags & _FP_ENTRY_STAT_VALID) {
        rv = bcm_esw_field_entry_stat_attach(unit, dst_entry,
                f_ent_src->statistic.sid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy
                    (unit, dst_entry));
            return (rv);
        }
        /* Preseve original entry flags. */
        f_ent_dst->statistic.flags = (f_ent_src->statistic.flags &  \
                (_FP_ENTRY_STAT_VALID | _FP_ENTRY_STAT_EMPTY |
                 _FP_ENTRY_STAT_USE_EVEN | _FP_ENTRY_STAT_USE_ODD));
    }

    /*  Copy meter, if it exists. */
    for (i = 0; i < _FP_POLICER_LEVEL_COUNT; i++)  {
        if (f_ent_src->policer[i].flags & _FP_POLICER_VALID) {
            rv = bcm_esw_field_entry_policer_attach(unit, dst_entry, i,
                                                    f_ent_src->policer[i].pid);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy
                        (unit, dst_entry));
                return (rv);
            }
        }
    }

    /* Copy source entry's action linked list.  */
    /* This also copies the counter specific actions */
    for (i = 0; i < parts_count; i++) {
        for (fa_src = f_ent_src[i].actions;
             fa_src != NULL;
             fa_src = fa_src->next) {

            int idx = 0;
            if ((bcmFieldActionRedirectPbmp == fa_src->action)
                || (bcmFieldActionEgressMask == fa_src->action)
                || (bcmFieldActionEgressPortsAdd == fa_src->action)
                || (bcmFieldActionRedirectBcastPbmp == fa_src->action)) {

                SOC_PBMP_CLEAR(pbmp);

                for (idx = 0; (idx < _FP_ACTION_PARAM_SZ) && 
                     (idx < SOC_PBMP_WORD_MAX); idx++) {

                     SOC_PBMP_WORD_SET(pbmp, idx, fa_src->param[idx]);
                }

                rv = bcm_esw_field_action_ports_add(unit,
                                                    dst_entry,
                                                    fa_src->action,
                                                    pbmp);
            } else {
                rv = bcm_esw_field_action_add(unit,
                                              dst_entry,
                                              fa_src->action,
                                              fa_src->param[0],
                                              fa_src->param[1]);
            }
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy
                        (unit, dst_entry));
                return (rv);
            }
        }
    }
    f_ent_dst->flags     |= _FP_ENTRY_DIRTY;

    /* Set the destination entry's priority to the same as the source's. */
    rv = _field_entry_prio_set(unit, dst_entry, f_ent_src->prio);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        BCM_IF_ERROR_RETURN(bcm_esw_field_entry_destroy(unit, dst_entry));
        return (rv);
    }
    FP_UNLOCK(unit);
    return (rv);
}



/*
 * Function:
 *      _field_qualify_VlanTranslationHit
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVlanTranslationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
_field_qualify_VlanTranslationHit(int               unit,
                                  bcm_field_entry_t entry,
                                  uint8             *data,
                                  uint8             *mask
                                 )
{

    /* Check for valid data mask combinations */
    switch (*data) {
    case BCM_FIELD_VXLT_LOOKUP_STATUS_NO_HIT:
        *data = 0x0;
        *mask = 0x1;
        break;
    case BCM_FIELD_VXLT_LOOKUP_STATUS_HIT:
        *data = 0x1;
	*mask = 0x1;
	break;
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: PacketRes *data=%#x undefined\n"),
                   unit,
                   *data));
        return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_qualify_VlanTranslationHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVlanTranslationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_qualify_VlanTranslationHit_get(int               unit,
                                      bcm_field_entry_t entry,
                                      uint8             *data,
                                      uint8             *mask
                                     )
{
    /* Translate data #defines to hardware encodings */
    switch (*data) {
    case 0x0:
        *data = BCM_FIELD_VXLT_LOOKUP_STATUS_NO_HIT;
        break;
    case 0x1:
        *data = BCM_FIELD_VXLT_LOOKUP_STATUS_HIT;
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    /*
     * In bcm_field_qualify_VlanTranslationHit, mask passed by application code
     * will be ignored, and SDK will internally set the right mask in h/w.
     * In this get routine, giving h/w encoded mask confuses end user.
     * So mask is setting to EXACT_MASK(1bit is allocated in h/w to qualify
     * Vlan Translation Hit Status).
     */

   *mask = 0x1;

    return (BCM_E_NONE);
}


int
_field_qualify_PacketRes(int               unit,
                         bcm_field_entry_t entry,
                         uint32            *data,
                         uint32            *mask
                         )
{

    /* Check for valid data mask combinations */
    if ((*mask != *data) && (!((*mask & 0x1f) == 0x1f))) {
         return (BCM_E_PARAM);
    }

    switch (*data) {
    case BCM_FIELD_PKT_RES_UNKNOWN:
        *data = 0x0;
        break;
    case BCM_FIELD_PKT_RES_CONTROL:
        *data = 0x1;
        break;
    case BCM_FIELD_PKT_RES_BPDU:
        *data = 0x2;
        break;
    case BCM_FIELD_PKT_RES_L2BC:
        *data = 0x3;
        break;
    case BCM_FIELD_PKT_RES_L2UC:
        *data = 0x4;
        break;
    case BCM_FIELD_PKT_RES_L2UNKNOWN:
        *data = 0x5;
        break;
    case BCM_FIELD_PKT_RES_L3MCUNKNOWN:
#ifdef BCM_RAPTOR1_SUPPORT
        if (SOC_IS_RAPTOR(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_RAPTOR1_SUPPORT */
        *data = 0x6;
        break;
    case BCM_FIELD_PKT_RES_L3MCKNOWN:
#ifdef BCM_RAPTOR1_SUPPORT
        if (SOC_IS_RAPTOR(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_RAPTOR1_SUPPORT */
        *data = 0x7;
        break;
    case BCM_FIELD_PKT_RES_L2MCKNOWN:
        *data = 0x8;
        break;
    case BCM_FIELD_PKT_RES_L2MCUNKNOWN:
        *data = 0x9;
        break;
    case BCM_FIELD_PKT_RES_L3UCKNOWN:
#ifdef BCM_RAPTOR1_SUPPORT
        if (SOC_IS_RAPTOR(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_RAPTOR1_SUPPORT */
        *data = 0xA;
        break;
    case BCM_FIELD_PKT_RES_L3UCUNKNOWN:
#ifdef BCM_RAPTOR1_SUPPORT
        if (SOC_IS_RAPTOR(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_RAPTOR1_SUPPORT */
        *data = 0xB;
        break;
    case BCM_FIELD_PKT_RES_MPLSKNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0xC;
            break;
        }
        return (BCM_E_UNAVAIL);
    case BCM_FIELD_PKT_RES_MPLSL3KNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0xD;
            break;
        }
        return (BCM_E_UNAVAIL);
    case BCM_FIELD_PKT_RES_MPLSL2KNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0xE;
            break;
        }
        return (BCM_E_UNAVAIL);
    case BCM_FIELD_PKT_RES_MPLSUNKNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0xF;
            break;
        }
        return (BCM_E_UNAVAIL);
    case BCM_FIELD_PKT_RES_MIMKNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0x10;
            break;
        }
        return (BCM_E_UNAVAIL);
    case BCM_FIELD_PKT_RES_MIMUNKNOWN:
        if (SOC_IS_TR_VL(unit)) {
            *data = 0x11;
            break;
        }
        return (BCM_E_UNAVAIL);
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                          "FP(unit %d) Error: PacketRes *data=%#x undefined\n"),
                   unit, *data));
        return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}


int
_bcm_esw_field_qualify_aux_tag(int                 unit,
                               bcm_field_entry_t   entry,
                               bcm_field_qualify_t qual,
                               uint32              data,
                               uint32              mask
                               )
{
    _field_entry_t           *f_ent;
    _field_group_t           *fg;
    _bcm_field_qual_offset_t *q_offset;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;


    FP_LOCK(unit);

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
          (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id))) {
       rv = _field_qualify32(unit, entry, qual, data, mask);
       FP_UNLOCK(unit);
       return rv;
    }

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Take the given 32-bit data and mask value, and prefix them with
       a 1 bit, which in the hardware is the "tag valid" bit.
    */

    /* The LLTAG overlaid the VNTAG lower 16bits, and the LLTAG VALID bit  will
    disambiguate the field. So the VNTAG_VALID field should be set to 0 and
    LLTAG_VALID field should be set to 1.
    */
    fg = f_ent->group;
    if ((_BCM_FIELD_STAGE_LOOKUP == fg->stage_id)
           && (qual == bcmFieldQualifySubportPktTag)) {
                ref_data[1] = 2;
        ref_mask[1] = 2;
        ref_data[0] = (data & 0xffff);
        ref_mask[0] = (mask & 0xffff);
    } else if ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id)
           && (qual == bcmFieldQualifySubportPktTag)) {
        ref_data[1] = 1;
        ref_mask[1] = 1;
        ref_data[0] = (data & 0xffff);
        ref_mask[0] = (mask & 0xffff);
    } else {
        ref_data[1] = 1;
        ref_mask[1] = 1;
        ref_data[0] = data;
        ref_mask[0] = mask;
    }

    /* Program data/mask pair to tcam buffer. */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent,
                                   ref_data, ref_mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_stat_counter_get
 * Description:
 *      Get counter statistic values for a field entity
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      Stat_id          - (IN) Statistics entity ID.
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *
 */

int
_bcm_esw_field_stat_counter_get(int unit, int sync_mode, uint32 stat_id,
                               bcm_field_stat_t stat, uint32 num_entries,
                               uint32 *counter_indexes,
                               bcm_stat_value_t *counter_values)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    _field_stat_t                   *f_st=NULL; /* Field statistics entity.  */
    uint32                          index_count=0;
    uint32                          byte_flag=0;

    if (!soc_feature(unit, soc_feature_advanced_flex_counter) &&
        !soc_feature(unit, soc_feature_flowcnt)) {
         return BCM_E_UNAVAIL;
    }

    if (stat == bcmFieldStatPackets ||
        stat == bcmFieldStatGreenPackets ||
        stat == bcmFieldStatYellowPackets ||
        stat == bcmFieldStatRedPackets ||
        stat == bcmFieldStatNotGreenPackets ||
        stat == bcmFieldStatNotYellowPackets ||
        stat == bcmFieldStatNotRedPackets) {
        byte_flag=0;
    } else {
        byte_flag=1;
    }


    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));
    if (f_st->flex_mode == 0) {
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "Entry not attached \n")));
        return BCM_E_PARAM;
    }
    for (index_count=0; index_count < num_entries ; index_count++) {
#if defined(BCM_HURRICANE3_SUPPORT)
        if (soc_feature(unit, soc_feature_flowcnt)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_flowcnt_counter_raw_get(
                             unit, sync_mode, f_st->flex_mode, byte_flag,
                             counter_indexes[index_count],
                             &counter_values[index_count]));
        }
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_stat_counter_raw_get(
                             unit, sync_mode, f_st->flex_mode, byte_flag,
                             counter_indexes[index_count],
                             &counter_values[index_count]));
        }
#endif /* BCM_KATANA_SUPPORT ||  BCM_TRIUMPH3_SUPPORT */
    }
    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}
/*
 * Function:
 *      _bcm_esw_field_stat_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      sync_mode - (IN) hwcount is to be synced to sw count
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_field_stat_get(int unit, int sync_mode, int stat_id,
                       bcm_field_stat_t stat, uint64 *value)
{
    _field_stat_t       *f_st;     /* Field statistics entity.   */
    int                 rv;        /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == value) {
        return (BCM_E_PARAM);
    }

    COMPILER_64_ZERO(*value);

    /* Get field control structure. */

    FP_LOCK(unit);

    /* Get statistics entity descriptor. */
    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (_FP_INVALID_INDEX != f_st->hw_index) {
        rv = _field_stat_value_get(unit, sync_mode, f_st, stat, value);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      _bcm_esw_field_stat_get32
 *
 * Description:
 *      Get lower 32 bit counter value for specific statistic type.
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      sync_mode - (IN) hwcount is to be synced to sw count
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_field_stat_get32(int unit, int sync_mode, int stat_id,
                         bcm_field_stat_t stat, uint32 *value)
{
    uint64 val64;            /* 64 bit counter value.    */
    int rv;                  /* Operation return status. */

    /* Input parameters check. */
    if (NULL == value) {
        return (BCM_E_PARAM);
    }

    /* Read 64 bit counter value. */
    rv = _bcm_esw_field_stat_get (unit, sync_mode, stat_id, stat, &val64);
    if (BCM_SUCCESS(rv)) {
        *value = COMPILER_64_LO(val64);
    }
    return rv;
}


/*
 * Function:
 *      _bcm_field_meter_pair_mode_get
 * Purpose:
 *      Set the config settings for a policer entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      f_pl  - (IN) Policer config.
 *      mode  - (OUT) Meter pair mode.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_meter_pair_mode_get(int unit, _field_policer_t *f_pl,
                               uint32 *mode)
{
    /* Input parameters check. */
    if ((NULL == f_pl) || (NULL == mode)) {
        return (BCM_E_PARAM);
    }

    switch (f_pl->cfg.mode) {
      case bcmPolicerModeSrTcmTsn:
          if (f_pl->cfg.flags & BCM_POLICER_COLOR_BLIND) {
              *mode = BCM_FIELD_METER_MODE_srTCM_COLOR_BLIND;
          } else {
              *mode = BCM_FIELD_METER_MODE_srTCM_COLOR_AWARE;
          }
          break;
      case bcmPolicerModeSrTcmModified:
      case bcmPolicerModeSrTcm:
          if (f_pl->cfg.flags & BCM_POLICER_COLOR_BLIND) {
              *mode = BCM_FIELD_METER_MODE_srTCM_COLOR_BLIND;
          } else {
              *mode = BCM_FIELD_METER_MODE_srTCM_COLOR_AWARE;
          }
          break;
      case bcmPolicerModeCommitted:
          *mode = BCM_FIELD_METER_MODE_FLOW;
          break;
      case bcmPolicerModeTrTcm:
          if (f_pl->cfg.flags & BCM_POLICER_COLOR_BLIND) {
              *mode = BCM_FIELD_METER_MODE_trTCM_COLOR_BLIND;
          } else {
              *mode = BCM_FIELD_METER_MODE_trTCM_COLOR_AWARE;
          }
          break;
      case bcmPolicerModeTrTcmDs:
      case bcmPolicerModeCoupledTrTcmDs:
          if (f_pl->cfg.flags & BCM_POLICER_COLOR_BLIND) {
              *mode = 4;
          } else {
              *mode = 5;
          }
          break;
      case bcmPolicerModePassThrough:
          if (SOC_IS_FIREBOLT2(unit)) {
              *mode = 4;
          } else {
              *mode = BCM_FIELD_METER_MODE_DEFAULT;
          }
          break;
      case bcmPolicerModeGreen:
          *mode = BCM_FIELD_METER_MODE_DEFAULT;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_qualify_InPorts_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) BCM field qualifier.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_qualify_InPorts_get(int unit,  bcm_field_entry_t entry,
                               bcm_field_qualify_t qual,
                               bcm_pbmp_t *data,
                               bcm_pbmp_t *mask)
{
    _field_entry_t *f_ent;   /* Field entry pointer.        */
    uint32 hw_data;          /* HW encoded qualifier data.  */
    uint32 hw_mask;          /* HW encoding qualifier mask. */
    int rv;                  /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_ingress_ipbm) ||
        _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(f_ent->group->flags)) {

        /* Add data & mask to entry. */
        BCM_PBMP_ASSIGN(*data, f_ent->pbmp.data);
        BCM_PBMP_ASSIGN(*mask, f_ent->pbmp.mask);

        if (qual == bcmFieldQualifyInPorts) {
           bcm_pbmp_t lb_pbm;       /* Loopback port bitmap. */

           /* Remove loopback port from ipbm data and mask */
           BCM_PBMP_CLEAR(lb_pbm);
           BCM_PBMP_OR(lb_pbm, PBMP_LB(unit));
           if (BCM_PBMP_NOT_NULL(lb_pbm)) {
              BCM_PBMP_REMOVE(*data, PBMP_LB(unit));
              BCM_PBMP_REMOVE(*mask, PBMP_LB(unit));
           }
        }

        return (BCM_E_NONE);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, qual,
                                              (uint32 *)&hw_data,
                                              (uint32 *)&hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    SOC_PBMP_WORD_SET(*data, 0, hw_data);
    SOC_PBMP_WORD_SET(*mask, 0, hw_mask);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_PacketRes_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyPacketRes
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_field_qualify_PacketRes_get(int               unit,
                             bcm_field_entry_t entry,
                             uint32            *data,
                             uint32            *mask
                             )
{
    /* Translate data #defines to hardware encodings */
    switch (*data) {
    case 0x0:
        *data = BCM_FIELD_PKT_RES_UNKNOWN;
        break;
    case 0x1:
        *data = BCM_FIELD_PKT_RES_CONTROL;
        break;
    case 0x2:
        *data = BCM_FIELD_PKT_RES_BPDU;
        break;
    case 0x3:
        *data = BCM_FIELD_PKT_RES_L2BC;
        break;
    case 0x4:
        *data = BCM_FIELD_PKT_RES_L2UC;
        break;
    case 0x5:
        *data = BCM_FIELD_PKT_RES_L2UNKNOWN;
        break;
    case 0x6:
        *data = BCM_FIELD_PKT_RES_L3MCUNKNOWN;
        break;
    case 0x7:
        *data = BCM_FIELD_PKT_RES_L3MCKNOWN;
        break;
    case 0x8:
        *data = BCM_FIELD_PKT_RES_L2MCKNOWN;
        break;
    case 0x9:
        *data = BCM_FIELD_PKT_RES_L2MCUNKNOWN;
        break;
    case 0xa:
        *data = BCM_FIELD_PKT_RES_L3UCKNOWN;
        break;
    case 0xb:
        *data = BCM_FIELD_PKT_RES_L3UCUNKNOWN;
        break;
    case 0xc:
        *data = BCM_FIELD_PKT_RES_MPLSKNOWN;
        break;
    case 0xd:
        *data = BCM_FIELD_PKT_RES_MPLSL3KNOWN;
        break;
    case 0xe:
        *data = BCM_FIELD_PKT_RES_MPLSL2KNOWN;
        break;
    case 0xf:
        *data = BCM_FIELD_PKT_RES_MPLSUNKNOWN;
        break;
    case 0x10:
        *data = BCM_FIELD_PKT_RES_MIMKNOWN;
        break;
    case 0x11:
        *data = BCM_FIELD_PKT_RES_MIMUNKNOWN;
        break;

    default:
        return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_entry_backup
 * Purpose:
 *     Backup a field entry configuration.
 * Parameters:
 *     unit       - (IN) BCM device number
 *     entry_id   - (IN) Entry identifier
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_entry_backup(int unit, bcm_field_entry_t entry_id)
{
    _field_entry_t      *f_ent_orig;        /* Field entry to be backed up.   */
    _field_entry_t      *f_ent_copy = NULL; /* Backup copy of field entry.    */
    _field_action_t     *fa_orig;           /* Pointer to entry action list.  */
    _field_action_t     *fa = NULL;         /* Field action descriptor.       */
    _field_action_t     *fa_free = NULL;    /* Field action descriptor.       */
    _field_stat_t       *f_st;              /* Internal Statisics descriptor. */
    _field_policer_t    *f_pl;              /* Internal policer descriptor.   */
    int                 free_tcam = FALSE;  /* KEY/MASK memory alloc status.  */
    int                 parts_count = 0;    /* Entry parts count.             */
    int                 i;                  /* Iterator variable.             */
    int                 rv;                 /* Operation return status.       */
    uint32              mem_sz;             /* Field entry alloc size.        */


    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit,
                                    entry_id,
                                    &f_ent_orig);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (NULL != f_ent_orig->ent_copy) {
        rv = _bcm_field_entry_cleanup(unit, entry_id);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Get number of entry parts . */
    rv = _bcm_field_entry_tcam_parts_count(unit,
                                           f_ent_orig->group->stage_id,
                                           f_ent_orig->group->flags,
                                           &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    mem_sz = parts_count * sizeof(_field_entry_t);

    _FP_XGS3_ALLOC(f_ent_copy, mem_sz, "field entry copy");
    if (f_ent_copy == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: allocation failure for field_entry\n"),
                   unit));
        FP_UNLOCK(unit);
        return (BCM_E_MEMORY);
    }


    for (i = 0; i < parts_count; i++) {

        f_ent_copy[i].eid = f_ent_orig[i].eid;
        f_ent_copy[i].prio = f_ent_orig[i].prio;
        f_ent_copy[i].slice_idx = f_ent_orig[i].slice_idx;
        f_ent_copy[i].fs = f_ent_orig[i].fs;
        f_ent_copy[i].group = f_ent_orig[i].group;
        f_ent_copy[i].flags = f_ent_orig[i].flags;

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) &&
        (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
        f_ent_copy->efp_key_match_type = f_ent_orig->efp_key_match_type;
    }
#endif

        if (NULL == f_ent_orig[i].tcam.key) {
            free_tcam = TRUE;
        }

        rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent_orig + i);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }

        /*
         * Calling backup routine for the second time, means
         * TCAM buffer already allocated needs to be freed.
         */
        rv = _bcm_field_qual_tcam_key_mask_free(unit, f_ent_copy + i);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }

        /* Copy qualification data. */
        sal_memcpy(&f_ent_copy[i].tcam, &f_ent_orig[i].tcam,
                   sizeof(_field_tcam_t));
        sal_memcpy(&f_ent_copy[i].extra_tcam, &f_ent_orig[i].extra_tcam,
                   sizeof(_field_tcam_t));
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            sal_memcpy(&f_ent_copy[i].key_match_tcam,
                       &f_ent_orig[i].key_match_tcam,
                       sizeof(_field_tcam_t));
        }
#endif

        f_ent_copy[i].tcam.key  = NULL;/* Do not copy allocated part.*/
        f_ent_copy[i].tcam.mask = NULL;/* Do not copy allocated part.*/
        f_ent_copy[i].extra_tcam.key  = NULL;/* Do not copy allocated part.*/
        f_ent_copy[i].extra_tcam.mask = NULL;/* Do not copy allocated part.*/
        if (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            f_ent_copy[i].tcam.key_hw = NULL;
            f_ent_copy[i].tcam.mask_hw = NULL;
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            f_ent_copy[i].key_match_tcam.key  = NULL; /* Do not copy
                                                         allocated part.*/
            f_ent_copy[i].key_match_tcam.mask = NULL; /* Do not copy
                                                         allocated part.*/
        }
#endif

        /* Allocate tcam key and mask for destination entry. */
        rv = _bcm_field_qual_tcam_key_mask_get(unit,  f_ent_copy + i);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }

        /* Copy key and mask information. */
        sal_memcpy(f_ent_copy[i].tcam.key, f_ent_orig[i].tcam.key,
                   f_ent_copy[i].tcam.key_size);
        sal_memcpy(f_ent_copy[i].tcam.mask, f_ent_orig[i].tcam.mask,
                   f_ent_copy[i].tcam.key_size);

        if (f_ent_orig[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
            sal_memcpy(f_ent_copy[i].extra_tcam.key,
                f_ent_orig[i].extra_tcam.key,
                f_ent_orig[i].extra_tcam.key_size);

            sal_memcpy(f_ent_copy[i].extra_tcam.mask,
                f_ent_orig[i].extra_tcam.mask,
                f_ent_orig[i].extra_tcam.key_size);
        }

        if (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            sal_memcpy(f_ent_copy[i].tcam.key_hw,
                       f_ent_orig[i].tcam.key_hw,
                       f_ent_orig[i].tcam.key_size);
            sal_memcpy(f_ent_copy[i].tcam.mask_hw,
                       f_ent_orig[i].tcam.mask_hw,
                       f_ent_orig[i].tcam.key_size);
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            /* Copy key and mask information. */
            sal_memcpy(f_ent_copy[i].key_match_tcam.key,
                       f_ent_orig[i].key_match_tcam.key,
                       f_ent_copy[i].key_match_tcam.key_size);
            sal_memcpy(f_ent_copy[i].key_match_tcam.mask,
                       f_ent_orig[i].key_match_tcam.mask,
                       f_ent_copy[i].key_match_tcam.key_size);

        }
#endif
        if (free_tcam) {

            if (NULL != f_ent_orig[i].tcam.key) {
                sal_free(f_ent_orig[i].tcam.key);
                sal_free(f_ent_orig[i].tcam.mask);
            }

            if (f_ent_orig[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
                if (NULL != f_ent_orig[i].extra_tcam.key) {
                    sal_free(f_ent_orig[i].extra_tcam.key);
                    sal_free(f_ent_orig[i].extra_tcam.mask);
                }
            }

            f_ent_orig[i].tcam.key = f_ent_orig[i].tcam.mask =
                f_ent_orig[i].extra_tcam.key = f_ent_orig[i].extra_tcam.mask =
                    NULL;
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_copy[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            if (NULL != f_ent_orig[i].key_match_tcam.key) {
                sal_free(f_ent_orig[i].key_match_tcam.key);
                sal_free(f_ent_orig[i].key_match_tcam.mask);
            }
            f_ent_orig[i].key_match_tcam.key = NULL;
            f_ent_orig[i].key_match_tcam.mask = NULL;
        }
#endif
            free_tcam = FALSE;
        }
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_ingress_ipbm) ||
        _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(f_ent_orig->group->flags)) {
        BCM_PBMP_ASSIGN(f_ent_copy->pbmp.data, f_ent_orig->pbmp.data);
        BCM_PBMP_ASSIGN(f_ent_copy->pbmp.mask, f_ent_orig->pbmp.mask);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    if (f_ent_orig->statistic.flags & _FP_ENTRY_STAT_VALID) {

        /* Get statistics entity  description structure. */
        rv = _bcm_field_stat_get(unit, f_ent_orig->statistic.sid, &f_st);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }

        f_ent_copy->statistic.sid = f_ent_orig->statistic.sid;

        /* Increment statistics entity reference counter. */
        f_st->sw_ref_count++;

        f_ent_copy->statistic.flags = f_ent_orig->statistic.flags;

    }

    /*  Copy meter, if it exists. */
    for (i = 0; i < _FP_POLICER_LEVEL_COUNT; i++)  {

        if (f_ent_orig->policer[i].flags & _FP_POLICER_VALID) {

            /* Get policer description structure. */
            rv = _bcm_field_policer_get(unit,
                                        f_ent_orig->policer[i].pid,
                                        &f_pl);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }

            f_ent_copy->policer[i].pid = f_ent_orig->policer[i].pid;

            /* Increment policer reference counter. */
            f_pl->sw_ref_count++;

            f_ent_copy->policer[i].flags = f_ent_orig->policer[i].flags;
        }
    }

    for (fa_orig = f_ent_orig->actions;
        fa_orig != NULL;
        fa_orig = fa_orig->next) {
        rv = _field_action_alloc(unit,
                                fa_orig->action,
                                fa_orig->param[0],
                                fa_orig->param[1],
                                fa_orig->param[2],
                                fa_orig->param[3],
                                fa_orig->param[4],
                                fa_orig->param[5],
                                &fa);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                       unit));
            goto cleanup;
        }

        fa->next = f_ent_copy->actions;
        fa->flags |= fa_orig->flags;
        fa->hw_index = fa_orig->hw_index;
        fa->old_index = fa_orig->old_index;
        f_ent_copy->actions = fa;
    }

    /*Remove the Installed and Enabled flags in the backup copy
    so that restore and install updates tcam*/
    f_ent_copy->flags |= _FP_ENTRY_DIRTY;
    f_ent_copy->flags &= ~_FP_ENTRY_INSTALLED;
    f_ent_copy->flags &= ~_FP_ENTRY_ENABLED;

    f_ent_orig->ent_copy = f_ent_copy;

    FP_UNLOCK(unit);
    return (BCM_E_NONE);

cleanup:

    fa = f_ent_copy->actions;
    while (fa != NULL) {
        fa_free = fa;
        fa = fa->next;
        sal_free(fa_free);
    }

    for (i = 0; i < parts_count; i++) {
        _bcm_field_qual_tcam_key_mask_free(unit, f_ent_copy + i);
    }

    if (NULL != f_ent_copy) {
        sal_free(f_ent_copy);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     _bcm_field_entry_restore
 * Purpose:
 *     Restore the configuration of a field entry from backup. Resources
 *     allocated for the backup entry are released by calling the API
 *     with BCM_FIELD_ENTRY_OPER_CLEANUP flag bit set.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     entry_id   - (IN) Entry identifier
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_entry_restore(int unit, bcm_field_entry_t entry_id)
{
    _field_entry_t      *f_ent_orig;
    _field_entry_t      *f_ent_copy;
    _field_action_t     *fa_copy;
    _field_action_t     *fa = NULL;         /* Field action descriptor.       */
    _field_action_t     *fa_iter = NULL;    /* Field action descriptor.       */
    _field_stat_t       *f_st;          /* Internal statisics descriptor. */
    _field_policer_t    *f_pl;          /* Internal policer descriptor.   */
    int                 parts_count = 0;
    int                 i;
    int                 rv;



    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit,
                                    entry_id,
                                    &f_ent_orig);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in "
                               "bcm_esw_field_entry_policer_detach() - rv:%s\n"),
                   unit, bcm_errmsg(rv)));
        return (rv);
    }

    if (NULL == f_ent_orig->ent_copy) {
        FP_UNLOCK(unit);
        return (BCM_E_NOT_FOUND);
    }

    /* Detach any attached policers. */
    for (i = 0; i < _FP_POLICER_LEVEL_COUNT; i++)  {
        if (f_ent_orig->policer[i].flags & _FP_POLICER_VALID) {
            rv = bcm_esw_field_entry_policer_detach(unit,
                                                    f_ent_orig->eid,
                                                    i);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "FP(unit %d) Error: failure in "
                                       "bcm_esw_field_entry_policer_detach() - rv:%s\n"),
                           unit, bcm_errmsg(rv)));
                return (rv);
            }
        }
    }

    /* Detach attached STATs. */
    if (f_ent_orig->statistic.flags & _FP_ENTRY_STAT_VALID) {
        rv = bcm_esw_field_entry_stat_detach(unit,
                                             f_ent_orig->eid,
                                             f_ent_orig->statistic.sid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: failure in "
                                   "bcm_esw_field_stat_detach() - rv:%s\n"),
                       unit, bcm_errmsg(rv)));
            return (rv);
        }
    }

    /* Remove all actions set for this entry. */
    rv = bcm_esw_field_action_remove_all(unit, f_ent_orig->eid);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in "
                               "bcm_esw_field_action_remove_all() - rv:%s\n"),
                   unit, bcm_errmsg(rv)));
        return (rv);
    }

    /* Clear qualifiers set for this entry. */
    rv = bcm_esw_field_qualify_clear(unit, f_ent_orig->eid);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in "
                               "bcm_esw_field_qualify_clear() - rv:%s\n"),
                   unit, bcm_errmsg(rv)));
        return (rv);
    }

    /* Get the backup entry pointer. */
    f_ent_copy = f_ent_orig->ent_copy;

    /* Get number of entry parts . */
    rv = _bcm_field_entry_tcam_parts_count(unit,
                                           f_ent_orig->group->stage_id,
                                           f_ent_orig->group->flags,
                                           &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    for (i = 0; i < parts_count; i++) {
        f_ent_orig[i].eid = f_ent_copy[i].eid;
        f_ent_orig[i].group = f_ent_copy[i].group;
        f_ent_orig[i].flags = f_ent_copy[i].flags;

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) &&
        (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
        f_ent_orig->efp_key_match_type = f_ent_copy->efp_key_match_type;
    }
#endif

        /* Free allocated portion of sw tcam image. */
        _bcm_field_qual_tcam_key_mask_free(unit, &f_ent_orig[i]);
        if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return (rv);
        }

        /* Copy qualification data. */
        sal_memcpy(&f_ent_orig[i].tcam, &f_ent_copy[i].tcam,
                    sizeof(_field_tcam_t));
        sal_memcpy(&f_ent_orig[i].extra_tcam, &f_ent_copy[i].extra_tcam,
                    sizeof(_field_tcam_t));

#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            sal_memcpy(&f_ent_orig[i].key_match_tcam,
                       &f_ent_copy[i].key_match_tcam,
                       sizeof(_field_tcam_t));
        }
#endif
        f_ent_orig[i].tcam.key  = NULL; /* Do not copy allocated part.*/
        f_ent_orig[i].tcam.mask = NULL; /* Do not copy allocated part.*/
        f_ent_orig[i].extra_tcam.key  = NULL; /* Do not copy allocated part.*/
        f_ent_orig[i].extra_tcam.mask = NULL; /* Do not copy allocated part.*/

        if (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
            f_ent_orig[i].tcam.key_hw = NULL;
            f_ent_orig[i].tcam.mask_hw = NULL;
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            f_ent_orig[i].key_match_tcam.key  = NULL; /* Do not copy
                                                         allocated part.*/
            f_ent_orig[i].key_match_tcam.mask = NULL; /* Do not copy
                                                         allocated part.*/
        }
#endif
        if (f_ent_copy[i].flags & _FP_ENTRY_DIRTY) {

            /* Allocate tcam key and mask for entry. */
            rv = _bcm_field_qual_tcam_key_mask_get(unit,  f_ent_orig + i);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Copy key and mask information. */
            sal_memcpy(f_ent_orig[i].tcam.key, f_ent_copy[i].tcam.key,
                f_ent_copy[i].tcam.key_size);
            sal_memcpy(f_ent_orig[i].tcam.mask, f_ent_copy[i].tcam.mask,
                f_ent_copy[i].tcam.key_size);
            if (f_ent_orig[i].flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
                sal_memcpy(f_ent_orig[i].extra_tcam.key,
                    f_ent_copy[i].extra_tcam.key,
                    f_ent_copy[i].extra_tcam.key_size);
                sal_memcpy(f_ent_orig[i].extra_tcam.mask,
                    f_ent_copy[i].extra_tcam.mask,
                    f_ent_copy[i].extra_tcam.key_size);
            }

            if (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
                sal_memcpy(f_ent_orig[i].tcam.key_hw,
                    f_ent_copy[i].tcam.key_hw,
                    f_ent_copy[i].tcam.key_size);
                sal_memcpy(f_ent_orig[i].tcam.mask_hw,
                    f_ent_copy[i].tcam.mask_hw,
                    f_ent_copy[i].tcam.key_size);
            }

#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
            (f_ent_orig[i].fs->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            /* Copy key and mask information. */
            sal_memcpy(f_ent_orig[i].key_match_tcam.key,
                       f_ent_copy[i].key_match_tcam.key,
                       f_ent_orig[i].key_match_tcam.key_size);
            sal_memcpy(f_ent_orig[i].key_match_tcam.mask,
                       f_ent_copy[i].key_match_tcam.mask,
                       f_ent_orig[i].key_match_tcam.key_size);

        }
#endif
        }
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_field_ingress_ipbm) ||
        _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(f_ent_copy->group->flags)) {
        BCM_PBMP_ASSIGN(f_ent_orig->pbmp.data, f_ent_copy->pbmp.data);
        BCM_PBMP_ASSIGN(f_ent_orig->pbmp.mask, f_ent_copy->pbmp.mask);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    if (f_ent_copy->statistic.flags & _FP_ENTRY_STAT_VALID) {

        /* Get statistics entity  description structure. */
        rv = _bcm_field_stat_get(unit, f_ent_copy->statistic.sid, &f_st);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* Decrement statistics entity reference counter. */
        f_st->sw_ref_count--;

        rv = bcm_esw_field_entry_stat_attach(unit, f_ent_orig->eid,
                                             f_ent_copy->statistic.sid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        f_ent_copy->statistic.flags
            = (f_ent_orig->statistic.flags
                & (_FP_ENTRY_STAT_VALID | _FP_ENTRY_STAT_EMPTY
                    | _FP_ENTRY_STAT_USE_EVEN | _FP_ENTRY_STAT_USE_ODD));

    }

    /*  Copy meter, if it exists. */
    for (i = 0; i < _FP_POLICER_LEVEL_COUNT; i++)  {

        if (f_ent_copy->policer[i].flags & _FP_POLICER_VALID) {

            /* Get policer description structure. */
            rv = _bcm_field_policer_get(unit,
                                        f_ent_copy->policer[i].pid,
                                        &f_pl);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Decrement policer entity reference counter. */
            f_pl->sw_ref_count--;

            rv = bcm_esw_field_entry_policer_attach(unit,
                                                    f_ent_orig->eid,
                                                    i,
                                                    f_ent_copy->policer[i].pid);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
    }

    for (fa_copy = f_ent_copy->actions;
        fa_copy != NULL;
        fa_copy = fa_copy->next) {
        rv = _field_action_alloc(unit,
                                fa_copy->action,
                                fa_copy->param[0],
                                fa_copy->param[1],
                                fa_copy->param[2],
                                fa_copy->param[3],
                                fa_copy->param[4],
                                fa_copy->param[5],
                                &fa);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                       unit));
            FP_UNLOCK(unit);
            return (rv);
        }

        fa->next = f_ent_orig->actions;
        fa->flags |= fa_copy->flags;
        f_ent_orig->actions = fa;
    }

    /* Free resources allocated for entry dirty actions. */
    rv = _field_invalid_actions_remove(unit, f_ent_orig);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in "
                               "_field_invalid_actions_remove() - rv:%s\n"),
                   unit, bcm_errmsg(rv)));
        return (rv);
    }

    /* Update hardware index for profiled actions. */
    for (fa = f_ent_copy->actions;
        fa != NULL;
        fa = fa->next) {

        if (_FP_INVALID_INDEX != fa->hw_index) {
            fa_iter = f_ent_orig->actions;
            while (fa_iter != NULL) {
                if ((1 == (fa_iter->flags & _FP_ACTION_VALID))
                        && (fa_iter->action == fa->action)
                        && (_FP_INVALID_INDEX == fa_iter->hw_index)) {
                    fa_iter->hw_index = fa->hw_index;
                    fa_iter->old_index = fa->old_index;
                    break;
                }
                fa_iter = fa_iter->next;
            }
        }
    }

    /* Restore the entry priority. */
    rv = _field_entry_prio_set(unit, entry_id, f_ent_copy[0].prio);

    FP_UNLOCK(unit);
    return (rv);

}

/*
 * Function:
 *     _bcm_field_entry_cleanup
 * Purpose:
 *     Release the resources allocated for the back entry.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     entry_id   - (IN) Entry identifier
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_entry_cleanup(int unit, bcm_field_entry_t entry_id)
{
    _field_entry_t      *f_ent_orig;
    _field_entry_t      *f_ent_copy;
    _field_action_t     *fa = NULL;         /* Field action descriptor.       */
    _field_action_t     *fa_free = NULL;    /* Field action descriptor.       */
    _field_stat_t       *f_st;              /* Internal Statisics descriptor. */
    _field_policer_t    *f_pl;              /* Internal policer descriptor.   */
    int                 rv;
    int                 parts_count = 0;
    int                 i;


    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit,
                                    entry_id,
                                    &f_ent_orig);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (NULL == f_ent_orig->ent_copy) {
        FP_UNLOCK(unit);
        /* No resources to free. */
        return (BCM_E_NONE);
    }

    /* Get number of entry parts . */
    rv = _bcm_field_entry_tcam_parts_count(unit,
                                           f_ent_orig->group->stage_id,
                                           f_ent_orig->group->flags,
                                           &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    f_ent_copy = f_ent_orig->ent_copy;

    for (i = 0; i < parts_count; i++) {
        _bcm_field_qual_tcam_key_mask_free(unit, f_ent_copy + i);
    }

    if (f_ent_copy->statistic.flags & _FP_ENTRY_STAT_VALID) {

        /* Get statistics entity  description structure. */
        rv = _bcm_field_stat_get(unit, f_ent_copy->statistic.sid, &f_st);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
        /* Decrement statistics entity reference counter. */
        f_st->sw_ref_count--;
    }

    for (i = 0; i < _FP_POLICER_LEVEL_COUNT; i++)  {
        if (f_ent_copy->policer[i].flags & _FP_POLICER_VALID) {

            /* Get policer description structure. */
            rv = _bcm_field_policer_get(unit,
                                        f_ent_copy->policer[i].pid,
                                        &f_pl);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            /* Decrement policer reference counter. */
            f_pl->sw_ref_count--;
        }
    }

cleanup:
    fa = f_ent_copy->actions;
    while (fa != NULL) {
        fa_free = fa;
        fa = fa->next;
        sal_free(fa_free);
    }

    if (NULL != f_ent_copy) {
        sal_free(f_ent_orig->ent_copy);
        f_ent_orig->ent_copy = NULL;
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

#if defined (BCM_TRIUMPH2_SUPPORT)
/*
 * Function:
 *      _bcm_esw_field_udf_chunks_to_int_qset
 * Purpose:
 *      Sets internal data qualifiers corrspeonding to the
 *      offset chunks used by the UDF.
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      udf_chunks_bmap     - (IN)  UDF offsets chunks map
 *      qset                - (OUT) Qualifier set
 * Returns:
 *      BCM_E_NONE
 * Notes:
 */
int
_bcm_esw_field_udf_chunks_to_int_qset(int unit, uint32 udf_chunks_bmap,
                                      bcm_field_qset_t *qset)
{
    int gran = 0, max_chunks = 0;
    int idx;             /* HW bitmap iteration index. */
    int offset0_1 = 0;   /* HW offset 0 and 1 usage status. */
    int offset2_3 = 0;   /* HW offset 2 and 3 usage status. */
    int offset4_5 = 0;   /* HW offset 4 and 5 usage status. */
    int offset6_7 = 0;   /* HW offset 6 and 7 usage status. */

    /* Retreive granularity and max chunks in unit */
    gran = BCMI_XGS4_UDF_CTRL_OFFSET_GRAN(unit);
    max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);


#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if(!(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageLookup))) {
            return (
                _bcm_field_th_udf_chunks_to_int_qset(
                           unit, udf_chunks_bmap, qset));
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* First Check Data0 and Data1 Qualify */
    for (idx = 0; idx <= max_chunks; idx++) {
        if(udf_chunks_bmap & (1 << idx)) {
            if (idx >= 0 && idx < (max_chunks/2)) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
            } else if (idx >= (max_chunks/2) && idx < max_chunks) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData1);
            }
        }
    }

    /* Based on Granularity set Data2 and Data3 Qualify */
    if(gran == UDF_OFFSET_GRAN2) {

        if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0)) {

            /* See if not having to use all UDF1 */
            BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
            BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
            BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

            /* Get HW offsets usage status. */
            /* coverity[callee_ptr_arith : FALSE] */
            SHR_BITTEST_RANGE(&udf_chunks_bmap, 0, 2, offset0_1);
            /* coverity[callee_ptr_arith : FALSE] */
            SHR_BITTEST_RANGE(&udf_chunks_bmap, 2, 2, offset2_3);
            /* coverity[callee_ptr_arith : FALSE] */
            SHR_BITTEST_RANGE(&udf_chunks_bmap, 4, 2, offset4_5);
            /* coverity[callee_ptr_arith : FALSE] */
            SHR_BITTEST_RANGE(&udf_chunks_bmap, 6, 2, offset6_7);


            /* Add new internal qualifiers based on HW offsets usage status. */
            if ((!offset0_1 && !offset4_5) && (offset2_3 || offset6_7)) {
                if (offset2_3 && offset6_7) {
                    /* Add both UDF1_31_0 and UDF1_95_64 */
                    BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                    BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
                } else if (offset6_7 && !offset2_3) {
                    /* Add UDF1_31_0 */
                    BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                } else {
                    /* Add UDF1_95_64 */
                    BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
                }
            } else {
                /* Add UDF1_127_0 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
            }
        }

    }

    return BCM_E_NONE;
}



/*
 * Function:
 *      bcmi_xgs4_field_qset_udf_id_multi_set
 * Purpose:
 *      Sets the list of udf id objects in the qset
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      num_objects         - (IN)  Number of objects.
 *      object_list         - (IN)  List of objects (Ex; UDF ids).
 *      qset                - (OUT) Qualifier set.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_xgs4_field_qset_udf_id_multi_set(
    int unit,
    int num_objects,
    int objects_list[],
    bcm_field_qset_t *qset
    )
{

    int i;
    int rv;
    uint32 udf_chunks = 0;
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL;
#ifdef BCM_TOMAHAWK_SUPPORT
    int j;
#endif

    UDF_LOCK(unit);

    for (i = 0; i < num_objects;  i++) {
        /* Fetch udf info for hw_bmap */
        rv = bcmi_xgs4_udf_offset_node_get(unit, objects_list[i], &offset_info);
        if (BCM_FAILURE(rv)) {
            UDF_UNLOCK(unit);
            return rv;
        }

        udf_chunks |= offset_info->hw_bmap;
    }

    /* Update udf_chuks bmap with qset */
    for (i = 0; i < BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit); i++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(qset->udf_map, i)) {
            SHR_BITSET(&udf_chunks, i);
        }
    }
    /* Update qset with internal data qualifiers based on udf_chunks */
    rv = _bcm_esw_field_udf_chunks_to_int_qset(unit, udf_chunks, qset);
    if (BCM_FAILURE(rv)) {
        UDF_UNLOCK(unit);
        return rv;
    }

    /* setting udf_map helps in gets/deletes */
    for (i = 0; i < BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit); i++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(&udf_chunks, i)) {
            SHR_BITSET(qset->udf_map, i);
        }
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    /* SDK builds key gen mask for exact match group during group create.
     * group control structure has information only about data qualifiers
     * (_bcmFieldQualifyData0 - _bcmFieldQualifyData9) and chunks allocated
     * in groups qset.But no information is available about which bytes of
     * the chunk is actually allocated.
     * But we need which bytes of chunk is allocated for the data qualifier to
     * properly build the EM key gen mask, in case of partially allocated chunks.
     * So updating the unused bits of udf_map in bcm_field_qset_t to hold the
     * bytes allocated in chunks allocated for the data qualifier.*/
    for (j = 0; j < num_objects;  j++) {
        rv = bcmi_xgs4_udf_offset_node_get(unit, objects_list[j], &offset_info);
        if (BCM_FAILURE(rv)) {
            UDF_UNLOCK(unit);
            return rv;
        }
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            for (i = 0; i < (BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit) * 2); i++) {
                if (SHR_BITGET(&(offset_info->byte_bmap), i)) {
                    SHR_BITSET(qset->udf_map,
                              (BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit) + i));
                }
            }
        }
    }
#endif

    UDF_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcmi_xgs4_field_qset_udf_id_multi_delete
 * Purpose:
 *      Deletes list of udf id objects from the qset
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      num_objects         - (IN)  Number of objects.
 *      object_list         - (IN)  List of objects (Ex; UDF ids).
 *      qset                - (OUT) Qualifier set.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_xgs4_field_qset_udf_id_multi_delete(
    int unit,
    int num_objects,
    int objects_list[],
    bcm_field_qset_t *qset
    )
{

    int i;
    int rv;
    uint32 udf_chunks = 0; /* Offset chunks bitmap */
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL; /* UDF offset info */


    UDF_LOCK(unit);

    for (i = 0; i < num_objects;  i++) {
        /* Fetch udf info for hw_bmap */
        rv = bcmi_xgs4_udf_offset_node_get(unit, objects_list[i], &offset_info);
        if (BCM_FAILURE(rv)) {
            UDF_UNLOCK(unit);
            return rv;
        }

        udf_chunks |= offset_info->hw_bmap;
    }

    /* Update qset with internal data qualifiers based on udf_chunks */
    rv = _bcm_esw_field_udf_chunks_to_int_qset(unit, udf_chunks, qset);
    if (BCM_FAILURE(rv)) {
        UDF_UNLOCK(unit);
        return rv;
    }

    /* setting udf_map helps in gets/deletes */
    for (i = 0; i < BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit); i++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(&udf_chunks, i)) {
            SHR_BITCLR(qset->udf_map, i);
        }
    }

    UDF_UNLOCK(unit);

    return rv;
}


/*
 * Function:
 *      bcmi_xgs4_field_qset_udf_id_multi_get
 * Purpose:
 *      Gets list of udf id objects in a qset
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      qset                - (IN)  Qualifier set.
 *      max                 - (IN)  Max number of objects.
 *      object_list         - (OUT) List of objects (Ex; UDF ids).
 *      actual              - (OUT) Number of objects.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_xgs4_field_qset_udf_id_multi_get(
    int unit,
    bcm_field_qset_t qset,
    int max,
    int objects_list[],
    int *actual
    )
{
    int i;
    uint32 hw_bmap = 0;
    int max_chunks = 0;
    bcmi_xgs4_udf_offset_info_t *tmp;

    UDF_LOCK(unit);

    max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);

    /* Input parameters check. */
    if (actual == NULL) {
	UDF_UNLOCK(unit);
        return BCM_E_PARAM;
    }

    for (i = 0; i < max_chunks; i++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(qset.udf_map, i)) {
            SHR_BITSET(&hw_bmap, i);
        }
    }

    i = 0;
    tmp = UDF_CTRL(unit)->offset_info_head;

    while (tmp != NULL) {
       if ( hw_bmap & (tmp->hw_bmap)) {
           if (i >= max) {
               break;
           }
           objects_list[i++] = tmp->udf_id;
       }
       tmp = tmp->next;
    }


    *actual = i;

    UDF_UNLOCK(unit);

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_esw_field_qual_udf_offsets_get
 * Purpose:
 *      Gets list of udf id objects in a qset
 * Parameters:
 *      unit          - (IN)  Unit number.
 *      qid           - (IN)  Internal Data qualifier.
 *      chunk_order   - (IN)  Offset chunks in the order of availability.
 *      num_chunks    - (OUT) Number of chunks.
 * Returns:
 *      BCM_E_NONE
 * Notes:
 */
int
_bcm_esw_field_qual_udf_offsets_get(int unit, int qid,  _field_group_t *fg,
                                    int chunk_order[], int *num_chunks,
                                    int pipe_num)
{
    int idx;
    int alloc_count = 0;
    uint32 hw_bmap;
    int max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);
    int gran = BCMI_XGS4_UDF_CTRL_OFFSET_GRAN(unit);

#if defined (BCM_TOMAHAWK_SUPPORT)
    bcm_udf_oper_mode_t udf_oper_mode = bcmUdfOperModeGlobal;
    bcmi_xgs4_udf_oper_mode_get(unit, &udf_oper_mode);

    if ((soc_feature(unit, soc_feature_udf_multi_pipe_support)) &&
        (udf_oper_mode == bcmUdfOperModePipeLocal)) {
            hw_bmap = (UDF_CTRL(unit)->hw_bmap_per_pipe[pipe_num]);
    } else
#endif
    {
        hw_bmap = (UDF_CTRL(unit)->hw_bmap);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        return (
            _bcm_field_th_qual_udf_offsets_get(
                       unit, qid, chunk_order, num_chunks, hw_bmap));
    }
#endif

    for (idx = 0; idx < max_chunks; idx++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(&hw_bmap, idx)) {
            continue;
        }

        /* Allocate as per granularity */
        if (gran == UDF_OFFSET_GRAN2) {
            if (((qid == _bcmFieldQualifyData2) && ((idx == 6) || (idx == 7)))  ||
                    ((qid == _bcmFieldQualifyData3) && ((idx == 2) || (idx == 3)))  ||
                    ((qid == _bcmFieldQualifyData1) && ((idx >= 8)))                ||
                    ((qid == _bcmFieldQualifyData0) && ((idx <= 7))))               {

                chunk_order[alloc_count] = idx;
                alloc_count++;

                if ((*num_chunks + alloc_count) >= max_chunks) {
                    break;
                }
            }
        } else {
            if (((qid == _bcmFieldQualifyData2) && (idx == 3))       ||
                    ((qid == _bcmFieldQualifyData3) && (idx == 1))   ||
                    ((qid == _bcmFieldQualifyData1) && ((idx >= 4))) ||
                    ((qid == _bcmFieldQualifyData0) && ((idx <= 3))))               {

                chunk_order[alloc_count] = idx;
                alloc_count++;

                if ((*num_chunks + alloc_count) >= max_chunks) {
                    break;
                }
            }
        }
    }

    *num_chunks += alloc_count;

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_esw_field_qset_udf_offsets_alloc
 * Purpose:
 *      Allocates offset chunks based on the INPUT qset.
 * Parameters:
 *      unit          - (IN)  Unit number.
 *      stage         - (IN)  Field Group Stage.
 *      qset          - (IN)  Qualifier set.
 *      req_offsets   - (IN)  Number of chunks to be allocated.
 *      offset_array  - (OUT) Offset chunks in the order of availability.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_esw_field_qset_udf_offsets_alloc(int unit, _field_stage_id_t stage,
    bcm_field_qset_t qset, int req_offsets, int offset_array[], int *max_chunks,
    int pipe_num)
{
    int group_flags[5] =  {
            /* SINGLE */
            (_FP_GROUP_SPAN_SINGLE_SLICE),
            /* DOUBLE_INTRA */
            (_FP_GROUP_SPAN_SINGLE_SLICE | _FP_GROUP_INTRASLICE_DOUBLEWIDE),
            /* DOUBLE */
            (_FP_GROUP_SPAN_DOUBLE_SLICE),
            /* QUAD_INTRA */
            (_FP_GROUP_SPAN_DOUBLE_SLICE | _FP_GROUP_INTRASLICE_DOUBLEWIDE),
            /* TRIPLE */
            (_FP_GROUP_SPAN_TRIPLE_SLICE)
        };

    int qset_comb[9][4] =  {
            /* Internal qualifier Data2 (UDF1_6,UDF1_7) for Gran2
             *                          (UDF1_3) for Gran4
             */
            {1, _bcmFieldQualifyData2, -1, -1},
            /* Internal qualifier Data3 (UDF1_2,UDF1_3) for Gran2
             *                          (UDF1_1) for Gran 4
             */
            {1, _bcmFieldQualifyData3, -1, -1},
            /* Internal qualifier Data2 & Data3 (UDF1_6,UDF1_7,UDF1_2,UDF1_3)
             *                     for Gran2 and (UDF1_3,UDF1_1) for Gran4
             */
            {2, _bcmFieldQualifyData2,
                _bcmFieldQualifyData3,
                -1},
            /* Internal qualifier Data1 (UDF2) */
            {1, _bcmFieldQualifyData1, -1, -1},
            /* Internal qualifier Data0 (UDF1) */
            {1, _bcmFieldQualifyData0, -1, -1},
            /* Internal qualifier Data1 & Data2 (UDF1_6, UDF1_7 & UDF2) for Gran2
             *                                  (UDF1_3 & UDF2) for Gran4
             */
            {2, _bcmFieldQualifyData1,
                _bcmFieldQualifyData2,
                -1},
            /* Internal qualifier Data1 & Data3 (UDF1_2, UDF1_3 & UDF2) for Gran 2
             *                                  (UDF1_1 & UDF2) for Gran4
             */
            {2, _bcmFieldQualifyData1,
                _bcmFieldQualifyData3,
                -1},
            /* Internal qualifier Data1, Data2 & Data3 (UDF1_6, UDF1_7, UDF1_2, UDF1_3 & UDF2)
             *                for Gran2 and (UDF1_3, UDF1_1, & UDF2) for Gran4
             */
            {3, _bcmFieldQualifyData1,
                _bcmFieldQualifyData2,
                _bcmFieldQualifyData3},
            /* Internal qualifier Data0 & Data1 (UDF1 & UDF2) */
            {2, _bcmFieldQualifyData0,
                _bcmFieldQualifyData1,
                -1}
        };

    int i, j;
    int qid;
    int qual_count;
    int rv = BCM_E_NONE;
    int num_chunks = 0;
    _field_group_t fg;
    bcm_field_qset_t qset_test;
    int idx;

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == stage) {
        return (_bcm_field_th_qset_udf_offsets_alloc(
                    unit, stage, qset, req_offsets,
                    offset_array, max_chunks, pipe_num));

    }
#endif

    /* Initialize group creation tracking structure. */
    sal_memset(&fg, 0, sizeof(fg));

    fg.stage_id = stage;
    for (i = 0; i < COUNTOF(group_flags); i++) {

        /* TD_TT family  support intra_double mode group only in VFP */
        if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
            if (((i == 1) || (i == 4)) && (stage != _BCM_FIELD_STAGE_LOOKUP)) {
                continue;
            }
        }

        fg.flags = group_flags[i];

        for (j = 0; j < COUNTOF(qset_comb); j++) {

            num_chunks = 0;
            qual_count = qset_comb[j][0];

            sal_memcpy(&qset_test, &qset, sizeof(bcm_field_qset_t));

            for (qid = 0; qid < qual_count; qid++) {
                BCM_FIELD_QSET_ADD_INTERNAL(qset_test, qset_comb[j][1 + qid]);
            }

            FP_LOCK(unit);
            rv = _field_selcode_assign(unit, qset_test, 1, &fg);
            FP_UNLOCK(unit);

            if (BCM_SUCCESS(rv)) {

                for (qid = 0; qid < qual_count; qid++) {
                    rv = _bcm_esw_field_qual_udf_offsets_get(unit,
                                     qset_comb[j][1 + qid], &fg,
                                     offset_array+num_chunks, &num_chunks,
                                     pipe_num);
                    if (BCM_FAILURE(rv)) {
                        for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
                            BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&fg, idx));
                        }
                        return rv;
                    }
                }

                if (num_chunks >= req_offsets) {
                    break;
                }
            }
        }

        if (num_chunks >= req_offsets) {
            break;
        }
    }

    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&fg, idx));
    }

    /* The UDF offset allocation to suit in an fp group
     * that consists of the user specified qset is not possible */
    if (num_chunks < req_offsets) {
        return BCM_E_RESOURCE;
    }

    *max_chunks = num_chunks;

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_xgs4_field_qualify_udf_data_elem
 * Purpose:
 *      Qualify the field entry with data/mask corresponding to an offset chunk.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      offset_info     - (IN)  UDF offset info.
 *      data_idx        - (IN)  The offset chunk index.
 *      data            - (IN)  Input data to qualify the entry.
 *      mask            - (IN)  Input mask to qualify the entry.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_xgs4_field_qualify_udf_data_elem(int unit, bcm_field_entry_t eid,
                         bcmi_xgs4_udf_offset_info_t *offset_info,
                         int data_idx, uint32 data, uint32 mask)
{
    int rv;
    int idx;
    int elem_idx = 0;
    int qid = 0;
    int gran, max_chunks;
    _field_entry_t *f_ent = NULL;
    _bcm_field_qual_offset_t *q_offset;
    _bcm_field_qual_offset_t q_offset_temp;
#if defined (BCM_TOMAHAWK_SUPPORT)
    uint32                   q_data = 0;        /* Qualifier data             */
    uint32                   q_mask = 0;        /* Qualifier mask             */
    int                      bit32_chunk = 0;   /* Chunk is 32bit or 16bit    */
#endif

    max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);
    gran = BCMI_XGS4_UDF_CTRL_OFFSET_GRAN(unit);

    /* Get the appropriate element index to insert the data */
    for (idx = 0; idx < max_chunks; idx++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(&(offset_info->hw_bmap), idx)) {
            if (elem_idx == data_idx) {
                break;
            } else {
                elem_idx++;
            }
        }
    }

    /* Get entry info. */
    BCM_IF_ERROR_RETURN
        (_field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent));

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id ||
         f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
        BCM_IF_ERROR_RETURN(
                    _bcm_field_th_qualify_udf_data_elem_get
                                 (unit, idx, max_chunks, &qid));
    } else
#endif
    {
        /* idx - chunk id; data_idx - ? */
        if ((idx >= 0) && (idx < max_chunks/2)) {

            /*
             * If _bcmFieldQualifyData0 is not set in the qset,
             * either _bcmFieldQualifyData2 or _bcmFieldQualifyData3
             * will be set in the qset.
             */
            if (gran == UDF_OFFSET_GRAN2) {
                if (!BCM_FIELD_QSET_TEST_INTERNAL
                        (f_ent->group->qset, _bcmFieldQualifyData0)) {
                    if ((2 == idx || 3 == idx)
                            && !(offset_info->hw_bmap & 0x33)) {
                        /* UDF1_95_64 */
                        qid = _bcmFieldQualifyData3;
                    } else if ((6 == idx || 7 == idx)
                            && !(offset_info->hw_bmap & 0x33)) {
                        /* UDF1_31_0 */
                        qid = _bcmFieldQualifyData2;
                    } else {
                        /*
                         * udf_offset0_1 and udf_offset4_5 must be in
                         * _bcmFieldQualifyData0
                         */
                        return (BCM_E_INTERNAL);
                    }
                } else {
                    /* UDF1_127_0 */
                    qid = _bcmFieldQualifyData0;
                }
            } else {
                /* GRAN 4 */
                qid = _bcmFieldQualifyData0;
            }
        } else if ((idx >= max_chunks/2) &&
                   idx < max_chunks) {
            qid =  _bcmFieldQualifyData1;
            idx -= (max_chunks / 2);
        } else {
            return (BCM_E_INTERNAL);
        }

        /* Get entry qualifier offset in tcam */
        if(gran == UDF_OFFSET_GRAN2) {
            if (qid == _bcmFieldQualifyData3) {
                if (idx == 2) {
                    idx = 1;
                } else {
                    idx = 0;
                }
            } else {
                idx = (((max_chunks/2) - 1) - idx);
            }
        } else {
            /* GRAN4 Case */
            idx = (((max_chunks/2) - 1) - idx);
        }
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {

        if (idx != 0x0 && idx != 0x1 && idx != 0x8 && idx != 0x9)
        {
            bit32_chunk = 1;
        }

        if(bit32_chunk) {
            /*Since a 32 bit chunk can be allocated even partially,
              do not overwrite existing data in 32bit chunk.*/
            rv = _bcm_field_entry_qualifier_uint32_get(unit, f_ent->eid, qid,
                                                           &q_data, &q_mask);

            if ((rv != BCM_E_NOT_FOUND) && (BCM_FAILURE(rv))) {
                return rv;
            }

            if (rv == BCM_E_NONE) {
                if((idx % 2) == 0) {
                    /* Idx is even => Upper 16 bits need to be written.Hence,mask the lower
                     *16 bits of the q_data fetched from tcam and add the data*/
                    q_data &= ((1 << 16) - 1);
                    q_mask &= ((1 << 16) - 1);

                    data = data << 16 | q_data;
                    mask = mask << 16 | q_mask;
                } else {
                    /* Idx is odd => Lower 16 bits need to be written.Hence,mask the upper
                     *16 bits of the q_data fetched from tcam and add the data*/
                    q_data &= ~((1 << 16) - 1);
                    q_mask &= ~((1 << 16) - 1);

                    data |= q_data;
                    mask |= q_mask;
                }
            }
        }

        /* For exact Match, though 32bit/16bit chunk is  partially allocated,
         * _bcm_field_th_entry_check_full_mask will expect full mask to during
         * validation.
         */
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {

            if (bit32_chunk) {
                if ((idx % 2) == 0) {
                    mask |= 0xffff;
                } else {
                    mask |= 0xffff0000;
                }
            }

            if (!(offset_info->byte_bmap & (1 << (idx * 2)))) {
                mask |= 0xff;
            }

            if (!(offset_info->byte_bmap & (1 << ((idx * 2) + 1)))) {
                    mask |= 0xff00;
            }
        }

        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, eid, qid,
                                          &data, &mask,
                                          _FP_QUALIFIER_ADD));
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        return (_bcm_field_th_class_qualify_set(unit, eid, qid,
                                                &data, &mask));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get entry qualifier should be installed in. */
    f_ent = NULL;
    rv = _bcm_field_entry_qual_get(unit, eid, qid, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Get entry qualifier offset in tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qid, &q_offset);
    BCM_IF_ERROR_RETURN(rv);

    sal_memcpy(&q_offset_temp, q_offset,
               sizeof(_bcm_field_qual_offset_t));

    q_offset_temp.offset[0] += idx * gran * 8;
    q_offset_temp.width[0] = gran * 8;

   /*
    * COVERITY
    *
    * This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */

    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, &q_offset_temp, f_ent, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;

    return (BCM_E_NONE);
}


/*
 * Function:
 *      bcmi_xgs4_field_qualify_udf_data
 * Purpose:
 *      Add UDF data that the packet must match to trigger qualifier.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      udf_id          - (IN)  UDF ID.
 *      length          - (IN)  Number of bytes to match in field entry.
 *      data            - (IN)  Input data to qualify the entry.
 *      mask            - (IN)  Input mask to qualify the entry.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcmi_xgs4_field_qualify_udf_data (int unit, bcm_field_entry_t eid,
    bcm_udf_id_t udf_id, int length, uint8 *data, uint8 *mask)
{
    int      idx = 0;            /* HW bitmap iteration index. */
    int      data_idx = 0;       /* Qualifier element index.   */
    int      rv = BCM_E_NONE;    /* Operation return status.   */
    int      byte_offset;        /* Byte offset in the word.   */
    int      gran = 0;           /* Granularity of the chunk.  */
    uint32   data_elem = 0;      /* Hw info data word.         */
    uint32   mask_elem = 0;      /* Hw info data mask.         */
    uint8    data_qual_done = 0;
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL;   /* UDF offset info */

    UDF_LOCK(unit);

    /* Get UDF info. */
    rv = bcmi_xgs4_udf_offset_node_get(unit, udf_id,  &offset_info);
    if (BCM_FAILURE(rv)) {
        UDF_UNLOCK(unit);
        return rv;
    }

    /* If provided entry data length is greater than UDF width */
    if ((length > offset_info->width) || (length <=0)) {
        UDF_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    /* Max chunks */
    gran = BCMI_XGS4_UDF_CTRL_OFFSET_GRAN(unit);

    /* data_idx - chunk iterator */
    data_elem = 0;
    mask_elem = 0;
    data_idx = 0;
    byte_offset = offset_info->byte_offset;

    /* idx - input data bytes iterator */
    for (idx = 0; idx < length; idx++) {

        data_elem |= (data[idx] << (8 * (gran - 1 - byte_offset)));
        mask_elem |= (mask[idx] << (8 * (gran - 1 - byte_offset)));

        byte_offset += 1;
        data_qual_done = 0;

        if ((byte_offset == gran)) {
            /* Install the element data & mask of "gran" bytes (even if zeros) */
            rv = _bcm_xgs4_field_qualify_udf_data_elem(unit, eid, offset_info,
                                               data_idx, data_elem, mask_elem);
            if (BCM_FAILURE(rv)) {
                UDF_UNLOCK(unit);
                return rv;
            }

            data_idx += 1;
            byte_offset = 0;
            data_elem = 0;
            mask_elem = 0;
            data_qual_done = 1;
        }
    }

    /* Install last element data & mask, if data/mask still exists to be qualified */
    if (data_qual_done != 1) {
        rv = _bcm_xgs4_field_qualify_udf_data_elem(unit, eid, offset_info,
                data_idx, data_elem, mask_elem);
    }

    UDF_UNLOCK(unit);

    return (rv);
}


/*
 * Function:
 *      bcmi_xgs4_field_qualify_udf_get
 * Purpose:
 *      Qualify the field entry with data/mask corresponding to an offset chunk.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      udf_id          - (IN)  UDF ID.
 *      max_length      - (IN)  Length of bytes of data/mask to fetch.
 *      data            - (OUT) Data to qualify the entry.
 *      mask            - (OUT  Mask to qualify the entry.
 *      actual_length   - (OUT) Length of bytes of data/mask fetched.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_xgs4_field_qualify_udf_get(int unit, bcm_field_entry_t eid,
                              bcm_udf_id_t udf_id, int max_length,
                              uint8 *data, uint8 *mask, int *actual_length)
{
    _field_stage_t          *stage_fc;          /* Stage field control.       */
    _field_entry_t          *f_ent = NULL;
    _field_group_t          *fg;
    bcm_field_qset_t        *qset;
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL;   /* UDF offset info.   */
    int  num_elems = 0;
    int  qid = 0;
    int idx;        /* HW bitmap iteration index. */
    int rv;         /* Operation return status.   */
    int copy_len;
    int len = 0;
    int off = 0;
    int max_elems = 0;
    int min_elems = 0;
    int udf1_elems = 0; /* elements in UDF1 */
    int udf2_elems = 0; /* elements in UDF2 */
    _bcm_field_udf_data_t udf_data; /* UDF full data */
    _bcm_field_udf_data_t udf_mask; /* UDF mask for full data */
    _bcm_field_qual_data_t udf_data1; /* UDF full data */
    _bcm_field_qual_data_t udf_mask1; /* UDF mask for full data */
    int gran = 0;

#ifdef LE_HOST
    _bcm_field_udf_data_t udf_data_swap; /* UDF full data */
    _bcm_field_udf_data_t udf_mask_swap; /* UDF mask for full data */
    int part = 0;
#endif /* LE_HOST */


    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask) ||
            (NULL == actual_length) || (max_length == 0)) {
        return (BCM_E_PARAM);
    }

   UDF_LOCK(unit);

    /* Get Granularity */
    gran = BCMI_XGS4_UDF_CTRL_OFFSET_GRAN(unit);

    /* Get UDF info. */
    rv = bcmi_xgs4_udf_offset_node_get(unit, udf_id,  &offset_info);
    if (BCM_FAILURE(rv)) {
        UDF_UNLOCK(unit);
        return (rv);
    }

    /*
     * If provided entry data length is less than data length used
     * to create qualifier then return error
     */

    if (max_length < offset_info->width) {
        UDF_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_get_by_id(unit, eid, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (rv);
    }

    /* Get field group */
    fg = f_ent->group;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (bcmi_field_th_qualify_udf_get(
                    unit, eid, udf_id, max_length,
                    data, mask, actual_length));
    }
#endif


    /* get qset */
    qset = &(fg->qset);

    /* Get number of elems per UDF and elem size */
    num_elems = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);

    for (idx = 0; idx < num_elems/2; idx++) {
        if (!(offset_info->hw_bmap & (1 << idx))) {
            continue;
        }
        udf1_elems++;
    }

    for (idx = num_elems/2; idx < num_elems; idx++) {
        if (!(offset_info->hw_bmap & (1 << idx))) {
            continue;
        }
        udf2_elems++;
    }

    if (udf1_elems != 0) {
        qid = _bcmFieldQualifyData0;
        max_elems = num_elems/2;
        min_elems = 0;
    } else if (udf2_elems != 0) {
        qid = _bcmFieldQualifyData1;
        max_elems = num_elems;
        min_elems = num_elems/2;
    }

    do {
        /* Qset has Data2 Data3 instead of Data0 qualifier */
        if ((qid == _bcmFieldQualifyData0) &&
                (!BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0))) {
            sal_memset(udf_data, 0, sizeof(_bcm_field_qual_data_t));
            sal_memset(udf_mask, 0, sizeof(_bcm_field_qual_data_t));
            if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData2)) {
                rv = _field_entry_qualifier_key_get(unit, eid, _bcmFieldQualifyData2,
                        udf_data1, udf_mask1);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    UDF_UNLOCK(unit);
                    return (rv);
                }
                udf_data[0] = udf_data1[0];
                udf_mask[0] = udf_mask1[0];
            }
            if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData3)) {
                rv = _field_entry_qualifier_key_get(unit, eid, _bcmFieldQualifyData3,
                        udf_data1, udf_mask1);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    UDF_UNLOCK(unit);
                    return (rv);
                }
                udf_data[2] = udf_data1[0];
                udf_mask[2] = udf_mask1[0];
            }
        } else {
            rv = _field_entry_qualifier_key_get(unit, eid, qid,
                    udf_data, udf_mask);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                UDF_UNLOCK(unit);
                return (rv);
            }
        }
#ifdef LE_HOST
        for (part = 0; part < _FP_UDF_DATA_WORDS; part++) {
            udf_data_swap[part]= BCMSWAP32(udf_data[part]);
            udf_data[part]= udf_data_swap[part];
            udf_mask_swap[part]= BCMSWAP32(udf_mask[part]);
            udf_mask[part]= udf_mask_swap[part];
        }
#endif /* LE_HOST */

        for (idx = min_elems; idx < max_elems; idx++) {
            if (!(offset_info->hw_bmap & (1 << idx))) {
                continue;
            }

            if ((offset_info->width - len) <= 0) {
                break;
            }

            if (gran == UDF_OFFSET_GRAN2) {
                /*
                 * Retreive the relevant data and mask from 4 words
                 * (4 * 4 = 16 bytes) of data and mask.
                 * For each index set  a chunk(2 bytes) are read. The way
                 * information is organized is for different index values
                 * data resides in following location.
                 * index = 0 data in 12,13 - W = 3 offset = 0
                 * index = 1 data in 14,15 - W = 3 offset = 2
                 * index = 2 data in 8,9   - W = 2 offset = 0
                 * index = 3 data in 10,11 - W = 2 offset = 2
                 * index = 4 data in 4,5   - W = 1 offset = 0
                 * index = 5 data in 6,7   - W = 1 offset = 2
                 * index = 6 data is 0,1   - W = 0 offset = 0
                 * index = 7 data is 2,3   - W = 0 offset = 2
                 */
                off = idx % 2 * 2;
                copy_len = ((offset_info->width - len) == 1)? 1 : 2;
                if (len == 0) {
                    off += offset_info->byte_offset;
                    copy_len = 2 - offset_info->byte_offset;
                    if (copy_len > offset_info->width) {
                        copy_len = offset_info->width;
                    }
                }
                sal_memcpy(data+len,
                        (uint8 *)&udf_data[((max_elems - 1)
                            - idx)/2]+off, copy_len);
                sal_memcpy(mask+len,
                        (uint8 *)&udf_mask[((max_elems - 1)
                            - idx)/2]+off, copy_len);
                len += copy_len;
            } else {
                /* Retreive the relevant data and mask from 4 words
                 * (4 * 4 = 16 bytes) of data and mask.
                 * For each index set  a chunk(4 bytes) are read. The way
                 * information is organized is for different index values
                 * data resides in following location.
                 * index = 0 data in 12,13,14,15 - W = 3 offset = 0
                 * index = 1 data in 8,9,10,11   - W = 2 offset = 0
                 * index = 2 data in 4,5,6,7     - W = 1 offset = 0
                 * index = 3 data is 0,1,2,3     - W = 0 offset = 0
                 */
                off = offset_info->byte_offset;
                if (len == 0) {
                    /* first word */
                    copy_len = 4 - off;
                    /* Only one word */
                    if (copy_len > offset_info->width) {
                        copy_len = offset_info->width;
                    }
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx] + off,
                            copy_len);
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx] + off,
                            copy_len);
                    len += copy_len;
                } else if ((len + 4) > offset_info->width) {
                    /* last word */
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx],
                            (offset_info->width - len));
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx],
                            (offset_info->width - len));
                    len += (offset_info->width - len);
                } else {
                    /* others */
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx], 4);
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx], 4);
                    len += 4;
                }
            }
        }

        if ((qid == _bcmFieldQualifyData0) && (udf2_elems != 0)) {
            qid = _bcmFieldQualifyData1;
            max_elems = num_elems;
            min_elems = num_elems/2;
            continue;
        }

        *actual_length = offset_info->width;
        break;

    } while (1);

    FP_UNLOCK(unit);
    UDF_UNLOCK(unit);

    return rv;
}

#endif /* (BCM_TRIUMPH2_SUPPORT) */

#if defined(INCLUDE_L3)
/*
 * Function: _bcm_field_l3_egr_object_ifp_type_get
 *
 * Purpose:
 *     Retrieve the IFP type and resolved next hop index with flags for the
 *     given egress object index.
 *
 * Parameters:
 *      unit       - (IN) Unit number.
 *      nh_index   - (IN) Egress object index.
 *      ifp_type   - (OUT) TRUE or FALSE
 *      nh_flags   - (OUT) Next Hop Flags
 *      nh_ecmp_id - (OUT) Resolved Next Hop Index.
 *
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_field_l3_egr_object_ifp_type_index_get(int unit, bcm_if_t nh_index,
                                                int *ifp_type, uint32 *nh_flags,
                                                int *nh_ecmp_id)
{
    int rv, ct;
    int intf_ct = 0;
    int intf_size = 0;
    bcm_l3_egress_t l3_egr;
    bcm_if_t *intf_arr = NULL;
    int l3_object_ct = 0;
    int ifp_object_ct = 0;
#ifdef BCM_TOMAHAWK_SUPPORT
    int i = 0;
    int total_intf_ct = 0, tmp_intf_ct = 0;
    bcm_if_t *total_intf_arr = NULL;
    int offset = 0;
    int *intf_arr_cnt = NULL;
#endif

    if ((ifp_type == NULL) || (nh_flags == NULL) || (nh_ecmp_id == NULL)) {
       return BCM_E_PARAM;
    }

    /* Get next hop info from Egress Object ID param */
    BCM_IF_ERROR_RETURN(_bcm_field_policy_set_l3_nh_resolve(unit,
                                      nh_index, nh_flags, nh_ecmp_id));

    if (*nh_flags & BCM_L3_MULTIPATH) {

        if (!BCM_XGS3_L3_MPATH_EGRESS_IDX_VALID(unit, nh_index)) {
            nh_index += BCM_XGS3_MPATH_EGRESS_IDX_MIN;
        }

        rv = bcm_xgs3_l3_egress_multipath_get(unit, nh_index,
                                              0, NULL, &intf_ct);
        BCM_IF_ERROR_RETURN(rv);

        _FP_XGS3_ALLOC(intf_arr, (sizeof(bcm_if_t) * intf_ct),
                       "FP: Temp Intf Array");
        if (intf_arr == NULL) {
           return (BCM_E_MEMORY);
        }

        intf_size = intf_ct;
        intf_ct = 0;
        rv = bcm_esw_l3_egress_multipath_get(unit, nh_index,
                                             intf_size,
                                             intf_arr, &intf_ct);
        if (BCM_FAILURE(rv)) {
            sal_free(intf_arr);
            return BCM_E_PARAM;
        }
#ifdef BCM_TOMAHAWK_SUPPORT
        /* In case of Hierarchical ECMP, Overlay groups may contain ECMP
           interfaces as members. In such cases, these ecmp interfaces have to
           be further resolved to get l3 interfaces */
        if (soc_feature(unit, soc_feature_hierarchical_ecmp) &&
            BCM_XGS3_L3_MPATH_EGRESS_IDX_VALID(unit, nh_index)) {

            /* coverity[overrun-local] */
            if ((BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit,
                 nh_index - BCM_XGS3_MPATH_EGRESS_IDX_MIN, BCM_L3_ECMP_OVERLAY))) {
                 _FP_XGS3_ALLOC(intf_arr_cnt, sizeof(bcm_if_t) * intf_ct,
                                             "FP:temp intf arr");
                 /* First get the count of total ECMP interfaces.
                    Go through all interfaces and get the next level interfaces
                    if it is an ECMP interface. If not, add that to array of
                    interfaces Count of ECMP interfaces needs to be maintained
                    as bcm_xgs3_l3_egress_multipath_get returns interfaces only
                    when correct count is passed. */
                 for (i=0; i < intf_ct; i++) {
                    if (!BCM_XGS3_L3_MPATH_EGRESS_IDX_VALID(unit, intf_arr[i])){
                        total_intf_ct += 1;
                        continue;
                    }
                    if ((BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit,
                        intf_arr[i]-BCM_XGS3_MPATH_EGRESS_IDX_MIN,
                        BCM_L3_ECMP_UNDERLAY))) {
                        tmp_intf_ct = 0;
                        nh_index = intf_arr[i];
                        rv = bcm_xgs3_l3_egress_multipath_get(unit, nh_index, 0,
                                                            NULL, &tmp_intf_ct);
                        if (BCM_FAILURE(rv)) {
                            sal_free(intf_arr_cnt);
                            sal_free(intf_arr);
                            return BCM_E_PARAM;
                        }
                        intf_arr_cnt[i] = tmp_intf_ct;
                        total_intf_ct += tmp_intf_ct;
                    } else {
                            sal_free(intf_arr_cnt);
                            sal_free(intf_arr);
                            return BCM_E_PARAM;
                    }
                }
                _FP_XGS3_ALLOC(total_intf_arr, sizeof(bcm_if_t) * total_intf_ct,
                                                        "FP:temp intf arr");
                offset = 0;
                for (i=0; i < intf_ct; i++) {
                    tmp_intf_ct = 0;
                    if (!BCM_XGS3_L3_MPATH_EGRESS_IDX_VALID(unit, intf_arr[i])){
                        sal_memcpy(&total_intf_arr[offset], &intf_arr[i],
                                   sizeof(bcm_if_t));
                        offset += 1;
                        continue;
                    }

                    if ((BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit,
                        intf_arr[i]-BCM_XGS3_MPATH_EGRESS_IDX_MIN, BCM_L3_ECMP_UNDERLAY))) {
                        nh_index = intf_arr[i];
                        rv = bcm_esw_l3_egress_multipath_get(unit, nh_index,
                                intf_arr_cnt[i], &total_intf_arr[offset], &tmp_intf_ct);
                        if (BCM_FAILURE(rv)) {
                            sal_free(intf_arr);
                            sal_free(total_intf_arr);
                            sal_free(intf_arr_cnt);
                            return BCM_E_PARAM;
                        }
                        offset += tmp_intf_ct;
                    }
                }
                sal_free(intf_arr);
                sal_free(intf_arr_cnt);
                intf_arr = total_intf_arr;
                intf_ct = total_intf_ct;

            }
        }
#endif

    } else {

        if (!BCM_XGS3_L3_EGRESS_IDX_VALID(unit, nh_index)) {
            nh_index += BCM_XGS3_EGRESS_IDX_MIN;
        }

        intf_ct = 1;
        _FP_XGS3_ALLOC(intf_arr, (sizeof(bcm_if_t) * intf_ct),
                       "FP: Temp Intf Array");
        if (intf_arr == NULL) {
           return (BCM_E_MEMORY);
        }
        intf_arr[0] = nh_index;
    }

    for (ct = 0; ct < intf_ct; ct++) {
        rv = bcm_esw_l3_egress_get(unit, intf_arr[ct], &l3_egr);
        if (BCM_FAILURE(rv)) {
           sal_free(intf_arr);
           return BCM_E_PARAM;
        }

        if (l3_egr.flags2 & BCM_L3_FLAGS2_FIELD_ONLY) {
           ifp_object_ct++;
        } else {
           l3_object_ct++;
        }
    }

    if (ifp_object_ct && l3_object_ct) {
       sal_free(intf_arr);
       return BCM_E_PARAM;
    }

    if (ifp_object_ct) {
       *ifp_type = TRUE;
    } else {
       *ifp_type = FALSE;
    }

    sal_free(intf_arr);
    return BCM_E_NONE;
}

#endif /* INCLUDE_L3 */

/*
 * Function:
 *     _bcm_field_initialized_status_get
 * Purpose:
 *     Check whether the field module is initialized
 * Parameters:
 *     unit   - BCM device number
 *     status - Reference to the init status.
 *              returns TRUE if initialized
 *                      FALSE if not initialized.
 */
int
_bcm_field_initialized_status_get(int unit, uint8 *status)
{
    if (status == NULL) {
        return BCM_E_PARAM;
    }

    if (!soc_feature(unit, soc_feature_field)) {
        return (BCM_E_UNAVAIL);
    }

    *status = FALSE;
    if (_field_control[unit] != NULL) {
       *status = (TRUE == _field_control[unit]->init) ? TRUE:FALSE;
    }

    return BCM_E_NONE;
}


#ifdef BCM_WARM_BOOT_SUPPORT
int
_field_table_pointers_init(int unit, _field_table_pointers_t *field_tables)
{
    if (NULL == field_tables) {
        return BCM_E_INTERNAL;
    }

    field_tables->fp_global_mask_tcam_buf = NULL;
    field_tables->fp_gm_tcam_x_buf        = NULL;
    field_tables->fp_gm_tcam_y_buf        = NULL;
    field_tables->fp_tcam_buf             = NULL;
    field_tables->fp_tcam_x_buf           = NULL;
    field_tables->fp_tcam_y_buf           = NULL;

    return BCM_E_NONE;
}

/*
 * Function: _field_entry_no_param_actions_scache_sync
 *
 * Purpose:
 *        Sync entry field actions with no params into scache
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Stage Control.
 *     fc         - (IN) Field Control.
 *     f_ent      - (IN) Entry structure.
 *     scache_buf - (OUT) Update Scache buffer.
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _field_entry_no_param_actions_scache_sync(int unit,
                                     _field_stage_t   *stage_fc,
                                     _field_control_t *fc,
                                     _field_entry_t   *f_ent,
                                     uint8 *scache_buf)
{
    _field_action_t  *fa;
    _field_action_bmp_t action_bk_bitmap; /* bit map of actions used for entry */
    int _action = -1;
    int size;
    int copyToCpuZeroParam1 = 0;
    int gport_type = 0;
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
                defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    uint32 PortPrioIntGportVal = 0;
    uint32 YpPortPrioIntGportVal = 0;
    uint32 RpPortPrioIntGportVal = 0;
#endif
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    int ingressGportAction = -1;
    int ingressGportVal = 0;
#endif
    bcm_gport_t ingress_mirror_gport[4] = {0};
    _bcmFieldActionNoParam_t ingress_mirror_actions[] = {
                                    _bcmFieldActionNoParamMirrorIngress,
                                    _bcmFieldActionNoParamMirrorIngress1,
                                    _bcmFieldActionNoParamMirrorIngress2,
                                    _bcmFieldActionNoParamMirrorIngress3};
    bcm_gport_t egress_mirror_gport[4] = {0};
    _bcmFieldActionNoParam_t egress_mirror_actions[] = {
                                    _bcmFieldActionNoParamMirrorEgress,
                                    _bcmFieldActionNoParamMirrorEgress1,
                                    _bcmFieldActionNoParamMirrorEgress2,
                                    _bcmFieldActionNoParamMirrorEgress3};
    uint32 param0 = 0;
    uint8  index = 0;
#if defined(BCM_KATANA_SUPPORT)
    uint32 param1 = 0;
#endif /* BCM_KATANA_SUPPORT */

    if (stage_fc == NULL || fc == NULL || f_ent == NULL || scache_buf == NULL) {
       return BCM_E_PARAM;
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) &&
        (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS) &&
        (stage_fc->stage_id != _BCM_FIELD_STAGE_LOOKUP)) {
        return BCM_E_NONE;
    }

    action_bk_bitmap.w = NULL;
    _FP_XGS3_ALLOC(action_bk_bitmap.w, SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                    "Action No Param Bitmap");

    if (action_bk_bitmap.w == NULL) {
       return BCM_E_MEMORY;
    }

    fa = f_ent->actions;
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
       switch(fa->action) {
         case bcmFieldActionPrioPktAndIntCopy:
         case bcmFieldActionPrioPktAndIntNew:
         case bcmFieldActionPrioPktNew:
         case bcmFieldActionPrioPktAndIntTos:
         case bcmFieldActionPrioPktAndIntCancel:
         case bcmFieldActionPrioPktCopy:
         case bcmFieldActionPrioPktTos:
         case bcmFieldActionPrioPktCancel:
              _action = _bcmFieldActionNoParamPrioPktNoColor;
              break;
         case bcmFieldActionPrioIntCopy:
         case bcmFieldActionPrioIntNew:
         case bcmFieldActionPrioIntTos:
         case bcmFieldActionPrioIntCancel:
              _action = _bcmFieldActionNoParamPrioIntNoColor;
              break;
         case bcmFieldActionCopyToCpu:
         case bcmFieldActionTimeStampToCpu:
              _action = _bcmFieldActionNoParamCopyToCpuNoColor;
              if ((fa->param[0] != 0) && (fa->param[1] == 0)) {
                 copyToCpuZeroParam1 = 1;
              }
              break;
         case bcmFieldActionCopyToCpuCancel:
         case bcmFieldActionSwitchToCpuCancel:
         case bcmFieldActionSwitchToCpuReinstate:
         case bcmFieldActionTimeStampToCpuCancel:
              _action = _bcmFieldActionNoParamCopyToCpuNoColor;
              break;
         case bcmFieldActionRpCopyToCpu:
         case bcmFieldActionRpTimeStampToCpu:
              if ((fa->param[0] != 0) && (fa->param[1] == 0)) {
                 _action = _bcmFieldActionNoParamRpCopyToCpuZeroParam1;
              }
              break;
         case bcmFieldActionYpCopyToCpu:
         case bcmFieldActionYpTimeStampToCpu:
              if ((fa->param[0] != 0) && (fa->param[1] == 0)) {
                 _action = _bcmFieldActionNoParamYpCopyToCpuZeroParam1;
              }
              break;
         case bcmFieldActionGpCopyToCpu:
         case bcmFieldActionGpTimeStampToCpu:
              if ((fa->param[0] != 0) && (fa->param[1] == 0)) {
                 _action = _bcmFieldActionNoParamCopyToCpuZeroParam1;
              }
              break;
         case bcmFieldActionDrop:
         case bcmFieldActionDropCancel:
              _action = _bcmFieldActionNoParamDropNoColor;
              break;
         case bcmFieldActionOamUpMep:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamUpMep;
              break;
         case bcmFieldActionOamTx:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamTx;
              break;
         case bcmFieldActionOamLmepEnable:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamLmepEnable;
              break;
         case bcmFieldActionOamLmEnable:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamLmEnable;
              break;
         case bcmFieldActionOamDmEnable:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamDmEnable;
              break;
         case bcmFieldActionOamLmepMdl:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamLmepMdl;
              break;
         case bcmFieldActionOamLmBasePtr:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamLmBasePtr;
              break;
         case bcmFieldActionOamServicePriMappingPtr:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamServicePriMappingPtr;
              break;
         case bcmFieldActionOamPbbteLookupEnable:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamPbbteLookupEnable;
              break;
         case bcmFieldActionOamLmDmSampleEnable:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamOamLmDmSampleEnable;
              break;
         case bcmFieldActionNewClassId:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamNewClassId;
              break;
         case bcmFieldActionDscpNew:
         case bcmFieldActionDscpCancel:
              _action = _bcmFieldActionNoParamDscpNoColor;
              break;
         case bcmFieldActionInnerVlanPrioNew:
              _action = _bcmFieldActionNoParamInnerVlanPriNewNoColor;
              break;
         case bcmFieldActionOuterVlanPrioNew:
              _action = _bcmFieldActionNoParamOuterVlanPriNewNoColor;
              break;
         case bcmFieldActionInnerVlanCfiNew:
              _action = _bcmFieldActionNoParamInnerVlanCfiNewNoColor;
              break;
         case bcmFieldActionOuterVlanCfiNew:
              _action = _bcmFieldActionNoParamOuterVlanCfiNewNoColor;
              break;
         case bcmFieldActionEcnNew:
              _action = _bcmFieldActionNoParamEcnNewNoColor;
              break;
         case bcmFieldActionRpDropPrecedence:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamRpDropPrecedence;
              break;
         case bcmFieldActionYpDropPrecedence:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamYpDropPrecedence;
              break;
         case bcmFieldActionGpDropPrecedence:
              if (fa->param[0] != 0) {
                 continue;
              }
              _action = _bcmFieldActionNoParamGpDropPrecedence;
              break;
         case bcmFieldActionDropPrecedence:
              _action = _bcmFieldActionNoParamDropPrecedenceNoColor;
              break;
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
         case bcmFieldActionIngressGportSet:
              _action = _bcmFieldActionNoParamIngressGportSet;
              ingressGportAction = 1;
              ingressGportVal = fa->param[0];
              break;
#endif /* INCLUDE_L3 */
         case bcmFieldActionRedirectIpmc:
              if (_BCM_MULTICAST_IS_WLAN(fa->param[0])) {
                  _action = _bcmFieldActionNoParamRedirectIpmcWlan;
              } else if (_BCM_MULTICAST_IS_VPLS(fa->param[0])) {
                  _action = _bcmFieldActionNoParamRedirectIpmcVpls;
              } else if (_BCM_MULTICAST_IS_L3(fa->param[0])) {
                  _action = _bcmFieldActionNoParamRedirectIpmcL3;
              }
              break;
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
         case bcmFieldActionIncomingMplsPortSet:
             _action = _bcmFieldActionNoParamIncomingMplsPortSet;
              ingressGportAction = 1;
              ingressGportVal = fa->param[0];
              break;
#endif /* INCLUDE_L3 */
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
         case bcmFieldActionPortPrioIntCosQNew:
             _action = _bcmFieldActionNoParamPortPrioIntCosQNew;
              PortPrioIntGportVal = fa->param[1];
              break;
         case bcmFieldActionGpPortPrioIntCosQNew:
             _action = _bcmFieldActionNoParamGpPortPrioIntCosQNew;
              PortPrioIntGportVal = fa->param[1];
              break;
         case bcmFieldActionYpPortPrioIntCosQNew:
             _action = _bcmFieldActionNoParamYpPortPrioIntCosQNew;
              YpPortPrioIntGportVal = fa->param[1];
              break;
         case bcmFieldActionRpPortPrioIntCosQNew:
             _action = _bcmFieldActionNoParamRpPortPrioIntCosQNew;
              RpPortPrioIntGportVal = fa->param[1];
              break;
#endif
         case bcmFieldActionMirrorIngress:
             if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_20) {
                if (!BCM_GPORT_IS_MIRROR(fa->param[1])) {
                   continue;
                }

#ifdef BCM_TRIUMPH2_SUPPORT
                if (((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) &&
                        soc_feature(unit, soc_feature_mirror_flexible) &&
                        (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
                    int mtp_type_index;
                    int flexibleMirror;
                    int directedMirror;
                    int rv;

                    rv = bcm_esw_switch_control_get(unit,bcmSwitchFlexibleMirrorDestinations,
                            &flexibleMirror);
                    BCM_IF_ERROR_RETURN(rv);

                    rv = bcm_esw_switch_control_get(unit,bcmSwitchDirectedMirroring,
                            &directedMirror);
                    BCM_IF_ERROR_RETURN(rv);

                    if (flexibleMirror && directedMirror) {
                        mtp_type_index = ((fa->hw_index >> BCM_MIRROR_MTP_FLEX_SLOT_SHIFT)
                                & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
                    } else {
                        mtp_type_index = fa->hw_index;
                    }
                    if ((mtp_type_index >= 4) || (mtp_type_index < 0)) {
                        return (BCM_E_INTERNAL);
                    }
                    _action = ingress_mirror_actions[mtp_type_index];
                    ingress_mirror_gport[mtp_type_index] = fa->param[1];
                } else
#endif
                {
                    _action = _bcmFieldActionNoParamMirrorIngress;
                    ingress_mirror_gport[0] = fa->param[1];
                }
             }
             break;
         case bcmFieldActionMirrorEgress:
             if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_20) {
                if (!BCM_GPORT_IS_MIRROR(fa->param[1])) {
                   continue;
                }
#ifdef BCM_TRIUMPH2_SUPPORT
                if (((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) &&
                        soc_feature(unit, soc_feature_mirror_flexible) &&
                        (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
                    int mtp_type_index;
                    int flexibleMirror;
                    int directedMirror;
                    int rv;

                    rv = bcm_esw_switch_control_get(unit,bcmSwitchFlexibleMirrorDestinations,
                            &flexibleMirror);
                    BCM_IF_ERROR_RETURN(rv);

                    rv = bcm_esw_switch_control_get(unit,bcmSwitchDirectedMirroring,
                            &directedMirror);
                    BCM_IF_ERROR_RETURN(rv);

                    if (flexibleMirror && directedMirror) {
                        mtp_type_index = ((fa->hw_index >> BCM_MIRROR_MTP_FLEX_SLOT_SHIFT)
                                & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
                    } else {
                        mtp_type_index = fa->hw_index;
                    }
                    if ((mtp_type_index >= 4) || (mtp_type_index < 0)) {
                        return (BCM_E_INTERNAL);
                    }
                    _action = egress_mirror_actions[mtp_type_index];
                    egress_mirror_gport[mtp_type_index] = fa->param[1];
                } else
#endif
                {
                    _action = _bcmFieldActionNoParamMirrorEgress;
                    egress_mirror_gport[0] = fa->param[1];
                }
             }
             break;
         case bcmFieldActionRedirDropPrecedence:
              _action = _bcmFieldActionNoParamRedirDropPrecedenceNoColor;
              break;
         case bcmFieldActionFabricQueue:
             _action = _bcmFieldActionNoParamFabricQueue;
             param0 = fa->param[0];
#if defined(BCM_KATANA_SUPPORT)
             if (SOC_IS_KATANAX(unit)) {
                 param1 = fa->param[1];
             }
#endif
             break;
         case bcmFieldActionEnableVlanCheck:
             _action = _bcmFieldActionNoParamEnableVlanCheck;
             break;
         case bcmFieldActionHiGigIntPriNew:
             _action = _bcmFieldActionNoParamHiGigIntPriNew;
             break;
         case bcmFieldActionHiGigDropPrecedenceNew:
             _action = _bcmFieldActionNoParamHiGigDropPrecedenceNew;
             break;
         default:
              continue;
       }
       if (_action != -1) {
          _FP_ACTION_BMP_ADD(action_bk_bitmap, _action);
          _action = -1;
       }
    }

    if (copyToCpuZeroParam1 == 1) {
       _FP_ACTION_BMP_ADD(action_bk_bitmap,
                          _bcmFieldActionNoParamCopyToCpuZeroParam1);
    }

    size = SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount);
    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Writing actions backup bitmap[0x%x] for entry:%d size:%d"
            " @ byte %d.\n\r"), __func__,
            action_bk_bitmap.w[0], f_ent->eid, size, fc->scache_pos));

    /* To avoid endiness issues always sync in mutlple of 4 bytes */
    scache_buf[fc->scache_pos] = action_bk_bitmap.w[0];
    fc->scache_pos++;
    scache_buf[fc->scache_pos] = action_bk_bitmap.w[0] >> 8;
    fc->scache_pos++;
    scache_buf[fc->scache_pos] = action_bk_bitmap.w[0] >> 16;
    fc->scache_pos++;
    scache_buf[fc->scache_pos] = action_bk_bitmap.w[0] >> 24;
    fc->scache_pos++;
    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_19) {
       scache_buf[fc->scache_pos] = action_bk_bitmap.w[1];
       fc->scache_pos++;
       scache_buf[fc->scache_pos] = action_bk_bitmap.w[1] >> 8;
       fc->scache_pos++;
       scache_buf[fc->scache_pos] = action_bk_bitmap.w[1] >> 16;
       fc->scache_pos++;
       scache_buf[fc->scache_pos] = action_bk_bitmap.w[1] >> 24;
       fc->scache_pos++;
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
       /* Sync data only if actions are present */
       if ((SHR_BITGET(action_bk_bitmap.w, _bcmFieldActionNoParamPortPrioIntCosQNew)) ||
           (SHR_BITGET(action_bk_bitmap.w, _bcmFieldActionNoParamGpPortPrioIntCosQNew))) {
           scache_buf[fc->scache_pos] = PortPrioIntGportVal;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = PortPrioIntGportVal >> 8;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = PortPrioIntGportVal >> 16;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = PortPrioIntGportVal >> 24;
           fc->scache_pos++;
       }
       if (SHR_BITGET(action_bk_bitmap.w, _bcmFieldActionNoParamYpPortPrioIntCosQNew)) {
           scache_buf[fc->scache_pos] = YpPortPrioIntGportVal;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = YpPortPrioIntGportVal >> 8;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = YpPortPrioIntGportVal >> 16;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = YpPortPrioIntGportVal >> 24;
           fc->scache_pos++;
       }
       if (SHR_BITGET(action_bk_bitmap.w, _bcmFieldActionNoParamRpPortPrioIntCosQNew)) {
           scache_buf[fc->scache_pos] = RpPortPrioIntGportVal;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = RpPortPrioIntGportVal >> 8;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = RpPortPrioIntGportVal >> 16;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = RpPortPrioIntGportVal >> 24;
           fc->scache_pos++;
       }
#endif
    }  

     _FP_ACTION_BMP_FREE(action_bk_bitmap);
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    if (ingressGportAction == 1) {
        /* Get the source virtual port value */
        if (BCM_GPORT_IS_MPLS_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeMpls;
        } else if (BCM_GPORT_IS_MIM_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeMim;
        } else if (BCM_GPORT_IS_WLAN_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeWlan;
        } else if (BCM_GPORT_IS_TRILL_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeTrill;
        } else if (BCM_GPORT_IS_NIV_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeNiv;
        } else if (BCM_GPORT_IS_VXLAN_PORT(ingressGportVal)) {
            gport_type = _bcmVpTypeVxlan;
        } else {
            return BCM_E_PARAM;
        }
    }
#endif /* INCLUDE_L3 */
    /* Reserve 1-byte to write IngressGportAction Gport Type. */
    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_16) {
        scache_buf[fc->scache_pos] = gport_type;
        fc->scache_pos++;
    }

    /* Reserve 4-bytes each for Ingress and Egress Mirror Gports. */ 
    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_20) {
        for (index = 0 ; index < 4; index++) {
            if (SHR_BITGET(action_bk_bitmap.w, ingress_mirror_actions[index])) {
                scache_buf[fc->scache_pos] = ingress_mirror_gport[index];
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = ingress_mirror_gport[index] >> 8;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = ingress_mirror_gport[index] >> 16;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = ingress_mirror_gport[index] >> 24;
                fc->scache_pos++;
            }
        }
        for (index = 0 ; index < 4; index++) {
            if (SHR_BITGET(action_bk_bitmap.w, egress_mirror_actions[index])) {
                scache_buf[fc->scache_pos] = egress_mirror_gport[index];
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = egress_mirror_gport[index] >> 8;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = egress_mirror_gport[index] >> 16;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = egress_mirror_gport[index] >> 24;
                fc->scache_pos++;
            }
        }
         if ( SHR_BITGET(action_bk_bitmap.w,
                _bcmFieldActionNoParamFabricQueue)) {
           scache_buf[fc->scache_pos] = param0;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = param0 >> 8;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = param0 >> 16;
           fc->scache_pos++;
           scache_buf[fc->scache_pos] = param0 >> 24;
           fc->scache_pos++;
#if defined(BCM_KATANA_SUPPORT)
            if (SOC_IS_KATANAX(unit)) {
                scache_buf[fc->scache_pos] = param1;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = param1 >> 8;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = param1 >> 16;
                fc->scache_pos++;
                scache_buf[fc->scache_pos] = param1 >> 24;
                fc->scache_pos++;
            }
#endif /* BCM_KATANA_SUPPORT*/
        }
    }

    return BCM_E_NONE;
}

int _field_group_slice_sel_get(int unit,
                               _field_group_t *fg,
                               _field_slice_sel_info_t *slice_sels)
{
    int i = 0;
    int parts_count = 0;

    /* Retrieve the parts count for the given group */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                           fg->flags, &parts_count));

    for (i = 0; i < parts_count; i++) {
        if (fg->sel_codes[i].src_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceSrcClassSel);
         }
         if (fg->sel_codes[i].dst_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceDstClassSel);
         }
         if (fg->sel_codes[i].intf_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceIntfClassSel);
         }
         if (fg->sel_codes[i].intf_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceIntfClassSel);
         }
         if (fg->sel_codes[i].ingress_entity_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceIngressEntitySel);
         }
         if (fg->sel_codes[i].src_entity_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceSrcEntitySel);
         }
         if (fg->sel_codes[i].dst_fwd_entity_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceDstFwdEntitySel);
         }
         if (fg->sel_codes[i].fwd_field_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceFwdFieldSel);
         }
         if (fg->sel_codes[i].ttl_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceTtlClassSelect);
         }
         if (fg->sel_codes[i].tos_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceTosClassSelect);
         }
         if (fg->sel_codes[i].tcp_class_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceTcpClassSelect);
         }
         if (fg->sel_codes[i].loopback_type_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceLoopbackTypeSel);
         }
         if (fg->sel_codes[i].ip_header_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceIpHeaderSel);
         }
         if (fg->sel_codes[i].ip6_addr_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceIp6AddrSel);
         }
         if (fg->sel_codes[i].aux_tag_1_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceAuxTag1Sel);
         }
         if (fg->sel_codes[i].aux_tag_2_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceAuxTag2Sel);
         }
         if (fg->sel_codes[i].normalize_ip_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceNormalizeIpSel);
         }
         if (fg->sel_codes[i].normalize_mac_sel != _FP_INVALID_INDEX) {
           _FP_SEL_BMP_ADD(slice_sels->slice_sel[i],
                           _bcmFieldGroupSliceNormalizeMacSel);
         }
    }

    return BCM_E_NONE;

}

int _field_group_slice_sel_set(int unit, _field_group_t *fg,
                               _field_slice_sel_info_t *slice_sels)
{
    int i = 0;
    int parts_count = 0;

    /* Retrieve the parts count for the given group */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                           fg->flags, &parts_count));

    for (i = 0; i < parts_count; i++) {

        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceSrcClassSel) == 0)
        && (_bcmFieldGroupSliceSrcClassSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].src_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceDstClassSel) == 0)
        && (_bcmFieldGroupSliceDstClassSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].dst_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceIntfClassSel) == 0)
        && (_bcmFieldGroupSliceIntfClassSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].intf_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceIngressEntitySel) == 0)
        && (_bcmFieldGroupSliceIngressEntitySel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].ingress_entity_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceSrcEntitySel) == 0)
        && (_bcmFieldGroupSliceSrcEntitySel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].src_entity_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceDstFwdEntitySel) == 0)
        && (_bcmFieldGroupSliceDstFwdEntitySel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].dst_fwd_entity_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceFwdFieldSel) == 0)
        && (_bcmFieldGroupSliceFwdFieldSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].fwd_field_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceTtlClassSelect) == 0)
        && (_bcmFieldGroupSliceTtlClassSelect < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].ttl_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceTosClassSelect) == 0)
        && (_bcmFieldGroupSliceTosClassSelect < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].tos_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceTcpClassSelect) == 0)
        && (_bcmFieldGroupSliceTcpClassSelect < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].tcp_class_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceLoopbackTypeSel) == 0)
        && (_bcmFieldGroupSliceLoopbackTypeSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].loopback_type_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceIpHeaderSel) == 0)
        && (_bcmFieldGroupSliceIpHeaderSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].ip_header_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceIp6AddrSel) == 0)
        && (_bcmFieldGroupSliceIp6AddrSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].ip6_addr_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceAuxTag1Sel) == 0)
        && (_bcmFieldGroupSliceAuxTag1Sel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].aux_tag_1_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceAuxTag2Sel) == 0)
        && (_bcmFieldGroupSliceAuxTag2Sel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].aux_tag_2_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceNormalizeIpSel) == 0)
        && (_bcmFieldGroupSliceNormalizeIpSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].normalize_ip_sel = _FP_INVALID_INDEX;
        }
        if((_FP_SEL_BMP_TEST(slice_sels->slice_sel[i],
                          _bcmFieldGroupSliceNormalizeMacSel) == 0)
        && (_bcmFieldGroupSliceNormalizeMacSel < slice_sels->slice_sel_count)) {
            fg->sel_codes[i].normalize_mac_sel = _FP_INVALID_INDEX;
        }
    }

    return BCM_E_NONE;

}


/* Function: _field_group_slice_selectors_sync
 *
 * Purpose:
 *        Sync the hint id associated with the group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     uint8     - (IN) Scache_ptr
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _field_group_slice_selectors_sync (int unit, uint8 *scache_ptr,
                                       _field_stage_id_t stage_id)
{
    _field_control_t    *fc;             /* Field control structure. */
    _field_group_t      *fg;             /* Field group info.        */
    _field_slice_sel_info_t slice_sels;  /* Field Group Slice selectors */
    int idx = 0;
    int parts_count = 0;

    if (scache_ptr == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    fg = fc->groups;
    if (NULL == fg) {
        return (BCM_E_NONE);
    }

    for (; fg != NULL; fg = fg->next) {
        if (stage_id == fg->stage_id) {
            /* Retrieve the parts count for the given group */
            BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                                           fg->stage_id,
                                           fg->flags, &parts_count));

            for (idx = 0; idx < parts_count; idx++) {
                slice_sels.slice_sel[idx].w = NULL;
                _FP_XGS3_ALLOC(slice_sels.slice_sel[idx].w,
                               SHR_BITALLOCSIZE(_bcmFieldGroupSliceCount),
                               "Group Slice Selectors Bitmap");
                if (slice_sels.slice_sel[idx].w == NULL) {
                   int index;
                   for (index = 0; index < idx; index++) {
                      _FP_SEL_BMP_FREE(slice_sels.slice_sel[index]);
                   }
                   return BCM_E_MEMORY;
                }
            }
            _field_group_slice_sel_get(unit, fg,
                                       &slice_sels);
            slice_sels.gid = fg->gid;
            slice_sels.slice_sel_count = _bcmFieldGroupSliceCount;

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Writing gid[%d] @ byte %d.\n\r"), __func__,
            slice_sels.gid, fc->scache_pos));
            sal_memcpy (scache_ptr, &(slice_sels.gid),
                    sizeof(bcm_field_group_t));
            fc->scache_pos += sizeof (bcm_field_group_t);
            scache_ptr += sizeof (bcm_field_group_t);

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Writing slice_sel_count[%d] @ byte %d.\n\r"), __func__,
            slice_sels.slice_sel_count, fc->scache_pos));
            sal_memcpy (scache_ptr, &(slice_sels.slice_sel_count),
                    sizeof(slice_sels.slice_sel_count));
            fc->scache_pos += sizeof (slice_sels.slice_sel_count);
            scache_ptr += sizeof (slice_sels.slice_sel_count);


            for (idx = 0; idx < parts_count; idx++) {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "%s(): Writing selector bitmap[0x%x] group:%d part:%d"
                  " @ byte %d.\n\r"), __func__,
                 slice_sels.slice_sel[idx].w[0], fg->gid, idx, fc->scache_pos));

                sal_memcpy (scache_ptr, slice_sels.slice_sel[idx].w,
                        sizeof(_field_selector_bmp_t));
                fc->scache_pos += sizeof (_field_selector_bmp_t);
                scache_ptr += sizeof (_field_selector_bmp_t);

                _FP_SEL_BMP_FREE(slice_sels.slice_sel[idx]);
            }
        }
    }

    return BCM_E_NONE;
}

/* Function: _field_group_slice_selectors_recover
 *
 * Purpose:
 *        Sync the hint id associated with the group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     uint8     - (IN) Scache_ptr
 * Returns:
 *      BCM_E_XXXX.
 *
 */
int _field_group_slice_selectors_recover (int unit, uint8 *scache_ptr,
                                          _field_stage_id_t stage_id)
{
    _field_control_t    *fc;             /* Field control structure. */
    _field_group_t      *fg;             /* Field group info.        */
    _field_slice_sel_info_t slice_sels;  /* Field Group Slice selectors */
    int idx = 0, grp_idx = 0;
    int group_count = 0;
    int rv = 0;
    int parts_count = 0;

    if (scache_ptr == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    fg = fc->groups;
    if (NULL == fg) {
        return (BCM_E_NONE);
    }

    for (; fg != NULL; fg = fg->next) {
        if (stage_id == fg->stage_id) {
            group_count++;
        }
    }

    if (group_count == 0) {
        return (BCM_E_NONE);
    }

    fg = NULL;
    for (grp_idx = 0; grp_idx < group_count; grp_idx++) {
        sal_memcpy (&(slice_sels.gid), scache_ptr,
                    sizeof (bcm_field_group_t));
        fc->scache_pos += sizeof (bcm_field_group_t);
        scache_ptr += sizeof (bcm_field_group_t);

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Recovering gid[%d] @ byte %d.\n\r"), __func__,
            slice_sels.gid, (fc->scache_pos - 4)));

        sal_memcpy (&(slice_sels.slice_sel_count), scache_ptr,
                    sizeof (slice_sels.slice_sel_count));
        fc->scache_pos += sizeof (slice_sels.slice_sel_count);
        scache_ptr += sizeof (slice_sels.slice_sel_count);

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Recovering slice_sel_count[%d] @ byte %d.\n\r"), __func__,
            slice_sels.slice_sel_count, (fc->scache_pos - 1)));

        rv = _field_group_get(unit, slice_sels.gid, &fg);
        if (BCM_FAILURE(rv)) {
            return rv;
        }

        /* Retrieve the parts count for the given group */
        rv = _bcm_field_entry_tcam_parts_count(unit,
                                           fg->stage_id,
                                           fg->flags, &parts_count);
        if (BCM_FAILURE(rv)) {
            return rv;
        }

        sal_memset(slice_sels.slice_sel, 0x0,
                   sizeof(_field_selector_bmp_t) * _FP_MAX_ENTRY_WIDTH);

        for (idx = 0; idx < parts_count; idx++) {
            slice_sels.slice_sel[idx].w = NULL;
            _FP_XGS3_ALLOC(slice_sels.slice_sel[idx].w,
                           SHR_BITALLOCSIZE(slice_sels.slice_sel_count),
                           "Group Slice Selectors Bitmap");
            if (slice_sels.slice_sel[idx].w == NULL) {
               rv = BCM_E_MEMORY;
               goto cleanup;
            }

            sal_memcpy (slice_sels.slice_sel[idx].w, scache_ptr,
                    sizeof(_field_selector_bmp_t));
            fc->scache_pos += sizeof (_field_selector_bmp_t);
            scache_ptr += sizeof (_field_selector_bmp_t);

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "%s(): Recovering selectors bitmap[0x%x] for group:%d part:%d"
            " @ byte %d.\n\r"), __func__,
            slice_sels.slice_sel[idx].w[0], fg->gid, idx,
            (fc->scache_pos - 4)));
        }

        _field_group_slice_sel_set(unit, fg,
                                   &slice_sels);
        for (idx = 0; idx < parts_count; idx++) {
            if (slice_sels.slice_sel[idx].w != NULL) {
                _FP_SEL_BMP_FREE(slice_sels.slice_sel[idx]);
                slice_sels.slice_sel[idx].w = NULL;
            }
        }
    }

cleanup:
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
         if (slice_sels.slice_sel[idx].w != NULL) {
             _FP_SEL_BMP_FREE(slice_sels.slice_sel[idx]);
         }
    }
    return rv;
}


#endif



/*
 * Function: _field_dump_brief
 *
 * Purpose:
 *     Show current S/W state if compiled in debug mode without entries.
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     BCM_E_XXX.
 */

int
_field_dump_brief(int unit, const char *pfx)
{
    int                 idx;
    _field_group_t      *fg;
    _field_range_t      *fr;
    _field_stage_t      *stage_fc;
    _field_control_t    *fc;
    int                  rv = 0;
    int                  entry_ratio;  /* Invalid entries ratio. */


    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    stage_fc = fc->stages;


    LOG_CLI((BSL_META_U(unit,
                        "%s:\tunit %d:\n"), pfx, unit));

    while(stage_fc) {

        entry_ratio = (stage_fc->flags & _FP_STAGE_QUARTER_SLICE) ? 4:
            ((stage_fc->flags & _FP_STAGE_HALF_SLICE) ? 2 : 1);

        switch (stage_fc->stage_id) {
            case _BCM_FIELD_STAGE_INGRESS:
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE INGRESS\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                          pfx, stage_fc->tcam_sz/entry_ratio,
                          stage_fc->tcam_sz/entry_ratio));
              break;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
          case _BCM_FIELD_STAGE_LOOKUP:
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE LOOKUP\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                          pfx, stage_fc->tcam_sz/entry_ratio,
                          stage_fc->tcam_sz/entry_ratio));
              break;
          case _BCM_FIELD_STAGE_EGRESS:
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE EGRESS\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                          pfx, stage_fc->tcam_sz/entry_ratio,
                          stage_fc->tcam_sz/entry_ratio));
              break;
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
          case _BCM_FIELD_STAGE_EXTERNAL:
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE EXTERNAL\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                          pfx, stage_fc->tcam_sz, stage_fc->tcam_sz));
              break;
          default:
              break;
        }

        LOG_CLI((BSL_META_U(unit,
                            " tcam_slices=%d,"), stage_fc->tcam_slices));
        LOG_CLI((BSL_META_U(unit,
                            " tcam_ext_numb=%d,"), fc->tcam_ext_numb));
        LOG_CLI((BSL_META_U(unit,
                            "\n")));

        /* Display any range checkers defined. */
        if ((_BCM_FIELD_STAGE_INGRESS  == stage_fc->stage_id) ||
            (_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id)) {
            for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
                _field_range_dump(pfx, fr);
            }
        }
        stage_fc = stage_fc->next;
    }
    /* Print the any defined UDFs. */
    for (idx = 0; idx < BCM_FIELD_USER_NUM_UDFS; idx++) {
        if (fc->udf[idx].valid) {
        LOG_CLI((BSL_META_U(unit,
                            "%s:\tudf %d: use_count=%d, udf_num=%s, user_num=%d\n"),
                 pfx, idx, fc->udf[idx].use_count,
                 _field_qual_name(fc->udf[idx].udf_num + _bcmFieldQualifyData0),
                 fc->udf[idx].user_num));
        }
    }

    /* Print the groups, along with their entries. */
    for (fg = fc->groups; fg != NULL ; fg = fg->next) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
            /* Don't dump Class Group in 'fp show brief' command */
            continue;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        _field_group_dump_brief(unit, fg->gid);
    }

    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            _bcm_trx_field_egr_ports_recovery_print (unit);
        }
#endif
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: _field_dump_class
 * Purpose:
 *  Show current S/W state for class.
 * Parameters:
 *  unit - BCM device number
 *  pfx - Character string to prefix output lines.
 *  flag - Flag to control class display.
 * Returns:
 *  BCM_E_XXX.
 * Notes:
 *  If flag is -1 it dumps class group and entries as well.
 *  Otherwise it dumps brief class table summary.
 */
int
_field_dump_class(int unit, const char *pfx, int flag)
{
     int rv = BCM_E_NONE;
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_group_t      *fg = NULL;
    _field_stage_t      *stage_fc = NULL;
    _field_control_t    *fc = NULL;

    /* Retreive Field Control. */

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    stage_fc = fc->stages;

    LOG_CLI((BSL_META_U(unit,
             "%s:\tunit %d:"), pfx, unit));

    /* Retreive Field Stage Class Control */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_CLASS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    LOG_CLI((BSL_META_U(unit,
                    "PIPELINE STAGE CLASS\n")));
    _bcm_field_th_class_stage_dump(unit,stage_fc);

    /* Dump groups and entries if flag is -1. */
    if (flag == -1) {
        /* Print the groups, along with their entries. */
        for (fg = fc->groups; fg != NULL ; fg = fg->next) {
            if (fg->stage_id == _BCM_FIELD_STAGE_CLASS) {
                /* Dump Group only if it is stage class */
                _bcm_esw_field_group_dump(unit, fg->gid, -1);
            }
        }
    }

    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}


/*
 * Function: _field_group_dump_brief
 *
 * Purpose:
 *     Show contents of a field group without the entries.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group to dump
 *
 * Returns:
 *     Nothing.
 */
int
_field_group_dump_brief(int unit, bcm_field_group_t group)
{
    _field_stage_t      *stage_fc;
    _field_group_t      *fg;
    int                 enable = 0;
    int                 parts_count = 0;
    int                 idx;
    char                buf[100];
    int                 rv;


    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
        rv = _bcm_field_th_class_group_brief_dump(unit,fg);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
        (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,
                            "Quad wide intra-slice group, ")));
    } else if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
               (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,
                            "Intra-slice double wide group, ")));
    }
    LOG_CLI((BSL_META_U(unit,
                        "GID %10d: gid=0x%x, mode=%s, stage=%s "), group,
             fg->gid, _field_group_mode_name(fg->flags),
             _field_stage_name(stage_fc)));
    bcm_esw_field_group_enable_get(unit, group, &enable);
    if (enable) {
        LOG_CLI((BSL_META_U(unit,
                            "lookup=Enabled, ")));
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "lookup=Disabled, ")));
    }

    LOG_CLI((BSL_META_U(unit,
                        "ActionResId={%d}, "), fg->action_res_id));
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                        "VMAP={%d %d %d}, "),
                 fg->vmap_group[0], fg->vmap_group[1], fg->vmap_group[2]));

    LOG_CLI((BSL_META_U(unit,
                        "pbmp={%s}\n"), SOC_PBMP_FMT(fg->pbmp, buf)));

    _field_qset_dump("         qset=", fg->qset, ",\n");

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (fg->flags & _FP_GROUP_PRESELECTOR_SUPPORT)) {
       uint8              not_first = 0;

       LOG_CLI((BSL_META_U(unit,
                    "         preselectors={")));
       for (idx = 0; idx < _FP_PRESEL_ENTRIES_MAX_PER_GROUP; idx++) {
           if (fg->presel_ent_arr[idx] != NULL) {
              if (not_first) {
                 LOG_CLI((BSL_META_U(unit, ", ")));
              }
              LOG_CLI((BSL_META_U(unit, "%d"), fg->presel_ent_arr[idx]->presel_id));
              not_first = 1;
           }
       }
       LOG_CLI((BSL_META_U(unit, "}\n\r")));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (fg->hintid != 0) {
        LOG_CLI((BSL_META_U(unit,
                        "         HintId=%d\n"), fg->hintid));
    }

    for (idx = 0; idx < parts_count; idx++) {
        sal_sprintf(buf, "         selcodes[%d]=\n", idx);
        _field_selcode_dump(unit, buf, fg->sel_codes + idx,  ", ", fg->stage_id);
        _field_qual_list_dump(" ",fg, idx,",\n");

    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    /* Print the primary slice data. */
    LOG_CLI((BSL_META_U(unit,
                        "         slice_pri= %d "), fg->priority));
    _field_slice_dump(unit, "   ", fg, &fg->slices[0], "\n");

    /* Print the secondary slice data. */
    if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,"         slice_sec = {slice_number=%d}\n"),
                            fg->slices[1].slice_number));
    }

    /* Print the tertiary slice data. */
    if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        LOG_CLI((BSL_META_U(unit,"         slice_ter = {slice_number=%d}\n"),
                            fg->slices[2].slice_number));
    }

#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        /* Get TH IFP group's status. */
        rv = _bcm_field_th_group_status_calc(unit, fg);
    } else
#endif /* !BCM_TOMAHAWK_SUPPORT */
    {
        /* Update the numbers of free entries, meters and counters. */
        rv = _bcm_field_group_status_calc(unit, fg);
    }

    /* Print group used resources status */
    if (BCM_SUCCESS(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "         group_status=")));
        _field_group_status_dump(&fg->group_status);
        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_presel_dump
 *
 * Purpose:
 *     Show current S/W state for Preselectors
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     BCM_E_XXX.
 */

int
_bcm_field_presel_dump(int unit, bcm_field_presel_t presel_id, int stage)
{
     int rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_action_t           *fa;
    _field_presel_entry_t     *f_presel;
    bcm_field_presel_t        presel;
    _field_control_t          *fc;

    /* Preselector feature check */
    if (!soc_feature(unit, soc_feature_field_preselector_support)) {
       return BCM_E_UNAVAIL;
    }

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    for (presel = 0; presel < BCM_FIELD_PRESEL_SEL_MAX; presel++) {

       if ((presel_id != -1) && (presel != presel_id)) {
          continue;
       }

        /* Check if presel ID present in presel_set */
       if (!BCM_FIELD_PRESEL_TEST(fc->presel_info->presel_set, presel)) {
          continue;
       }

       /* Retrieve the Presel Entry */
       rv = _bcm_field_presel_entry_get(unit, presel, &f_presel);
       if (BCM_FAILURE(rv)) {
           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "ERROR: Couldn't retrieve the Preselector Entry for the given"
              " Presel ID[%d].\n\r"), presel));
           FP_UNLOCK(unit);
           return rv;
       }


       if (BCM_FIELD_QSET_TEST(f_presel->p_qset, bcmFieldQualifyStage)) {
           if (BCM_FIELD_QSET_TEST(f_presel->p_qset, bcmFieldQualifyStageIngress)) {
               if ((-1 != stage) &&
                   (_BCM_FIELD_STAGE_INGRESS != stage)) {
                   continue;
               }
               LOG_CLI((BSL_META_U(unit,
                               "PRESEL ID:  %d, eid=0x%x, priority=%d, hw_index=%d\n\r"), presel,
                           (presel | BCM_FIELD_QUALIFY_PRESEL), f_presel->priority,
                           f_presel->hw_index));
               LOG_CLI((BSL_META_U(unit, "\tStage:%s"), "Ingress, "));
           } else {
               if ((-1 != stage) &&
                       (_BCM_FIELD_STAGE_EXACTMATCH != stage)) {
                   continue;
               }
               LOG_CLI((BSL_META_U(unit,
                               "PRESEL ID:  %d, eid=0x%x, priority=%d, hw_index=%d\n\r"), presel,
                           (presel | BCM_FIELD_QUALIFY_PRESEL), f_presel->priority,
                           f_presel->hw_index));
               LOG_CLI((BSL_META_U(unit, "\tStage:%s"), "IngressExactMatch, "));
           }
           LOG_CLI((BSL_META_U(unit, " Status:")));
           if (!(f_presel->flags & _FP_ENTRY_INSTALLED)) {
              LOG_CLI((BSL_META_U(unit,
                              "Not installed")));
           } else {
              LOG_CLI((BSL_META_U(unit,
                              "Installed")));

              if (!(f_presel->flags & _FP_ENTRY_ENABLED)) {
                 LOG_CLI((BSL_META_U(unit,
                                  ", Disabled")));
              } else {
                 LOG_CLI((BSL_META_U(unit,
                                ", Enabled")));
              }

              if (f_presel->flags & _FP_ENTRY_DIRTY) {
                  LOG_CLI((BSL_META_U(unit,
                                 ", Dirty")));
              }
           }
           LOG_CLI((BSL_META_U(unit, "\n\r")));
       } else {
           LOG_CLI((BSL_META_U(unit,
                              "\tNot Configured\n\r")));
           LOG_CLI((BSL_META_U(unit, "\n\r")));
           continue;
       }

       _field_qset_dump("\tQualifiers=", f_presel->p_qset, ",\n\r");

       _bcm_field_presel_qualifiers_dump(unit, presel);

       LOG_CLI((BSL_META_U(unit, "\n\r")));
       fa = f_presel->actions;
       while (fa != NULL) {
            LOG_CLI((BSL_META_U(unit,
                                "\taction=")));
            _field_action_dump (fa);
            LOG_CLI((BSL_META_U(unit,
                                "\n\r")));
            fa = fa->next;
       }

       if (presel_id != -1) {
          break;
       }
       LOG_CLI((BSL_META_U(unit, "\n\r")));
    }

    FP_UNLOCK(unit);
    rv = BCM_E_NONE;
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function: _field_calc_cache_size
 *
 * Purpose:
 *     Show Scache size for FP for current configuration
 *
 * Parameters:
 *     unit - BCM device number
 *
 * Returns:
 *     BCM_E_XXX.
 */

int
_field_calc_cache_size(int unit)
{

#ifdef BCM_WARM_BOOT_SUPPORT
#ifdef BCM_TOMAHAWK_SUPPORT

   _field_control_t *fc = NULL;       /* Field control Structure */
   _field_stage_t *stage_fc = NULL;   /* Field Stage Structure */
   uint32 final_pos = 0;              /* Final Scache size */

   BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

   fc->scache_pos = 0;
   wb_write_disable = 1;

   BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                _BCM_FIELD_STAGE_INGRESS,
                                                &stage_fc));

   BCM_IF_ERROR_RETURN(_bcm_field_th_stage_ingress_sync(unit,
                                                        stage_fc));
   /* End Header */
   fc->scache_pos = fc->scache_pos + 4;

   BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                _BCM_FIELD_STAGE_CLASS,
                                                &stage_fc));
   /* Start Header */
   fc->scache_pos = fc->scache_pos + 5;

   BCM_IF_ERROR_RETURN(_bcm_field_th_stage_class_sync(unit, fc, stage_fc));

   /* End Header */
   fc->scache_pos = fc->scache_pos + 5;

   BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                _BCM_FIELD_STAGE_EXACTMATCH,
                                                &stage_fc));

   BCM_IF_ERROR_RETURN(_bcm_field_th_stage_em_sync(unit, fc, stage_fc));

   /* End Header */
   fc->scache_pos = fc->scache_pos + 5;

                               /* size for IFP */
   final_pos = (((fc->scache_pos + 1023) / 1024) * 1024)
               + (294 * 1024)  /* Size for EFP,VFP partition 0 */
               + (20 *1024);   /* Size for EFP,VFP partition 1 */

   LOG_CLI((BSL_META("Scache size for Field Module : %d \n"), final_pos));
   wb_write_disable = 0;
   fc->scache_pos = 0;

#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* BCM_TOMAHAWK_SUPPORT */

   return BCM_E_NONE;
}

#ifdef BCM_WARM_BOOT_SUPPORT

/*
 * Function: _field_scache_pointer_realloc
 *
 * Purpose:
 *     Initialize field component scache pointers and scache sizes for
 *     multiple partitions.
 * Parameters:
 *     unit - BCM device number
 *     fc   - Field Control Structure
 *
 * Returns:
 *     BCM_E_XXX.
 */


static int
_field_scache_pointer_realloc(int unit, _field_control_t  *fc)
{
    int               stable_size;
    int               rv = BCM_E_NONE;
    uint32            alloc_get;
    soc_scache_handle_t handle;

    if ((NULL != fc->scache_ptr[_FIELD_SCACHE_PART_0]) ||
        (NULL != fc->scache_ptr[_FIELD_SCACHE_PART_1])) {

        SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
        SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD,
                              _FIELD_SCACHE_PART_0);
        if ((stable_size > 0) && !SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)) {
            if (SOC_IS_TRX(unit)) {

                fc->scache_size[_FIELD_SCACHE_PART_0] = 294 * 1024;
                /* Taking all average number into account
                 * (Note:S-Slices , P- Ports and Q - Qualifiers)
                 * IFP - 16S * 48P * 25Q
                 * VFP and EFP - 16S * 25Q
                 */
                fc->scache_size[_FIELD_SCACHE_PART_1] = 20 * 1024;

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
                    /*
                     * OAM => 70 * 1024 ((7 bytes * 8K IFP entries) + (7 bytes * 2K EFP entries))
                     * Policer L1 => 20 * 1024 (4 bytes * 20 slices * 256 entries.)
                     * No Param Actions => 40 * 1024 (4 bytes * 20 slices * 512 entries.)
                     * Slice/Secondary Selectors => 5 * 1024 (2 bytes * 128 ports/groups * 20 Slices.)
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += 135 * 1024;
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_17) {

                    /* For WB sync and recovery of configured policer rates,
                     * syncing only the delta value (diff btw configured and programmed
                     * for ckbits_sec, ckbits_burst, pkbits_sec, pkbits_burst.
                     * Taking 2 bytes for each of the delta,
                     * Required size = Maximum Number of entries * 8 bytes
                     * IFP := 16K * 8  = 128 KB
                     * EFP := 2K  * 8 = 16KB
                     * Total size = 144 KB
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += 144 * 1024;
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
                    /* Sync for SVP DVP type per entry part and
                     * ingress, src entity selcode per group part
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (21 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_19) {
                    /* Sync No Param Actions enum and PortPrioIntCosQNew Actions Gport Values
                     * ((4) Bytes * (16 + 1 + 1)  + ((12) bytes * 16) K entries
                     * in IFP Stage
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (264 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_20) {
                    /* Allocate additional scache to sync IFP action ingress
                     * and egress mirror gport value in no parm actions sync
                     * enums per entry. IngressMirror and EgressMirror GPORT
                     * can be assigned to single entry. Have to allocate (4+4)
                     * bytes per entry.
                     * IFP = (8 bytes * 512 entries * 12 slices).
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (48 * 1024);
                    /*
                     * Scache size is increased by (16 * 4) * 1024 bytes for
                     * all devices and (8 * 4) *1024 * 2 for KT2 devices
                     * to sync and recover the params of fabricQueue action
                     * for all entries of Ingress.
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += (16 * 4 * 1024);
                }

                if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) {
                    /*
                     * Group PBMP is synced with max_groups * size of the pbmp array
                     */
                    fc->scache_size[_FIELD_SCACHE_PART_0] += ((512 * _SHR_PBMP_WORD_MAX * 4) + (16 * 1024 * 12));
                }

            } else {
                /* Allocate a section of the Level 2 Warm Boot
                 * global cache.
                 * Assume 90% of the total stable size - just a heuristic
                 */
                fc->scache_size[_FIELD_SCACHE_PART_0] = (9 * stable_size) / 10;
                fc->scache_size[_FIELD_SCACHE_PART_1] = (1 * stable_size) / 100;
            }

            /* Get the pointer for the Level 2 cache */
            SOC_IF_ERROR_RETURN(soc_scache_ptr_get(unit, handle,
                                    &(fc->scache_ptr[_FIELD_SCACHE_PART_0]),
                                    &alloc_get));
            if (!SOC_WARM_BOOT(unit)) {
                /* Not yet allocated in Cold Boot */
                SOC_IF_ERROR_RETURN
                    (soc_scache_realloc(unit, handle,
                                  (fc->scache_size[_FIELD_SCACHE_PART_0]
                                  - (alloc_get - SOC_WB_SCACHE_CONTROL_SIZE))));
                rv = soc_scache_ptr_get(unit, handle,
                                        &(fc->scache_ptr[_FIELD_SCACHE_PART_0]),
                                        &alloc_get);
            }

            if (BCM_FAILURE(rv)) {
                return rv;
            } else if (alloc_get != fc->scache_size[_FIELD_SCACHE_PART_0] +
                                    SOC_WB_SCACHE_CONTROL_SIZE) {
                   /* Expected size doesn't match retrieved size */
                   /* Scache size is increased by 16*1024 bytes
                    * from version BCM_FIELD_WB_VERSION_1_6.The below check is
                    * for upgrades from lower versions to BCM_FIELD_WB_VERSION_1_6
                    * and above.
                    * Scache size increased by 128 bytes from BCM_FIELD_WB_VERSION_1_8.
                    * with respect to BCM_FIELD_WB_VERSION_1_6
                    */
                    rv = _field_scache_version_size_check(unit, alloc_get,
                                                          (fc->wb_recovered_version),
                                                          fc->scache_size[_FIELD_SCACHE_PART_0] +
                                                          SOC_WB_SCACHE_CONTROL_SIZE,
                                                          (fc->wb_current_version));
                    if (rv != TRUE) {
                        return BCM_E_INTERNAL;
                    }
            } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_0]) {
                return BCM_E_MEMORY;
            }

            SOC_SCACHE_HANDLE_SET(handle, unit, BCM_MODULE_FIELD, 1);
            SOC_SCACHE_MODULE_MAX_PARTITIONS_SET(unit, BCM_MODULE_FIELD, 1);

            /* Get the pointer for the Level 2 cache */
            SOC_IF_ERROR_RETURN(soc_scache_ptr_get(unit, handle,
                                    &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                    &alloc_get));
            if (!SOC_WARM_BOOT(unit)) {
                /*Allocated in Cold Boot */
                SOC_IF_ERROR_RETURN
                    (soc_scache_realloc(unit, handle,
                             (fc->scache_size[_FIELD_SCACHE_PART_1]
                             - (alloc_get - SOC_WB_SCACHE_CONTROL_SIZE))));
                rv = (soc_scache_ptr_get(unit, handle,
                                        &(fc->scache_ptr[_FIELD_SCACHE_PART_1]),
                                        &alloc_get));
            }

            if (BCM_FAILURE(rv)) {
                return rv;
            } else if (alloc_get != fc->scache_size[_FIELD_SCACHE_PART_1] +
                                    SOC_WB_SCACHE_CONTROL_SIZE) {
                /* Expected size doesn't match retrieved size */
                return BCM_E_INTERNAL;
            } else if (NULL == fc->scache_ptr[_FIELD_SCACHE_PART_1]) {
                return BCM_E_MEMORY;
            }

        }
    }
    return rv;
}


/*
 * Function: _bcm_field_wb_downgrade_config_set
 *
 * Purpose:
 *     Field Downgrade Configuration Set
 *
 * Parameters:
 *     unit - BCM device number
 *     warmboot_ver - WarmBoot Version for SDK
 *
 * Returns:
 *     BCM_E_XXX.
 */

int
_bcm_field_wb_downgrade_config_set(int unit, uint32 warmboot_ver) {

    int pos = 0;
    _field_control_t *fc;
    int rv = BCM_E_NONE;
    uint32 prev_version;


    FP_LOCK(unit);

    rv = _field_control_get(unit, &fc);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    prev_version = fc->wb_current_version;

    for (pos = 0; pos < COUNTOF(_field_sdk_warmboot_version); pos++) {
        if (_field_sdk_warmboot_version[pos][0] == warmboot_ver) {
            if (fc->wb_current_version != _field_sdk_warmboot_version[pos][1]) {
                fc->wb_current_version = _field_sdk_warmboot_version[pos][1];
                break;
            } else {
                FP_UNLOCK(unit);
                return BCM_E_NONE;
            }
        } else if ((pos > 0) &&
                (_field_sdk_warmboot_version[pos][0] > warmboot_ver) &&
                (_field_sdk_warmboot_version[pos - 1][0] < warmboot_ver)) {
            /* As _field_sdk_warmboot_version database will be updated only when a
             * WB change in present in a version. So this database structure will not have
             * all the version number. When a requested version number is in between 2
             * valid versions, use the previous version number. */
            pos--;
            if (fc->wb_current_version != _field_sdk_warmboot_version[pos][1]) {
                fc->wb_current_version = _field_sdk_warmboot_version[pos][1];
                break;
            } else {
                FP_UNLOCK(unit);
                return BCM_E_NONE;
            }
        }
    }

    if (pos == COUNTOF(_field_sdk_warmboot_version)) {
        if (_field_sdk_warmboot_version[pos - 1][0] < warmboot_ver) {
            /* Upgrade case or like to like case */
            if (fc->wb_current_version != _field_sdk_warmboot_version[pos -1][1]) {
                fc->wb_current_version = _field_sdk_warmboot_version[pos - 1][1];
            } else {
                FP_UNLOCK(unit);
                return BCM_E_NONE;
            }
        } else {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "Version invalid for Warmboot Downgrade\n")));
            FP_UNLOCK(unit);
            return BCM_E_PARAM;
        }
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit, "FP(unit %d) Current WB version [0x%x]\n"),
             unit, fc->wb_current_version));

#ifdef BCM_TOMAHAWK_SUPPORT
     if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
         rv = (_bcm_field_scache_th_pointer_realloc(unit, fc));
     } else
#endif
     {
         rv = (_field_scache_pointer_realloc(unit, fc));
     }

    if (BCM_FAILURE(rv)) {
        /* In case of failure, reallocate based on
         * previous version number */
        fc->wb_current_version = prev_version;
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            _bcm_field_scache_th_pointer_realloc(unit, fc);
        } else
#endif
        {
            _field_scache_pointer_realloc(unit, fc);
        }
    }
    FP_UNLOCK(unit);
    return rv;
}

#endif /* BCM_WARM_BOOT_SUPPORT */


/*
 * Function: _bcm_esw_field_init
 *
 * Purpose:
 *    Initialize field module.
 *
 * Parameters:
 *     unit - (IN) BCM device number
 *
 * Returns:
 *     BCM_E_UNIT    - Invalid BCM unit number.
 *     BCM_E_UNAVAIL - Field Processor not on device.
 *     BCM_E_MEMORY  - Allocation failure
 *     BCM_E_XXX     - Error code from bcm_XX_field_init()
 *     BCM_E_NONE    - Success
 */
int
_bcm_esw_field_init(int unit)
{
    int                udf_idx;    /* Iteration index.         */
    int                rv;         /* Operation return value.  */
    int                size;       /* Allocation size.         */
    _field_control_t   *fc = NULL; /* Field control structure. */
#ifdef BCM_WARM_BOOT_SUPPORT
    _field_stage_id_t  stage_id;
    _field_stage_t     *stage_fc = NULL;
#endif /* BCM_WARM_BOOT_SUPPORT */
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;

    /* Make sure the Unit can support this module. */
    if (SOC_IS_SHADOW(unit) || !soc_feature(unit, soc_feature_field)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: No Field Processor available \n"),
                   unit));
        return (BCM_E_UNAVAIL);
    }

    /* Detatch first if it's been previously initialized. */
    if (_field_control[unit] != NULL) {
        _field_control[unit]->init = FALSE;
        rv = bcm_esw_field_detach(unit);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: Module deinit failed.\n"),
                       unit));
            return (rv);
        }
    }

    /* Allocate a bcm_field_control */
    _FP_XGS3_ALLOC(fc, sizeof (_field_control_t), "field_control");
    if (NULL == fc) {
        return (BCM_E_MEMORY);
    }

    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        /* Allocate a _field_egr_ports_recovery_t */
        _FP_XGS3_ALLOC(f_egr_recovery,
                sizeof (_field_egr_ports_recovery_t),
                "field_egr_ports_recovery");
        if (NULL == f_egr_recovery) {
            _field_control_free(unit, fc);
            return (BCM_E_MEMORY);
        }

        /* Allocate a _field_entry_egr_ports_recovery_t */
        _FP_XGS3_ALLOC(f_egr_recovery->entry_recover_egr_ports,
              (sizeof (_field_entry_recover_egr_ports_t *) * SOC_MAX_NUM_PORTS),
                "field_entry_egr_ports_recovery");

        if (NULL == f_egr_recovery->entry_recover_egr_ports) {
            _field_egr_ports_recovery_control_free (unit, f_egr_recovery);
            _field_control_free(unit, fc);
            return (BCM_E_MEMORY);
        }

        _field_egr_ports_recovery[unit] = f_egr_recovery;

        /* Initialize _field_egr_ports_recovery*/
        sal_memset (_field_egr_ports_recovery_lock, 0,
                sizeof (_field_egr_ports_recovery_lock));
    }

#if defined (BCM_TRIUMPH3_SUPPORT)
    if(SOC_IS_TRIUMPH3(unit)) {
        fc->_fp_egr_ifp_mod_fields_size = soc_mem_index_count(unit,EGR_IFP_MOD_FIELDSm);
        size = SHR_BITALLOCSIZE(fc->_fp_egr_ifp_mod_fields_size);
        fc->field_action_l2mod_index_bmp.w = NULL;
        _FP_XGS3_ALLOC(fc->field_action_l2mod_index_bmp.w,
                        size, "L2ModIndexSize Bitmap");
        if (NULL == fc->field_action_l2mod_index_bmp.w) {
            _field_control_free(unit, fc);
            return (BCM_E_MEMORY);
        }
    }
#endif

    /* First check if external FP is present. */

#if defined(BCM_TRIUMPH_SUPPORT)
    if (soc_feature(unit, soc_feature_esm_support)) {
        if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
            if ((SOC_MEM_IS_VALID(unit, EXT_FP_CNTRm)) &&
                (soc_mem_index_count(unit, EXT_FP_CNTRm))
                ) {
                fc->flags |= _FP_EXTERNAL_PRESENT;
            }
        }
    }
#endif /* BCM_TRIUMPH_SUPPORT */

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) && _bcm_field_tr3_external_present(unit)) {
        fc->flags |= _FP_EXTERNAL_PRESENT;
    }
#endif

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) || SOC_IS_BRADLEY(unit)) {
        /*
         * Note:
         * Enable field stat sync with hardware
         * for bcm_field_stat_get()/_getxx() apis.
         */
        fc->flags |= _FP_STAT_SYNC_ENABLE;
    }
#endif

    /*Set field control- Color Independent to TRUE which implies -
     *Packet Redirect and L3SW_CHANGE_L2 field actions are applicable
     *to all packets(Green/Yellow/Red)*/
    fc->flags |= _FP_COLOR_INDEPENDENT;

    /* Allocate Hints lookup hash. */
    _FP_XGS3_ALLOC(fc->hints_hash, _FP_HASH_SZ(fc) * \
                   sizeof(_field_hints_t *), "Hints hash");
    if (NULL == fc->hints_hash) {
        _field_control_free(unit, fc);
        return (BCM_E_MEMORY);
    }
    size = SHR_BITALLOCSIZE(_FP_HINT_ID_MAX);

    _FP_XGS3_ALLOC(fc->hintid_bmp.w, size, "HintIds Bitmap");
    if (NULL == fc->hintid_bmp.w) {
        _field_control_free(unit, fc);
        return (BCM_E_MEMORY);
    }

    /* Allocate policer lookup hash. */
    _FP_XGS3_ALLOC(fc->policer_hash, _FP_HASH_SZ(fc) * \
                   sizeof(_field_policer_t *), "Policer hash");
    if (NULL == fc->policer_hash) {
        _field_control_free(unit, fc);
        return (BCM_E_MEMORY);
    }

    /* Allocate statistics collection lookup hash. */
    _FP_XGS3_ALLOC(fc->stat_hash, _FP_HASH_SZ(fc) * \
                   sizeof(_field_stat_t *), "Stat hash");
    if (NULL == fc->stat_hash) {
        _field_control_free(unit, fc);
        return (BCM_E_MEMORY);
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_field_preselector_support)) {
        /* Allocate memory for preselector lookup database. */
        _FP_XGS3_ALLOC(fc->presel_db, BCM_FIELD_PRESEL_SEL_MAX * \
                sizeof(_field_presel_entry_t *), "Presel db");
        if (NULL == fc->presel_db) {
            _field_control_free(unit, fc);
            return (BCM_E_MEMORY);
        }

        /* Allocate preselector information structure. */
        _FP_XGS3_ALLOC(fc->presel_info, sizeof(_field_presel_info_t),
                "Field Control Presel Info Alloc.");
        if (NULL == fc->presel_info) {
            _field_control_free(unit, fc);
            return (BCM_E_MEMORY);
        }

        /* Update the Preselector Max Limit */
        fc->presel_info->presel_limit = _BCM_FIELD_PRESEL_ID_MAX;
    }

    /* Initialize field control lt table structures. */
    rv =  _field_th_lt_config_init(unit, fc);
    if (BCM_FAILURE(rv)) {
        _field_control_free(unit, fc);
        return rv;
    }
#endif

    /* Allocate user defined qualifiers. */
    _FP_XGS3_ALLOC(fc->udf, BCM_FIELD_USER_NUM_UDFS * \
                   sizeof(_field_udf_t), "Udf table");
    if (NULL == fc->udf) {
        _field_control_free(unit, fc);
        return (BCM_E_MEMORY);
    }

    /* Initialize pipeline stages field control structures. */
    rv = _field_stages_init(unit, fc);
    if (BCM_FAILURE(rv)) {
        _field_control_free(unit, fc);
        return rv;
    }

    /* Initialize fp status structure. */
    fc->stage       = bcmFieldStageDefault;

#ifdef BCM_WARM_BOOT_SUPPORT
    /* Inititalize WB default/Recovered Version */
    fc->wb_current_version = BCM_FIELD_WB_DEFAULT_VERSION;
    fc->wb_recovered_version = 0;
#endif

    if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
        fc->flags |= _FP_INTRASLICE_ENABLE;
    }

    /* Assign the virtual UDFs to the underlying H/W */
    for (udf_idx = 0; udf_idx < BCM_FIELD_USER_NUM_UDFS; udf_idx++) {
        fc->udf[udf_idx].udf_num = udf_idx >> 2;
        fc->udf[udf_idx].user_num = udf_idx & 0x03;
    }

#if defined(BCM_RAPTOR_SUPPORT)
    if (SOC_IS_RAPTOR(unit) || SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        rv = _bcm_field_raptor_init(unit, fc);
    } else
#endif /* BCM_RAPTOR_SUPPORT */

#if defined(BCM_TRIUMPH_SUPPORT)
    if (SOC_IS_TR_VL(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            rv = _bcm_field_th_init(unit, fc);
        } else
#endif /*BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            rv = _bcm_field_td2_init(unit, fc);
        } else
#endif /*BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            rv = _bcm_field_tr3_init(unit, fc);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT)
        if (SOC_IS_TD_TT(unit)) {
            rv = _bcm_field_trident_init(unit, fc);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit)) {
            rv = _bcm_field_tr2_init(unit, fc);
        } else
#endif /* BCM_TRIUMPH2_SUPPORT */
#if defined(BCM_ENDURO_SUPPORT)
        if (SOC_IS_ENDURO(unit)) {
            rv = _bcm_field_en_init(unit, fc);
        } else
#endif /* BCM_ENDURO_SUPPORT */
#if defined(BCM_HURRICANE1_SUPPORT)
        if (SOC_IS_HURRICANE(unit)) {
            rv = _bcm_field_hu_init(unit, fc);
        } else
#endif /* BCM_HURRICANE1_SUPPORT */
#if defined(BCM_HURRICANE2_SUPPORT)
        if (SOC_IS_HURRICANE2(unit)) {
            rv = _bcm_field_hu2_init(unit,fc);
        } else
#endif /* BCM_HURRICANE_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANA(unit)) {
            rv = _bcm_field_katana_init(unit, fc);
        } else
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            rv = _bcm_field_kt2_init(unit, fc);
        } else
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_GREYHOUND(unit)) {
            rv = _bcm_field_gh_init(unit,fc);
        } else
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_HURRICANE3_SUPPORT)
        if (SOC_IS_HURRICANE3(unit)) {
            rv = _bcm_field_hr3_init(unit,fc);
        } else
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            rv = _bcm_field_gh2_init(unit,fc);
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */

        {
            rv = _bcm_field_tr_init(unit, fc);
        }
    } else
#endif /* BCM_TRIUMPH_SUPPORT */

#if defined(BCM_SCORPION_SUPPORT)
    if (SOC_IS_SC_CQ(unit)) {
        rv = _bcm_field_sc_init(unit, fc);
    } else
#endif /* BCM_TRIUMPH_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        rv = _bcm_field_fb_init(unit, fc);
    }
#endif /* BCM_FIREBOLT_SUPPORT */


    /* cleanup on device specific init failure.  */
    if (BCM_FAILURE(rv)) {
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            /* Destroy all CAP stages and its FP instances. */
            fc->stage_func.fp_stages_delete(unit, fc);
        } else {
            _field_stages_destroy(unit, fc);
        }
        _field_control_free(unit, fc);
        return rv;
    }

    /* Initialize supported qset for each stage. */
    _bcm_field_stages_supported_qset_init(unit, fc);

    fc->last_allocated_eid = 0;
    _field_control[unit] = fc;

    /* Register counter collection callback. */
    soc_counter_extra_register(unit, _bcm_esw_fp_counters_collect);

#ifdef BCM_WARM_BOOT_SUPPORT
#ifdef BCM_TOMAHAWK_SUPPORT
     if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
         BCM_IF_ERROR_RETURN(_bcm_field_scache_th_pointer_init(unit, fc));
     } else
#endif
     {
         BCM_IF_ERROR_RETURN(_field_scache_pointer_init(unit, fc));
     }
    /* Construct the _field_stage_t structure based on HW programming
     * in Warm Boot mode */
    if (SOC_WARM_BOOT(unit)) {
        fc->l2warm = (fc->scache_size[_FIELD_SCACHE_PART_0] &&
                      !SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)) ? 1 : 0;

        if (SOC_IS_FIREBOLT(unit) || SOC_IS_HB_GW(unit)) {
            stage_id = _BCM_FIELD_STAGE_INGRESS;

            BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, stage_id,
                &stage_fc));

            rv = _field_fb_stage_reinit(unit, fc, stage_fc);
            if ((rv == BCM_E_INTERNAL) &&
                (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                (fc->l2warm == 0)) {
                /* Stale scache */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE, SOC_STABLE_FIELD, 0));
                /* Clean up generated state and restart as Level 1 */
                BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                rv = _field_fb_stage_reinit(unit, fc, stage_fc);
            }
        } else if (SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
#ifdef BCM_RAVEN_SUPPORT
            stage_id = _BCM_FIELD_STAGE_INGRESS;
            BCM_IF_ERROR_RETURN
                (_field_stage_control_get(unit, stage_id, &stage_fc));
            rv = _field_raven_stage_reinit(unit, fc, stage_fc);
            if ((rv == BCM_E_INTERNAL) &&
                (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                (fc->l2warm == 0)) {
                /* Stale scache */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE, SOC_STABLE_FIELD, 0));
                /* Clean up generated state and restart as Level 1 */
                BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                rv = _field_raven_stage_reinit(unit, fc, stage_fc);
            }
#endif
        } else if (SOC_IS_FIREBOLT2(unit)) {
#ifdef BCM_FIREBOLT2_SUPPORT
            uint8 oldl2warm = 0;
            stage_id = _BCM_FIELD_STAGE_INGRESS;
            BCM_IF_ERROR_RETURN
                (_field_stage_control_get(unit, stage_id, &stage_fc));
            rv = _field_fb2_stage_ingress_reinit(unit, fc, stage_fc);
            if ((rv == BCM_E_INTERNAL) &&
                (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                (fc->l2warm == 0)) {
                /* Stale scache in ingress section */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE, SOC_STABLE_FIELD, 0));
                /* Clean up generated state and restart as Level 1 */
                BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                rv = _field_fb2_stage_ingress_reinit(unit, fc, stage_fc);
            }
            if (BCM_SUCCESS(rv)) {
                stage_id = _BCM_FIELD_STAGE_EGRESS;
                BCM_IF_ERROR_RETURN
                    (_field_stage_control_get(unit, stage_id, &stage_fc));
                oldl2warm = fc->l2warm;
                rv = _field_fb2_stage_egress_reinit(unit, fc, stage_fc);
                if ((rv == BCM_E_INTERNAL) &&
                    (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                    (fc->l2warm == 0) && (oldl2warm != 0)) {
                    /* Stale scache in egress section */
                    SOC_IF_ERROR_RETURN
                        (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                            SOC_STABLE_STALE,
                                            SOC_STABLE_FIELD, 0));
                    /* Clean up generated state and restart as Level 1 */
                    BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                    stage_id = _BCM_FIELD_STAGE_INGRESS;
                    BCM_IF_ERROR_RETURN
                        (_field_stage_control_get(unit, stage_id, &stage_fc));
                    rv = _field_fb2_stage_ingress_reinit(unit, fc, stage_fc);
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EGRESS;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _field_fb2_stage_egress_reinit(unit, fc, stage_fc);
                    }
                }
            }
            if (BCM_SUCCESS(rv)) {
                stage_id = _BCM_FIELD_STAGE_LOOKUP;
                BCM_IF_ERROR_RETURN
                    (_field_stage_control_get(unit, stage_id, &stage_fc));
                oldl2warm = fc->l2warm;
                rv = _field_fb2_stage_lookup_reinit(unit, fc, stage_fc);
                if ((rv == BCM_E_INTERNAL) &&
                    (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                    (fc->l2warm == 0) && (oldl2warm != 0)) {
                    /* Stale scache in lookup section */
                    SOC_IF_ERROR_RETURN
                        (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                            SOC_STABLE_STALE,
                                            SOC_STABLE_FIELD, 0));
                    /* Clean up generated state and restart as Level 1 */
                    BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                    stage_id = _BCM_FIELD_STAGE_INGRESS;
                    BCM_IF_ERROR_RETURN
                        (_field_stage_control_get(unit, stage_id, &stage_fc));
                    rv = _field_fb2_stage_ingress_reinit(unit, fc, stage_fc);
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EGRESS;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _field_fb2_stage_egress_reinit(unit, fc, stage_fc);
                    }
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_LOOKUP;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _field_fb2_stage_lookup_reinit(unit, fc, stage_fc);
                    }
                }
            }
#endif
        } else if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {

#if defined(BCM_TOMAHAWK_SUPPORT)

            uint8 oldl2warm = 0;
            rv = BCM_E_NONE;

            /* Tomahawk supports only level-2 for Warmboot */
            if (fc->l2warm) {
            do {
               stage_id = _BCM_FIELD_STAGE_INGRESS;
               BCM_IF_ERROR_RETURN
                   (_field_stage_control_get(unit, stage_id, &stage_fc));

               if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_9) {
                  rv = _bcm_field_th_stage_ingress_reinit(unit, fc, stage_fc);
               } else {
                  /* To account for start marker */
                  fc->scache_pos += SOC_WB_SCACHE_CONTROL_SIZE;
                  /* To account for end marker */
                  fc->scache_pos += SOC_WB_SCACHE_CONTROL_SIZE;
               }
            } while (0);
            do {
               if (BCM_SUCCESS(rv) &&
                   soc_feature(unit, soc_feature_field_multi_stage)) {
                   stage_id = _BCM_FIELD_STAGE_EGRESS;

                   rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                   if (BCM_FAILURE(rv)) {
                       _bcm_field_th_tlv_recovery_map_free(unit);
                       return rv;
                   }

                   oldl2warm = fc->l2warm;
                   rv = _bcm_field_th_stage_egress_reinit(unit, fc, stage_fc);
                   if ((rv == BCM_E_INTERNAL) &&
                       (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                       (fc->l2warm == 0) && (oldl2warm != 0)) {

                       _bcm_field_th_tlv_recovery_map_free(unit);

                       /* Stale scache in egress section */
                       SOC_IF_ERROR_RETURN
                           (soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_STABLE_ERROR,
                                               SOC_STABLE_STALE,
                                               SOC_STABLE_FIELD, 0));
                       /* Clean up generated state and restart as Level 1 */
                       BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                   }
                }

            } while (0);

            do {
               if (BCM_SUCCESS(rv) &&
                   soc_feature(unit, soc_feature_field_multi_stage)) {

                   stage_id = _BCM_FIELD_STAGE_LOOKUP;

                   rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                   if (BCM_FAILURE(rv)) {
                       _bcm_field_th_tlv_recovery_map_free(unit);
                       return rv;
                   }

                   oldl2warm = fc->l2warm;

                   rv = _bcm_field_th_stage_lookup_reinit(unit, fc, stage_fc);

                   if ((rv == BCM_E_INTERNAL) &&
                       (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                       (fc->l2warm == 0) && (oldl2warm != 0)) {

                       _bcm_field_th_tlv_recovery_map_free(unit);

                       /* Stale scache in lookup section */
                       SOC_IF_ERROR_RETURN
                           (soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_STABLE_ERROR,
                                               SOC_STABLE_STALE,
                                               SOC_STABLE_FIELD, 0));

                       /* Clean up generated state and restart as Level 1 */
                       BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                   }
                }
            } while(0);

            do {
                if (BCM_SUCCESS(rv) &&
                    soc_feature(unit, soc_feature_field_compression)) {
                    stage_id = _BCM_FIELD_STAGE_CLASS;
                    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                   if (BCM_FAILURE(rv)) {
                       _bcm_field_th_tlv_recovery_map_free(unit);
                       return rv;
                   }
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
                         rv = _bcm_field_th_stage_class_reinit(unit,
                                                               fc, stage_fc);
                     }
                }
            } while(0);

            do {
                if (BCM_SUCCESS(rv) &&
                    soc_feature(unit, soc_feature_field_exact_match_support)) {
                    stage_id = _BCM_FIELD_STAGE_EXACTMATCH;
                    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                    if (BCM_FAILURE(rv)) {
                        _bcm_field_th_tlv_recovery_map_free(unit);
                        return rv;
                    }
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
                        rv = _bcm_field_th_stage_em_reinit(unit,
                                                          fc, stage_fc);
                    }
                }
            } while(0);

            _bcm_field_th_tlv_recovery_map_free(unit);

            } else {
                LOG_WARN(BSL_LS_BCM_FP,
                 (BSL_META_U(unit,
                  "Warning: Level-1 not supported for FP Warmboot\n")));
            }
#endif
        } else if (SOC_IS_TRIUMPH(unit)
                   || SOC_IS_VALKYRIE(unit)
                   || SOC_IS_ENDURO(unit)
                   || SOC_IS_TRIUMPH2(unit)
                   || SOC_IS_APOLLO(unit)
                   || SOC_IS_VALKYRIE2(unit)
                   || SOC_IS_SC_CQ(unit) || SOC_IS_HURRICANEX(unit)
                   || SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)
                   || SOC_IS_GREYHOUND(unit)
                   || SOC_IS_GREYHOUND2(unit)
                   ) {
#if defined(BCM_TRX_SUPPORT)
            uint8 oldl2warm = 0;
            stage_id = _BCM_FIELD_STAGE_INGRESS;
            BCM_IF_ERROR_RETURN
                (_field_stage_control_get(unit, stage_id, &stage_fc));
            rv = _field_tr2_stage_ingress_reinit(unit, fc, stage_fc);
            if ((rv == BCM_E_INTERNAL) &&
                (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                (fc->l2warm == 0)) {
                /* Stale scache in ingress section */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE, SOC_STABLE_FIELD, 0));
                /* Clean up generated state and restart as Level 1 */
                BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                rv = _field_tr2_stage_ingress_reinit(unit, fc, stage_fc);
            }
            do {
               if (BCM_SUCCESS(rv)) {
                   stage_id = _BCM_FIELD_STAGE_EGRESS;

#if defined(BCM_HURRICANE1_SUPPORT)
                   /* Egress Stage might not be available for some devices
                      (hurricane) */
                   if (SOC_IS_HURRICANE(unit) ||
                        (!soc_feature(unit, soc_feature_field_multi_stage))) {
                       LOG_VERBOSE(BSL_LS_BCM_FP,
                                   (BSL_META_U(unit,
                                  "\t#Skipping Egress Stage(NotAvailable)\n")));
                       rv = BCM_E_NONE;
                       break;
                   }
#endif /* BCM_HURRICANE1_SUPPORT */
                   rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                   if ((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_UNAVAIL)) {
                        /* Cannot return as LOOKUP+External Stages need to be
                           checked yet */
                        rv = BCM_E_NONE;
                        break;
                   }
                   BCM_IF_ERROR_RETURN(rv);
                   oldl2warm = fc->l2warm;
                   rv = _field_tr2_stage_egress_reinit(unit, fc, stage_fc);
                   if ((rv == BCM_E_INTERNAL) &&
                       (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                       (fc->l2warm == 0) && (oldl2warm != 0)) {
                       /* Stale scache in egress section */
                       SOC_IF_ERROR_RETURN
                           (soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_STABLE_ERROR,
                                               SOC_STABLE_STALE,
                                               SOC_STABLE_FIELD, 0));
                       /* Clean up generated state and restart as Level 1 */
                       BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                       stage_id = _BCM_FIELD_STAGE_INGRESS;
                       BCM_IF_ERROR_RETURN
                         (_field_stage_control_get(unit, stage_id, &stage_fc));
                       rv = _field_tr2_stage_ingress_reinit(unit, fc,
                                                            stage_fc);
                       if (BCM_SUCCESS(rv)) {
                           stage_id = _BCM_FIELD_STAGE_EGRESS;
                           BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                               stage_id, &stage_fc));
                           rv = _field_tr2_stage_egress_reinit(unit, fc,
                                                               stage_fc);
                       }
                   }
               }
            } while (0);
            do {
               if (BCM_SUCCESS(rv)) {
                   stage_id = _BCM_FIELD_STAGE_LOOKUP;
#if defined(BCM_HURRICANE1_SUPPORT)
                   if (SOC_IS_HURRICANE(unit) ||
                        (!soc_feature(unit, soc_feature_field_multi_stage))) {
                       LOG_VERBOSE(BSL_LS_BCM_FP,
                                   (BSL_META_U(unit,
                                               "\t#Skipping Lookup Stage(NotAvailable)\n")));
                       rv = BCM_E_NONE;
                       break;
                   }
#endif /* BCM_HURRICANE1_SUPPORT */
                   rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                   if ((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_UNAVAIL)) {
                        /* Cannot return as External Stages need to be checked*/
                        rv = BCM_E_NONE;
                        break;
                   }
                   BCM_IF_ERROR_RETURN(rv);
                   oldl2warm = fc->l2warm;

#if defined(BCM_TRIDENT2_SUPPORT)
                   if (SOC_IS_TD2_TT2(unit)) {
                       rv = _bcm_field_td2_stage_lookup_reinit(unit, fc, stage_fc);
                   } else
#endif
#if defined(BCM_KATANA2_SUPPORT)
                   if (SOC_IS_KATANA2(unit)) {
                       rv = _field_kt2_stage_lookup_reinit(unit, fc, stage_fc);
                   } else
#endif
                   {
                       rv = _field_tr2_stage_lookup_reinit(unit, fc, stage_fc);
                   }

                   if ((rv == BCM_E_INTERNAL) &&
                       (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                       (fc->l2warm == 0) && (oldl2warm != 0)) {
                       /* Stale scache in lookup section */
                       SOC_IF_ERROR_RETURN
                           (soc_event_generate(unit,
                                               SOC_SWITCH_EVENT_STABLE_ERROR,
                                               SOC_STABLE_STALE,
                                               SOC_STABLE_FIELD, 0));
                       /* Clean up generated state and restart as Level 1 */
                       BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                       stage_id = _BCM_FIELD_STAGE_INGRESS;
                       BCM_IF_ERROR_RETURN
                          (_field_stage_control_get(unit, stage_id, &stage_fc));
                       rv = _field_tr2_stage_ingress_reinit(unit, fc, stage_fc);
                       if (BCM_SUCCESS(rv)) {
                           stage_id = _BCM_FIELD_STAGE_EGRESS;
                           BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                               stage_id, &stage_fc));
                           rv = _field_tr2_stage_egress_reinit(unit, fc,
                                                               stage_fc);
                       }
                       if (BCM_SUCCESS(rv)) {
                           stage_id = _BCM_FIELD_STAGE_LOOKUP;
                           BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                               stage_id, &stage_fc));
#if defined(BCM_TRIDENT2_SUPPORT)
                           if (SOC_IS_TD2_TT2(unit)) {
                               rv = _bcm_field_td2_stage_lookup_reinit(unit, fc, stage_fc);
                           } else
#endif
                           {
                               rv = _field_tr2_stage_lookup_reinit(unit, fc, stage_fc);
                           }
                       }
                   }
               }
            } while(0);
            do {
            if (BCM_SUCCESS(rv) && soc_feature(unit, soc_feature_esm_support)) {
                stage_id = _BCM_FIELD_STAGE_EXTERNAL;
                rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                if (rv == BCM_E_UNAVAIL) {
                    /* External stage supported but not configured => Skip it */

                    rv = BCM_E_NONE;
                    break;
                }
                BCM_IF_ERROR_RETURN(rv);

                oldl2warm = fc->l2warm;
                rv = _field_tr2_stage_external_reinit(unit, fc, stage_fc);
                if ((rv == BCM_E_INTERNAL) &&
                    (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                    (fc->l2warm == 0) && (oldl2warm != 0)) {
                    /* Stale scache in lookup section */
                    SOC_IF_ERROR_RETURN
                        (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                            SOC_STABLE_STALE,
                                            SOC_STABLE_FIELD, 0));
                    /* Clean up generated state and restart as Level 1 */
                    BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                    stage_id = _BCM_FIELD_STAGE_INGRESS;
                    BCM_IF_ERROR_RETURN
                        (_field_stage_control_get(unit, stage_id, &stage_fc));
                    rv = _field_tr2_stage_ingress_reinit(unit, fc, stage_fc);
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EGRESS;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _field_tr2_stage_egress_reinit(unit, fc, stage_fc);
                    }
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_LOOKUP;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
#if defined(BCM_TRIDENT2_SUPPORT)
                        if (SOC_IS_TD2_TT2(unit)) {
                            rv = _bcm_field_td2_stage_lookup_reinit(unit, fc, stage_fc);
                        } else
#endif
                        {
                            rv = _field_tr2_stage_lookup_reinit(unit, fc, stage_fc);
                        }
                    }
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EXTERNAL;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _field_tr2_stage_external_reinit(unit, fc, stage_fc);
                    }
                }
            }
            }while(0);
#endif /* BCM_TRX_SUPPORT */
        } else if (SOC_IS_TRIUMPH3(unit)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
            uint8 oldl2warm = 0;
            stage_id = _BCM_FIELD_STAGE_INGRESS;
            BCM_IF_ERROR_RETURN
                (_field_stage_control_get(unit, stage_id, &stage_fc));
            rv = _bcm_field_tr3_stage_ingress_reinit(unit, fc, stage_fc);
            if ((rv == BCM_E_INTERNAL) &&
                (fc->scache_size[_FIELD_SCACHE_PART_0] > 0)
                && (fc->l2warm == 0)) {
                /* Stale scache in ingress section */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit,
                                        SOC_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE,
                                        SOC_STABLE_FIELD,
                                        0
                                        )
                    );
                /* Clean up generated state and restart as Level 1 */
                BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                rv = _bcm_field_tr3_stage_ingress_reinit(unit, fc, stage_fc);
            }
            do {
                if (BCM_SUCCESS(rv)) {
                    stage_id = _BCM_FIELD_STAGE_EGRESS;
                    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                    if ((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_UNAVAIL)) {
                        /* Cannot return as LOOKUP+External Stages need to be
                         * checked yet.
                         */
                        rv = BCM_E_NONE;
                        break;
                    }
                    BCM_IF_ERROR_RETURN(rv);
                    oldl2warm = fc->l2warm;
                    rv = _field_tr2_stage_egress_reinit(unit, fc, stage_fc);
                    if ((rv == BCM_E_INTERNAL) &&
                        (fc->scache_size[_FIELD_SCACHE_PART_0] > 0)
                        && (fc->l2warm == 0) && (oldl2warm != 0)) {
                        /* Stale scache in egress section */
                        SOC_IF_ERROR_RETURN
                            (soc_event_generate(unit,
                                                SOC_SWITCH_EVENT_STABLE_ERROR,
                                                SOC_STABLE_STALE,
                                                SOC_STABLE_FIELD,
                                                0
                                                )
                            );
                        /* Clean up generated state and restart as Level 1 */
                        BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                        stage_id = _BCM_FIELD_STAGE_INGRESS;
                        BCM_IF_ERROR_RETURN
                            (_field_stage_control_get(unit,
                                                      stage_id,
                                                      &stage_fc)
                            );
                        rv = _field_tr2_stage_ingress_reinit
                                (unit,
                                 fc,
                                 stage_fc
                                 );
                        if (BCM_SUCCESS(rv)) {
                            stage_id = _BCM_FIELD_STAGE_EGRESS;
                            BCM_IF_ERROR_RETURN
                                (_field_stage_control_get(unit,
                                                          stage_id,
                                                          &stage_fc
                                                          )
                                );
                            rv = _field_tr2_stage_egress_reinit(unit,
                                                                fc,
                                                                stage_fc);
                        }
                    }
                }
            } while (0);
            do {
                if (BCM_SUCCESS(rv)) {
                    stage_id = _BCM_FIELD_STAGE_LOOKUP;
                    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                    if ((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_UNAVAIL)) {
                        /* Cannot return as External Stages need to be checked*/
                        rv = BCM_E_NONE;
                        break;
                    }
                    BCM_IF_ERROR_RETURN(rv);
                    oldl2warm = fc->l2warm;
                    rv = _bcm_field_tr3_stage_lookup_reinit(unit, fc, stage_fc);
                    if ((rv == BCM_E_INTERNAL) &&
                        (fc->scache_size[_FIELD_SCACHE_PART_0] > 0)
                        && (fc->l2warm == 0) && (oldl2warm != 0)) {
                        /* Stale scache in lookup section */
                        SOC_IF_ERROR_RETURN
                            (soc_event_generate(unit,
                                                SOC_SWITCH_EVENT_STABLE_ERROR,
                                                SOC_STABLE_STALE,
                                                SOC_STABLE_FIELD, 0
                                                )
                            );
                        /* Clean up generated state and restart as Level 1 */
                        BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                        stage_id = _BCM_FIELD_STAGE_INGRESS;
                        BCM_IF_ERROR_RETURN
                            (_field_stage_control_get(unit,
                                                      stage_id,
                                                      &stage_fc
                                                      )
                            );
                        rv = _bcm_field_tr3_stage_ingress_reinit(unit, fc, stage_fc);
                        if (BCM_SUCCESS(rv)) {
                            stage_id = _BCM_FIELD_STAGE_EGRESS;
                            BCM_IF_ERROR_RETURN
                                (_field_stage_control_get(unit,
                                                          stage_id,
                                                          &stage_fc
                                                          )
                                );
                            rv = _field_tr2_stage_egress_reinit(unit,
                                                                fc,
                                                                stage_fc
                                                                );
                        }
                        if (BCM_SUCCESS(rv)) {
                            stage_id = _BCM_FIELD_STAGE_LOOKUP;
                            BCM_IF_ERROR_RETURN
                                (_field_stage_control_get(unit,
                                                          stage_id,
                                                          &stage_fc
                                                          )
                                );
                            rv = _bcm_field_tr3_stage_lookup_reinit(unit,
                                                                fc,
                                                                stage_fc
                                                                );
                        }
                    }
                }
            } while(0);
            /* Warm boot level 1 and level 2 recovery for TR3 FP ESM */
            do {
            if (BCM_SUCCESS(rv) && soc_feature(unit, soc_feature_esm_support)) {
                stage_id = _BCM_FIELD_STAGE_EXTERNAL;
                rv = _field_stage_control_get(unit, stage_id, &stage_fc);
                if (rv == BCM_E_UNAVAIL) {
                    /* External stage supported but not configured => Skip it */
                    rv = BCM_E_NONE;
                    break;
                }
                BCM_IF_ERROR_RETURN(rv);

                oldl2warm = fc->l2warm;
                rv = _bcm_field_tr3_stage_external_reinit(unit, fc, stage_fc);
                if ((rv == BCM_E_INTERNAL) &&
                    (fc->scache_size[_FIELD_SCACHE_PART_0] > 0) &&
                    (fc->l2warm == 0) && (oldl2warm != 0)) {
                    /* Stale scache in lookup section */
                    SOC_IF_ERROR_RETURN
                        (soc_event_generate(unit, SOC_SWITCH_EVENT_STABLE_ERROR,
                                            SOC_STABLE_STALE,
                                            SOC_STABLE_FIELD, 0));
                    /* Clean up generated state and restart as Level 1 */
                    BCM_IF_ERROR_RETURN(_field_state_cleanup(unit, fc));
                    stage_id = _BCM_FIELD_STAGE_INGRESS;
                    BCM_IF_ERROR_RETURN
                        (_field_stage_control_get(unit, stage_id, &stage_fc));
                    rv = _bcm_field_tr3_stage_ingress_reinit(unit, fc, stage_fc);
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EGRESS;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _bcm_field_tr3_stage_egress_reinit(unit, fc, stage_fc);
                    }
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_LOOKUP;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _bcm_field_tr3_stage_lookup_reinit(unit, fc, stage_fc);
                    }
                    if (BCM_SUCCESS(rv)) {
                        stage_id = _BCM_FIELD_STAGE_EXTERNAL;
                        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                            stage_id, &stage_fc));
                        rv = _bcm_field_tr3_stage_external_reinit(unit, fc, stage_fc);
                    }
                }
            }
            } while(0);
#endif
        }

        if (BCM_FAILURE(rv)) {
            _field_stage_delete(unit, fc, stage_fc);
            return (rv);
        }

        /* During Warm Boot upgrade partitions not existed in previous code
           version but need to be existed , must be created now */

        if (fc->l2warm) {
#ifdef BCM_TOMAHAWK_SUPPORT
            if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
                BCM_IF_ERROR_RETURN(_bcm_field_scache_th_pointer_realloc(unit,
                                                                         fc));
            } else
#endif
            {
                BCM_IF_ERROR_RETURN(_field_scache_pointer_init_wb(unit, fc));
            }

        }
    }
#endif
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        bcm_esw_linkscan_register(unit, _bcm_field_linkscan_update);
    }

    _field_control[unit]->init = TRUE;

    return (BCM_E_NONE);
}

/*
 * Function: _bcm_esw_field_detach
 *
 * Purpose:
 *     Free resources associated with field module
 *
 * Parameters:
 *     unit - BCM device number
 *
 * Returns:
 *     BCM_E_INIT - BCM Unit not initialized.
 *     BCM_E_XXX  - Error code from bcm_field_group_destroy() or
 *                  bcm_field_entry_destroy_all().
 *     BCM_E_NONE - Success
 */

int
_bcm_esw_field_detach(int unit)
{
    _field_control_t    *fc;
    _field_group_t      *fg;
    int                  rv = BCM_E_NONE;
    int                  id = 0;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_detach()\n"),
               unit));

    FP_LOCK(unit);
    fc = _field_control[unit];
    if (NULL == fc) {
        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }

    /*
     * De-initialize the field module as all
     * the componenets are getting detached
     */
    _field_control[unit]->init = FALSE;

    soc_counter_extra_unregister(unit, _bcm_esw_fp_counters_collect);
    /* Unregister counter collection callback. */


    /* Unregister link scan updates */
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        rv = bcm_esw_linkscan_unregister(unit, _bcm_field_linkscan_update);
        if (rv != BCM_E_NONE) {
            LOG_VERBOSE(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb:Field Module not registered to LinkScan\n"),
               unit));
        }
    }

    /* Destroy all entries in unit. */
    rv = bcm_esw_field_entry_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Destroy all statistics entities. */
    rv = _field_stat_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Destroy all policers. */
    rv = bcm_esw_policer_destroy_all(unit);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Destroy all groups in unit. */
    fg = fc->groups;
    while (fg != NULL) {
        rv = bcm_esw_field_group_destroy(unit, fg->gid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        fg = fc->groups;
    }

    /* Destroy all hints */
    for (id = _FP_HINT_ID_BASE; id < _FP_HINT_ID_MAX; id++) {
        if (_FP_HINTID_BMP_TEST(fc->hintid_bmp, id)) {
            rv = bcm_esw_field_hints_destroy (unit, id);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
    }

    /* Device specific detach */
    if (NULL != fc->functions.fp_detach) {
        rv = fc->functions.fp_detach(unit, fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Invoke tomahawk stage delete routine.*/
        rv = fc->stage_func.fp_stages_delete(unit, fc);
    } else {
        /* Destroy a Unit's stages*/
        rv = _field_stages_destroy(unit, fc);
    }
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#if defined (BCM_APACHE_SUPPORT)
    if (SOC_IS_APACHE(unit)) {
        rv = bcm_esw_field_sat_macsa_delete_all(unit);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif

    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);
        _field_egr_ports_recovery_control_free (unit, f_egr_recovery);
    }

    _field_control_free(unit, fc);
    FP_UNLOCK(unit);

    return (BCM_E_NONE);
}

#if defined(BCM_TRX_SUPPORT)

/*
 * Function: _bcm_field_flex_port_detach
 *
 * Purpose:
 *    Detached Flexed ports from Field Group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     port  - Port to be cleared
 *
 * Returns:
 *     BCM_E_XXX  - Error code from _bcm_field_pfs_entry_clear() or
 *                  _field_control_get().
 */

int 
_bcm_field_flex_port_detach(int unit, bcm_port_t port)
{
    _field_control_t        *fc = NULL;
    _field_group_t          *fg = NULL;
    int                     rv = BCM_E_NONE;

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    fg = fc->groups;
    while (fg != NULL) {
           if ((fg->flags & _FP_GROUP_PER_PORT_OR_PBMP)) {
              if (BCM_PBMP_MEMBER(fg->pbmp,port)) {
                   rv = _bcm_field_pfs_entry_clear(unit,
                                                   fg, port);
                   if (BCM_FAILURE(rv)) {
                       goto cleanup;
                   }
              }
           } else {
               if(BCM_PBMP_MEMBER(fg->pbmp, port)) {
                   BCM_PBMP_PORT_REMOVE(fg->pbmp, port);
                   BCM_PBMP_PORT_REMOVE(fg->slices[0].pbmp, port);
               }

           }
           fg = fg->next;
    } 

cleanup:
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: _bcm_field_flex_port_attach
 *
 * Purpose:
 *    Detached Flexed ports from Field Group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     port  - Port to be cleared
 *
 * Returns:
 *     BCM_E_NONE - Success
 */

int
_bcm_field_flex_port_attach(int unit, bcm_port_t port)
{
    _field_control_t *fc = NULL;
    _field_group_t   *fg = NULL;
    bcm_port_config_t port_config;
    bcm_error_t       rv = BCM_E_NONE;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (!soc_feature(unit, soc_feature_field_multi_pipe_enhanced))) {
        return BCM_E_NONE;
    }
#endif

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    rv = bcm_esw_port_config_get(unit, &port_config);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    for (fg = fc->groups; fg != NULL; fg = fg->next) {
        if (fg->flags & _FP_GROUP_PER_PORT_OR_PBMP) {
            /* Ignore per port based groups*/
            continue;
        }
        BCM_PBMP_PORT_ADD(fg->pbmp, port);
        BCM_PBMP_PORT_ADD(fg->slices[0].pbmp, port);
    }

cleanup:
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: _bcm_field_flex_port_update
 *
 * Purpose:
 *    Routine is invoked after performing flex operation to
 *    update the field module resources.
 *
 * Parameters:
 *     unit  - BCM device number
 *     detached_pbmp  - Ports detached after flex operation.
 *     attached_pbmp  - Ports attached after flex operation.
 *
 * Returns:
 *     BCM_E_xxx
 */

int
_bcm_field_flex_port_update(int unit,
                            bcm_pbmp_t detached_pbmp,
                            bcm_pbmp_t attached_pbmp)
{
    _field_control_t *fc = NULL;
    _field_group_t   *fg = NULL;
    bcm_error_t       rv = BCM_E_NONE;

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (!SOC_IS_TRIDENT2PLUS(unit)) {
       return BCM_E_NONE;
    }
#endif

    /* considering only attached ports */
    if (BCM_PBMP_IS_NULL(attached_pbmp)) {
       return BCM_E_NONE;
    }

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    for (fg = fc->groups; fg != NULL; fg = fg->next) {
        if (fg->flags & _FP_GROUP_PER_PORT_OR_PBMP) {
            /* Ignore per port based groups*/
            continue;
        }
        if (BCM_FIELD_QSET_TEST(fg->qset,
                                 bcmFieldQualifyInPorts)) {
           (void)_bcm_field_group_entry_port_update(unit, fg,
                                                    attached_pbmp);
        }
    }

cleanup:
    FP_UNLOCK(unit);
    return (rv);

}

/*
 * Function: _bcm_esw_field_group_ports_add
 *
 * Purpose:
 *    Add ports to the specified group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     pbmp  - Set of Ports
 *
 * Returns:
 *     BCM_E_XXX  - Error code from _bcm_field_fb_group_install() or
 *                  _field_group_get().
 *     BCM_E_NONE - If ports are already part of the group.
 */

int
_bcm_esw_field_group_ports_add(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    _field_group_t          *fg = NULL;
    bcm_port_t              port;
    int                     rv = BCM_E_NONE;
    bcm_pbmp_t              group_pbmp;
    bcm_pbmp_t              add_pbmp;
    bcm_pbmp_t              valid_pbmp;
    bcm_pbmp_t              temp_pbmp;

    BCM_PBMP_CLEAR(valid_pbmp);

    /* check if the ports are valid */
    rv = _bcm_field_valid_pbmp_get(unit, &valid_pbmp);
    if (BCM_FAILURE(rv)) {
        return rv;
    }

    BCM_PBMP_ASSIGN(temp_pbmp, valid_pbmp);
    BCM_PBMP_OR(temp_pbmp, pbmp);
    if (BCM_PBMP_NEQ(valid_pbmp, temp_pbmp)) {
         return BCM_E_PARAM;
    }

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)){
        return rv;
    }

    if ((fg->flags & _FP_GROUP_PER_PORT_OR_PBMP)) {

        BCM_PBMP_CLEAR(add_pbmp);

        BCM_PBMP_ASSIGN(group_pbmp, fg->pbmp);
        BCM_PBMP_OR(group_pbmp, pbmp);

        if (BCM_PBMP_EQ(group_pbmp, fg->pbmp)) {
            /* Ports are already part of this group */
            return BCM_E_NONE;
        }
        BCM_PBMP_ITER(pbmp, port) {
            if((BCM_PBMP_MEMBER(fg->slices[0].pbmp, port))) {
                if(BCM_PBMP_MEMBER(fg->pbmp,port)) {
                    continue;
                }
                /* Port is part of another group in same slice */
                LOG_DEBUG(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                         "Port is present in another group in same slice\n")));
                return BCM_E_PARAM;
            }
            BCM_PBMP_PORT_ADD(add_pbmp, port);
        }
        BCM_PBMP_OR(fg->pbmp, add_pbmp);
        BCM_PBMP_OR(fg->slices[0].pbmp, add_pbmp);
        rv = _bcm_field_fb_group_install(unit,fg);
        if (BCM_FAILURE(rv)){
            BCM_PBMP_REMOVE(fg->pbmp, add_pbmp);
            BCM_PBMP_REMOVE(fg->slices[0].pbmp, add_pbmp);
        }
    } else {
        rv = BCM_E_PARAM;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Per port or Pbmp base Group is expected \n")));
    }
    return (rv);

}
/*
 * Function: _field_entry_update_ipbm
 *
 * Purpose:
 *    Remove given pbmp from the entry IPBM
 *
 * Parameters:
 *     unit  - BCM device number
 *     f_ent - Field entry structure
 *     pbmp  - Set of Ports
 *
 * Returns:
 *     BCM_E_XXX  - Error code from internal functions
 */
STATIC int
_field_entry_update_ipbm(
      int unit,
      _field_entry_t *f_ent,
      bcm_pbmp_t pbmp)
{
    int                           tcam_idx;
    bcm_error_t                   rv = BCM_E_NONE;
    bcm_error_t                   rv_internal = BCM_E_NONE;
    bcm_pbmp_t                    ipbm;
    bcm_pbmp_t                    ipbm_copy;
    bcm_field_entry_t             backup_entry;
    fp_global_mask_tcam_entry_t   ipbm_entry;

    if (!soc_mem_is_valid(unit, FP_GLOBAL_MASK_TCAMm)) {
           return BCM_E_NONE;
    }

    rv = _bcm_field_entry_tcam_idx_get(unit, f_ent, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    BCM_PBMP_CLEAR(ipbm);
    sal_memset(&ipbm_entry, 0, sizeof(fp_global_mask_tcam_entry_t));

    rv = READ_FP_GLOBAL_MASK_TCAMm(unit, MEM_BLOCK_ANY, tcam_idx,
                                    &ipbm_entry);
    BCM_IF_ERROR_RETURN(rv);

    soc_mem_pbmp_field_get(unit, FP_GLOBAL_MASK_TCAMm, &ipbm_entry, IPBMf,
                           &ipbm);

    BCM_PBMP_ASSIGN(ipbm_copy, ipbm);
    /* Removing pbmp from ipbm. ipbm &= ~pbmp */
    BCM_PBMP_NEGATE(pbmp, pbmp);
    BCM_PBMP_AND(ipbm, pbmp);

    if (BCM_PBMP_EQ(ipbm, ipbm_copy)) {
        /* pbmp is not part of f_ent IPBM. Nothing to be done */
        return BCM_E_NONE;
    }

    rv = _field_internal_backup_entry_create(unit, f_ent->eid,
                                             &backup_entry);
    BCM_IF_ERROR_RETURN(rv);

    soc_mem_pbmp_field_set(unit, FP_GLOBAL_MASK_TCAMm, &ipbm_entry, IPBMf,
                           &ipbm);
    soc_mem_pbmp_field_set(unit, FP_GLOBAL_MASK_TCAMm, &ipbm_entry,
                           IPBM_MASKf, &f_ent->pbmp.mask);
    rv = WRITE_FP_GLOBAL_MASK_TCAMm(unit, MEM_BLOCK_ALL,
                                    tcam_idx, &ipbm_entry);

    rv_internal = _field_internal_backup_entry_delete(unit, backup_entry);
    if (BCM_FAILURE(rv_internal)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Internal backup entry delete failed \n")));
        if (BCM_SUCCESS(rv)) {
            return rv_internal;
        }
    }
    return rv;
}

/*
 * Routine to add newly attached port to the InPorts qualifier of all the
 * group entries in order to avoid the false match.
 * Note: The change affects only if mask parameter of InPorts qualifier
 * configured for all valid ports before flex operation.
 */
STATIC
int _bcm_field_group_entry_port_update(int unit,
                                        _field_group_t *fg,
                                        bcm_pbmp_t new_pbmp)
{
    int                           idx;
    _field_entry_t                *f_ent;
    int                           tcam_idx;
    bcm_error_t                   rv = BCM_E_NONE;
    bcm_error_t                   rv_internal = BCM_E_NONE;
    bcm_field_entry_t             backup_entry;
    bcm_pbmp_t                    valid_full_mask;
    bcm_pbmp_t                    temp_mask;
    fp_global_mask_tcam_entry_t   ipbm_entry;

    /* Retrieve valid pbmp of the device */
    rv = _bcm_field_valid_pbmp_get(unit, &valid_full_mask);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }
    BCM_PBMP_OR(valid_full_mask, PBMP_LB(unit));
    BCM_PBMP_REMOVE(valid_full_mask, new_pbmp);

    for (idx = 0; idx < fg->group_status.entry_count; idx++) {
        f_ent = fg->entry_arr[idx];
        if ((f_ent == NULL) ||
             BCM_PBMP_IS_NULL(f_ent->pbmp.mask)) {
           continue;
        }

        /* Check if entry is already part of new_pbmp */
        BCM_PBMP_ASSIGN(temp_mask, f_ent->pbmp.mask);
        BCM_PBMP_OR(temp_mask, new_pbmp);
        if (BCM_PBMP_EQ(temp_mask, f_ent->pbmp.mask)) {
           continue;
        }

        /* Check if entry pbmp contains all valid ports */
        BCM_PBMP_ASSIGN(temp_mask, f_ent->pbmp.mask);
        BCM_PBMP_AND(temp_mask, valid_full_mask);
        if (BCM_PBMP_EQ(valid_full_mask, temp_mask)) {
           /* Add newly attached ports to the entry mask */
           BCM_PBMP_OR(f_ent->pbmp.mask, new_pbmp);

           rv = _bcm_field_entry_tcam_idx_get(unit, f_ent, &tcam_idx);
           BCM_IF_ERROR_RETURN(rv);

           rv = _field_internal_backup_entry_create(unit, f_ent->eid,
                                             &backup_entry);
           BCM_IF_ERROR_RETURN(rv);

           sal_memset(&ipbm_entry, 0, sizeof(fp_global_mask_tcam_entry_t));
           rv = READ_FP_GLOBAL_MASK_TCAMm(unit, MEM_BLOCK_ANY, tcam_idx,
                                          &ipbm_entry);
           BCM_IF_ERROR_RETURN(rv);
           soc_mem_pbmp_field_set(unit, FP_GLOBAL_MASK_TCAMm, &ipbm_entry, IPBMf,
                                  &f_ent->pbmp.data);
           soc_mem_pbmp_field_set(unit, FP_GLOBAL_MASK_TCAMm, &ipbm_entry,
                                  IPBM_MASKf, &f_ent->pbmp.mask);
           rv = WRITE_FP_GLOBAL_MASK_TCAMm(unit, MEM_BLOCK_ALL,
                                  tcam_idx, &ipbm_entry);

           rv_internal = _field_internal_backup_entry_delete(unit, backup_entry);
           if (BCM_FAILURE(rv_internal)) {
               LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Internal backup entry delete failed \n")));
               if (BCM_SUCCESS(rv)) {
                  return rv_internal;
               }
           }
        }
    }

    return BCM_E_NONE; 
}

/*
 * Function: _bcm_esw_field_group_ports_remove
 *
 * Purpose:
 *    Remove ports from the specified group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     pbmp  - Set of Ports
 *
 * Returns:
 *     BCM_E_XXX  - Error code from _bcm_field_pfs_entry_clear() or
 *                  _field_control_get().
 */

int
_bcm_esw_field_group_ports_remove(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    _field_group_t          *fg = NULL;
    _field_entry_t          **entries = NULL;
    bcm_port_t              port;
    int                     rv = BCM_E_NONE;
    int                     idx;

    rv = _field_group_get(unit, group, &fg);
    BCM_IF_ERROR_RETURN(rv);

    if ((fg->flags & _FP_GROUP_PER_PORT_OR_PBMP)) {
        BCM_PBMP_ITER(pbmp, port) {
            if (BCM_PBMP_MEMBER(fg->pbmp, port)) {
                rv = _bcm_field_pfs_entry_clear(unit,
                                                fg, port);
                BCM_IF_ERROR_RETURN(rv);

             }
        }
        entries = fg->entry_arr;
        for (idx = 0; idx < fg->group_status.entry_count; idx++) {
            rv = _field_entry_update_ipbm(unit, (entries[idx]), pbmp);
            BCM_IF_ERROR_RETURN(rv);
        }
    } else {
        rv = BCM_E_PARAM;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Per port or Pbmp base Group is expected \n")));
    }

    return (rv);
}

int
_bcm_esw_field_class_map_get(
                       int unit,
                       bcm_field_qualify_t qual,
                       uint32 num_entries,
                       uint32 *orig_values_array,
                       uint32 *map_values_array)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32 i = 0;
    ttl_fn_entry_t map_buf;

    soc_mem_t mem = INVALIDm;
    soc_field_t fld = INVALIDf;

    if ((NULL == orig_values_array) ||
        (NULL == map_values_array)) {
        return BCM_E_PARAM;
    }

    switch(qual) {
        case bcmFieldQualifyTtlClassZero :
        case bcmFieldQualifyTtl          :
            mem = TTL_FNm;
            fld = FN0f;
            break;
        case bcmFieldQualifyTtlClassOne  :
            mem = TTL_FNm;
            fld = FN1f;
            break;
        case bcmFieldQualifyTosClassZero  :
        case bcmFieldQualifyTos :
            mem = TOS_FNm;
            fld = FN0f;
            break;
        case bcmFieldQualifyTosClassOne  :
            mem = TOS_FNm;
            fld = FN1f;
            break;
        case bcmFieldQualifyTcpClassZero :
        case bcmFieldQualifyTcpControl :
            mem = TCP_FNm;
            fld = FN0f;
            break;
        case bcmFieldQualifyTcpClassOne  :
            mem = TCP_FNm;
            fld = FN1f;
            break;
        default :
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Field class mapping is "
                                "not applicable for qual %s\n"),
                     unit, _field_qual_name(qual)));
            return BCM_E_UNAVAIL;
    }

    sal_memset(&map_buf, 0, sizeof(ttl_fn_entry_t));
    for (i = 0; i < (num_entries); i++) {
        if ((orig_values_array[i] > soc_mem_index_max(unit, mem)) ||
                (orig_values_array[i] < soc_mem_index_min(unit, mem))) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Original value %d "
                                "is out of range for qual %s \n"),
                     unit,orig_values_array[i], _field_qual_name(qual)));
            return BCM_E_PARAM;
        }
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                                         orig_values_array[i], &map_values_array[i]));
        map_values_array[i] = soc_mem_field32_get(unit, mem, &map_values_array[i], fld);
    }

    return rv;
}

int
_bcm_esw_field_class_map_set(
                       int unit,
                       bcm_field_qualify_t qual,
                       uint32 num_entries,
                       uint32 *orig_values_array,
                       uint32 *map_values_array)
{
    int    rv            = BCM_E_NONE;
    uint32 i             = 0;
    uint32 hw_retain_val = 0;
    uint32 *hw_val_array = NULL;

    soc_mem_t mem = INVALIDm;
    soc_field_t mod_fld = INVALIDf;
    soc_field_t retain_fld = INVALIDf;

    if ((NULL == orig_values_array) ||
        (NULL == map_values_array)) {
        return BCM_E_PARAM;
    }

    switch(qual) {
        case bcmFieldQualifyTtlClassZero :
        case bcmFieldQualifyTtl          :
            mem = TTL_FNm;
            mod_fld = FN0f;
            retain_fld = FN1f;
            break;
        case bcmFieldQualifyTtlClassOne  :
            mem = TTL_FNm;
            mod_fld = FN1f;
            retain_fld = FN0f;
            break;
        case bcmFieldQualifyTosClassZero :
        case bcmFieldQualifyTos          :
            mem = TOS_FNm;
            mod_fld = FN0f;
            retain_fld = FN1f;
            break;
        case bcmFieldQualifyTosClassOne  :
            mem = TOS_FNm;
            mod_fld = FN1f;
            retain_fld = FN0f;
            break;
        case bcmFieldQualifyTcpClassZero :
        case bcmFieldQualifyTcpControl   :
            mem = TCP_FNm;
            mod_fld = FN0f;
            retain_fld = FN1f;
            break;
        case bcmFieldQualifyTcpClassOne  :
            mem = TCP_FNm;
            mod_fld = FN1f;
            retain_fld = FN0f;
            break;
        default :
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Field class mapping is "
                                "not applicable for qual %s\n"),
                     unit, _field_qual_name(qual)));
            return BCM_E_UNAVAIL;
    }

    _FP_XGS3_ALLOC(hw_val_array, num_entries * sizeof(uint32), "Field class Mapping array");
    if (NULL == hw_val_array) {
        return BCM_E_MEMORY;
    }

    for (i = 0; i < (num_entries); i++) {

        if ((orig_values_array[i] > soc_mem_index_max(unit, mem)) ||
                (orig_values_array[i] < soc_mem_index_min(unit, mem))) {

            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Original value %d "
                                "is out of range for qual %s \n"),
                     unit,orig_values_array[i], _field_qual_name(qual)));
            rv = BCM_E_PARAM;
            goto cleanup;
        }

        /*
         * Soc mem write over writes all fields in the memory
         * So retaining the other field (FN0f or FN1f).
         */
        rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                          orig_values_array[i], &hw_retain_val);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
        hw_retain_val = soc_mem_field32_get(unit, mem, &hw_retain_val, retain_fld);
        soc_mem_field32_set(unit, mem, &hw_val_array[i], mod_fld, map_values_array[i]);
        soc_mem_field32_set(unit, mem, &hw_val_array[i], retain_fld, hw_retain_val);
    }

    /* Write to Hardware only after SW operations and error/range checks */
    for (i = 0; i < (num_entries); i++) {
        rv = soc_mem_write(unit, mem, MEM_BLOCK_ALL, orig_values_array[i], &hw_val_array[i]);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
    }

cleanup:
    sal_free(hw_val_array);
    return rv;
}

/*
 * Function: _bcm_field_pfs_entry_clear
 *
 * Purpose:
 *    Remove ports from the specified group's PFS entry
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     port  - Port for PFS clear
 *
 * Returns:
 *     BCM_E_XXX  - Error code from _bcm_field_entry_tcam_parts_count() or
 *                  READ_FP_PORT_FIELD_SELm() or
 *                  _bcm_field_tcam_part_to_slice_number() or
 *                  WRITE_FP_PORT_FIELD_SELm(). 
 */

int _bcm_field_pfs_entry_clear(int unit,
                               _field_group_t *fg,
                               bcm_port_t port) {

    fp_port_field_sel_entry_t   pfs_entry;
    int                         index;
    int                         rv = 0;
    uint8                       slice_numb = -1;
    int                         parts_count = -1;
    int                         idx = -1;

    index = (int)port;

    /* Get number of entry parts for the group. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                                fg->flags, &parts_count);
    
    BCM_IF_ERROR_RETURN(rv);

    /* Read Port's current entry in FP_PORT_FIELD_SEL table */
    rv = READ_FP_PORT_FIELD_SELm(unit, MEM_BLOCK_ALL,
                                 index, &pfs_entry);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < parts_count;  idx++) {

        /* Get slice id for entry part */
        rv = _bcm_field_tcam_part_to_slice_number(unit, idx, fg,
                                                  &slice_numb);
        BCM_IF_ERROR_RETURN(rv);
    
        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][0],
             0
             );
        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][1],
             0
             );
        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][2],
             0
             );
   
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm,
                    _bcm_ifp_normalize_fldtbl[slice_numb][0])) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry,
                    _bcm_ifp_normalize_fldtbl[slice_numb][0], 0);
        }
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm,
                    _bcm_ifp_normalize_fldtbl[slice_numb][1])) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry,
                    _bcm_ifp_normalize_fldtbl[slice_numb][1], 0);
        }
#endif
        if (SOC_MEM_FIELD_VALID(unit,
                 FP_PORT_FIELD_SELm,
                 _bcm_field_trx_d_type_sel[slice_numb])) {
             soc_FP_PORT_FIELD_SELm_field32_set(unit,
                 &pfs_entry,
                 _bcm_field_trx_d_type_sel[slice_numb], 0);
        }
        if (SOC_MEM_FIELD_VALID(unit,
                 FP_PORT_FIELD_SELm,
                 _bcm_field_trx_s_type_sel[slice_numb])) {
             soc_FP_PORT_FIELD_SELm_field32_set(unit,
                 &pfs_entry,
                 _bcm_field_trx_s_type_sel[slice_numb], 0);
        }        
 
     }

    rv = WRITE_FP_PORT_FIELD_SELm(unit, MEM_BLOCK_ALL, index, &pfs_entry);
    BCM_IF_ERROR_RETURN(rv);
    
    BCM_PBMP_PORT_REMOVE(fg->pbmp,port);
    BCM_PBMP_PORT_REMOVE(fg->slices[0].pbmp, port);

    return rv;

}
#endif  /* BCM_TRX_SUPPORT */ 

/* Function: _bcm_esw_field_group_config_create
 *
 * Purpose:
 *     Create a group with a mode (single, double, etc.), a port bitmap,
 *     group size and a Group ID.
 * Parameters:
 *     unit - BCM device number.
 *     group_config - Group create attributes namely:
 *          flags       - (IN) Bits indicate which parameters have been
 *                             passed to API and should be used during group
 *                             creation.
 *          qset        - (IN) Field qualifier set
 *          priority    - (IN) Priority within allowable range,
 *                             or BCM_FIELD_GROUP_PRIO_ANY to automatically
 *                             assign a priority; each priority value may be
 *                             used only once
 *          mode        - (IN) Group mode (single, double, triple or Auto-wide)
 *          ports       - (IN) Ports where group is defined
 *          group       - (IN/OUT) Requested Group ID. If Group ID is not set,
 *                              then API allocates and returns the created
 *                              Group ID.
 *    flags - internal Group Config flags.
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
_bcm_esw_field_group_config_create(int unit,
                                  bcm_field_group_config_t *group_config,
                                  uint32 flags)
{
    bcm_port_config_t  *port_config;/* Device port config structure. */
    _field_group_add_fsm_t *fsm;     /* Group creation state machine. */
    _field_control_t       *fc;     /* Field control structure.      */
    int                    rv;      /* Operation return status.      */
    bcm_pbmp_t             all_pbmp;
    _field_hints_t         *f_ht = NULL;
                                     /* Field hints Structure. */
    _field_hint_t          *hint_list = NULL;
                                     /* Field Hints Structure. */
    bcm_field_hint_t       *hint_entry;
                                     /* Hint Entry.            */


    if (NULL == group_config) {
        return (BCM_E_PARAM);
    }

    fsm = NULL;

    
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
        /* Call Flexible Key Extraction programming function for TH IFP. */
        rv = fc->functions.fp_group_add(unit, group_config);
        return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if passed group configuration is valid for this device */
    if ((0 == soc_feature(unit, soc_feature_field_ingress_two_slice_types))
        && ((group_config->flags & BCM_FIELD_GROUP_CREATE_SMALL)
            || (group_config->flags & BCM_FIELD_GROUP_CREATE_LARGE)
            || group_config->hintid != 0)) {
        return (BCM_E_UNAVAIL);
    }

    /* Read device port configuration. */ 
    port_config = NULL;
    _FP_XGS3_ALLOC(port_config, sizeof(bcm_port_config_t),
                   "Port config info ");
    if (port_config == NULL) {
        rv = BCM_E_MEMORY;
        goto  bcm_error;
    }
    rv = bcm_esw_port_config_get(unit, port_config);
    if (rv < 0) {
        goto bcm_error;
    }
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, port_config->all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        goto bcm_error;
    }
 
    if (!(group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ID)) {
        /* qset and pri are validated in bcm_field_group_create_mode_id(). */
        rv = _bcm_field_group_id_generate(unit, &group_config->group);
        if (BCM_FAILURE(rv)) {
           goto bcm_error;
        }
    }

    /* Initialize group creation tracking structure. */
    _FP_XGS3_ALLOC(fsm, sizeof(_field_group_add_fsm_t),
                   "Group fsm info ");
    if (fsm == NULL) {
        rv = BCM_E_MEMORY;
        goto  bcm_error;
    }

    fsm->fsm_state = _BCM_FP_GROUP_ADD_STATE_START;
    fsm->priority  = group_config->priority;
    fsm->group_id  = group_config->group;
    fsm->qset = group_config->qset;
    fsm->hintid = group_config->hintid;
    fsm->action_res_id     = group_config->action_res_id;

    if (fsm->hintid != 0) {
        if (fsm->hintid >= _FP_HINT_ID_MAX) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "HintId is out of allowed range\r\n")));
            rv = BCM_E_PARAM;
            goto bcm_error;
        }

        if (_FP_HINTID_BMP_TEST(fc->hintid_bmp, fsm->hintid) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "Trying to attach hintid which is"
                                " not created\r\n")));
            rv = BCM_E_NOT_FOUND;
            goto bcm_error;
        }

        rv= _field_hints_control_get (unit, group_config->hintid, &f_ht);
        if ( (BCM_FAILURE(rv)) || (f_ht == NULL) ){
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"Hints are not attached to hintid(%d)."
                                "\r\n"),
                                group_config->hintid));
            rv = BCM_E_NOT_FOUND;
            goto bcm_error;
        }

        if (BCM_FIELD_QSET_TEST(fsm->qset,
                                 bcmFieldQualifyStageExternal)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,"Unsupported hint type attached"
                                  "to hintid(%d).\r\n"),
                                   group_config->hintid));
            rv = BCM_E_PARAM;
            goto bcm_error;
        }

        hint_list = f_ht->hints;
        while (hint_list != NULL) {
            hint_entry = hint_list->hint;
            if (hint_entry != NULL) {
                if ((BCM_FIELD_QSET_TEST(fsm->qset,
                                bcmFieldQualifyStageEgress)) ||
                    (BCM_FIELD_QSET_TEST(fsm->qset,
                                bcmFieldQualifyStageLookup))) {

                    if(!((hint_entry->hint_type ==
                            bcmFieldHintTypeGroupAutoExpansion) &&
                         (hint_entry->flags ==
                            BCM_FIELD_GROUP_MAX_SIZE_HARD_LIMIT) ) ) {
                        LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"Unsupported hint type attached"
                                         "to hintid(%d).\r\n"),
                                          group_config->hintid));
                        rv = BCM_E_PARAM;
                        goto bcm_error; /*error*/
                    }
                }
            }
            hint_list = hint_list->next;
        } /* while (hint_list != NULL) */
    }

    /* Apply group member port configuration */
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PORT) {
        BCM_PBMP_ASSIGN(fsm->pbmp, group_config->ports);
    } else {
        BCM_PBMP_ASSIGN(fsm->pbmp, all_pbmp);
    }

    /* Apply group mode configuration */
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE) {
        fsm->mode = group_config->mode;
    } else {
        fsm->mode = bcmFieldGroupModeDefault;
    }

    /* Apply slice selection configuration */
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_SMALL) {
        fsm->flags |= _BCM_FP_GROUP_ADD_SMALL_SLICE;
    } else if (group_config->flags & BCM_FIELD_GROUP_CREATE_LARGE) {
        fsm->flags |= _BCM_FP_GROUP_ADD_LARGE_SLICE;
    }

    if (flags & _FP_GROUP_CONFIG_VALIDATE) {
        fsm->flags |= _FP_GROUP_CONFIG_VALIDATE;
    }

    /*  Add FP group. */
    rv = _bcm_field_group_add(unit, fsm);

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

bcm_error:
    if (port_config != NULL) {
        sal_free(port_config);
    }
    if (fsm != NULL) {
        sal_free(fsm);
    }
    return (rv);
}



/*
 * Function: _bcm_esw_field_group_config_validate
 *
 * Purpose:
 *     To verify whether a group can be created with a given qset and mode.
 *
 * Parameters:
 *     unit  - BCM device number
 *     gc    - Field group config.
 *     group_mode - Field Group Mode.
 *
 * Returns:
 *     BCM_E_XXX - from _bcm_esw_field_group_config_validate()
 */

int _bcm_esw_field_group_config_validate(
                          int unit,
                          bcm_field_group_config_t *group_config,
                          bcm_field_group_mode_t *group_mode) {

    int rv = BCM_E_NONE;
    _field_group_t *fg = NULL;
    uint32 flags = 0;

    flags |= _FP_GROUP_CONFIG_VALIDATE;
    rv = _bcm_esw_field_group_config_create(unit,group_config, flags);
    if (BCM_SUCCESS(rv)) {

        /* Search the field control for the Group ID. */
        rv = _field_group_get(unit, group_config->group, &fg); 
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
        /* Get  the mode from group */
        rv = _bcm_esw_field_group_mode_get(fg->flags, group_mode);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
        fg->flags |= _FP_GROUP_CONFIG_VALIDATE;
        /* Destroy the group */
        rv = bcm_esw_field_group_destroy(unit, group_config->group);
    }
cleanup:
    return rv;
}

/*
 * Function: _bcm_field_entry_dump
 *
 * Purpose:
 *     Show contents of a field entry.
 *
 * Parameters:
 *     unit  - BCM device number
 *     entry - Field entry to dump
 *
 * Returns:
 *     Nothing.
 */
int
_bcm_esw_field_entry_dump(int unit, bcm_field_entry_t entry, int stage)
{
    int                 parts_count = 0;
    _field_stage_t *stage_fc = NULL;    /* Field Stage Control.      */
    _field_group_t      *fg;
    _field_action_t     *fa;
    _field_entry_t      *f_ent;
    bcm_pbmp_t          pbmp;
    uint8               idx;
    int                 rv;
    char                buf_pbmp[SOC_PBMP_FMT_LEN];
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    bcm_policer_t    policer_id = 0;
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    exact_match_2_entry_t ebuf_nar;  /* Narrow Entry Buffer.        */
    exact_match_4_entry_t ebuf_wide; /* Wide Entry Buffer.          */
    uint32 tbuf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                                     /* Temp Buffer One.            */
    uint32 tbuf_temp[SOC_MAX_MEM_FIELD_WORDS] = {0};
                                     /* Temp Buffer Two.            */
    soc_mem_t mem = INVALIDm;
    int eindex = 0;                  /* Entry Index inn UFT memory. */
    _field_entry_t *f_ent_part = NULL;
    static soc_mem_t em_entry_nar_mem[_FP_MAX_NUM_PIPES] = {
        EXACT_MATCH_2_PIPE0m,
        EXACT_MATCH_2_PIPE1m,
        EXACT_MATCH_2_PIPE2m,
        EXACT_MATCH_2_PIPE3m,
    };
    static soc_mem_t em_entry_wide_mem[_FP_MAX_NUM_PIPES] = {
        EXACT_MATCH_4_PIPE0m,
        EXACT_MATCH_4_PIPE1m,
        EXACT_MATCH_4_PIPE2m,
        EXACT_MATCH_4_PIPE3m,
    };
    uint32 *bufp = NULL;                /* Hardware Buffer Ptr.      */
    uint32 qp_idx = -1;                  /* Qos Actions Profile Index.*/
    uint32 ap_idx = -1;                  /* Actions Profile Index.    */
#endif
    
    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_CLASS == f_ent->group->stage_id)) {
        rv = _bcm_field_th_class_entry_dump(unit,f_ent);
        FP_UNLOCK(unit); 
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    fg = f_ent->group;
    LOG_CLI((BSL_META_U(unit,
                    "EID 0x%08x: gid=0x%x,\n"), f_ent->eid, fg->gid));

    /* Retreive Stage Control. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get number of entry parts. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Display Entry info for multi-pipe supported devices */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
       rv =  _bcm_field_th_entry_phys_dump(unit, f_ent);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
    	  return (rv);
       }
       if  ((-1 != stage) && (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) {
           /* Get Hardware Buffer Pointer and memory identifier. */
           if ((fg->em_mode == _FieldExactMatchMode128) ||
                   (fg->em_mode == _FieldExactMatchMode160)) {
               bufp = (uint32 *)&ebuf_nar;
               if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                   mem = EXACT_MATCH_2m;
               } else {
                   mem = em_entry_nar_mem[fg->instance];
               }
           } else {
               bufp = (uint32 *)&ebuf_wide;
               if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                   mem = EXACT_MATCH_4m;
               } else {
                   mem = em_entry_wide_mem[fg->instance];
               }
           }
           /* Initialize exact match entries. */
           sal_memcpy(bufp, soc_mem_entry_null(unit, mem),
                   soc_mem_entry_words(unit, mem) * sizeof(uint32));

           /* Set Exact Match Entry Search Key. */
           if (fg->em_mode == _FieldExactMatchMode128) {

               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_0f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_1f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, VALID_0f, 1);
               soc_mem_field32_set(unit, mem, bufp, VALID_1f, 1);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 0,
                       EM_MODE128_KEY_PART0_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE128__KEY_0_ONLYf, tbuf);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 
                       EM_MODE128_KEY_PART0_SIZE,
                       EM_MODE128_KEY_PART1_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE128__KEY_1_ONLYf, tbuf);

           } else if (fg->em_mode == _FieldExactMatchMode160) {

               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_0f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_1f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, VALID_0f, 1);
               soc_mem_field32_set(unit, mem, bufp, VALID_1f, 1);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 0, 
                       EM_MODE160_KEY_PART0_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE160__KEY_0_ONLYf, tbuf);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 
                       EM_MODE160_KEY_PART0_SIZE, 
                       EM_MODE160_KEY_PART1_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE160__KEY_1_ONLYf, tbuf);

           } else if (fg->em_mode == _FieldExactMatchMode320) {

               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_0f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_1f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_2f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, KEY_TYPE_3f, fg->em_mode);
               soc_mem_field32_set(unit, mem, bufp, VALID_0f, 1);
               soc_mem_field32_set(unit, mem, bufp, VALID_1f, 1);
               soc_mem_field32_set(unit, mem, bufp, VALID_2f, 1);
               soc_mem_field32_set(unit, mem, bufp, VALID_3f, 1);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 0, 
                       EM_MODE320_KEY_PART0_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE320__KEY_0_ONLYf, tbuf);
               _bcm_field_th_val_get(f_ent->tcam.key_hw, tbuf, 
                       EM_MODE320_KEY_PART0_SIZE, 59);

               /* Key From Second Entry Part. */
               f_ent_part = f_ent + 1;
               _bcm_field_th_val_get(f_ent_part->tcam.key_hw, tbuf_temp, 0, 42);
               _bcm_field_th_val_set(tbuf, tbuf_temp, 59, 42);
               soc_mem_field_set(unit, mem, bufp, MODE320__KEY_1_ONLYf, tbuf);;
               _bcm_field_th_val_get(f_ent_part->tcam.key_hw, tbuf, 42, 
                       EM_MODE320_KEY_PART2_SIZE);
               soc_mem_field_set(unit, mem, bufp, MODE320__KEY_2_ONLYf, tbuf);
               _bcm_field_th_val_get(f_ent_part->tcam.key_hw, tbuf, 143, 17);
               soc_mem_field_set(unit, mem, bufp, MODE320__KEY_3_ONLYf, tbuf);

           }

           rv = soc_mem_search(unit, mem, MEM_BLOCK_ANY, &eindex, bufp, bufp, 0);
           if (BCM_FAILURE(rv)) {
               FP_UNLOCK(unit);
               return (rv);
           }

           /* Get Qos and Action Profile Index Allocated From Entry. */
           if (fg->em_mode == _FieldExactMatchMode128) {
               qp_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE128__QOS_PROFILE_IDf);
               ap_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE128__ACTION_PROFILE_IDf);
           } else if (fg->em_mode == _FieldExactMatchMode160) {
               qp_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE160__QOS_PROFILE_IDf);
               ap_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE160__ACTION_PROFILE_IDf);
           } else if (fg->em_mode == _FieldExactMatchMode320) {
               qp_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE320__QOS_PROFILE_IDf);
               ap_idx = soc_mem_field32_get(unit, mem,
                       bufp, MODE320__ACTION_PROFILE_IDf);
           }
           LOG_CLI((BSL_META_U(unit,
                           "         {Action_profile_idx=%d"), ap_idx));
           LOG_CLI((BSL_META_U(unit,
                           " Qos_action_profile_idx=%d }\n"), qp_idx));
       }
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Dump the primary entry. */
       for(idx = 0; idx < parts_count; idx++) { 
           _field_entry_phys_dump(unit, f_ent + idx, idx);
       }
    }
    /* Display action data */
    for(idx = 0; idx < parts_count; idx++) {
        fa = f_ent[idx].actions;
        while (fa != NULL) {
            LOG_CLI((BSL_META_U(unit,
                                "         action=")));
            if ((fa->action == bcmFieldActionEgressMask) ||
               (fa->action == bcmFieldActionEgressPortsAdd) ||
               (fa->action == bcmFieldActionRedirectPbmp) ||
               (fa->action == bcmFieldActionRedirectBcastPbmp)) {
                rv = bcm_esw_field_action_ports_get (unit, f_ent->eid, fa->action, &pbmp);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                }
                LOG_CLI((BSL_META("{act=%s, pbmp=%s  %s"),
                            _field_action_name(fa->action),SOC_PBMP_FMT(pbmp, buf_pbmp),
                            (fa->flags & _FP_ACTION_DIRTY) ? ", Dirty" : ""));
                if (stage != -1) {
                    LOG_CLI((BSL_META(", ActionFlags=%08x "),
                                fa->flags));
                    if (!(fa->flags & _FP_ACTION_DIRTY)) {
                        LOG_CLI((BSL_META(", Redirection_Profile=%d "),
                                    fa->hw_index));
                    }
                }
                LOG_CLI((BSL_META_U(unit,
                                "}")));

            } else {
                _field_action_dump (fa);
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            fa = fa->next;
        }
    }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)
            || SOC_IS_APACHE(unit)) {
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            if (f_ent->global_meter_policer.pid) {
                policer_id = f_ent->global_meter_policer.pid;
            } 
            LOG_CLI((BSL_META_U(unit,
                                " Global Meter policer=0x%x"), policer_id));
        }
    }
#endif
#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) {
            if (f_ent->global_meter_policer.pid) {
                policer_id = f_ent->global_meter_policer.pid;
            } 
            LOG_CLI((BSL_META_U(unit,
                                " Global Meter policer=%x"), policer_id));
        }
    }
#endif

    /* Display entry's meter. */
    LOG_CLI((BSL_META_U(unit,
                        "         policer=")));
    _field_policers_dump(unit, f_ent);
    LOG_CLI((BSL_META_U(unit,
                        "\n")));

#if defined (BCM_TRIDENT2PLUS_SUPPORT)
    /* Display Oam Stat Actions */
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _field_oam_stat_action_dump (unit, f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    /* Display entry's counter. */
    LOG_CLI((BSL_META_U(unit,
                        "         statistics=")));
    rv = _field_stat_dump(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
    	return (rv);
    }
    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}
/*
 * Function: _bcm_field_group_dump
 *
 * Purpose:
 *     Show contents of a field group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group to dump
 *     stage - -1 for print all groups otherwise stage id
 *
 * Returns:
 *     Nothing.
 */
int
_bcm_esw_field_group_dump(int unit, bcm_field_group_t group, int stage)
{
    _field_stage_t      *stage_fc;
    _field_group_t      *fg;
    int                 enable = 0;
    int                 parts_count = 0;
    int                 idx;
    char                buf[SOC_PBMP_FMT_LEN];
    int                 rv;
    int entry_count;
    int entry_index;
    bcm_field_entry_t *entry_ids;
    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
        rv = _bcm_field_th_class_group_dump(unit,fg);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id, 
                                            fg->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) && 
        (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,
                            "Quad wide intra-slice group, ")));
    } else if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) && 
               (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,"Intra-slice double wide group, ")));
    } 
    LOG_CLI((BSL_META_U(unit,
             "GID %10d: gid=0x%x, instance=%d mode=%s, stage=%s "), group,
             fg->gid, fg->instance, _field_group_mode_name(fg->flags), 
             _field_stage_name(stage_fc)));
    bcm_esw_field_group_enable_get(unit, group, &enable);
    if (enable) {
        LOG_CLI((BSL_META_U(unit,"lookup=Enabled, ")));
    } else {
        LOG_CLI((BSL_META_U(unit,"lookup=Disabled, ")));
    }

    LOG_CLI((BSL_META_U(unit,
                        "ActionResId={%d}, "), fg->action_res_id));
    LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                      "VMAP={%d %d %d}, "),
                      fg->vmap_group[0], fg->vmap_group[1], fg->vmap_group[2]));

    LOG_CLI((BSL_META_U(unit,
                    "pbmp={%s}\n"), SOC_PBMP_FMT(fg->pbmp, buf)));

    _field_qset_dump("         qset=", fg->qset, ",\n");

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id) {
        _field_aset_dump("         aset=", fg->aset, ",\n");
    }

    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (fg->flags & _FP_GROUP_PRESELECTOR_SUPPORT)) {
       uint8              not_first = 0;

       LOG_CLI((BSL_META_U(unit,
                    "         preselectors={")));
       for (idx = 0; idx < _FP_PRESEL_ENTRIES_MAX_PER_GROUP; idx++) {
           if (fg->presel_ent_arr[idx] != NULL) {
              if (not_first) {
                 LOG_CLI((BSL_META_U(unit, ", ")));
              }
              LOG_CLI((BSL_META_U(unit, "%d"), fg->presel_ent_arr[idx]->presel_id));
              not_first = 1;  
           }
       }
       LOG_CLI((BSL_META_U(unit, "}\n\r")));
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (fg->hintid != 0) {
        LOG_CLI((BSL_META_U(unit,"         HintId=%d\n"),fg->hintid));
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        ((_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id) ||
         (_BCM_FIELD_STAGE_INGRESS == fg->stage_id))) {
        /* Lot of values to print. So we will revisit if there are 
         * any debugging requirements. */
        for (idx = 0; ((idx < parts_count) && (1 != parts_count)); idx++) {
            LOG_CLI((BSL_META_U(unit,
                               "         Qualifiers in Part-%d:"), idx));
            _field_qual_list_dump(" ", fg, idx,",\n");
        }
    } else 
#endif
    if ((_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) ||
               (_BCM_FIELD_STAGE_EGRESS == fg->stage_id) ||
               (_BCM_FIELD_STAGE_INGRESS == fg->stage_id)) {
        for (idx = 0; idx < parts_count; idx++) {
            sal_sprintf(buf, "         selcodes[%d]=\n", idx);
            _field_selcode_dump(unit, buf, fg->sel_codes + idx,  ", ", 
                                                         fg->stage_id);
            _field_qual_list_dump(" ",fg, idx,",\n");

        }
    }

    LOG_CLI((BSL_META_U(unit,"\n")));

    /* Print the primary slice data. */
    LOG_CLI((BSL_META_U(unit,"         group_priority= %d\n"), fg->priority));

    LOG_CLI((BSL_META_U(unit,"         slice_primary =")));

    _field_slice_dump(unit, "  ", fg, &fg->slices[0], "\n");
    
    /* Print the secondary slice data. */
    if ((fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
        (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE)) {
        LOG_CLI((BSL_META_U(unit,"         slice_secondary = {slice_number=%d}\n"),
                            fg->slices[1].slice_number));
    }

    /* Print the tertiary slice data. */
    if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        LOG_CLI((BSL_META_U(unit,"         slice_ternary = {slice_number=%d}\n"),
                            fg->slices[2].slice_number));
                                
    }
#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        /* Get TH IFP group's status. */
        rv = _bcm_field_th_group_status_calc(unit, fg);
    } else
#endif /* !BCM_TOMAHAWK_SUPPORT */
    {
        /* Update the numbers of free entries, meters and counters. */
        rv = _bcm_field_group_status_calc(unit, fg);
    }

    /* Print group used resources status */
    if (BCM_SUCCESS(rv)) {
        LOG_CLI((BSL_META_U(unit,"         group_status=")));
        _field_group_status_dump(&fg->group_status);
        LOG_CLI((BSL_META_U(unit,"\n")));
    }

#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if ((soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (-1 != stage)) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        for (idx = 0; idx < parts_count; idx++) {
            LOG_CLI((BSL_META_U(unit,
                            "Keygen_profile%d=%u\n"), fg->instance,
                        fg->ext_codes[idx].keygen_index));
        }
    }
#endif /* !BCM_TOMAHAWK_SUPPORT */

    /* Print group's entries */
    rv = bcm_esw_field_entry_multi_get(unit, group, 0, NULL, &entry_count);

    if (BCM_SUCCESS(rv))
    {
        entry_ids = sal_alloc(entry_count * sizeof (bcm_field_entry_t),
            "Entry ID array");

        if (entry_ids == NULL)
        {
            rv = BCM_E_MEMORY;
        }
        else
        {
            rv = bcm_esw_field_entry_multi_get(unit, group, entry_count,
                entry_ids, &entry_count);

            if (BCM_SUCCESS(rv))
            {
                for (entry_index = 0; entry_index < entry_count;
                    ++entry_index)
                {
                    _bcm_esw_field_entry_dump(unit, entry_ids[entry_index], stage);
                }
            }

            sal_free(entry_ids);
        }
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE); 
}
/*
 * Function: bcm_field_show
 *
 * Purpose:
 *     Show current S/W state if compiled in debug mode.
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     Nothing.
 */
int
_bcm_esw_field_show(int unit, const char *pfx, int stage)
{
    _field_group_t      *fg;
    _field_stage_t      *stage_fc;
    _field_control_t    *fc;
    int                  entry_ratio;  /* Invalid entries ratio. */
    int                  rv = 0;
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    stage_fc = fc->stages;

    LOG_CLI((BSL_META_U(unit,
                        "%s:\tunit %d:\n"), pfx, unit));

    while(stage_fc) {

        if ((stage != -1) &&
                (stage != stage_fc->stage_id)) {
            stage_fc = stage_fc->next;
            continue;
        }
        entry_ratio = (stage_fc->flags & _FP_STAGE_QUARTER_SLICE) ? 4:
            ((stage_fc->flags & _FP_STAGE_HALF_SLICE) ? 2 : 1);

        switch (stage_fc->stage_id) {
          case _BCM_FIELD_STAGE_INGRESS: 
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE INGRESS\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                 pfx, stage_fc->tcam_sz/entry_ratio,
                      stage_fc->tcam_sz/entry_ratio));
              break;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
          case _BCM_FIELD_STAGE_LOOKUP: 
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE LOOKUP\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                 pfx, stage_fc->tcam_sz/entry_ratio,
                      stage_fc->tcam_sz/entry_ratio));
              break;
          case _BCM_FIELD_STAGE_EGRESS: 
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE EGRESS\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                 pfx, stage_fc->tcam_sz/entry_ratio,
                      stage_fc->tcam_sz/entry_ratio));
              break; 
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
          case _BCM_FIELD_STAGE_EXTERNAL:
              LOG_CLI((BSL_META_U(unit,
                                  "PIPELINE STAGE EXTERNAL\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                 pfx, stage_fc->tcam_sz, stage_fc->tcam_sz));
              break;
#ifdef BCM_TOMAHAWK_SUPPORT
          case _BCM_FIELD_STAGE_EXACTMATCH:
              LOG_CLI((BSL_META_U(unit,
                              "PIPELINE STAGE EXACTMATCH\n")));
              LOG_CLI((BSL_META_U(unit,
                              "%s:\t      :tcam_sz=%d(%#x),"),
                          pfx, stage_fc->tcam_sz, stage_fc->tcam_sz));
              break;
#endif
          default: 
              break;
        }

        /* Skip for Stage Class alone. */
        if (stage_fc->stage_id != _BCM_FIELD_STAGE_CLASS) {
            LOG_CLI((BSL_META_U(unit,
                        " tcam_slices=%d,"), stage_fc->tcam_slices));
            LOG_CLI((BSL_META_U(unit,
                        " tcam_ext_numb=%d,"), fc->tcam_ext_numb));
            LOG_CLI((BSL_META_U(unit,
                        "\n")));
        }

#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_field_preselector_support) &&
           (stage_fc->stage_id == stage)) {
            _bcm_field_presel_dump(unit, -1, stage);
        }
        if ((-1 != stage) && (stage_fc->stage_id == _BCM_FIELD_STAGE_CLASS)) {
            _field_dump_class(unit, pfx, -1);
        }
#endif
        stage_fc = stage_fc->next;

    }
    
    /* Print the groups, along with their entries. */
    for (fg = fc->groups; fg != NULL ; fg = fg->next) {
        if ((stage != -1) &&
                (stage != fg->stage_id)) {
            continue;
        }
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
            /* Don't dump Class Group in 'fp show' command */
            continue;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        _bcm_esw_field_group_dump(unit, fg->gid, stage);
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}
/*
 * Function: _bcm_esw_field_range_show
 *
 * Purpose:
 *     Show current S/W state of field range if compiled in debug mode.
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     Nothing.
 */
int 
_bcm_esw_field_range_show(int unit, const char *pfx, int stage)
{
    int                 rv = BCM_E_NONE;
    _field_range_t      *fr;
    _field_stage_t      *stage_fc;
    _field_control_t    *fc;

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    stage_fc = fc->stages;

    while(stage_fc) {
        /* Display any range checkers defined. */
        if ((_BCM_FIELD_STAGE_INGRESS  == stage_fc->stage_id) ||
           ((_BCM_FIELD_STAGE_EXTERNAL == stage_fc->stage_id) && (stage == -1))){
            for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
                _field_range_dump(pfx, fr);
            }
        }
        stage_fc = stage_fc->next;
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}
/*
 * Function: _bcm_esw_field_udf_show
 *
 * Purpose:
 *     Show current S/W state of field range if compiled in debug mode.
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     Nothing.
 */
int 
_bcm_esw_field_udf_show(int unit, const char *pfx)
{
    _field_control_t    *fc;
    int                 idx = 0;
    int                 rv = BCM_E_NONE;

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    /* Print the any defined UDFs. */
    for (idx = 0; idx < BCM_FIELD_USER_NUM_UDFS; idx++) {
        if (fc->udf[idx].valid) {
        LOG_CLI((BSL_META_U(unit,
                            "%s:\tudf %d: use_count=%d, udf_num=%s, user_num=%d\n"),
                 pfx, idx, fc->udf[idx].use_count,
                 _field_qual_name(fc->udf[idx].udf_num + _bcmFieldQualifyData0),
                 fc->udf[idx].user_num));
        }
    }
    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

#endif  /* BCM_FIELD_SUPPORT */
#endif  /* BCM_ESW_SUPPORT */

