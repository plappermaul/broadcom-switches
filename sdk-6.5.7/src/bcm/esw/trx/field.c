/* $Id: field.c,v 1.484 $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * File:        field.c
 * Purpose:     BCM56624 Field Processor installation functions.
 */
#include <shared/bsl.h>

#include <soc/defs.h>
#if defined(BCM_TRX_SUPPORT) && defined(BCM_FIELD_SUPPORT)

#include <soc/drv.h>
#include <soc/scache.h>
#include <bcm/error.h>
#include <bcm/l3.h>
#include <bcm/field.h>
#include <bcm/mirror.h>
#include <bcm/tunnel.h>
#include <bcm_int/common/field.h>
#include <bcm_int/esw/field.h>
#include <bcm_int/esw/l3.h>
#include <bcm_int/esw/firebolt.h>
#include <bcm_int/esw/trx.h>
#include <bcm_int/esw/triumph.h>
#include <bcm_int/esw/triumph3.h>
#include <bcm_int/esw/triumph2.h>
#include <bcm_int/esw/trident.h>
#include <bcm_int/esw/trident2.h>
#include <bcm_int/esw/katana.h>
#include <bcm_int/esw/apache.h>
#include <bcm_int/esw/scorpion.h>
#include <bcm_int/esw/mirror.h>
#include <bcm_int/esw/multicast.h>
#include <bcm_int/esw/virtual.h>
#include <bcm_int/common/multicast.h>
#include <bcm_int/esw_dispatch.h>
#include <bcm_int/esw/flex_ctr.h>
#include <bcm_int/esw/oam.h>
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
#include <bcm_int/esw/policer.h>
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
#include <bcm_int/esw/nat.h>
#endif
#if defined(BCM_KATANA2_SUPPORT)
#include <bcm_int/esw/katana2.h>
#endif
#if defined(BCM_SABER2_SUPPORT)
#include <bcm_int/esw/saber2.h>
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
#include <bcm_int/esw/hurricane3.h>
#include <bcm_int/esw/flowcnt.h>
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
#include <bcm_int/esw/greyhound2.h>
#endif

typedef struct _field_flex_stat_info_s {
    int   flex_mode;
    int   hw_flags;
    uint8 valid;
    uint8 flex_stat_map;
} _field_flex_stat_info_t;

soc_tcam_partition_type_t _bcm_field_fp_tcam_partitions[] =  {
    TCAM_PARTITION_ACL_L2C,
    TCAM_PARTITION_ACL_L2,
    TCAM_PARTITION_ACL_IP4C,
    TCAM_PARTITION_ACL_IP4,
    TCAM_PARTITION_ACL_L2IP4,
    TCAM_PARTITION_ACL_IP6C,
    TCAM_PARTITION_ACL_IP6S,
    TCAM_PARTITION_ACL_IP6F,
    TCAM_PARTITION_ACL_L2IP6};

soc_mem_t _bcm_field_ext_data_mask_mems[] = {
    EXT_ACL144_TCAM_L2m, EXT_ACL288_TCAM_L2m,
    EXT_ACL144_TCAM_IPV4m, EXT_ACL288_TCAM_IPV4m, 0,
    EXT_ACL144_TCAM_IPV6m, 0, 0, 0};
soc_mem_t _bcm_field_ext_data_mems[] = {
    0, 0,
    0, 0, EXT_ACL432_TCAM_DATA_L2_IPV4m,
    0, EXT_ACL360_TCAM_DATA_IPV6_SHORTm, EXT_ACL432_TCAM_DATA_IPV6_LONGm,
    EXT_ACL432_TCAM_DATA_L2_IPV6m};
soc_mem_t _bcm_field_ext_mask_mems[] = {
    0, 0,
    0, 0, EXT_ACL432_TCAM_MASKm,
    0, EXT_ACL360_TCAM_MASKm, EXT_ACL432_TCAM_MASKm, EXT_ACL432_TCAM_MASKm};

soc_mem_t _bcm_field_ext_policy_mems[] = {
    EXT_FP_POLICY_ACL144_L2m, EXT_FP_POLICY_ACL288_L2m,
    EXT_FP_POLICY_ACL144_IPV4m, EXT_FP_POLICY_ACL288_IPV4m,
    EXT_FP_POLICY_ACL432_L2_IPV4m,
    EXT_FP_POLICY_ACL144_IPV6m, EXT_FP_POLICY_ACL360_IPV6_SHORTm,
    EXT_FP_POLICY_ACL432_IPV6_LONGm,
    EXT_FP_POLICY_ACL432_L2_IPV6m};

soc_mem_t _bcm_field_ext_counter_mems[] = {
    EXT_FP_CNTR_ACL144_L2m,
    EXT_FP_CNTR_ACL288_L2m,
    EXT_FP_CNTR_ACL144_IPV4m,
    EXT_FP_CNTR_ACL288_IPV4m,
    EXT_FP_CNTR_ACL432_L2_IPV4m,
    EXT_FP_CNTR_ACL144_IPV6m,
    EXT_FP_CNTR_ACL360_IPV6_SHORTm,
    EXT_FP_CNTR_ACL432_IPV6_LONGm,
    EXT_FP_CNTR_ACL432_L2_IPV6m};
const soc_field_t _bcm_field_trx_slice_pairing_field[] = {
    SLICE1_0_PAIRINGf,
    SLICE3_2_PAIRINGf,
    SLICE5_4_PAIRINGf,
    SLICE7_6_PAIRINGf,
    SLICE9_8_PAIRINGf,
    SLICE11_10_PAIRINGf,
    SLICE13_12_PAIRINGf,
    SLICE15_14_PAIRINGf
};
const soc_field_t _bcm_field_trx_slice_wide_mode_field[16] = {
    SLICE0_DOUBLE_WIDE_MODEf,
    SLICE1_DOUBLE_WIDE_MODEf,
    SLICE2_DOUBLE_WIDE_MODEf,
    SLICE3_DOUBLE_WIDE_MODEf,
    SLICE4_DOUBLE_WIDE_MODEf,
    SLICE5_DOUBLE_WIDE_MODEf,
    SLICE6_DOUBLE_WIDE_MODEf,
    SLICE7_DOUBLE_WIDE_MODEf,
    SLICE8_DOUBLE_WIDE_MODEf,
    SLICE9_DOUBLE_WIDE_MODEf,
    SLICE10_DOUBLE_WIDE_MODEf,
    SLICE11_DOUBLE_WIDE_MODEf,
    SLICE12_DOUBLE_WIDE_MODEf,
    SLICE13_DOUBLE_WIDE_MODEf,
    SLICE14_DOUBLE_WIDE_MODEf,
    SLICE15_DOUBLE_WIDE_MODEf};
static soc_field_t _trx_efp_slice_mode[4][2] =  {
    {SLICE_0_MODEf, SLICE_0_IPV6_KEY_MODEf},
    {SLICE_1_MODEf, SLICE_1_IPV6_KEY_MODEf},
    {SLICE_2_MODEf, SLICE_2_IPV6_KEY_MODEf},
    {SLICE_3_MODEf, SLICE_3_IPV6_KEY_MODEf}};
const soc_field_t _bcm_field_trx_field_sel[16][3] = {
    {SLICE0_F1f, SLICE0_F2f, SLICE0_F3f},
    {SLICE1_F1f, SLICE1_F2f, SLICE1_F3f},
    {SLICE2_F1f, SLICE2_F2f, SLICE2_F3f},
    {SLICE3_F1f, SLICE3_F2f, SLICE3_F3f},
    {SLICE4_F1f, SLICE4_F2f, SLICE4_F3f},
    {SLICE5_F1f, SLICE5_F2f, SLICE5_F3f},
    {SLICE6_F1f, SLICE6_F2f, SLICE6_F3f},
    {SLICE7_F1f, SLICE7_F2f, SLICE7_F3f},
    {SLICE8_F1f, SLICE8_F2f, SLICE8_F3f},
    {SLICE9_F1f, SLICE9_F2f, SLICE9_F3f},
    {SLICE10_F1f, SLICE10_F2f, SLICE10_F3f},
    {SLICE11_F1f, SLICE11_F2f, SLICE11_F3f},
    {SLICE12_F1f, SLICE12_F2f, SLICE12_F3f},
    {SLICE13_F1f, SLICE13_F2f, SLICE13_F3f},
    {SLICE14_F1f, SLICE14_F2f, SLICE14_F3f},
    {SLICE15_F1f, SLICE15_F2f, SLICE15_F3f}};
const soc_field_t _bcm_field_trx_d_type_sel[] =  {
    SLICE0_D_TYPE_SELf, SLICE1_D_TYPE_SELf,
    SLICE2_D_TYPE_SELf, SLICE3_D_TYPE_SELf,
    SLICE4_D_TYPE_SELf, SLICE5_D_TYPE_SELf,
    SLICE6_D_TYPE_SELf, SLICE7_D_TYPE_SELf,
    SLICE8_D_TYPE_SELf, SLICE9_D_TYPE_SELf,
    SLICE10_D_TYPE_SELf, SLICE11_D_TYPE_SELf,
    SLICE12_D_TYPE_SELf, SLICE13_D_TYPE_SELf,
    SLICE14_D_TYPE_SELf, SLICE15_D_TYPE_SELf};
const soc_field_t _bcm_field_trx_s_type_sel[] =  {
    SLICE0_S_TYPE_SELf, SLICE1_S_TYPE_SELf,
    SLICE2_S_TYPE_SELf, SLICE3_S_TYPE_SELf,
    SLICE4_S_TYPE_SELf, SLICE5_S_TYPE_SELf,
    SLICE6_S_TYPE_SELf, SLICE7_S_TYPE_SELf,
    SLICE8_S_TYPE_SELf, SLICE9_S_TYPE_SELf,
    SLICE10_S_TYPE_SELf, SLICE11_S_TYPE_SELf,
    SLICE12_S_TYPE_SELf, SLICE13_S_TYPE_SELf,
    SLICE14_S_TYPE_SELf, SLICE15_S_TYPE_SELf};
    /*
     * IFP - FP_DOUBLE_WIDE_SELECT fields.
     */
const soc_field_t _bcm_field_trx_dw_f1_sel[] =  {
    SLICE_0_F1f, SLICE_1_F1f,
    SLICE_2_F1f, SLICE_3_F1f,
    SLICE_4_F1f, SLICE_5_F1f,
    SLICE_6_F1f, SLICE_7_F1f,
    SLICE_8_F1f, SLICE_9_F1f,
    SLICE_10_F1f, SLICE_11_F1f,
    SLICE_12_F1f, SLICE_13_F1f,
    SLICE_14_F1f, SLICE_15_F1f};
const soc_field_t _bcm_field_trx_dw_f4_sel[] =  {
    SLICE_0_F4f, SLICE_1_F4f,
    SLICE_2_F4f, SLICE_3_F4f,
    SLICE_4_F4f, SLICE_5_F4f,
    SLICE_6_F4f, SLICE_7_F4f,
    SLICE_8_F4f, SLICE_9_F4f,
    SLICE_10_F4f, SLICE_11_F4f,
    SLICE_12_F4f, SLICE_13_F4f,
    SLICE_14_F4f, SLICE_15_F4f};
const soc_field_t _trx_ifp_double_wide_key[] = {
    SLICE0_DOUBLE_WIDE_KEY_SELECTf,
    SLICE1_DOUBLE_WIDE_KEY_SELECTf,
    SLICE2_DOUBLE_WIDE_KEY_SELECTf,
    SLICE3_DOUBLE_WIDE_KEY_SELECTf,
    SLICE4_DOUBLE_WIDE_KEY_SELECTf,
    SLICE5_DOUBLE_WIDE_KEY_SELECTf,
    SLICE6_DOUBLE_WIDE_KEY_SELECTf,
    SLICE7_DOUBLE_WIDE_KEY_SELECTf,
    SLICE8_DOUBLE_WIDE_KEY_SELECTf,
    SLICE9_DOUBLE_WIDE_KEY_SELECTf,
    SLICE10_DOUBLE_WIDE_KEY_SELECTf,
    SLICE11_DOUBLE_WIDE_KEY_SELECTf,
    SLICE12_DOUBLE_WIDE_KEY_SELECTf,
    SLICE13_DOUBLE_WIDE_KEY_SELECTf,
    SLICE14_DOUBLE_WIDE_KEY_SELECTf,
    SLICE15_DOUBLE_WIDE_KEY_SELECTf};
soc_field_t _trx_src_class_id_sel[] = {
    SLICE_0_SRC_CLASS_ID_SELf,
    SLICE_1_SRC_CLASS_ID_SELf,
    SLICE_2_SRC_CLASS_ID_SELf,
    SLICE_3_SRC_CLASS_ID_SELf,
    SLICE_4_SRC_CLASS_ID_SELf,
    SLICE_5_SRC_CLASS_ID_SELf,
    SLICE_6_SRC_CLASS_ID_SELf,
    SLICE_7_SRC_CLASS_ID_SELf,
    SLICE_8_SRC_CLASS_ID_SELf,
    SLICE_9_SRC_CLASS_ID_SELf,
    SLICE_10_SRC_CLASS_ID_SELf,
    SLICE_11_SRC_CLASS_ID_SELf,
    SLICE_12_SRC_CLASS_ID_SELf,
    SLICE_13_SRC_CLASS_ID_SELf,
    SLICE_14_SRC_CLASS_ID_SELf,
    SLICE_15_SRC_CLASS_ID_SELf};
soc_field_t _trx_dst_class_id_sel[] = {
    SLICE_0_DST_CLASS_ID_SELf,
    SLICE_1_DST_CLASS_ID_SELf,
    SLICE_2_DST_CLASS_ID_SELf,
    SLICE_3_DST_CLASS_ID_SELf,
    SLICE_4_DST_CLASS_ID_SELf,
    SLICE_5_DST_CLASS_ID_SELf,
    SLICE_6_DST_CLASS_ID_SELf,
    SLICE_7_DST_CLASS_ID_SELf,
    SLICE_8_DST_CLASS_ID_SELf,
    SLICE_9_DST_CLASS_ID_SELf,
    SLICE_10_DST_CLASS_ID_SELf,
    SLICE_11_DST_CLASS_ID_SELf,
    SLICE_12_DST_CLASS_ID_SELf,
    SLICE_13_DST_CLASS_ID_SELf,
    SLICE_14_DST_CLASS_ID_SELf,
    SLICE_15_DST_CLASS_ID_SELf};
soc_field_t _trx_interface_class_id_sel[] = {
    SLICE_0_INTERFACE_CLASS_ID_SELf,
    SLICE_1_INTERFACE_CLASS_ID_SELf,
    SLICE_2_INTERFACE_CLASS_ID_SELf,
    SLICE_3_INTERFACE_CLASS_ID_SELf,
    SLICE_4_INTERFACE_CLASS_ID_SELf,
    SLICE_5_INTERFACE_CLASS_ID_SELf,
    SLICE_6_INTERFACE_CLASS_ID_SELf,
    SLICE_7_INTERFACE_CLASS_ID_SELf,
    SLICE_8_INTERFACE_CLASS_ID_SELf,
    SLICE_9_INTERFACE_CLASS_ID_SELf,
    SLICE_10_INTERFACE_CLASS_ID_SELf,
    SLICE_11_INTERFACE_CLASS_ID_SELf,
    SLICE_12_INTERFACE_CLASS_ID_SELf,
    SLICE_13_INTERFACE_CLASS_ID_SELf,
    SLICE_14_INTERFACE_CLASS_ID_SELf,
    SLICE_15_INTERFACE_CLASS_ID_SELf};

const soc_field_t _bcm_field_trx_vfp_double_wide_sel[]= {
    SLICE_0_DOUBLE_WIDE_KEY_SELECTf,
    SLICE_1_DOUBLE_WIDE_KEY_SELECTf,
    SLICE_2_DOUBLE_WIDE_KEY_SELECTf,
    SLICE_3_DOUBLE_WIDE_KEY_SELECTf
};
const soc_field_t _bcm_field_trx_vfp_field_sel[][2] = {
    { SLICE_0_F2f, SLICE_0_F3f },
    { SLICE_1_F2f, SLICE_1_F3f },
    { SLICE_2_F2f, SLICE_2_F3f },
    { SLICE_3_F2f, SLICE_3_F3f }
};
const soc_field_t _bcm_field_trx_vfp_ip_header_sel[]= {
    SLICE_0_IP_FIELD_SELECTf,
    SLICE_1_IP_FIELD_SELECTf,
    SLICE_2_IP_FIELD_SELECTf,
    SLICE_3_IP_FIELD_SELECTf
};
const soc_field_t _trx_vfp_src_type_sel[]= {
    SLICE_0_SOURCE_TYPE_SELf, SLICE_1_SOURCE_TYPE_SELf,
    SLICE_2_SOURCE_TYPE_SELf, SLICE_3_SOURCE_TYPE_SELf};

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
/* Static variables. */
static soc_field_t _trx2_offset_field[2][8] = {
    {
        UDF1_OFFSET0f, UDF1_OFFSET1f,
        UDF1_OFFSET2f, UDF1_OFFSET3f,
        UDF1_OFFSET4f, UDF1_OFFSET5f,
        UDF1_OFFSET6f, UDF1_OFFSET7f
    },
    {
        UDF2_OFFSET0f, UDF2_OFFSET1f,
        UDF2_OFFSET2f, UDF2_OFFSET3f,
        UDF2_OFFSET4f, UDF2_OFFSET5f,
        UDF2_OFFSET6f, UDF2_OFFSET7f
    }
};
static soc_field_t _trx2_base_field[2][8] = {
    {
        UDF1_BASE_OFFSET_0f, UDF1_BASE_OFFSET_1f,
        UDF1_BASE_OFFSET_2f, UDF1_BASE_OFFSET_3f,
        UDF1_BASE_OFFSET_4f, UDF1_BASE_OFFSET_5f,
        UDF1_BASE_OFFSET_6f, UDF1_BASE_OFFSET_7f
    },
    {
        UDF2_BASE_OFFSET_0f, UDF2_BASE_OFFSET_1f,
        UDF2_BASE_OFFSET_2f, UDF2_BASE_OFFSET_3f,
        UDF2_BASE_OFFSET_4f, UDF2_BASE_OFFSET_5f,
        UDF2_BASE_OFFSET_6f, UDF2_BASE_OFFSET_7f
    }
};
#endif /* BCM_TRIUMPH2_SUPPORT || BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
const soc_field_t _bcm_td2plus_oam_overlay_field[] = {
    SLICE0_OAM_OVERLAY_ENABLEf,
    SLICE1_OAM_OVERLAY_ENABLEf,
    SLICE2_OAM_OVERLAY_ENABLEf,
    SLICE3_OAM_OVERLAY_ENABLEf,
    SLICE4_OAM_OVERLAY_ENABLEf,
    SLICE5_OAM_OVERLAY_ENABLEf,
    SLICE6_OAM_OVERLAY_ENABLEf,
    SLICE7_OAM_OVERLAY_ENABLEf,
    SLICE8_OAM_OVERLAY_ENABLEf,
    SLICE9_OAM_OVERLAY_ENABLEf,
    SLICE10_OAM_OVERLAY_ENABLEf,
    SLICE11_OAM_OVERLAY_ENABLEf,
};
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
const soc_field_t _bcm_ifp_normalize_fldtbl[][2] = {
    { SLICE0_NORMALIZE_IP_ADDRf,  SLICE0_NORMALIZE_MAC_ADDRf },
    { SLICE1_NORMALIZE_IP_ADDRf,  SLICE1_NORMALIZE_MAC_ADDRf },
    { SLICE2_NORMALIZE_IP_ADDRf,  SLICE2_NORMALIZE_MAC_ADDRf },
    { SLICE3_NORMALIZE_IP_ADDRf,  SLICE3_NORMALIZE_MAC_ADDRf },
    { SLICE4_NORMALIZE_IP_ADDRf,  SLICE4_NORMALIZE_MAC_ADDRf },
    { SLICE5_NORMALIZE_IP_ADDRf,  SLICE5_NORMALIZE_MAC_ADDRf },
    { SLICE6_NORMALIZE_IP_ADDRf,  SLICE6_NORMALIZE_MAC_ADDRf },
    { SLICE7_NORMALIZE_IP_ADDRf,  SLICE7_NORMALIZE_MAC_ADDRf },
    { SLICE8_NORMALIZE_IP_ADDRf,  SLICE8_NORMALIZE_MAC_ADDRf },
    { SLICE9_NORMALIZE_IP_ADDRf,  SLICE9_NORMALIZE_MAC_ADDRf },
    { SLICE10_NORMALIZE_IP_ADDRf, SLICE10_NORMALIZE_MAC_ADDRf },
    { SLICE11_NORMALIZE_IP_ADDRf, SLICE11_NORMALIZE_MAC_ADDRf },
    { SLICE12_NORMALIZE_IP_ADDRf, SLICE12_NORMALIZE_MAC_ADDRf },
    { SLICE13_NORMALIZE_IP_ADDRf, SLICE13_NORMALIZE_MAC_ADDRf },
    { SLICE14_NORMALIZE_IP_ADDRf, SLICE14_NORMALIZE_MAC_ADDRf },
    { SLICE15_NORMALIZE_IP_ADDRf, SLICE15_NORMALIZE_MAC_ADDRf }
};
#endif

const soc_field_t _bcm_trx2_aux_tag_1_field[] = {
    SLICE0_AUX_TAG_1_SELf,
    SLICE1_AUX_TAG_1_SELf,
    SLICE2_AUX_TAG_1_SELf,
    SLICE3_AUX_TAG_1_SELf,
    SLICE4_AUX_TAG_1_SELf,
    SLICE5_AUX_TAG_1_SELf,
    SLICE6_AUX_TAG_1_SELf,
    SLICE7_AUX_TAG_1_SELf,
    SLICE8_AUX_TAG_1_SELf,
    SLICE9_AUX_TAG_1_SELf,
    SLICE10_AUX_TAG_1_SELf,
    SLICE11_AUX_TAG_1_SELf,
    SLICE12_AUX_TAG_1_SELf,
    SLICE13_AUX_TAG_1_SELf,
    SLICE14_AUX_TAG_1_SELf,
    SLICE15_AUX_TAG_1_SELf
};

const soc_field_t _bcm_trx2_aux_tag_2_field[] = {
    SLICE0_AUX_TAG_2_SELf,
    SLICE1_AUX_TAG_2_SELf,
    SLICE2_AUX_TAG_2_SELf,
    SLICE3_AUX_TAG_2_SELf,
    SLICE4_AUX_TAG_2_SELf,
    SLICE5_AUX_TAG_2_SELf,
    SLICE6_AUX_TAG_2_SELf,
    SLICE7_AUX_TAG_2_SELf,
    SLICE8_AUX_TAG_2_SELf,
    SLICE9_AUX_TAG_2_SELf,
    SLICE10_AUX_TAG_2_SELf,
    SLICE11_AUX_TAG_2_SELf,
    SLICE12_AUX_TAG_2_SELf,
    SLICE13_AUX_TAG_2_SELf,
    SLICE14_AUX_TAG_2_SELf,
    SLICE15_AUX_TAG_2_SELf
};

const soc_field_t _bcm_trx2_vrf_force_forwarding_enable_field[] = {
    SLICE_0_ENABLEf,
    SLICE_1_ENABLEf,
    SLICE_2_ENABLEf,
    SLICE_3_ENABLEf,
    SLICE_4_ENABLEf,
    SLICE_5_ENABLEf,
    SLICE_6_ENABLEf,
    SLICE_7_ENABLEf,
    SLICE_8_ENABLEf,
    SLICE_9_ENABLEf,
    SLICE_10_ENABLEf,
    SLICE_11_ENABLEf,
    SLICE_12_ENABLEf,
    SLICE_13_ENABLEf,
    SLICE_14_ENABLEf,
    SLICE_15_ENABLEf
};

const soc_field_t _trx_tcp_slice_control_enable_field[] = {
    SLICE_0_TCP_FN_SELf,
    SLICE_1_TCP_FN_SELf,
    SLICE_2_TCP_FN_SELf,
    SLICE_3_TCP_FN_SELf,
    SLICE_4_TCP_FN_SELf,
    SLICE_5_TCP_FN_SELf,
    SLICE_6_TCP_FN_SELf,
    SLICE_7_TCP_FN_SELf,
    SLICE_8_TCP_FN_SELf,
    SLICE_9_TCP_FN_SELf,
    SLICE_10_TCP_FN_SELf,
    SLICE_11_TCP_FN_SELf
};

const soc_field_t _trx_ttl_slice_control_enable_field[] = {
    SLICE_0_TTL_FN_SELf,
    SLICE_1_TTL_FN_SELf,
    SLICE_2_TTL_FN_SELf,
    SLICE_3_TTL_FN_SELf,
    SLICE_4_TTL_FN_SELf,
    SLICE_5_TTL_FN_SELf,
    SLICE_6_TTL_FN_SELf,
    SLICE_7_TTL_FN_SELf,
    SLICE_8_TTL_FN_SELf,
    SLICE_9_TTL_FN_SELf,
    SLICE_10_TTL_FN_SELf,
    SLICE_11_TTL_FN_SELf
};

const soc_field_t _trx_tos_slice_control_enable_field[] = {
    SLICE_0_TOS_FN_SELf,
    SLICE_1_TOS_FN_SELf,
    SLICE_2_TOS_FN_SELf,
    SLICE_3_TOS_FN_SELf,
    SLICE_4_TOS_FN_SELf,
    SLICE_5_TOS_FN_SELf,
    SLICE_6_TOS_FN_SELf,
    SLICE_7_TOS_FN_SELf,
    SLICE_8_TOS_FN_SELf,
    SLICE_9_TOS_FN_SELf,
    SLICE_10_TOS_FN_SELf,
    SLICE_11_TOS_FN_SELf
};

#ifdef BCM_KATANA_SUPPORT
#define _BCM_QOS_MAP_MASK                            0x1fff
#define _BCM_QOS_MAP_OFFSET_MASK                     0x3ff
#define _BCM_QOS_MAP_TYPE_SHIFT                        10
#define _BCM_QOS_MAP_TYPE_ING_QUEUE_OFFSET_MAP_TABLE   5
#define _BCM_QOS_MAP_ING_QUEUE_OFFSET_MAX              7
#endif

/* UDF data format flags specific fields */
soc_field_t udf_fields_f[][4] = {
    {HIGIG_MASKf,         HIGIGf,       BCM_FIELD_DATA_FORMAT_F_ENCAP_STACK,
                                        BCM_FIELD_DATA_FORMAT_F_NO_ENCAP_STACK},
    {VNTAG_PRESENT_MASKf, VNTAG_PRESENTf, BCM_FIELD_DATA_FORMAT_F_VNTAG,
                                          BCM_FIELD_DATA_FORMAT_F_NO_VNTAG},
    {CNTAG_PRESENT_MASKf, CNTAG_PRESENTf, BCM_FIELD_DATA_FORMAT_F_CNTAG,
                                          BCM_FIELD_DATA_FORMAT_F_NO_CNTAG},
    {ETAG_PACKET_MASKf,   ETAG_PACKETf,   BCM_FIELD_DATA_FORMAT_F_ETAG,
                                          BCM_FIELD_DATA_FORMAT_F_NO_ETAG},
    {ICNM_PACKET_MASKf,   ICNM_PACKETf,   BCM_FIELD_DATA_FORMAT_F_ICNM,
                                          BCM_FIELD_DATA_FORMAT_F_NO_ICNM},
    {INVALIDf,            INVALIDf,       0,
                                          0}
};

#if defined BCM_WARM_BOOT_SUPPORT
extern _field_dscp_map_new_eid_list_t  *dscp_map_new_eid_list[BCM_MAX_NUM_UNITS];
#if defined INCLUDE_L3
_bcm_field_l3_callback_recover_t *_field_l3_cb = NULL;
#endif
#endif /* BCM_WARM_BOOT_SUPPORT */

/*
 * Function:
 *     _bcm_field_group_qual_copy_and_clear
 * Purpose:
 *     copy qual_arr from source to destination and reset the source qual_arr
 * Parameters:
 *     qual_arr_1  - (IN) pointer to qualifier information.
 *     qual_arr_2  - (OUT) pointer to qualifier information to be filled.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_group_qual_copy_and_clear(_bcm_field_group_qual_t *qual_arr_1,
                           _bcm_field_group_qual_t *qual_arr_2)
{
    if ((NULL == qual_arr_2) || (NULL == qual_arr_1)) {
        return BCM_E_INTERNAL;
    }

    qual_arr_2->qid_arr = qual_arr_1->qid_arr;
    qual_arr_2->offset_arr = qual_arr_1->offset_arr;
    qual_arr_2->size = qual_arr_1->size;

    qual_arr_1->qid_arr = NULL;
    qual_arr_1->offset_arr = NULL;
    qual_arr_1->size = 0;

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_trx_egress_default_selcode_get
 * Purpose:
 *     Finds a select encodings that will satisfy the
 *     requested qualifier set (Qset).
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     key_pri   - (IN) Primary key id.
 *     key_sec   - (IN) Secondary key id.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_egress_default_selcode_get(int unit, _field_stage_t *stage_fc,
                                          bcm_field_qset_t *qset_req,
                                          uint8 key_pri, uint8 key_sec,
                                          _field_group_t *fg)
{
    int             rv;          /* Operation return status. */
    int             rv1;          /* Operation return status. */
    int             idx;
    _bcm_field_group_qual_t temp_qual[_FP_MAX_ENTRY_WIDTH];
    int   parts_count = 0;
    _bcm_field_group_qual_t *qual_arr_1,*qual_arr_2;

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    qual_arr_1 = NULL;
    qual_arr_2 = NULL;

    /* Get number of entry parts. */
    rv  = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                             fg->flags, &parts_count);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < parts_count; idx++ ) {
        qual_arr_1 = &(fg->qual_arr[_FP_ENTRY_TYPE_0][idx]);
        rv = _bcm_field_group_qual_copy_and_clear(qual_arr_1, &temp_qual[idx]);
        BCM_IF_ERROR_RETURN(rv);
    }

    rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                       key_pri, key_sec, fg);
    if (BCM_SUCCESS(rv)) {

        for (idx = 0; idx < parts_count; idx++ ) {
            qual_arr_1 = &(fg->qual_arr[_FP_ENTRY_TYPE_0][idx]);
            qual_arr_2 = &(fg->qual_arr[_FP_ENTRY_TYPE_1][idx]);
            rv1 = _bcm_field_group_qual_copy_and_clear(qual_arr_1, qual_arr_2);
            BCM_IF_ERROR_RETURN(rv1);
        }
    }

    for (idx = 0; idx < parts_count; idx++ ) {
        qual_arr_1 = &(fg->qual_arr[_FP_ENTRY_TYPE_0][idx]);
        rv1 = _bcm_field_group_qual_copy_and_clear(&temp_qual[idx], qual_arr_1);
        BCM_IF_ERROR_RETURN(rv1);
    }

    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_qset_get
 * Purpose:
 *     Common qualifiers to qset_in and given selector code are
 *     added to qset_out
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     qset_in   - (IN) Input qualifier set.
 *     stage_fc  - (IN) Stage Field control structure.
 *     pri_sel_val_primary   - (IN) Selctor Code value for primary slice .
 *     pri_sel_val_secondary - (IN) Selctor Code value for secondary slice .
 *     qset_out  - (IN/OUT) Output qualifier set.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_trx_qset_get(int unit, bcm_field_qset_t *qset_in,
                        _field_stage_t *stage_fc,
                        int pri_sel_val_primary,
                        int pri_sel_val_secondary,
                        bcm_field_qset_t *qset_out,
                        _field_group_t *fg)
{
    uint16 qid;                            /* Field qualifier id          */
    int    idx;                            /* Index to qualifer conf_arr  */
    _bcm_field_qual_info_t *f_qual = NULL; /* Field qualifier info.       */
    _bcm_field_qual_conf_t *ptr;           /* Field qualifier config info */

    if ((NULL == qset_in) || (NULL == qset_out)) {
        return BCM_E_PARAM;
    }


    BCM_FIELD_QSET_INIT(*qset_out);
    for (qid = 0; qid < _bcmFieldQualifyCount; qid++) {
        /* Skip unused qualifiers. */
        if (0 == BCM_FIELD_QSET_TEST(*qset_in, qid)) {
            continue;
        }

        f_qual = stage_fc->f_qual_arr[qid];
        for (idx =0; idx < f_qual->conf_sz; idx++) {
            ptr = &(f_qual->conf_arr[idx]);
            if ((_bcmFieldSliceSelFpf3 == ptr->selector.pri_sel) &&
                ((pri_sel_val_primary == ptr->selector.pri_sel_val) ||
                 (pri_sel_val_secondary == ptr->selector.pri_sel_val))) {
#if defined(BCM_APACHE_SUPPORT)
                /* Skip when OamOverlay doesn't match */
                if (SOC_IS_APACHE(unit) &&
                        (ptr->selector.sec_sel == _bcmFieldSliceSelEgrOamOverlayKey4) &&
                        (((fg->sel_codes[0].egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE) &&
                          (fg->sel_codes[0].egr_oam_overlay_sel != ptr->selector.sec_sel_val)) ||
                         ((fg->sel_codes[1].egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE) &&
                          (fg->sel_codes[1].egr_oam_overlay_sel != ptr->selector.sec_sel_val)))) {
                    continue;
                }
#endif
                BCM_FIELD_QSET_ADD(*qset_out,qid);

            } else {
                continue;
            }
        }
    }

    if (BCM_FIELD_QSET_TEST(*qset_in, bcmFieldQualifyStageIngress)) {
        BCM_FIELD_QSET_ADD(*qset_out, bcmFieldQualifyStageIngress);
    } else if(BCM_FIELD_QSET_TEST(*qset_in, bcmFieldQualifyStageEgress)) {
        BCM_FIELD_QSET_ADD(*qset_out, bcmFieldQualifyStageEgress);
    } else if(BCM_FIELD_QSET_TEST(*qset_in, bcmFieldQualifyStageLookup)) {
        BCM_FIELD_QSET_ADD(*qset_out, bcmFieldQualifyStageLookup);
    } else if(BCM_FIELD_QSET_TEST(*qset_in, bcmFieldQualifyStageExternal)) {
        BCM_FIELD_QSET_ADD(*qset_out, bcmFieldQualifyStageExternal);
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_trx_egress_selcode_get
 * Purpose:
 *     Finds a select encodings that will satisfy the
 *     requested qualifier set (Qset).
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_egress_selcode_get(int unit, _field_stage_t *stage_fc,
                               bcm_field_qset_t *qset_req,
                               _field_group_t *fg)
{
    int             rv;          /* Operation return status. */
    bcm_field_qset_t new_qset;

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    if  (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        /* Attempt _BCM_FIELD_EFP_KEY4  (L2 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY4, 0, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);

            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Attempt _BCM_FIELD_EFP_KEY1_NO_V4  (L3 any key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1_NO_V4, 0, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);

            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1_NO_V4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }


        /* Attempt _BCM_FIELD_EFP_KEY1  (IPv4 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1, 0, fg);

        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Attempt _BCM_FIELD_EFP_KEY2  (IPv6 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY2, 0, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY2;
            return rv;
        }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            /* Attempt _BCM_FIELD_EFP_KEY5  (FCOE key). */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                    _BCM_FIELD_EFP_KEY5, 0, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                        _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
                   combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */


                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                        &new_qset,
                        _BCM_FIELD_EFP_KEY4,
                        0, fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                            (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY5;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }

            /* Attempt _BCM_FIELD_EFP_KEY6  (OAM SAT key). */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                    _BCM_FIELD_EFP_KEY6, 0, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                        _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
                   combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */


                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                        &new_qset,
                        _BCM_FIELD_EFP_KEY4,
                        0, fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                            (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY6;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }
#endif

    }  else  {
        /* L2 + L3 double wide predefined key. */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1_NO_V4,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1_NO_V4;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* L2 + L3 v4 double wide predefined key. */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        if (SOC_IS_TD2_TT2(unit) ||
               SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit)) {
             /* L2 + L3 v6  double wide predefined key. */
             rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                                _BCM_FIELD_EFP_KEY2,
                                                _BCM_FIELD_EFP_KEY4, fg);

             if (BCM_SUCCESS(rv)) {


                 /* In EFP, for a given qset we can have two selector code
                    combination. So attempt _BCM_FIELD_EFP_KEY1 and
                    _BCM_FIELD_EFP_KEY4 (Any Packet type) */

                 rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                              _BCM_FIELD_EFP_KEY1,
                                              _BCM_FIELD_EFP_KEY4,
                                              &new_qset, fg);
                 BCM_IF_ERROR_RETURN(rv);

                 rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                                &new_qset,
                                                                _BCM_FIELD_EFP_KEY1,
                                                                _BCM_FIELD_EFP_KEY4,
                                                                fg);
                 if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                        (rv != BCM_E_RESOURCE))) {
                     fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY2;
                     fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                     return rv;
                 }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }

        /* IPv6 double wide predefined key. */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY3,
                                           _BCM_FIELD_EFP_KEY2, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY3;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY2;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            /* FCOE double wide predefined key. */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                    _BCM_FIELD_EFP_KEY5,
                    _BCM_FIELD_EFP_KEY4, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                        _BCM_FIELD_EFP_KEY1,
                        _BCM_FIELD_EFP_KEY4,
                        &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
                   combination. So attempt _BCM_FIELD_EFP_KEY1 and
                   _BCM_FIELD_EFP_KEY4 (Any Packet type) */

                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                        &new_qset,
                        _BCM_FIELD_EFP_KEY1,
                        _BCM_FIELD_EFP_KEY4,
                        fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                            (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY5;
                    fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }
#endif
    }

    return (BCM_E_RESOURCE);
}
/*
 * Function:
 *     _bcm_field_trx_egress_mode_get
 *
 * Purpose:
 *     Helper function to get the mode of a slice in a
 *     register value that is to be used for FP_SLICE_CONFIGr.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     fg         - (IN) Installed group structure.
 *     slice_mode - (IN/OUT) Slice mode for the group.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_trx_egress_mode_get(int unit,
                               _field_group_t *fg,
                               uint8 *slice_mode)
{
    uint32 reg_value;
    uint32 slice_num;
    soc_field_t _trx_efp_slice_mode[4] =  {SLICE_0_MODEf, SLICE_1_MODEf,
                                           SLICE_2_MODEf, SLICE_3_MODEf};

    /* Input parameters check. */
    if ((NULL == fg) ||  (NULL == slice_mode)) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_EGRESS != fg->stage_id) {
        return BCM_E_PARAM;
    }

    slice_num = fg->slices->slice_number;

    if (slice_num >= COUNTOF(_trx_efp_slice_mode)) {
        return (BCM_E_PARAM);
    }

    SOC_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &reg_value));
    *slice_mode = soc_reg_field_get(unit,
                                    EFP_SLICE_CONTROLr,
                                    reg_value,
                                    _trx_efp_slice_mode[slice_num]);
    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_trx_egress_mode_set
 *
 * Purpose:
 *     Helper function to _bcm_field_fb_mode_install that sets the mode of a
 *     slice in a register value that is to be used for FP_SLICE_CONFIGr.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Slice number to set mode for.
 *     fg         - (IN) Installed group structure.
 *     flags      - (IN) New group/slice mode.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_trx_egress_mode_set(int unit, uint8 slice_numb,
                               _field_group_t *fg, uint8 flags)
{
    uint32 mode_val[2];
    /* Input parameters check. */
    if ((NULL == fg) || (slice_numb >= COUNTOF(_trx_efp_slice_mode))) {
        return (BCM_E_PARAM);
    }

    mode_val[1]  = _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_SIP6;

    if (flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
        /* IP + L2 Double wide key. */
        if ((_BCM_FIELD_EFP_KEY1_NO_V4 == fg->sel_codes[0].fpf3) && \
            (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3)) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY;
        }

        /* DstIP6 + SrcIp6 or IPv4 + L2 Double wide key. */
        if (((_BCM_FIELD_EFP_KEY3 == fg->sel_codes[0].fpf3) && \
            (_BCM_FIELD_EFP_KEY2 == fg->sel_codes[1].fpf3)) ||
            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE;
            if ((_BCM_FIELD_EFP_KEY3 == fg->sel_codes[0].fpf3) && \
                (_BCM_FIELD_EFP_KEY2 == fg->sel_codes[1].fpf3) &&
                (_FP_SELCODE_DONT_CARE != fg->sel_codes[1].ip6_addr_sel)) {
                mode_val[1] =fg->sel_codes[1].ip6_addr_sel;
            }
        }

        /* IPv6 + L2 Double wide key. */
        else if ((_BCM_FIELD_EFP_KEY2 == fg->sel_codes[0].fpf3) && \
                 (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3)) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6;
            if (_FP_SELCODE_DONT_CARE != fg->sel_codes[0].ip6_addr_sel) {
                mode_val[1] =fg->sel_codes[0].ip6_addr_sel;
            }
        }
#if defined(BCM_APACHE_SUPPORT)
        /* FCOE Double wide key. */
        else if ((_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3) && \
                (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3)) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE;
        }
#endif
        else {
            /* IPv4/Don't care + L2 Double wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY;
        }

        BCM_IF_ERROR_RETURN
            (soc_reg_fields32_modify(unit, EFP_SLICE_CONTROLr, REG_PORT_ANY, 2,
                                     _trx_efp_slice_mode[slice_numb], mode_val));
    } else {
        if (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[0].fpf3) {
            /* L2 - Slice mode. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2;

        } else  if (_BCM_FIELD_EFP_KEY1_NO_V4 == fg->sel_codes[0].fpf3) {
            /* L3 - Any single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY;

        } else  if ((_BCM_FIELD_EFP_KEY1 == fg->sel_codes[0].fpf3)  &&
                    BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) {
            /* L3 - IPv4 single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;

        } else if ((_BCM_FIELD_EFP_KEY2 == fg->sel_codes[0].fpf3)) {
            /* L3 - IPv6 single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;
            if (_FP_SELCODE_DONT_CARE != fg->sel_codes[0].ip6_addr_sel) {
                mode_val[1] =fg->sel_codes[0].ip6_addr_sel;
            }
        }
#if defined(BCM_APACHE_SUPPORT)
        else if ((_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3)) {
            /* FCOE single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;
        } else if (_BCM_FIELD_EFP_KEY6 == fg->sel_codes[0].fpf3) {
            /* OAM SAT - Slice mode. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2;
        }
#endif
        else {
            /* L3 common key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY;
        }

        BCM_IF_ERROR_RETURN
            (soc_reg_fields32_modify(unit, EFP_SLICE_CONTROLr, REG_PORT_ANY, 2,
                                     _trx_efp_slice_mode[slice_numb], mode_val));

    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_fb_egress_slice_clear
 *
 * Purpose:
 *     Reset slice configuraton on group deletion event.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Slice number to set mode for.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_egress_slice_clear(int unit, uint8 slice_numb)
{
    uint32 mode_val[2] =  {0, 0};
    int rv;

    /* Input parameters check. */
    if (slice_numb >= COUNTOF(_trx_efp_slice_mode)) {
        return (BCM_E_PARAM);
    }

    rv = soc_reg_fields32_modify(unit, EFP_SLICE_CONTROLr, REG_PORT_ANY,
                             2, _trx_efp_slice_mode[slice_numb], mode_val);

    return (rv);
}

/*
 * Function:
 *     _field_trx_mode_set
 *
 * Purpose:
 *    Auxiliary routine used to set group pairing mode.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Slice number to set mode for.
 *     fg         - (IN) Installed group structure.
 *     flags      - (IN) New group/slice mode.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_mode_set(int unit, uint8 slice_numb, _field_group_t *fg, uint8 flags)
{
    int rv;     /* Operation return status. */

    /* Input parameter check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    switch (fg->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
          rv = BCM_E_NONE; /* Mode and select codes programmed together. */
          break;
      case _BCM_FIELD_STAGE_LOOKUP:
          rv  = _bcm_field_fb_lookup_mode_set(unit, slice_numb, fg, flags);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          rv = _bcm_field_trx_egress_mode_set(unit, slice_numb, fg, flags);
          break;
#if defined (BCM_TRIUMPH_SUPPORT)
      case _BCM_FIELD_STAGE_EXTERNAL:
          rv = _bcm_field_tr_external_mode_set(unit, slice_numb, fg, flags);
          break;
#endif /* BCM_TRIUMPH_SUPPORT */
      default:
          rv = BCM_E_PARAM;
    }
    return (rv);
}

/*
 * Function:
 *      _bcm_trx_range_checker_selcodes_update
 *
 * Purpose:
 *     Update group select codes based on range checker id
 *     used in field group entry.
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     entry         - (IN) Field entry id.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_trx_range_checker_selcodes_update(int unit, bcm_field_entry_t entry)

{
    uint8            slice_number;          /* Slices iterator.         */
    uint8            entry_part;            /* Wide entry part number.  */
    uint32           buf[SOC_MAX_MEM_FIELD_WORDS];/* HW entry buffer.   */
    _field_sel_t     *sel;                  /* Group field selectors.   */
    _field_group_t   *fg;                   /* Field group structure.   */
    _field_slice_t   *fs;                   /* Field slice structure.   */
    int              rv;                    /* Operation return status. */
    _field_entry_t   *f_ent;                /* Field entry structure.   */


    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
            _bcmFieldQualifyRangeCheckBits24_31, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;

    /* Get tcam part. */
    rv = _bcm_field_entry_flags_to_tcam_part (unit, f_ent->flags, fg,
                                              &entry_part);
    BCM_IF_ERROR_RETURN(rv);

    /* Per slice selectors installed in primary portion only. */
    if ((entry_part > 0) && fg->sel_codes[entry_part].intraslice) {
        entry_part--;
    }

    /* Get slice number for the entry part. */
    rv = _bcm_field_tcam_part_to_slice_number(unit, entry_part, fg,
            &slice_number);
    BCM_IF_ERROR_RETURN(rv);

    /* Update selector value in all group slices. */
    fs = fg->slices + slice_number;

    sel = fg->sel_codes + entry_part;
    if (3 == sel->intf_class_sel) {
        return (BCM_E_NONE);
    } else {
        sel->intf_class_sel = 3;  /* Range checker selector. */
    }

    /* Update FP_SLICE_KEY_CONTROL memory entry. */
    sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
    rv = soc_mem_read(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ANY, 0, buf);
    BCM_IF_ERROR_RETURN(rv);

    while (fs != NULL) {
        /* Set interface class select field. */
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                _trx_interface_class_id_sel[fs->slice_number],
                sel->intf_class_sel);

        fs->intf_class_sel = sel->intf_class_sel;
        fs = fs->next;
    }
    rv = soc_mem_write(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ALL, 0, buf);
    return (rv);
}


/*
 * Function:
 *     _bcm_field_trx_ingress_pfs_bmap_get
 *
 * Purpose:
 *     Fill in set of (PFS) indexes applicable for the specific group.
 *
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     fg            - (IN) Field group.
 *     pbmp          - (IN) Group  active port bit map.
 *     selcode_index - (IN) Index into select codes array.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_ingress_pfs_bmap_get(int unit, _field_group_t *fg,
                                    bcm_pbmp_t *pbmp, int selcode_index,
                                    SHR_BITDCL *pfs_bmp)
{
    bcm_port_t         idx;               /* Device pfs indexes iterator.*/
    int                rv;                /* Operation return status.    */
    _field_sel_t       *sel;              /* Group field selectors.      */
    bcm_port_config_t  port_config;       /* Device port configuration.  */
    bcm_pbmp_t         all_pbmp;
#if defined(BCM_TRX_SUPPORT) || defined(BCM_SCORPION_SUPPORT)
    soc_info_t         *si;
#endif
    int pfs_idx_count = -1;               /* PFS count of indices        */
    int id = -1;                          /* Id for Loop */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == pbmp) || (NULL == pfs_bmp)) {
        return (BCM_E_PARAM);
    }

    /* Get group select codes. */
    sel = &fg->sel_codes[selcode_index];

    /* Read device port bitmaps. */
    rv = bcm_esw_port_config_get(unit, &port_config);
    BCM_IF_ERROR_RETURN(rv);
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    if (fg->flags & _FP_GROUP_WLAN) {
        SHR_BITSET(pfs_bmp, soc_mem_index_max(unit, FP_PORT_FIELD_SELm));
    } else if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
        ((selcode_index == 1) || (selcode_index == 3)) &&
        (sel->fpf2 != _FP_SELCODE_DONT_CARE)) {
        sal_memcpy(pfs_bmp, &all_pbmp, sizeof(bcm_pbmp_t));
    } else {
        sal_memcpy(pfs_bmp, pbmp, sizeof(bcm_pbmp_t));
    }

    /* Global All Port Groups */
    if (BCM_PBMP_EQ(all_pbmp,*pbmp)) {
        pfs_idx_count = soc_mem_index_count(unit, FP_PORT_FIELD_SELm);
        for (id = 0; id < pfs_idx_count;id++) {
            SHR_BITSET(pfs_bmp,id);
        }
        return BCM_E_NONE;
    } else {
        /* Update Group Flags to denote Port based Group */
        fg->flags |= _FP_GROUP_PER_PORT_OR_PBMP;
    }

#if defined(BCM_ENDURO_SUPPORT)
    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit) ||
        SOC_IS_HURRICANE2(unit)) {
        /* Have to set up CPU port for Enduro & Hurricane. */
        SHR_BITSET(pfs_bmp, 34);
    }
#endif /* BCM_ENDURO_SUPPORT */

    /* Following devices have static FP selector mapping when XE port
     * operating on HG mode.
     * Rest devices have FPF_sel_index in port table.
     */
#if defined(BCM_TRX_SUPPORT) || defined(BCM_SCORPION_SUPPORT)
    si = &SOC_INFO(unit);
    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
        SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit) ||
        SOC_IS_SC_CQ(unit) || SOC_IS_GREYHOUND(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        for (idx = 0; idx < BCM_PBMP_PORT_MAX; idx++) {
            if (SOC_PORT_VALID(unit, idx) && SHR_BITGET(pfs_bmp, idx)) {
                if ((si->fp_hg_port_offset != -1) &&
                        (idx >= si->hg_offset)) {
                    SHR_BITSET(pfs_bmp, idx + si->fp_hg_port_offset);
                    continue;
                }
#if defined(BCM_SCORPION_SUPPORT)
                if (SOC_IS_SC_CQ(unit)) {
                    SHR_BITSET(pfs_bmp, idx + 29);
                    continue;
                }
#endif /* BCM_SCORPION_SUPPORT */
                if (SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit)) {
                    switch (idx) {
                        case 2:
                            SHR_BITSET(pfs_bmp, 54);
                            break;
                        case 14:
                            SHR_BITSET(pfs_bmp, 55);
                            break;
                        case 26:
                            SHR_BITSET(pfs_bmp, 56);
                            break;
                        case 27:
                            SHR_BITSET(pfs_bmp, 57);
                            break;
                        case 28:
                            SHR_BITSET(pfs_bmp, 58);
                            break;
                        case 29:
                            SHR_BITSET(pfs_bmp, 59);
                            break;
                        case 30:
                            SHR_BITSET(pfs_bmp, 60);
                            break;
                        case 31:
                            SHR_BITSET(pfs_bmp, 61);
                            break;
                        case 0:
                            SHR_BITSET(pfs_bmp, 62);
                            break;
                        default:
                            ;
                    }
                }
            }
        }
    }
#endif
#if defined(BCM_TRIUMPH_SUPPORT)
    /* FPF programming for loopback port.*/
    if (soc_feature(unit, soc_feature_lport_tab_profile)) {
        SHR_BITSET(pfs_bmp,
                   soc_mem_index_max(unit, FP_PORT_FIELD_SELm) - 1);
        /*
         * The last index in FP_PORT_FIELD_SEL is dedicated to WLAN,
         * Include Loopback Port in the PBMP.
         */
        SHR_BITSET(pfs_bmp,
                   soc_mem_index_max(unit, FP_PORT_FIELD_SELm));
    }
#endif /* BCM_TRIUMPH_SUPPORT */
    return (rv);
}
/*
 * Function:
 *     _field_trx_ingress_selcodes_install
 *
 * Purpose:
 *     Writes the field select codes (ie. FPFx).
 *
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     fg            - (IN) Field group.
 *     slice_numb    - (IN) Slice number group installed in.
 *     pbmp          - (IN) Group  active port bit map.
 *     selcode_index - (IN) Index into select codes array.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_ingress_selcodes_install(int unit, _field_group_t *fg,
                                    uint8 slice_num, bcm_pbmp_t *pbmp,
                                    int selcode_index)
{
    _field_stage_t   *stage_fc;
    bcm_port_t       idx;                   /* Device pfs indexes iterator.*/
    uint32           buf[SOC_MAX_MEM_FIELD_WORDS];/* HW entry buffer.      */
    SHR_BITDCL       *pfs_bmp;              /* PFS bitmap.                 */
    int              pfs_idx_count;         /* PFS index count.            */
    _field_sel_t     *sel;                  /* Group field selectors.      */
    soc_field_t      fld;                   /* Port field select field.    */
    uint32           value;                 /* Per slice selector.         */
    int              rv;                    /* Operation return status.    */
    int              ingress_entity = _FP_SELCODE_DONT_CARE;
    soc_reg_t        double_wide_reg;

    /* Input parameters check. */

    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    if (slice_num >= stage_fc->tcam_slices) {
        return (BCM_E_PARAM);
    }

    sel = &fg->sel_codes[selcode_index];

    /* Get port field select table size and allocated bitmap of indexes
     * applicable to the group.
     */
    pfs_bmp = NULL;
    pfs_idx_count = soc_mem_index_count(unit, FP_PORT_FIELD_SELm);
    _FP_XGS3_ALLOC(pfs_bmp,
                   MAX(SHR_BITALLOCSIZE(pfs_idx_count), sizeof(bcm_pbmp_t)),
                   "PFS bmp");
    if (NULL == pfs_bmp) {
        return (BCM_E_MEMORY);
    }

    /* Populate pfs indexes applicable for the group. */
    rv = _bcm_field_trx_ingress_pfs_bmap_get(unit, fg, pbmp,
                                             selcode_index, pfs_bmp);
    if (BCM_FAILURE(rv)) {
        sal_free(pfs_bmp);
        return (rv);
    }

    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
        ((selcode_index == 1) || (selcode_index == 3))) {

        /* Write appropriate values in FP_DOUBLE_WIDE_F4_SELECTr and */
        if (SOC_IS_KATANA2(unit)) {
            double_wide_reg = FP_DOUBLE_WIDE_SELECTr;
            if (sel->fpf1 != _FP_SELCODE_DONT_CARE) {
                /*
                 * F1.0 - L4
                 * F1.1 - MPLS
                 */
                rv = soc_reg_field32_modify(unit, double_wide_reg,
                         REG_PORT_ANY, _bcm_field_trx_dw_f1_sel[slice_num],
                         sel->fpf1);
                if (BCM_FAILURE(rv)) {
                    sal_free(pfs_bmp);
                    return (rv);
                }
            }
        } else {
            double_wide_reg = FP_DOUBLE_WIDE_F4_SELECTr;
        }
        if ((sel->fpf4 != _FP_SELCODE_DONT_CARE) &&
            SOC_REG_FIELD_VALID(unit, double_wide_reg,
                                _bcm_field_trx_dw_f4_sel[slice_num])) {
            rv = soc_reg_field32_modify(unit, double_wide_reg,
                                        REG_PORT_ANY,
                                        _bcm_field_trx_dw_f4_sel[slice_num],
                                        sel->fpf4);
            if (BCM_FAILURE(rv)) {
                sal_free(pfs_bmp);
                return (rv);
            }
        }

        if ((sel->fpf1 != _FP_SELCODE_DONT_CARE) &&
            SOC_REG_FIELD_VALID(unit, FP_DOUBLE_WIDE_F1_SELECTr,
                                _bcm_field_trx_dw_f1_sel[slice_num])) {
            rv = soc_reg_field32_modify(unit, FP_DOUBLE_WIDE_F1_SELECTr,
                                        REG_PORT_ANY,
                                        _bcm_field_trx_dw_f1_sel[slice_num],
                                        sel->fpf1);
            if (BCM_FAILURE(rv)) {
                sal_free(pfs_bmp);
                return (rv);
            }
        }

        if ((sel->fpf2 != _FP_SELCODE_DONT_CARE) &&
            SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm,
                                _trx_ifp_double_wide_key[slice_num])) {
            /* Do the same thing for each entry in FP_PORT_FIELD_SEL table */
            for (idx = 0; idx < pfs_idx_count; idx++) {
                if (0 == SHR_BITGET(pfs_bmp, idx)) {
                    continue;
                }
                sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
                rv = soc_mem_read(unit, FP_PORT_FIELD_SELm, MEM_BLOCK_ANY,
                                  idx, buf);
                if (BCM_FAILURE(rv)) {
                    sal_free(pfs_bmp);
                    return (rv);
                }
                soc_mem_field32_set(unit, FP_PORT_FIELD_SELm, buf,
                                    _trx_ifp_double_wide_key[slice_num],
                                    sel->fpf2);




                rv = soc_mem_write(unit, FP_PORT_FIELD_SELm, MEM_BLOCK_ALL,
                                   idx, buf);
                if (BCM_FAILURE(rv)) {
                    sal_free(pfs_bmp);
                    return (rv);
                }
            }
        }
    } else {
        /* Iterate over all ports */
        for (idx = 0; idx < pfs_idx_count; idx++) {

            sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
            /* Read Port's current entry in FP_PORT_FIELD_SEL table */
            rv = soc_mem_read(unit, FP_PORT_FIELD_SELm, MEM_BLOCK_ANY, idx, buf);
            if (BCM_FAILURE(rv)) {
                sal_free(pfs_bmp);
                return (rv);
            }
            /* Set slice mode. */
            fld = _bcm_field_trx_slice_wide_mode_field[slice_num];
            if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm, fld)) {
                value = (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) ? 1 : 0;
                soc_FP_PORT_FIELD_SELm_field32_set(unit, buf, fld, value);
            }

            /* Set inter slice pair mode.  */
            value = (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ? 1 : 0;
            fld = _bcm_field_trx_slice_pairing_field[slice_num / 2];
            soc_FP_PORT_FIELD_SELm_field32_set(unit, buf, fld, value);

            if (0 == SHR_BITGET(pfs_bmp, idx)) {
                if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)
                        || (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)) {
                    /* Write each port's new entry */
                    rv = soc_mem_write(unit, FP_PORT_FIELD_SELm,
                            MEM_BLOCK_ALL, idx, buf);
                    if (BCM_FAILURE(rv)) {
                        sal_free(pfs_bmp);
                        return (rv);
                    }
                }
                continue;
            }

            /* modify 0-3 fields depending on state of SELCODE_INVALID */
            if (sel->fpf1 != _FP_SELCODE_DONT_CARE) {
                soc_mem_field32_set(unit,
                                    FP_PORT_FIELD_SELm, buf,
                                    _bcm_field_trx_field_sel[slice_num][0],
                                    sel->fpf1);
            }

            if (sel->fpf2 != _FP_SELCODE_DONT_CARE) {
                soc_mem_field32_set(unit,
                                    FP_PORT_FIELD_SELm, buf,
                                    _bcm_field_trx_field_sel[slice_num][1],
                                    sel->fpf2);
            }
            if (sel->fpf3 != _FP_SELCODE_DONT_CARE) {
                soc_mem_field32_set(unit,
                                    FP_PORT_FIELD_SELm, buf,
                                    _bcm_field_trx_field_sel[slice_num][2],
                                    sel->fpf3);
            }

            /* Set destination forwarding type selection. */
            if (sel->dst_fwd_entity_sel != _FP_SELCODE_DONT_CARE) {
                switch (sel->dst_fwd_entity_sel) {
                case _bcmFieldFwdEntityMultipath:
                    value = 7;
                    break;
                case _bcmFieldFwdEntityMplsGport:
                case _bcmFieldFwdEntityNivGport:
                case _bcmFieldFwdEntityCommonGport: /* for DstGport*/
                case _bcmFieldFwdEntityMimGport:
                case _bcmFieldFwdEntityWlanGport:
                case _bcmFieldFwdEntityVxlanGport:
                case _bcmFieldFwdEntityVlanGport:
                    value = 3;
                    break;
                case _bcmFieldFwdEntityMulticastGroup:
                    value = 2;
                    break;
                case _bcmFieldFwdEntityL3Egress:
                    value = 1;
                    break;
                default:
                    value = 0;
                    break;
                }
                if (SOC_MEM_FIELD_VALID(unit,
                        FP_PORT_FIELD_SELm,
                        _bcm_field_trx_d_type_sel[slice_num]
                        )
                    ) {
                    soc_mem_field32_set(unit,
                        FP_PORT_FIELD_SELm,
                        buf,
                        _bcm_field_trx_d_type_sel[slice_num],
                        value
                        );
                }
            }

            /* Set source entity type selection. */
            if (sel->src_entity_sel != _FP_SELCODE_DONT_CARE) {
                ingress_entity = sel->src_entity_sel;
            } else if (sel->ingress_entity_sel != _FP_SELCODE_DONT_CARE) {
                ingress_entity = sel->ingress_entity_sel;
            }

            if (ingress_entity != _FP_SELCODE_DONT_CARE) {
                switch (ingress_entity) {
                  case _bcmFieldFwdEntityMplsGport:
                  case _bcmFieldFwdEntityNivGport:
                  case _bcmFieldFwdEntityMimGport:
                  case _bcmFieldFwdEntityWlanGport:
                  case _bcmFieldFwdEntityVxlanGport:
                  case _bcmFieldFwdEntityVlanGport:
                      value = 3;
                      break;
                  case _bcmFieldFwdEntityModPortGport:
                      value = 2;
                      break;
                  case _bcmFieldFwdEntityGlp:
                      value = 1;
                      break;
                  case _bcmFieldFwdEntityCommonGport:
                      /* Value 0 supports SVP (or) SGLP.
                       * CommonGport can be VP or GLP.
                       */
                  default:
                      value = 0;
                      break;
                }
                if (SOC_MEM_FIELD_VALID(unit,
                         FP_PORT_FIELD_SELm,
                        _bcm_field_trx_s_type_sel[slice_num]
                        )
                    ) {
                    soc_mem_field32_set
                        (unit,
                         FP_PORT_FIELD_SELm,
                         buf,
                         _bcm_field_trx_s_type_sel[slice_num],
                         value
                         );
                }
            }

            /* Write each port's new entry */
            rv = soc_mem_write(unit, FP_PORT_FIELD_SELm,
                               MEM_BLOCK_ALL, idx, buf);
            if (BCM_FAILURE(rv)) {
                sal_free(pfs_bmp);
                return (rv);
            }
        }
    }
    sal_free(pfs_bmp);

    /* Set VRF Force Forwarding Enable Field */
    if (sel->fwd_field_sel != _FP_SELCODE_DONT_CARE) {
        if (_bcmFieldFwdFieldVrf == sel->fwd_field_sel) {
            rv = soc_reg_field32_modify(unit, FP_FORCE_FORWARDING_FIELDr,
                    REG_PORT_ANY,
                    _bcm_trx2_vrf_force_forwarding_enable_field[slice_num], 1);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    /* Update FP_SLICE_KEY_CONTROL memory entry. */
    sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
    rv = soc_mem_read(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ANY, 0, buf);
    BCM_IF_ERROR_RETURN(rv);


    /* Set source class select field. */
    if (sel->src_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_src_class_id_sel[slice_num],
                            sel->src_class_sel);
    }
    /* Set destination class select field. */
    if (sel->dst_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_dst_class_id_sel[slice_num],
                            sel->dst_class_sel);
    }

    /* Set interface class select field. */
    if (sel->intf_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_interface_class_id_sel[slice_num],
                            sel->intf_class_sel);
    }

    /* Set Ttl class select field. */
    if (sel->ttl_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_ttl_slice_control_enable_field[slice_num],
                            sel->ttl_class_sel);
    }

    /* Set Tcp class select field. */
    if (sel->tcp_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_tcp_slice_control_enable_field[slice_num],
                            sel->tcp_class_sel);
    }

    /* Set Tos class select field. */
    if (sel->tos_class_sel != _FP_SELCODE_DONT_CARE) {
        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _trx_tos_slice_control_enable_field[slice_num],
                            sel->tos_class_sel);
    }

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        if (sel->oam_overlay_sel != _FP_SELCODE_DONT_CARE) {
            switch (sel->oam_overlay_sel) {
                case _bcmFieldOamOverlayEnable:
                    value = 1;
                    break;
                case _bcmFieldOamOverlayDisable:
                    value = 0;
                    break;
                default:
                    return (BCM_E_INTERNAL);
            }
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _bcm_td2plus_oam_overlay_field[slice_num],
                    value
                    );
        }
    }
#endif

    if (sel->aux_tag_1_sel != _FP_SELCODE_DONT_CARE) {
        switch (sel->aux_tag_1_sel) {
        case _bcmFieldAuxTagAny:
            value = 0;
            break;
        case _bcmFieldAuxTagVn:
            value = 1;
            break;
        /* _bcmFieldAuxTagMimlHeader equals _bcmFieldAuxTagCn */
        case _bcmFieldAuxTagCn:
        /* case _bcmFieldAuxTagMimlHeader: */
            value = 2;
            break;
        /* _bcmFieldAuxTagCustomHeader equals _bcmFieldAuxTagFabricQueue */
        case _bcmFieldAuxTagFabricQueue:
        /* case _bcmFieldAuxTagCustomHeader: */
            value = 3;
            break;
        /* _bcmFieldAuxTagCapwapInfo equals _bcmFieldAuxTagMplsFwdingLabel */
        case _bcmFieldAuxTagMplsFwdingLabel:
        /* case _bcmFieldAuxTagCapwapInfo: */
            value = 4;
            break;
        case _bcmFieldAuxTagMplsCntlWord:
            value = 5;
            break;
        case _bcmFieldAuxTagRtag7A:
            value = 6;
            break;
        case _bcmFieldAuxTagRtag7B:
            value = 7;
            break;
        case _bcmFieldAuxTagVxlanOrLLTag:
            value = 8;
            break;
        case _bcmFieldAuxTagVxlanReserved:
            value = 9;
            break;
        default:
            return (BCM_E_INTERNAL);
        }

        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _bcm_trx2_aux_tag_1_field[slice_num],
                            value
                            );
    }

    if (sel->aux_tag_2_sel != _FP_SELCODE_DONT_CARE) {
        switch (sel->aux_tag_2_sel) {
        case _bcmFieldAuxTagAny:
            value = 0;
            break;
        case _bcmFieldAuxTagVn:
            value = 1;
            break;
        /* _bcmFieldAuxTagMimlHeader equals _bcmFieldAuxTagCn */
        case _bcmFieldAuxTagCn:
        /* case _bcmFieldAuxTagMimlHeader: */
            value = 2;
            break;
        /* _bcmFieldAuxTagCustomHeader equals _bcmFieldAuxTagFabricQueue */
        case _bcmFieldAuxTagFabricQueue:
        /* case _bcmFieldAuxTagCustomHeader: */
            value = 3;
            break;
        /* _bcmFieldAuxTagCapwapInfo equals _bcmFieldAuxTagMplsFwdingLabel */
        case _bcmFieldAuxTagMplsFwdingLabel:
        /* case _bcmFieldAuxTagCapwapInfo: */
            value = 4;
            break;
        case _bcmFieldAuxTagMplsCntlWord:
            value = 5;
            break;
        case _bcmFieldAuxTagRtag7A:
            value = 6;
            break;
        case _bcmFieldAuxTagRtag7B:
            value = 7;
            break;
        case _bcmFieldAuxTagVxlanOrLLTag:
            value = 8;
            break;
        case _bcmFieldAuxTagVxlanReserved:
            value = 9;
            break;
        default:
            return (BCM_E_INTERNAL);
        }

        soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                            _bcm_trx2_aux_tag_2_field[slice_num],
                            value
                            );
    }

    rv = soc_mem_write(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ALL, 0, buf);
    return (rv);
}

/*
 * Function:
 *     _field_trx_ingress_slice_clear
 *
 * Purpose:
 *     Resets the IFP field slice configuration.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Field slice number.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_ingress_slice_clear(int unit, uint8 slice_numb)
{
    int                         index;
    int                         index_max;
    fp_port_field_sel_entry_t   pfs_entry;
    soc_field_t                 dw_fld;
    int                         rv;
    soc_reg_t                   double_wide_reg;
    uint32           buf[SOC_MAX_MEM_FIELD_WORDS];/* HW entry buffer. */

    /* clear FP_SLICE_KEY_CONTROL */
    if (SOC_MEM_IS_VALID(unit, FP_SLICE_KEY_CONTROLm)) {
        sal_memset(buf, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));
        rv = soc_mem_read(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ANY, 0, buf);
        BCM_IF_ERROR_RETURN(rv);

        /* Reset SrcClassId Selector */
        if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                    _trx_src_class_id_sel[slice_numb])) {
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _trx_src_class_id_sel[slice_numb], 0);
        }
        /* Reset DstClassId Selector */
        if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                    _trx_dst_class_id_sel[slice_numb])) {
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _trx_dst_class_id_sel[slice_numb], 0);
        }
        /* Reset IntfClassId Selector */
        if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                    _trx_interface_class_id_sel[slice_numb])) {
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _trx_interface_class_id_sel[slice_numb], 0);
        }
        /* Reset Oam Overlay Selector */
#if defined BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_fp_based_oam)) {
            if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                        _bcm_td2plus_oam_overlay_field[slice_numb])) {
                soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                        _bcm_td2plus_oam_overlay_field[slice_numb], 0);
            }
        }
#endif
        /* Reset AuxTag1 Field Selector */
        if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                    _bcm_trx2_aux_tag_1_field[slice_numb])) {
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _bcm_trx2_aux_tag_1_field[slice_numb], 0);
        }
        /* Reset AuxTag2 Field Selector */
        if (SOC_MEM_FIELD_VALID(unit, FP_SLICE_KEY_CONTROLm,
                    _bcm_trx2_aux_tag_2_field[slice_numb])) {
            soc_mem_field32_set(unit, FP_SLICE_KEY_CONTROLm, buf,
                    _bcm_trx2_aux_tag_2_field[slice_numb], 0);
        }
        /* Write into Hardware */
        rv = soc_mem_write(unit, FP_SLICE_KEY_CONTROLm, MEM_BLOCK_ALL, 0, buf);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Clear FP_PORT_FIELD_SEL*/
    /* Iterate over all indexes */
    index_max = soc_mem_index_max(unit, FP_PORT_FIELD_SELm);
    for (index = 0; index < index_max; index++) {
        /* Read Port's current entry in FP_PORT_FIELD_SEL table */
        rv = READ_FP_PORT_FIELD_SELm(unit, MEM_BLOCK_ALL,
                                     index, &pfs_entry);
        BCM_IF_ERROR_RETURN(rv);
        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][0],
             0
             );
        BCM_IF_ERROR_RETURN(rv);

        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][1],
             0
             );
        BCM_IF_ERROR_RETURN(rv);
        soc_FP_PORT_FIELD_SELm_field32_set
            (unit,
             &pfs_entry,
             _bcm_field_trx_field_sel[slice_numb][2],
             0
             );
        BCM_IF_ERROR_RETURN(rv);

        dw_fld = _trx_ifp_double_wide_key[slice_numb];
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm, dw_fld)) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry, dw_fld, 0);
        }

        dw_fld = _bcm_field_trx_slice_wide_mode_field[slice_numb];
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm, dw_fld)) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry, dw_fld, 0);
        }

        dw_fld = _bcm_field_trx_slice_pairing_field[slice_numb / 2];
        soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry, dw_fld, 0);

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm,
                    _bcm_ifp_normalize_fldtbl[slice_numb][0])) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry,
                    _bcm_ifp_normalize_fldtbl[slice_numb][0], 0);
        }
        if (SOC_MEM_FIELD_VALID(unit, FP_PORT_FIELD_SELm,
                    _bcm_ifp_normalize_fldtbl[slice_numb][1])) {
            soc_FP_PORT_FIELD_SELm_field32_set(unit, &pfs_entry,
                    _bcm_ifp_normalize_fldtbl[slice_numb][1], 0);
        }
#endif
        rv = WRITE_FP_PORT_FIELD_SELm(unit, MEM_BLOCK_ALL, index, &pfs_entry);
        BCM_IF_ERROR_RETURN(rv);
    }

    if (SOC_IS_KATANA2(unit)) {
        double_wide_reg = FP_DOUBLE_WIDE_SELECTr;
        dw_fld = _bcm_field_trx_dw_f1_sel[slice_numb];
        if (SOC_REG_FIELD_VALID(unit, double_wide_reg, dw_fld)) {
            rv = soc_reg_field32_modify(unit, double_wide_reg,
                                        REG_PORT_ANY, dw_fld,  0);
            BCM_IF_ERROR_RETURN(rv);
        }
    } else {
        double_wide_reg = FP_DOUBLE_WIDE_F4_SELECTr;
    }
    dw_fld = _bcm_field_trx_dw_f4_sel[slice_numb];
    if (SOC_REG_FIELD_VALID(unit, double_wide_reg, dw_fld)) {
        rv = soc_reg_field32_modify(unit, double_wide_reg,
                                    REG_PORT_ANY, dw_fld,  0);
        BCM_IF_ERROR_RETURN(rv);
    }

    dw_fld = _bcm_field_trx_dw_f1_sel[slice_numb];
    if (SOC_REG_FIELD_VALID(unit, FP_DOUBLE_WIDE_F1_SELECTr, dw_fld)) {
        rv = soc_reg_field32_modify(unit, FP_DOUBLE_WIDE_F1_SELECTr,
                                    REG_PORT_ANY, dw_fld,  0);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Clear VRF Force Forwarding Enable Field */
    if (SOC_REG_FIELD_VALID(unit, FP_FORCE_FORWARDING_FIELDr,
                _bcm_trx2_vrf_force_forwarding_enable_field[slice_numb])) {
        rv =  soc_reg_field32_modify(unit, FP_FORCE_FORWARDING_FIELDr,
                    REG_PORT_ANY,
                    _bcm_trx2_vrf_force_forwarding_enable_field[slice_numb], 0);
            BCM_IF_ERROR_RETURN(rv);
    }
    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_trx_lookup_selcodes_install
 *
 * Purpose:
 *     Writes the field select codes (ie. FPFx).
 *     for VFP (_BCM_FIELD_STAGE_LOOKUP) lookup stage.
 *
 * Parameters:
 *     unit  - BCM device number
 *     fs    - slice that needs its select codes written
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_lookup_selcodes_install(int unit, _field_group_t *fg,
                                   uint8 slice_numb, int selcode_index)
{
    uint32        reg_val;
    _field_sel_t  *sel;
    int           rv;
    sel = &fg->sel_codes[selcode_index];

    rv = READ_VFP_KEY_CONTROLr(unit, &reg_val);
    BCM_IF_ERROR_RETURN(rv);

    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) &&
        (selcode_index % 2)) {
        if (sel->fpf2 != _FP_SELCODE_DONT_CARE) {
            soc_reg_field_set(unit,
                              VFP_KEY_CONTROLr,
                              &reg_val,
                              _bcm_field_trx_vfp_double_wide_sel[slice_numb],
                              sel->fpf2
                              );
        }
    } else {
        if (sel->fpf2 != _FP_SELCODE_DONT_CARE) {
            soc_reg_field_set(unit,
                              VFP_KEY_CONTROLr,
                              &reg_val,
                              _bcm_field_trx_vfp_field_sel[slice_numb][0],
                              sel->fpf2
                              );
        }
        if (sel->fpf3 != _FP_SELCODE_DONT_CARE) {
            soc_reg_field_set(unit,
                              VFP_KEY_CONTROLr,
                              &reg_val,
                              _bcm_field_trx_vfp_field_sel[slice_numb][1],
                              sel->fpf3
                              );
        }
    }
    rv = WRITE_VFP_KEY_CONTROLr(unit, reg_val);
    BCM_IF_ERROR_RETURN(rv);

    /* Set inner/outer ip header selection. */
    if (sel->ip_header_sel != _FP_SELCODE_DONT_CARE) {
        rv = soc_reg_field32_modify(unit,
                                    VFP_KEY_CONTROL_2r,
                                    REG_PORT_ANY,
                                    _bcm_field_trx_vfp_ip_header_sel[slice_numb],
                                    sel->ip_header_sel
                                    );
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA(unit)) {
       if (sel->src_entity_sel != _FP_SELCODE_DONT_CARE) {
          rv = soc_reg_field32_modify(unit, VFP_KEY_CONTROL_2r, REG_PORT_ANY,
                                    _trx_vfp_src_type_sel[slice_numb],
                         sel->src_entity_sel == _bcmFieldFwdEntityGlp ? 1 : 0);
       }
    }

    if (SOC_IS_KATANA2(unit)) {
       if (sel->src_type_sel != _FP_SELCODE_DONT_CARE) {
          rv = soc_reg_field32_modify(unit, VFP_KEY_CONTROL_1r, REG_PORT_ANY,
                                    _trx_vfp_src_type_sel[slice_numb],
                            sel->src_type_sel == _bcmFieldFwdEntityGlp ? 1 :0);
       }
    }
#endif
    return (rv);
}

/*
 * Function:
 *     _field_trx_lookup_slice_clear
 *
 * Purpose:
 *     Reset slice configuraton on group deletion event.
 *
 * Parameters:
 *     unit  - BCM device number
 *     fs    - slice that needs its select codes written
 *
 * Returns:
 *     BCM_E_NONE     - Success
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
STATIC int
_field_trx_lookup_slice_clear(int unit, uint8 slice_numb)
{
    uint32 reg_val;
    int    rv;

    SOC_IF_ERROR_RETURN(READ_VFP_KEY_CONTROLr(unit, &reg_val));
    soc_reg_field_set(unit,
                      VFP_KEY_CONTROLr,
                      &reg_val,
                      _bcm_field_trx_vfp_double_wide_sel[slice_numb],
                      0
                      );
    soc_reg_field_set(unit,
                      VFP_KEY_CONTROLr,
                      &reg_val,
                      _bcm_field_trx_vfp_field_sel[slice_numb][0],
                      0
                      );
    soc_reg_field_set(unit,
                      VFP_KEY_CONTROLr,
                      &reg_val,
                      _bcm_field_trx_vfp_field_sel[slice_numb][1],
                      0
                      );
    soc_reg_field_set(unit,
                      VFP_KEY_CONTROLr,
                      &reg_val,
                      _bcm_field_trx_slice_pairing_field[slice_numb / 2],
                      0
                      );
    SOC_IF_ERROR_RETURN(WRITE_VFP_KEY_CONTROLr(unit, reg_val));

    rv = soc_reg_field32_modify(unit,
                                VFP_KEY_CONTROL_2r,
                                REG_PORT_ANY,
                                _bcm_field_trx_vfp_ip_header_sel[slice_numb],
                                0
                                );
    if (SOC_IS_KATANA(unit)) {
       rv = soc_reg_field32_modify(unit, VFP_KEY_CONTROL_2r, REG_PORT_ANY,
                                    _trx_vfp_src_type_sel[slice_numb], 0);
    }

    if (SOC_IS_KATANA2(unit)) {
      rv = soc_reg_field32_modify(unit, VFP_KEY_CONTROL_1r, REG_PORT_ANY,
                                    _trx_vfp_src_type_sel[slice_numb], 0);
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_trx_slice_clear
 *
 * Purpose:
 *     Clear slice configuration on group removal
 *
 * Parameters:
 *     unit  - BCM device number
 *     fg    - Field group slice belongs to
 *     fs    - Field slice structure.
 *
 * Returns:
 *     BCM_E_XXX
 *
 */
int
_bcm_field_trx_slice_clear(int unit, _field_group_t *fg, _field_slice_t *fs)
{
    int rv;

    switch (fs->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
          rv = _bcm_field_trx_ingress_slice_clear(unit, fs->slice_number);
          break;
      case _BCM_FIELD_STAGE_LOOKUP:
          rv = _field_trx_lookup_slice_clear(unit, fs->slice_number);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          rv = _bcm_field_trx_egress_slice_clear(unit, fs->slice_number);
          break;
#if defined(BCM_TRIUMPH_SUPPORT)
      case _BCM_FIELD_STAGE_EXTERNAL:
          rv = _bcm_field_tr_external_slice_clear(unit, fg);
          break;
#endif /* BCM_TRIUMPH_SUPPORT */
      default:
          rv = BCM_E_INTERNAL;
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_trx_selcodes_install
 *
 * Purpose:
 *     Writes the field select codes (ie. FPFx).
 *
 * Parameters:
 *     unit  - BCM device number
 *     fs    - slice that needs its select codes written
 *
 * Returns:
 *     BCM_E_INTERNAL - On read/write errors
 *     BCM_E_NONE     - Success
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_trx_selcodes_install(int unit, _field_group_t *fg,
                                uint8 slice_numb, bcm_pbmp_t pbmp,
                                int selcode_index)
{
    int rv;    /* Operation return status. */

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Set slice mode. Single/Double/Triple, Intraslice */
    rv = _bcm_field_trx_mode_set(unit, slice_numb, fg, fg->flags);
    BCM_IF_ERROR_RETURN(rv);

    switch (fg->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
          rv = _bcm_field_trx_ingress_selcodes_install(unit, fg, slice_numb,
                                                       &pbmp, selcode_index);
          break;
      case _BCM_FIELD_STAGE_LOOKUP:
          rv = _bcm_field_trx_lookup_selcodes_install(unit, fg, slice_numb,
                                                  selcode_index);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
      case _BCM_FIELD_STAGE_EXTERNAL:
          rv = (BCM_E_NONE);
          break;
      default:
          rv = (BCM_E_PARAM);
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_trx_qual_lists_get
 * Purpose:
 *     Build a group's qualifiers array by assembling
 *     qualifiers from each select code.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_fc  - (IN) Stage field control structure.
 *     fg        - (IN) Group control structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_qual_lists_get(int unit, _field_stage_t *stage_fc,
                             _field_group_t *fg)
{
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_trx_tcam_get
 * Purpose:
 *    Get the rules to be written into tcam.
 * Parameters:
 *     unit      -  (IN) BCM device number.
 *     tcam_mem  -  (IN) TCAM memory
 *     f_ent     -  (IN)  Field entry structure to get tcam info from.
 *     buf       -  (OUT) TCAM entry
 * Returns:
 *     BCM_E_NONE  - Success
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_trx_tcam_get(int unit, soc_mem_t mem,
                        _field_entry_t *f_ent, uint32 *buf)
{
    soc_field_t         key_field, mask_field;
    _field_tcam_t       *tcam;
    _field_group_t      *fg;
    uint32 valid_value = 0;

    fg = f_ent->group;

    if (_BCM_FIELD_STAGE_INGRESS == fg->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
        if (mem == FP_GM_FIELDSm) {
            valid_value = 1;
            tcam = &f_ent->extra_tcam;
            key_field = KEYf;
            mask_field = MASKf;
        } else
#endif /* BCM_TRIDENT_SUPPORT */
        if ((SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_KATANAX(unit))
             && FP_GLOBAL_MASK_TCAMm == mem) {
        if (SOC_IS_KATANAX(unit)) {
                valid_value = SOC_IS_KATANA2(unit) ? 3: 1;
            }
            tcam = &f_ent->extra_tcam;
            key_field = IPBMf;
            mask_field = IPBM_MASKf;
        } else {
            valid_value = (fg->flags & _FP_GROUP_LOOKUP_ENABLED) ? 3 : 2;
            tcam = &f_ent->tcam;
        /* Intra-slice double wide key */
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                key_field = KEYf;
                mask_field = MASKf;
            } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_HURRICANE2_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
            if (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
                SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
               key_field = DATA_KEYf;
               mask_field = DATA_MASKf;
            } else
#endif
            {
                key_field = DATAf;
                mask_field = DATA_MASKf;
            }
        }

        if (soc_mem_field_valid(unit, mem, VALIDf)) {
            soc_mem_field32_set(unit, mem, buf, VALIDf, valid_value);
        }
        soc_mem_field_set(unit, mem, buf, key_field, tcam->key);
        soc_mem_field_set(unit, mem, buf, mask_field, tcam->mask);
    } else {
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            if (_BCM_FIELD_STAGE_EGRESS == fg->stage_id &&
               (f_ent->efp_key_match_type)) {
                tcam = &f_ent->key_match_tcam;
            } else {
                tcam = &f_ent->tcam;
            }
        } else
#endif
        {
            tcam = &f_ent->tcam;
        }
        if (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) {
            mask_field = MASKf;
        } else if (_BCM_FIELD_STAGE_EGRESS == fg->stage_id) {
            mask_field = KEY_MASKf;
        } else {
            return (BCM_E_PARAM);
        }

        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
            && (_BCM_FIELD_STAGE_EGRESS == fg->stage_id)) {
            soc_mem_field32_set(unit, mem, buf, KEY_SPAREf, 0);
            soc_mem_field32_set(unit, mem, buf, KEY_MASK_SPAREf, 0);
        }

        soc_mem_field_set(unit, mem, buf, KEYf, tcam->key);
        soc_mem_field_set(unit, mem, buf, mask_field, tcam->mask);
        soc_mem_field32_set(unit, mem, buf, VALIDf,
                            (fg->flags & _FP_GROUP_LOOKUP_ENABLED) ? 3 : 2);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_tcp_ttl_tos_init
 * Purpose:
 *     Initialize the TCP_FN, TTL_FN and TOS_FN tables
 * Parameters:
 *     unit       - (IN) BCM device number.
 * Returns:
 *     BCM_E_NONE
 * Notes:
 */
int
_bcm_field_trx_tcp_ttl_tos_init(int unit)
{
    int i;
    tcp_fn_entry_t tcp_entry;
    ttl_fn_entry_t ttl_entry;
    tos_fn_entry_t tos_entry;

    if (SOC_WARM_BOOT(unit)) {
        return (BCM_E_NONE);
    }

    sal_memset(&tcp_entry, 0, sizeof(tcp_fn_entry_t));
    sal_memset(&ttl_entry, 0, sizeof(ttl_fn_entry_t));
    sal_memset(&tos_entry, 0, sizeof(tos_fn_entry_t));

    /* TCP_FN table */
    for (i = soc_mem_index_min(unit, TCP_FNm);
         i <= soc_mem_index_max(unit, TCP_FNm); i++) {

        soc_mem_field32_set(unit, TCP_FNm, &tcp_entry, FN0f, i);
        soc_mem_field32_set(unit, TCP_FNm, &tcp_entry, FN1f, i);

        soc_mem_write(unit, TCP_FNm, MEM_BLOCK_ALL, i, &tcp_entry);
    }

    /* TTL_FN table */
    for (i = soc_mem_index_min(unit, TTL_FNm);
         i <= soc_mem_index_max(unit, TTL_FNm); i++) {

        soc_mem_field32_set(unit, TTL_FNm, &ttl_entry, FN0f, i);
        soc_mem_field32_set(unit, TTL_FNm, &ttl_entry, FN1f, i);

        soc_mem_write(unit, TTL_FNm, MEM_BLOCK_ALL, i, &ttl_entry);
    }

    /* TOS_FN table */
    for (i = soc_mem_index_min(unit, TOS_FNm);
         i <= soc_mem_index_max(unit, TOS_FNm); i++) {

        soc_mem_field32_set(unit, TOS_FNm, &tos_entry, FN0f, i);
        soc_mem_field32_set(unit, TOS_FNm, &tos_entry, FN1f, i);

        soc_mem_write(unit, TOS_FNm, MEM_BLOCK_ALL, i, &tos_entry);
    }

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* PAYLOAD_TOS_FN table */
        for (i = soc_mem_index_min(unit, PAYLOAD_TOS_FNm);
             i <= soc_mem_index_max(unit, PAYLOAD_TOS_FNm); i++) {

            soc_mem_field32_set(unit, PAYLOAD_TOS_FNm, &tos_entry, FN0f, i);
            soc_mem_field32_set(unit, PAYLOAD_TOS_FNm, &tos_entry, FN1f, i);

            soc_mem_write(unit, PAYLOAD_TOS_FNm, MEM_BLOCK_ALL, i, &tos_entry);
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_trx_write_slice_map_egress
 *
 * Purpose:
 *     Write the EFP_SLICE_MAP (EGRESS)
 *
 * Parameters:
 *     unit
 *     stage_fc - pointer to stage control block
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 */
int
_bcm_field_trx_write_slice_map_egress(int unit, _field_stage_t *stage_fc)
{
    soc_field_t field;               /* HW entry fields.         */
    uint32 map_entry;                /* HW entry buffer.         */
    int vmap_size;                   /* Virtual map index count. */
    uint32 value;                    /* Field entry value.       */
    int idx;                         /* Map fields iterator.     */
    int rv;                          /* Operation return status. */

    uint32 virtual_to_physical_map[] = {
        VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf};
    uint32 virtual_to_group_map[] = {
        VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf};

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    rv = READ_EFP_SLICE_MAPr(unit, &map_entry);
    BCM_IF_ERROR_RETURN(rv);
    for (idx = 0; idx < vmap_size; idx++) {
        value = (stage_fc->vmap[_FP_DEF_INST][_FP_VMAP_DEFAULT][idx]).vmap_key;
        field = virtual_to_physical_map[idx];
        soc_reg_field_set(unit, EFP_SLICE_MAPr, &map_entry, field, value);

        value = (stage_fc->vmap[_FP_DEF_INST][_FP_VMAP_DEFAULT][idx]).virtual_group;
        field = virtual_to_group_map[idx];
        soc_reg_field_set(unit, EFP_SLICE_MAPr, &map_entry, field, value);
    }

    rv = WRITE_EFP_SLICE_MAPr(unit, map_entry);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_write_slice_map_vfp
 *
 * Purpose:
 *     Write the VFP_SLICE_MAP (LOOKUP)
 *
 * Parameters:
 *     unit
 *     stage_fc - pointer to stage control block
 *
 * Returns:
 *     BCM_E_XXX
 *
 */
int
_bcm_field_trx_write_slice_map_vfp(int unit, _field_stage_t *stage_fc)
{
    soc_field_t field;               /* HW entry fields.         */
    uint32 map_entry;                /* HW entry buffer.         */
    int vmap_size;                   /* Virtual map index count. */
    uint32 value;                    /* Field entry value.       */
    int idx;                         /* Map fields iterator.     */
    int rv;                          /* Operation return status. */

    uint32 virtual_to_physical_map[] = {
        VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf};
    uint32 virtual_to_group_map[] = {
        VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf};

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    rv = READ_VFP_SLICE_MAPr(unit, &map_entry);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < vmap_size; idx++) {
        value = (stage_fc->vmap[_FP_DEF_INST][_FP_VMAP_DEFAULT][idx]).vmap_key;
        field = virtual_to_physical_map[idx];
        soc_reg_field_set(unit, VFP_SLICE_MAPr, &map_entry, field, value);

        value = (stage_fc->vmap[_FP_DEF_INST][_FP_VMAP_DEFAULT][idx]).virtual_group;
        field = virtual_to_group_map[idx];
        soc_reg_field_set(unit, VFP_SLICE_MAPr, &map_entry, field, value);
    }

    rv = WRITE_VFP_SLICE_MAPr(unit, map_entry);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}


#ifdef INCLUDE_L3
/*
 * Function:
 *     _field_trx_policy_set_l3_info
 * Purpose:
 *     Install l3 forwarding policy entry.
 * Parameters:
 *     unit      - (IN) BCM device number
 *     mem       - (IN) Policy table memory.
 *     value     - (IN) Egress object id or combined next hop information.
 *     buf       - (IN/OUT) Hw entry buffer to write.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_policy_set_l3_info(int unit, soc_mem_t mem, int value, uint32 *buf)
{
    uint32 flags;         /* L3 forwarding flags           */
    int nh_ecmp_id;       /* Next hop/Ecmp group id.       */
    int retval;           /* Operation return value.       */

    /* Resove next hop /ecmp group id. */
    retval = _bcm_field_policy_set_l3_nh_resolve(unit,  value,
                                                 &flags, &nh_ecmp_id);
    BCM_IF_ERROR_RETURN(retval);

    if (flags & BCM_L3_MULTIPATH) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: Install mpath L3 policy (Ecmp_group: %d)))"),
                   unit, nh_ecmp_id));
        PolicySet(unit, mem, buf, ECMPf, 1);
        PolicySet(unit, mem, buf, ECMP_PTRf, nh_ecmp_id);
    } else {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: Install unipath L3 policy(Next hop id: %d)))"),
                   unit, nh_ecmp_id));
        if (SOC_MEM_FIELD_VALID(unit, mem, ECMPf)) {
            PolicySet(unit, mem, buf, ECMPf, 0);
        }
        PolicySet(unit, mem, buf, NEXT_HOP_INDEXf, nh_ecmp_id);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_policy_egr_nexthop_info_set
 * Purpose:
 *     Set next hop redirection value in the policy table entry.
 * Parameters:
 *     unit      - (IN) BCM device number
 *     mem       - (IN) Policy table memory.
 *     value     - (IN) Egress object id or combined next hop information.
 *     buf       - (IN/OUT) Hw entry buffer to write.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_policy_egr_nexthop_info_set(int unit, soc_mem_t mem,
    int value, uint32 *buf)
{
    uint32 redirect_to_nhi = 0; /* Hw config + (ECMP or NH Info)    */
    uint32 flags;               /* L3 forwarding flags.             */
    int nh_ecmp_id;             /* Next hop/Ecmp group id.          */

    /* Resove next hop /ecmp group id. */
    BCM_IF_ERROR_RETURN(_bcm_field_policy_set_l3_nh_resolve(unit,  value,
            &flags, &nh_ecmp_id));

    /* Check if NextHop is ECMP or regular Next Hop */
    if (flags & BCM_L3_MULTIPATH) {
        /* ECMP next hop */
        if (soc_feature(unit, soc_feature_field_action_redirect_ecmp)) {
            if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                redirect_to_nhi = (0x3 << 18) | nh_ecmp_id;
            } else if (SOC_IS_KATANAX(unit)) {
                redirect_to_nhi = (0x2 << 16) | nh_ecmp_id;
            } else {
                redirect_to_nhi = (0x3 << 16) | nh_ecmp_id;
            }
        } else {
            /* Non-Trident devices do not support redirect to ECMP action */
            return (BCM_E_UNAVAIL);
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: Set ECMP (Group id: %d\n)))"),
                   unit, nh_ecmp_id));
    } else {
        /* Regular next hop */
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
            redirect_to_nhi = (0x2 << 18) | nh_ecmp_id;
        } else if (SOC_IS_TD_TT(unit)) {
            redirect_to_nhi = (0x2 << 16) | nh_ecmp_id;
        } else if (SOC_IS_KATANAX(unit) || SOC_IS_GREYHOUND2(unit)) {
            redirect_to_nhi = (0x1 << 16) | nh_ecmp_id;
        } else if (SOC_IS_HURRICANE3(unit)) {
            redirect_to_nhi = (0x1 << 15) | nh_ecmp_id;
        } else {
            redirect_to_nhi = (0x1 << 14) | nh_ecmp_id;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) vverb: Set unipath (Nexthop index: %d\n)))"),
                   unit, nh_ecmp_id));
    }

    /* Set policy table redirection fields */
    PolicySet(unit, mem, buf, REDIRECTIONf, redirect_to_nhi);
    PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 1);
    return (BCM_E_NONE);
}
#endif /* INCLUDE_L3 */

/*
 * Function:
 *     _field_trx_action_fabricQueue_actions_set
 * Purpose:
 *     Install add fabric tag action
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     cosq_idx  - (IN) cosq index or (ucast_queue_group/ucast_subscriber) cosq gport
 *     profile_idx - (IN) QoS map profile index
 *     buf      - (IN/OUT) Hw entry buffer to write.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_action_fabricQueue_actions_set(int unit, soc_mem_t mem, _field_action_t *fa,
                                     uint32 *buf)
{
    int traffic_manager;  /* Indicates the intended application for the
                            SBX_QUEUE_TAG.0x0-Fabric Interface Chip.
                                          0x1 Traffic Manager.*/
    int tag_type;        /*  SBX tag type.                    */
    uint32 param0 = 0;
    uint32 in_flags = 0;
    uint32 cosq_idx;
#ifdef BCM_KATANA_SUPPORT
    bcm_port_t port;
    int queue_index = 0, mask = 0, param1 = 0, modid = 0;
    ing_queue_map_entry_t ing_queue_entry;
    uint32 profile_idx;
#endif
    int rv = BCM_E_NONE;

    if (NULL == buf || NULL == fa) {
        return (BCM_E_PARAM);
    }

    cosq_idx = fa->param[0];

    param0 = cosq_idx;

#if defined(BCM_KATANA_SUPPORT)
    profile_idx = fa->param[1];
    param1 = profile_idx;
    /* If param1 BCM_FABRIC_QUEUE_xxx flags are set then
    *  param0 is ucast_queu_group or ucast_subscriber_queue_group cosq gport
    */
    if (SOC_IS_KATANAX(unit)) {
        if ((param1 & BCM_FABRIC_QUEUE_DEST_OFFSET) ||
            (param1 & BCM_FABRIC_QUEUE_CUSTOMER)) {
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(param0) ||
                BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(param0) ||
                BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(param0)) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    BCM_IF_ERROR_RETURN(_bcm_kt2_cosq_index_resolve(unit,
                        param0, 0, _BCM_KT_COSQ_INDEX_STYLE_BUCKET,
                        &port, (int *)&cosq_idx, NULL));
                } else
#endif
                {
                    if (SOC_IS_KATANA(unit)) {
                        BCM_IF_ERROR_RETURN(_bcm_kt_cosq_index_resolve(unit,
                            param0, 0, _BCM_KT_COSQ_INDEX_STYLE_BUCKET,
                            &port, (int *)&cosq_idx, NULL));
                    }
                }
                in_flags = param1;
            } else {
                return BCM_E_PARAM;
            }
        } else {
            /* backward compatibility : API passing hw_index directly */
            BCM_IF_ERROR_RETURN(
                bcm_kt_cosq_port_get(unit, cosq_idx & 0xffff, &port));
            in_flags = param0;
        }
        BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &modid));
        port = ((modid & 0xff) << 7) | (port & 0x7f);
    } else
#endif
    {
        in_flags = param0;
    }

    /* Tag type resolution. */
    if (in_flags & BCM_FABRIC_QUEUE_QOS_BASE) {
        tag_type = 0x3;  /* Offset to base queue number from the
                          QUEUE_MAP Table. Index into QUEUE_MAP
                          Table is {DST_MODID, DST_PID} */
    } else if (in_flags & BCM_FABRIC_QUEUE_DEST_OFFSET) {
        tag_type = 0x2;  /* Index into QUEUE_MAP Table used for lookup. */
    } else {
        tag_type = 0x1;  /* Explicit queue number. */
    }

    PolicySet(unit, mem, buf, EH_TAG_TYPEf, tag_type);

    /* Traffic manager vs Fabric chip queue selection. */
    if (soc_mem_field_valid (unit, mem, EH_TMf)) {
        traffic_manager = (cosq_idx & BCM_FABRIC_QUEUE_CUSTOMER) ? 0x1 : 0x0;
        PolicySet(unit, mem, buf, EH_TMf, traffic_manager);
    }

    /* Set queue number. */
    PolicySet(unit, mem, buf, EH_QUEUE_TAGf, cosq_idx & 0xffff);

#if defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_KATANAX(unit)) {
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x1);
        PolicySet(unit, mem, buf, REDIRECTION_DGLPf, port);

        if ((tag_type == 0x2) && (fa->flags & _FP_ACTION_DIRTY)) {
            queue_index = cosq_idx & 0xffff;
            rv =  _bcm_field_fabricQueue_action_node_increment_ref_Count (
                                  unit, queue_index, profile_idx);
            if(rv == BCM_E_NOT_FOUND) {
                /*entry not found. Add the entry in hw and linked list */
                sal_memset(&ing_queue_entry, 0, sizeof(ing_queue_map_entry_t));
                BCM_IF_ERROR_RETURN (soc_mem_read(unit, ING_QUEUE_MAPm,
                              MEM_BLOCK_ANY,  queue_index, &ing_queue_entry));
                mask = (1 << soc_mem_field_length(
                      unit, ING_QUEUE_MAPm, QUEUE_OFFSET_PROFILE_INDEXf)) - 1;
                soc_mem_field32_set(unit, ING_QUEUE_MAPm,
                                &ing_queue_entry, QUEUE_SET_BASEf,
                                queue_index);
                soc_mem_field32_set(unit, ING_QUEUE_MAPm, &ing_queue_entry,
                                QUEUE_OFFSET_PROFILE_INDEXf,
                                profile_idx & mask);
                BCM_IF_ERROR_RETURN(BCM_XGS3_MEM_WRITE(unit, ING_QUEUE_MAPm,
                                queue_index, &ing_queue_entry));
                BCM_IF_ERROR_RETURN(_bcm_field_fabricQueue_action_node_add (
                                unit, queue_index, profile_idx));
                rv = BCM_E_NONE;
            }
        }
    }
#endif

    return rv;
}

/*
 * Function:
 *     _field_trx_action_copy_to_cpu
 * Purpose:
 *     Install copy to cpu action in policy table.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     f_ent    - (IN) Field entry structure to get policy info from
 *     fa       - (IN  Field action
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_action_copy_to_cpu(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                              _field_action_t *fa, uint32 *buf)
{
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    switch (fa->action) {
      case bcmFieldActionTimeStampToCpu:
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x5);
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x5);
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x5);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, R_DROPf, 0x1);
              PolicySet(unit, mem, buf, Y_DROPf, 0x1);
              PolicySet(unit, mem, buf, G_DROPf, 0x1);
          }
          break;
      case bcmFieldActionRpTimeStampToCpu:
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x5);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, R_DROPf, 0x1);
          }
          break;
      case bcmFieldActionYpTimeStampToCpu:
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x5);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, Y_DROPf, 0x1);
          }
          break;
      case bcmFieldActionGpTimeStampToCpu:
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x5);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, G_DROPf, 0x1);
          }
          break;
      case bcmFieldActionCopyToCpu:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicySet(unit, mem, buf, COPY_TO_CPUf, 0x1);
          } else {
#ifdef BCM_APACHE_SUPPORT
              if (SOC_IS_APACHE(unit) &&
                      (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
                  PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x3);
                  PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x3);
                  PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x3);
              } else
#endif
              {
                  PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x1);
                  PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x1);
                  PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x1);
              }
          }
          break;
      case bcmFieldActionRpCopyToCpu:
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x1);
          break;
      case bcmFieldActionYpCopyToCpu:
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x1);
          break;
      case bcmFieldActionGpCopyToCpu:
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x1);
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    if (fa->param[0] != 0) {
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, VFP_MATCHED_RULEf, fa->param[1]);
        } else {
            PolicySet(unit, mem, buf, MATCHED_RULEf, fa->param[1]);
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_action_copy_to_cpu_cancel
 * Purpose:
 *     Override copy to cpu action in policy table.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     f_ent    - (IN) Field entry structure to get policy info from
 *     fa       - (IN  Field action
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_action_copy_to_cpu_cancel(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                                     _field_action_t *fa, uint32 *buf)
{
    uint32 value = 0;

    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    switch (fa->action) {
      case bcmFieldActionTimeStampToCpuCancel:
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x2);
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x2);
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x2);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, R_DROPf, 0x2);
              PolicySet(unit, mem, buf, Y_DROPf, 0x2);
              PolicySet(unit, mem, buf, G_DROPf, 0x2);
          }
          break;
      case bcmFieldActionRpTimeStampToCpuCancel:
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x2);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, R_DROPf, 0x2);
          }
          break;
      case bcmFieldActionYpTimeStampToCpuCancel:
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x2);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, Y_DROPf, 0x2);
          }
          break;
      case bcmFieldActionGpTimeStampToCpuCancel:
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x2);
          if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
              PolicySet(unit, mem, buf, G_DROPf, 0x2);
          }
          break;
      case bcmFieldActionCopyToCpuCancel:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicySet(unit, mem, buf, COPY_TO_CPUf, 0x2);
          } else {
              value = COPY_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  if ((SWITCH_TO_CPU_CANCEL ==
                       PolicyGet(unit, mem, buf, R_COPY_TO_CPUf)) &&
                      (SWITCH_TO_CPU_CANCEL ==
                       PolicyGet(unit, mem, buf, Y_COPY_TO_CPUf)) &&
                      (SWITCH_TO_CPU_CANCEL ==
                       PolicyGet(unit, mem, buf, G_COPY_TO_CPUf))) {

                      value = COPY_AND_SWITCH_TO_CPU_CANCEL;
          }
              }
#endif
              PolicySet(unit, mem, buf, R_COPY_TO_CPUf, value);
              PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, value);
              PolicySet(unit, mem, buf, G_COPY_TO_CPUf, value);
          }

          break;
      case bcmFieldActionRpCopyToCpuCancel:
          value = COPY_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
          if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
              SOC_IS_KATANA2(unit)) {
              if (SWITCH_TO_CPU_CANCEL ==
                  PolicyGet(unit, mem, buf, R_COPY_TO_CPUf)) {

                  value = COPY_AND_SWITCH_TO_CPU_CANCEL;
              }
          }
#endif
          PolicySet(unit, mem, buf, R_COPY_TO_CPUf, value);
          break;
      case bcmFieldActionYpCopyToCpuCancel:
          value = COPY_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
          if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
              SOC_IS_KATANA2(unit)) {
              if (SWITCH_TO_CPU_CANCEL ==
                  PolicyGet(unit, mem, buf, Y_COPY_TO_CPUf)) {

                  value = COPY_AND_SWITCH_TO_CPU_CANCEL;
              }
          }
#endif
          PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, value);
          break;
      case bcmFieldActionGpCopyToCpuCancel:
          value = COPY_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
          if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
              SOC_IS_KATANA2(unit)) {
              if (SWITCH_TO_CPU_CANCEL ==
                  PolicyGet(unit, mem, buf, G_COPY_TO_CPUf)) {

                  value = COPY_AND_SWITCH_TO_CPU_CANCEL;
              }
          }
#endif
          PolicySet(unit, mem, buf, G_COPY_TO_CPUf, value);

          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_action_ecn_update
 * Purpose:
 *     Install ECN bits int IP header TOS field update action.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory.
 *     f_ent    - (IN) Entry structure.
 *     fa       - (IN) Field action.
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_action_ecn_update (int unit, soc_mem_t mem, _field_entry_t *f_ent,
                                  _field_action_t *fa, uint32 *buf)
{
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }


    /* ECN value sanity check. */
    switch (fa->param[0]) {
      case 0x1:
      case 0x2:
      case 0x3:
          break;
      case 0:
          return (BCM_E_UNAVAIL);
      default:
          return (BCM_E_PARAM);
    }

    if (SOC_IS_TD2_TT2(unit)  ||
            ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
              SOC_IS_GREYHOUND2(unit)) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        switch (fa->action) {
            case bcmFieldActionEcnNew:
                PolicySet(unit, mem, buf, R_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, R_NEW_ECNf, fa->param[0]);
                PolicySet(unit, mem, buf, Y_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, Y_NEW_ECNf, fa->param[0]);
                PolicySet(unit, mem, buf, G_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, G_NEW_ECNf, fa->param[0]);
                break;
            case bcmFieldActionRpEcnNew:
                PolicySet(unit, mem, buf, R_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, R_NEW_ECNf, fa->param[0]);
                break;
            case bcmFieldActionYpEcnNew:
                PolicySet(unit, mem, buf, Y_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, Y_NEW_ECNf, fa->param[0]);
                break;
            case bcmFieldActionGpEcnNew:
                PolicySet(unit, mem, buf, G_CHANGE_ECNf, 1);
                PolicySet(unit, mem, buf, G_NEW_ECNf, fa->param[0]);
                break;
            default:
                return (BCM_E_PARAM);
        }
    }
    else {
        switch (fa->action) {
            case bcmFieldActionEcnNew:
                PolicySet(unit, mem, buf, R_CHANGE_ECNf, fa->param[0]);
                PolicySet(unit, mem, buf, Y_CHANGE_ECNf, fa->param[0]);
                PolicySet(unit, mem, buf, G_CHANGE_ECNf, fa->param[0]);
                break;
            case bcmFieldActionRpEcnNew:
                PolicySet(unit, mem, buf, R_CHANGE_ECNf, fa->param[0]);
                break;
            case bcmFieldActionYpEcnNew:
                PolicySet(unit, mem, buf, Y_CHANGE_ECNf, fa->param[0]);
                break;
            case bcmFieldActionGpEcnNew:
                PolicySet(unit, mem, buf, G_CHANGE_ECNf, fa->param[0]);
                break;
            default:
                return (BCM_E_PARAM);
        }
    }

    return (BCM_E_NONE);
}

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *     _field_trx_flex_stat_action_set
 * Purpose:
 *     Install flex counter update action into policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     mem          - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 *     buf          - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_flex_stat_action_set(int unit,
                                _field_entry_t *f_ent,
                                soc_mem_t mem,
                                int tcam_idx,
                                uint32 *buf)
{
    _field_stat_t  *f_st;  /* Field statistics descriptor. */
    int             idx;   /* Stat array index.            */


    /* Increment statistics hw reference count. */
    if ((f_ent->statistic.flags & _FP_ENTRY_STAT_VALID)
        && !(f_ent->statistic.flags & _FP_ENTRY_STAT_INSTALLED)) {
        /* Get statistics entity description structure. */
        BCM_IF_ERROR_RETURN
            (_bcm_field_stat_get(unit, f_ent->statistic.sid, &f_st));
        if (_FP_INVALID_INDEX != f_st->hw_index) {
            /*
             * For STATs that are shared by entries, hardware counters
             * are not allocated again. But reference count is incremented
             * for these counters.
             */
            f_st->hw_ref_count++;

            BCM_IF_ERROR_RETURN
                (_bcm_esw_stat_flex_attach_ingress_table_counters1
                    (unit, mem, tcam_idx, f_st->hw_mode, f_st->hw_index,
                    f_st->pool_index, buf));

            /* Mark entry as installed. */
            f_ent->statistic.flags |=  _FP_ENTRY_STAT_INSTALLED;

            /*
             * Write individual statistics previous value, first time
             * entry is installed in hardware.
             */
            if (1 == f_st->hw_ref_count) {
                for (idx = 0; idx < f_st->nstat; idx++) {
                    BCM_IF_ERROR_RETURN
                        (_field_stat_value_set(unit, f_st, f_st->stat_arr[idx],
                                               f_st->stat_values[idx]));
                }
            }
        }
    } else {
        /* Disable counting if counter was not attached to the entry. */
        PolicySet(unit, mem, buf, FLEX_CTR_POOL_NUMBERf, 0);
        PolicySet(unit, mem, buf, FLEX_CTR_OFFSET_MODEf, 0);
        PolicySet(unit, mem, buf, FLEX_CTR_BASE_COUNTER_IDXf, 0);
    }

    return (BCM_E_NONE);
}
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *     _field_trx_flowcnt_stat_action_set
 * Purpose:
 *     Install flow counter update action into policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     mem          - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 *     buf          - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_flowcnt_stat_action_set(int unit,
                                _field_entry_t *f_ent,
                                soc_mem_t mem,
                                int tcam_idx,
                                uint32 *buf)
{
    _field_stat_t  *f_st;  /* Field statistics descriptor. */
    int             idx;   /* Stat array index.            */
    bcm_stat_group_mode_t   group;
    bcm_stat_object_t      object;
    uint32                 profile_group, pool_idx, base_idx;


    /* Increment statistics hw reference count. */
    if ((f_ent->statistic.flags & _FP_ENTRY_STAT_VALID)
        && !(f_ent->statistic.flags & _FP_ENTRY_STAT_INSTALLED)) {
        /* Get statistics entity description structure. */
        BCM_IF_ERROR_RETURN
            (_bcm_field_stat_get(unit, f_ent->statistic.sid, &f_st));

        if (_FP_INVALID_INDEX != f_st->hw_index) {
            /*
             * For STATs that are shared by entries, hardware counters
             * are not allocated again. But reference count is incremented
             * for these counters.
             */
            f_st->hw_ref_count++;

            _bcm_esw_flowcnt_counter_id_get(f_st->flex_mode,
                &group, &object, &profile_group, &pool_idx, &base_idx);
            BCM_IF_ERROR_RETURN
                (_bcm_esw_flowcnt_object_table_attach
                    (unit, object, mem, tcam_idx, profile_group, base_idx,
                    pool_idx, buf));
            PolicySet(unit, mem, buf, VLAN_CTR_ENABLEf, 1);

            /* Mark entry as installed. */
            f_ent->statistic.flags |=  _FP_ENTRY_STAT_INSTALLED;

            /*
             * Write individual statistics previous value, first time
             * entry is installed in hardware.
             */
            if ((1 == f_st->hw_ref_count)
                && !(f_ent->flags & _FP_ENTRY_INSTALLED)) {
                for (idx = 0; idx < f_st->nstat; idx++) {
                    BCM_IF_ERROR_RETURN
                        (_field_stat_value_set(unit, f_st, f_st->stat_arr[idx],
                                               f_st->stat_values[idx]));
                }
            }
        }
    } else {
        /* Disable counting if counter was not attached to the entry. */
        PolicySet(unit, mem, buf, VLAN_CTR_ENABLEf, 0);
        PolicySet(unit, mem, buf, VLAN_CTR_BASE_INDEXf, 0);
        PolicySet(unit, mem, buf, VLAN_CTR_PROFILE_PTRf, 0);
    }

    return (BCM_E_NONE);
}
#endif


/*
 * Function:
 *     _bcm_field_trx_stat_action_set
 * Purpose:
 *     Install counter update action into policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     mem          - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 *     buf          - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_stat_action_set(int unit, _field_entry_t *f_ent,
                               soc_mem_t mem, int tcam_idx,
                               uint32 *buf)
{
    _field_stat_t  *f_st;  /* Field statistics descriptor. */
    int mode;              /* Counter hw mode.             */
    int idx;               /* Counter index.               */
    int rv;                /* Opear return status.         */

    if (NULL == f_ent || NULL == buf) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    f_st = NULL;

    /* VFP doesn't have counters. */
    if ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)
        && ((0 == soc_feature(unit, soc_feature_field_vfp_flex_counter))
        && (0 == soc_feature(unit, soc_feature_flowcnt))
        && (!soc_feature(unit, soc_feature_advanced_flex_counter)))) {
        return (BCM_E_NONE);
    }

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (soc_feature(unit, soc_feature_advanced_flex_counter)
        && (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) {
        return (_field_trx_flex_stat_action_set
                    (unit, f_ent, mem, tcam_idx, buf));
    }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
    if (soc_feature(unit, soc_feature_flowcnt)
        && (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) {
        return (_field_trx_flowcnt_stat_action_set
                    (unit, f_ent, mem, tcam_idx, buf));
    }
#endif


    if ((0 == (f_ent->statistic.flags & _FP_ENTRY_STAT_INSTALLED)) ||
        ((f_ent->flags & _FP_ENTRY_PRIMARY) &&
         (f_ent->flags & _FP_ENTRY_STAT_IN_SECONDARY_SLICE))) {
        /* Disable counting if counter was not attached to the entry. */
        idx = 0;
        mode = 0;
    } else {
        /* Get statistics entity description structure. */
        rv = _bcm_field_stat_get(unit, f_ent->statistic.sid, &f_st);
        BCM_IF_ERROR_RETURN(rv);
        idx = f_st->hw_index;
        mode = f_st->hw_mode;

        /* Adjust counter hw mode for COUNTER_MODE_YES_NO/NO_YES */
        if (f_ent->statistic.flags & _FP_ENTRY_STAT_USE_ODD) {
            mode++;
        }

    }

    /* Write policy table counter config. */
    if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) {
        if (NULL != f_st) {
            f_st->pool_index = f_ent->fs->slice_number;
            f_st->hw_index = f_ent->slice_idx;
        }
        PolicySet(unit, mem, buf, EXT_COUNTER_MODEf, mode);
    } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        if ((f_ent->statistic.flags & _FP_ENTRY_STAT_NOT_ALLOWED) == 0) {
            PolicySet(unit, mem, buf, PID_COUNTER_MODEf, mode);
            PolicySet(unit, mem, buf, PID_COUNTER_INDEXf, idx);
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
#endif
        }
    } else if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
        PolicySet(unit, mem, buf, USE_VINTF_CTR_IDXf, mode);
        PolicySet(unit, mem, buf, VINTF_CTR_IDXf, idx);
    } else {
        PolicySet(unit, mem, buf, COUNTER_MODEf, mode);
        PolicySet(unit, mem, buf, COUNTER_INDEXf, idx);
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_trx_redirect_profile_get
 * Purpose:
 *     Get the redirect profile for the unit
 * Parameters:
 *     unit             - BCM device number
 *     redirect_profile - (OUT) redirect profile
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     For triumph, External TCAM and IFP refer to same IFP_REDIRECTION_PROFILEm
 */
int
_field_trx_redirect_profile_get(int unit, soc_profile_mem_t **redirect_profile)
{
    _field_stage_t *stage_fc;

    /* Get stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    *redirect_profile = &stage_fc->redirect_profile;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_redirect_profile_ref_count_get
 * Purpose:
 *     Get redirect profile entry use count.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     index     - (IN) Profile entry index.
 *     ref_count - (OUT) redirect profile use count.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_redirect_profile_ref_count_get(int unit, int index, int *ref_count)
{
    soc_profile_mem_t *redirect_profile;

    if (NULL == ref_count) {
        return (BCM_E_PARAM);
    }

    /* Get the redirect profile */
    BCM_IF_ERROR_RETURN
        (_field_trx_redirect_profile_get(unit, &redirect_profile));

    BCM_IF_ERROR_RETURN(soc_profile_mem_ref_count_get(unit, redirect_profile,
                                                      index, ref_count));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_redirect_profile_delete
 * Purpose:
 *     Delete redirect profile entry.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     index     - (IN) Profile entry index.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_redirect_profile_delete(int unit, int index)
{
    soc_profile_mem_t *redirect_profile;

    /* Get the redirect profile */
    BCM_IF_ERROR_RETURN
        (_field_trx_redirect_profile_get(unit, &redirect_profile));

    BCM_IF_ERROR_RETURN(soc_profile_mem_delete(unit, redirect_profile, index));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_redirect_profile_alloc
 * Purpose:
 *     Allocate redirect profile index
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     fa       - (IN) Field action.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_redirect_profile_alloc(int unit, _field_entry_t *f_ent,
                                      _field_action_t *fa)
{
    ifp_redirection_profile_entry_t entry_arr[2];
    uint32            *entry_ptr[2];
    soc_profile_mem_t *redirect_profile;
    int               rv;
    int               i = 0;
#ifdef INCLUDE_L3
    bcm_pbmp_t       ipmc_l2_pbmp, ipmc_l3_pbmp;
    int              ipmc_index;
    int              entry_count;
#endif /* INCLUDE_L3 */
    int              mcast_index;
    bcm_mcast_addr_t mcaddr;
    bcm_pbmp_t       pbmp;
    void             *entries[1];
    soc_mem_t       profile_mem = IFP_REDIRECTION_PROFILEm;

    entry_ptr[0] = (uint32 *)(&entry_arr[0]);
    entry_ptr[1] = (uint32 *)(&entry_arr[1]);
    entries[0] = (void *)&entry_arr;

    if ((NULL == f_ent) || (NULL == fa)) {
        return (BCM_E_PARAM);
    }

    /* Reset redirection profile entry. */
    sal_memset(entry_arr, 0, 2*sizeof(ifp_redirection_profile_entry_t));

    /* Get the redirect profile */
    rv = _field_trx_redirect_profile_get(unit, &redirect_profile);
    BCM_IF_ERROR_RETURN(rv);

    switch (fa->action) {
      case bcmFieldActionRedirectPbmp:
      case bcmFieldActionRedirectBcastPbmp:
      case bcmFieldActionEgressMask:
      case bcmFieldActionEgressPortsAdd:
          SOC_PBMP_CLEAR(pbmp);
          for (i = 0; (i < _FP_ACTION_PARAM_SZ) && (i < SOC_PBMP_WORD_MAX); i++) {
              SOC_PBMP_WORD_SET(pbmp, i, fa->param[i]);
          }

          soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[0], BITMAPf, &pbmp);
          rv = soc_profile_mem_add(unit, redirect_profile, entries,
                                   1, (uint32*) &fa->hw_index);
          BCM_IF_ERROR_RETURN(rv);
          break;
#ifdef INCLUDE_L3
      case bcmFieldActionRedirectIpmc:
          if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
              if ((0 == _BCM_MULTICAST_IS_L3(fa->param[0])) &&
                  (0 == _BCM_MULTICAST_IS_WLAN(fa->param[0]))) {
                  return (BCM_E_PARAM);
              }
              ipmc_index = _BCM_MULTICAST_ID_GET(fa->param[0]);
          } else {
              ipmc_index = fa->param[0];
          }
          BCM_PBMP_CLEAR(ipmc_l2_pbmp);
          BCM_PBMP_CLEAR(ipmc_l3_pbmp);
          rv = _bcm_esw_multicast_ipmc_read(unit, ipmc_index,
                                            &ipmc_l2_pbmp, &ipmc_l3_pbmp);
          BCM_IF_ERROR_RETURN(rv);
          if (SOC_IS_TR_VL(unit)) {
              entry_count = 2;
              soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[0], BITMAPf,
                                     &ipmc_l3_pbmp);
              soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[1], BITMAPf,
                                     &ipmc_l2_pbmp);
          } else {
              entry_count = 1;
              soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[0], L3_BITMAPf,
                                     &ipmc_l3_pbmp);
              soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[0], BITMAPf,
                                     &ipmc_l2_pbmp);
          }
          soc_mem_field32_set(unit, profile_mem, entry_ptr[0], MC_INDEXf, ipmc_index);
          /* MTU profile index overlayed on MC_INDEXf. */
          rv = soc_profile_mem_add(unit, redirect_profile,
                                   entries, entry_count, (uint32*)&fa->hw_index);
          BCM_IF_ERROR_RETURN(rv);
          break;
#endif /* INCLUDE_L3 */
      case bcmFieldActionRedirectMcast:
          rv = _bcm_xgs3_mcast_index_port_get(unit, fa->param[0], &mcaddr);
          BCM_IF_ERROR_RETURN(rv);
          soc_mem_pbmp_field_set(unit, profile_mem, entry_ptr[0], BITMAPf,
                                 &mcaddr.pbmp);
          if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
              if (0 == _BCM_MULTICAST_IS_L2(fa->param[0])) {
                  return (BCM_E_PARAM);
              }
              mcast_index = _BCM_MULTICAST_ID_GET(fa->param[0]);
          } else {
              mcast_index = fa->param[0];
          }
          soc_mem_field32_set(unit, profile_mem, entry_ptr[0], MC_INDEXf,
                              mcast_index);
          rv = soc_profile_mem_add(unit, redirect_profile, entries,
                                   1, (uint32*)&fa->hw_index);
          BCM_IF_ERROR_RETURN(rv);
          break;
      default:
          return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_action_redirect
 * Purpose:
 *     Install redirect action in policy table.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     mem      - (IN) Policy table memory.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     fa       - (IN) Field action.
 *     buf      - (OUT) Field Policy table entry.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_action_redirect(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                           _field_action_t *fa, uint32 *buf)
{
    uint32          redir_field = 0;
    int             shift_val;
    soc_field_t     redir_field_type = INVALIDf;

    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    switch (fa->action) {
    case bcmFieldActionOffloadRedirect:
     if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TD2_TT2(unit) ||
         SOC_IS_GREYHOUND2(unit)) {
            redir_field = ((fa->param[0] & 0xff) << 7);
            redir_field |= (fa->param[1] & 0x7f);
        } else {
            redir_field = ((fa->param[0] & 0x7f) << 6);
            redir_field |= (fa->param[1] & 0x3f);
        }
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x1);
        PolicySet(unit, mem, buf, REDIRECTIONf, redir_field);

        PolicySet(unit, mem, buf, HI_PRI_ACTION_CONTROLf, 0x1);
        PolicySet(unit, mem, buf, HI_PRI_RESOLVEf, 0x1);
        PolicySet(unit, mem, buf, SUPPRESS_COLOR_SENSITIVE_ACTIONSf, 0x1);
        PolicySet(unit, mem, buf, DEFER_QOS_MARKINGSf, 0x1);
        PolicySet(unit, mem, buf, SUPPRESS_SW_ACTIONSf, 0x1);
        if (SOC_MEM_FIELD_VALID(unit,
                                FP_POLICY_TABLEm, SUPPRESS_VXLTf)) {
           PolicySet(unit, mem, buf, SUPPRESS_VXLTf, 0x1);
        } else if (SOC_MEM_FIELD_VALID(unit,
                                FP_POLICY_TABLEm, HI_PRI_SUPPRESS_VXLTf)) {
           PolicySet(unit, mem, buf, HI_PRI_SUPPRESS_VXLTf, 0x1);
        }
        break;
    case bcmFieldActionRedirect: /* param0 = modid, param1 = port*/
        redir_field_type = REDIRECTIONf;
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TD2_TT2(unit)) {
            redir_field_type = REDIRECT_DVPf;
            if (BCM_GPORT_IS_MPLS_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_MPLS_PORT_ID_GET((int)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else if (BCM_GPORT_IS_MIM_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_MIM_PORT_ID_GET((int)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else if (BCM_GPORT_IS_NIV_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_NIV_PORT_ID_GET((int)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_TRILL_PORT_ID_GET((int)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else if (BCM_GPORT_IS_L2GRE_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_L2GRE_PORT_ID_GET((int)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_VXLAN_PORT_ID_GET((bcm_gport_t)fa->param[1]);
                PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
            } else {
                if (SOC_IS_APACHE(unit) &&
                    (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
                    redir_field = ((fa->param[0] & 0xff) << 8);
                    redir_field |= (fa->param[1] & 0xff);
                } else {
                    redir_field_type = REDIRECTIONf;
                    redir_field = ((fa->param[0] & 0xff) << 7);
                    redir_field |= (fa->param[1] & 0x7f);
                }
            }
        } else
#endif
#if defined(BCM_KATANA_SUPPORT)
            if (SOC_IS_KATANAX(unit)) {
                if (BCM_GPORT_IS_MPLS_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_MIM_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_NIV_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_TRILL_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_L2GRE_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                           "FP(unit %d) Error: param1=0x%x "
                           "is not a valid port.\n"),
                           unit, fa->param[1]));
                    return (BCM_E_PARAM);
                } else {
                    redir_field = ((fa->param[0] & 0xff) << 7);
                    redir_field |= (fa->param[1] & 0x7f);
                }
            } else
#endif /* BCM_KATANA_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
                if (SOC_IS_TD_TT(unit)) {
                    if (BCM_GPORT_IS_MPLS_PORT(fa->param[1])) {
                        redir_field = BCM_GPORT_MPLS_PORT_ID_GET(
                                         (int)fa->param[1]);
                        redir_field |= (3 << 17);
                    } else if (BCM_GPORT_IS_MIM_PORT(fa->param[1])) {
                        redir_field = BCM_GPORT_MIM_PORT_ID_GET(
                                         (int)fa->param[1]);
                        redir_field |= (3 << 17);
                    } else {
                        redir_field = ((fa->param[0] & 0xff) << 7);
                        redir_field |= (fa->param[1] & 0x7f);
                    }
                } else
#endif /* BCM_TRIDENT_SUPPORT */
                {
                    if (SOC_IS_GREYHOUND2(unit)) {
                        redir_field = ((fa->param[0] & 0xff) << 7);
                        redir_field |= (fa->param[1] & 0x7f);
                    } else {
                        redir_field = ((fa->param[0] & 0x7f) << 6);
                        redir_field |= (fa->param[1] & 0x3f);
                    }
                }
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, REDIRECTION_DESTINATIONf, redir_field);
                PolicySet(unit, mem, buf, DROP_ORIGINAL_PACKETf, 0x1);
                if (SOC_IS_APACHE(unit)) {
                    PolicySet(unit, mem, buf, R_REDIRECTf, 0x3);
                    PolicySet(unit, mem, buf, G_REDIRECTf, 0x3);
                    PolicySet(unit, mem, buf, Y_REDIRECTf, 0x3);
                }
            } else {
                PolicySet(unit, mem, buf, REDIRECTIONf, redir_field);
            }
            if (SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, REDIRECTION_DEST_TYPEf, 0x5);
            } else {
                PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x5);
            }
        } else {
            PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x1);
            PolicySet(unit, mem, buf, redir_field_type, redir_field);
        }
        break;
    case bcmFieldActionRedirectTrunk:    /* param0 = trunk ID */
        redir_field_type = REDIRECTIONf;
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TD_TT(unit) ||
            SOC_IS_KATANAX(unit) || SOC_IS_GREYHOUND2(unit)) {
            shift_val = 9;
        } else if (SOC_IS_HURRICANE3(unit)) {
            shift_val = 8;
        } else if (SOC_IS_TR_VL(unit)) {
            shift_val = 7;
        } else {
            shift_val = 8;
        }
        redir_field |= (0x40 << shift_val);  /* Trunk indicator. */
        redir_field |= fa->param[0];

#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
        if (soc_feature(unit, soc_feature_vp_lag)) {
            int tid_is_vp_lag = 0;
            int vp = -1;
            int vp_id_min = -1;
            int rv = BCM_E_NONE;

            rv = _bcm_esw_trunk_id_is_vp_lag(unit, fa->param[0],
                                             &tid_is_vp_lag);
            BCM_IF_ERROR_RETURN(rv);

            if (tid_is_vp_lag) {

                rv = _bcm_esw_trunk_tid_to_vp_lag_vp(unit,
                                                     fa->param[0], &vp);
                BCM_IF_ERROR_RETURN(rv);

                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    rv =_bcm_esw_trunk_chip_info_vp_resource_get(unit,
                                                             &vp_id_min,
                                                             NULL, NULL);
                    BCM_IF_ERROR_RETURN(rv);
                    redir_field = fa->param[0] - vp_id_min;
                    PolicySet(unit, mem, buf, UNICAST_REDIRECT_CONTROLf, 0x6);
                    redir_field_type = REDIRECT_DVPf;
                } else {
                    return BCM_E_PARAM;
                }
            }
        }
#endif
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, REDIRECTION_DESTINATIONf, redir_field);
                PolicySet(unit, mem, buf, DROP_ORIGINAL_PACKETf, 0x1);
                if (SOC_IS_APACHE(unit)) {
                    PolicySet(unit, mem, buf, R_REDIRECTf, 0x3);
                    PolicySet(unit, mem, buf, G_REDIRECTf, 0x3);
                    PolicySet(unit, mem, buf, Y_REDIRECTf, 0x3);
                }
            } else {
                PolicySet(unit, mem, buf, REDIRECTIONf, redir_field);
            }
            if (SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, REDIRECTION_DEST_TYPEf, 0x6);
            } else {
                PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x6);
            }
        } else {
            PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x1);
            PolicySet(unit, mem, buf, redir_field_type, redir_field);
        }
        break;
    case bcmFieldActionRedirectCancel:
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 2);
        break;
    case bcmFieldActionRedirectPbmp:
        PolicySet(unit, mem, buf, REDIRECTIONf, fa->hw_index);
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x3);
        break;
    case bcmFieldActionEgressMask:
        PolicySet(unit, mem, buf, REDIRECTIONf, fa->hw_index);
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x4);
        break;
    case bcmFieldActionEgressPortsAdd:
        PolicySet(unit, mem, buf, REDIRECTIONf, fa->hw_index);
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x5);
        break;
#ifdef INCLUDE_L3
    case bcmFieldActionRedirectIpmc:
        if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
            if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                if ((0 == _BCM_MULTICAST_IS_L3(fa->param[0])) &&
                    (0 == _BCM_MULTICAST_IS_WLAN(fa->param[0])) &&
                    (0 == _BCM_MULTICAST_IS_VPLS(fa->param[0])) ) {
                    return (BCM_E_PARAM);
                }
                redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
            } else {
                redir_field = fa->param[0];
            }
        } else {
            redir_field = fa->hw_index;
        }
        /* Assign IPMC action to redirect profile index. */
        if ( SOC_IS_TRIUMPH3(unit)
            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
             SOC_IS_TITAN2X(unit)) {
            shift_val = 16;
        } else {
            shift_val = SOC_IS_TR_VL(unit) ? ((SOC_IS_TD_TT(unit)) ? 13 : 12) : 13;
        }

        PolicySet(unit, mem, buf, REDIRECTIONf,
                  (redir_field | (3 << shift_val)));
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x3);
        break;
#endif /* INCLUDE_L3 */
    case bcmFieldActionRedirectMcast:
        if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
            if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                if (0 == _BCM_MULTICAST_IS_L2(fa->param[0])) {
                    return (BCM_E_PARAM);
                }
                redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
            } else {
                redir_field = fa->param[0];
            }
        } else {
            redir_field = fa->hw_index;
        }

        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf,
                      ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) ? REDIRECTION_DESTINATIONf :
                       REDIRECTIONf), redir_field);
            if (SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, R_REDIRECTf, 0x3);
                PolicySet(unit, mem, buf, G_REDIRECTf, 0x3);
                PolicySet(unit, mem, buf, Y_REDIRECTf, 0x3);
                PolicySet(unit, mem, buf, REDIRECTION_DEST_TYPEf, 0x7);
            } else {
                PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x7);
            }
            if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) {
                PolicySet(unit, mem, buf, DROP_ORIGINAL_PACKETf, 0x1);
            }
        } else {
            /* Assign MCAST action to redirect profile index. */
            if (SOC_IS_TRIUMPH3(unit)
                || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
                 SOC_IS_TITAN2X(unit)) {
                shift_val = 16;
            } else {
                shift_val = SOC_IS_TR_VL(unit) ? ((SOC_IS_TD_TT(unit)) ? 13 : 12) : 13;
            }
            PolicySet(unit, mem, buf, REDIRECTIONf,
                      (redir_field | (2 << shift_val)));
            PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x3);
        }
        break;
    case bcmFieldActionRedirectVlan:
        if (SOC_IS_TRIUMPH3(unit)
            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
             SOC_IS_TITAN2X(unit)) {
            shift_val = 16;
        } else {
            shift_val = SOC_IS_TD_TT(unit) ? 13 : 12;
        }
        PolicySet(unit, mem, buf, REDIRECTIONf, (1 << shift_val));
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x3);
        break;
    case bcmFieldActionRedirectBcastPbmp:
        if (SOC_IS_TRIUMPH3(unit)
            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
             SOC_IS_TITAN2X(unit)) {
            shift_val = 16;
        } else {
            shift_val = SOC_IS_TD_TT(unit) ? 13 : 12;
        }
        redir_field = fa->hw_index;
        PolicySet(unit, mem, buf, REDIRECTIONf,
                  (redir_field | (1 << 11) | (1 << shift_val)));
        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x3);
        break;
#ifdef BCM_TRIUMPH3_SUPPORT
    case bcmFieldActionUnmodifiedPacketRedirectPort:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            redir_field = ((BCM_GPORT_MODPORT_MODID_GET(fa->param[0]) & 0xff)
                                                        << 7);
            redir_field |= (BCM_GPORT_MODPORT_PORT_GET(fa->param[0]) & 0x7f);
            redir_field |= (1 << 18);
        } else if (BCM_GPORT_IS_TRUNK(fa->param[0])) {
            redir_field = 0x1 << 15;
            redir_field |= BCM_GPORT_TRUNK_GET(fa->param[0]);
            redir_field |= (1 << 18);
        }

        PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x1);
        PolicySet(unit, mem, buf, REDIRECTIONf, redir_field);
        break;
#endif /* BCM_TRIUMPH3_SUPPORT */
    default:
        return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}

#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *     _field_action_unicast_cosq_get
 * Purpose:
 *     Get l2 UC cos queue offset and classifier id shift bits
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fa       - (IN) Field action.
 *     class_id - (OUT) bits need to be shifted to program classifer id
 *     cosq_new - (OUT) Field Policy table entry.
 * Returns:
 *     BCM_E_XXX
 */
static int
_field_action_unicast_cosq_get(int unit, _field_action_t *fa, int *class_id, int *cosq_new)
{

    bcm_port_t local_port = -1;
    int        local_port_base_queue = BCM_COS_INVALID;

    /* Parameter check. Don't allow NULL pointers */
    if ((NULL == fa) || (NULL == class_id) || (NULL == cosq_new)) {
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[1])) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            BCM_IF_ERROR_RETURN
                (_bcm_tr3_cosq_index_resolve(unit, fa->param[1], 0,
                                             _BCM_TR3_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, cosq_new, NULL));
            BCM_IF_ERROR_RETURN
                (_bcm_tr3_cosq_localport_resolve(unit, fa->param[1], &local_port));
            BCM_IF_ERROR_RETURN
                (_bcm_tr3_cosq_index_resolve(unit, local_port, 0,
                                             _BCM_TR3_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, &local_port_base_queue, NULL));
           /* 1 Bit is reserved for classfier which will be further ORed with ifp_cos_map */
           *class_id = 9;
        } else
#endif
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            BCM_IF_ERROR_RETURN
                (_bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                                             _BCM_KT2_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, cosq_new, NULL));
            BCM_IF_ERROR_RETURN
                (_bcm_kt2_cosq_localport_resolve(unit, fa->param[1], &local_port));
            BCM_IF_ERROR_RETURN
                (_bcm_kt2_cosq_index_resolve(unit, local_port, 0,
                                             _BCM_KT2_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, &local_port_base_queue, NULL));
           /*
            * 2 Bits are reserved for classfier in KATANA2 and
            * 1 Bit is reserved for classfier in Saber2 and Metrolite
            * which will be further ORed with ifp_cos_map
            */

           *class_id = (SOC_IS_SABER2(unit) ? 10: 12);
        } else
#endif
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            BCM_IF_ERROR_RETURN
                (_bcm_ap_cosq_index_resolve(unit, fa->param[1], 0,
                                            _BCM_AP_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                            NULL, cosq_new, NULL));
            BCM_IF_ERROR_RETURN
                (_bcm_ap_cosq_localport_resolve(unit, fa->param[1], &local_port));
            BCM_IF_ERROR_RETURN
                (_bcm_ap_cosq_index_resolve(unit, local_port, 0,
                                            _BCM_AP_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                            NULL, &local_port_base_queue, NULL));
           /* 2 Bits are reserved for classfier which will be further ORed with ifp_cos_map */
           *class_id = 12;
        } else
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            BCM_IF_ERROR_RETURN
                (_bcm_td2_cosq_index_resolve(unit, fa->param[1], 0,
                                             _BCM_TD2_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, cosq_new, NULL));
            BCM_IF_ERROR_RETURN
                (_bcm_td2_cosq_localport_resolve(unit, fa->param[1], &local_port));
            BCM_IF_ERROR_RETURN
                (_bcm_td2_cosq_index_resolve(unit, local_port, 0,
                                             _BCM_TD2_COSQ_INDEX_STYLE_UCAST_QUEUE,
                                             NULL, &local_port_base_queue, NULL));
           /* 2 Bits are reserved for classfier which will be further ORed with ifp_cos_map */
           *class_id = 12;
        } else
#endif
        {
            return BCM_E_UNAVAIL;
        }
        *cosq_new = (*cosq_new - local_port_base_queue);
    } else if (BCM_GPORT_IS_SET (fa->param[1])){
        return BCM_E_PARAM;
    } else {
        *cosq_new = fa->param[1];
        *class_id = SOC_IS_TRIUMPH3(unit) ? 9 : (SOC_IS_SABER2(unit) ? 10 : 12);
    }
    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *     _bcm_field_trx_action_params_check
 * Purpose:
 *     Check field action parameters.
 * Parameters:
 *     unit     - BCM device number
 *     f_ent    - Field entry structure.
 *     fa       - field action
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_action_params_check(int unit,_field_entry_t *f_ent,
                                   _field_action_t *fa)
{
    uint32   redir_field = 0;
    int      shift_val;
    soc_field_t fld;                    /* Policy table field info */
    soc_field_t redirect_field_type = INVALIDf;
#if defined(INCLUDE_L3)
    uint32 flags;            /* L3 forwarding flags.    */
    int nh_ecmp_id;          /* Next hop/Ecmp group id. */
    int svp = -1;
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    int vfi = 0;
#endif
#endif /* INCLUDE_L3 */
    soc_mem_t mem;           /* Policy table memory id. */
    soc_mem_t tcam_mem;      /* Tcam memory id.         */
    int rv;                  /* Operation return value. */
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || \
    defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    int cosq_new = 0;
#endif
#if defined(BCM_KATANA_SUPPORT)
    int temp_param;
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined (BCM_TRIDENT2_SUPPORT)
    int hw_index = 0;
#endif
#ifdef BCM_HURRICANE3_SUPPORT
    int index_array[2] = {0};
#endif

    if (NULL == f_ent || NULL == fa) {
        return (BCM_E_PARAM);
    }

    /* Resolve policy memory id. */
#if defined(BCM_TRIUMPH_SUPPORT)
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit)) {
            rv = _bcm_field_tr3_external_policy_mem_get(unit, fa, &mem);
        } else
#endif
            {
                rv = _bcm_field_tr_external_policy_mem_get(unit, fa, &mem);
            }
        BCM_IF_ERROR_RETURN(rv);
    } else
#endif /* BCM_TRIUMPH_SUPPORT */
        {
            rv = _field_fb_tcam_policy_mem_get(unit, f_ent->group->stage_id,
                                               &tcam_mem, &mem);
            BCM_IF_ERROR_RETURN(rv);
        }

    switch (fa->action) {
      case bcmFieldActionMultipathHash:
          PolicyCheck(unit, mem, ECMP_HASH_SELf, fa->param[0]);
          break;
      case bcmFieldActionCopyToCpu:
      case bcmFieldActionRpCopyToCpu:
      case bcmFieldActionYpCopyToCpu:
      case bcmFieldActionGpCopyToCpu:
      case bcmFieldActionTimeStampToCpu:
      case bcmFieldActionRpTimeStampToCpu:
      case bcmFieldActionYpTimeStampToCpu:
      case bcmFieldActionGpTimeStampToCpu:
          if (fa->param[0] != 0) {
              if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
                  PolicyCheck(unit, mem, VFP_MATCHED_RULEf, fa->param[1]);
              } else {
                  PolicyCheck(unit, mem, MATCHED_RULEf, fa->param[1]);
              }
          }
          break;
      case bcmFieldActionClassDestSet:
          PolicyCheck(unit, mem, VFP_CLASS_ID_Lf, fa->param[0]);
          break;

      case bcmFieldActionClassSourceSet:
          PolicyCheck(unit, mem, VFP_CLASS_ID_Hf, fa->param[0]);
          break;

      case bcmFieldActionVrfSet:
          if (soc_feature(unit, soc_feature_mpls)) {
              PolicyCheck(unit, mem, VFP_VRF_IDf, fa->param[0]);
          }  else {
              PolicyCheck(unit, mem, VFP_VRF_IDf, fa->param[0]);

          }
          break;

      case bcmFieldActionDropPrecedence:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_CNGf, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, R_DROP_PRECEDENCEf, fa->param[0]);
              PolicyCheck(unit, mem, Y_DROP_PRECEDENCEf, fa->param[0]);
              PolicyCheck(unit, mem, G_DROP_PRECEDENCEf, fa->param[0]);
          }
          break;
      case bcmFieldActionPrioPktNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              fld = (soc_mem_field_valid(unit, mem, NEW_OUTER_DOT1Pf)
                     ? NEW_OUTER_DOT1Pf : NEW_PKT_PRIORITYf);

              PolicyCheck(unit, mem, fld, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, R_NEW_PKT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_NEW_PKT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, G_NEW_PKT_PRIf, fa->param[0]);
          }
          break;
      case bcmFieldActionEcnNew:
          if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
              || (SOC_IS_TOMAHAWKX(unit)) ||
                  ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                    SOC_IS_GREYHOUND2(unit)) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
              PolicyCheck(unit, mem, R_NEW_ECNf, fa->param[0]);
              PolicyCheck(unit, mem, Y_NEW_ECNf, fa->param[0]);
              PolicyCheck(unit, mem, G_NEW_ECNf, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, R_CHANGE_ECNf, fa->param[0]);
              PolicyCheck(unit, mem, Y_CHANGE_ECNf, fa->param[0]);
              PolicyCheck(unit, mem, G_CHANGE_ECNf, fa->param[0]);
          }
          break;

      case bcmFieldActionDscpNew:
          PolicyCheck(unit, mem, R_NEW_DSCPf, fa->param[0]);
          PolicyCheck(unit, mem, Y_NEW_DSCPf, fa->param[0]);
          if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, G_NEW_DSCPf, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, G_NEW_DSCP_TOSf, fa->param[0]);
          }
          break;

      case bcmFieldActionCosQNew:
      case bcmFieldActionUcastCosQNew:
#if defined(BCM_TRIDENT2_SUPPORT)
          if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) &&
              SOC_IS_TD2_TT2(unit)) {
              rv = _bcm_td2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD2_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
          } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT)
          if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) &&
              SOC_IS_TD_TT(unit)) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
          } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_KATANAX(unit)) {
              rv = _bcm_kt_cosq_index_resolve(unit, fa->param[0], 0,
                  _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                  &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
          } else
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_GREYHOUND2(unit)) {
              rv = bcmi_gh2_cosq_index_resolve(unit, fa->param[0], &cosq_new);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, QUEUE_EXTENSION_NUMf, (cosq_new >> 3));
              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new & 0x7);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new & 0x7);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new & 0x7);
          } else
#endif /* BCM_GREYHOUND2_SUPPORT */
          {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, fa->param[0]);
          }
          break;

#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
      case bcmFieldActionMcastCosQNew:
          if (SOC_IS_TD_TT(unit) &&
              BCM_GPORT_IS_MCAST_QUEUE_GROUP(fa->param[0])) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (cosq_new << 4));
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (cosq_new << 4));
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (cosq_new << 4));
          } else {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (fa->param[0] << 4));
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (fa->param[0] << 4));
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (fa->param[0] << 4));
          }
          break;
#endif /* !BCM_TRIDENT_SUPPORT */

      case bcmFieldActionVlanCosQNew:
          /* Add 8 to the value since VLAN shaping queues are 8..23 */
          PolicyCheck(unit, mem, R_COS_INT_PRIf, fa->param[0] + 8);
          PolicyCheck(unit, mem, Y_COS_INT_PRIf, fa->param[0] + 8);
          PolicyCheck(unit, mem, G_COS_INT_PRIf, fa->param[0] + 8);
          break;

      case bcmFieldActionPrioIntNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_INT_PRIORITYf,  fa->param[0]);
#if defined BCM_KATANA2_SUPPORT
          } else if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                        && SOC_IS_KATANA2(unit)) {
              PolicyCheck(unit, mem, R_NEW_REDIR_INT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, G_NEW_REDIR_INT_PRIf, fa->param[0]);
#endif
          } else {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (0xf & fa->param[0]));
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (0xf & fa->param[0]));
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (0xf & fa->param[0]));
          }
          break;

      case bcmFieldActionPrioPktAndIntNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
              if (SOC_IS_TD_TT(unit)
                  || SOC_IS_KATANAX(unit)
                  || SOC_IS_TRIUMPH3(unit)) {
                  PolicyCheck(unit, mem, NEW_OUTER_DOT1Pf, fa->param[0]);
              } else
#endif /* !BCM_TRIDENT_SUPPORT */
              {
                  PolicyCheck(unit, mem, NEW_PKT_PRIORITYf, fa->param[0]);
              }
              PolicyCheck(unit, mem, NEW_INT_PRIORITYf,  fa->param[0]);
          } else {
              PolicyCheck(unit, mem, R_NEW_PKT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (0xf & fa->param[0]));
              PolicyCheck(unit, mem, Y_NEW_PKT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (0xf & fa->param[0]));
              PolicyCheck(unit, mem, G_NEW_PKT_PRIf, fa->param[0]);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (0xf & fa->param[0]));
          }
          break;

      case bcmFieldActionCosQCpuNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, CPU_COSf, fa->param[0]);
          } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_CPU_COSf, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, CPU_COSf, fa->param[0]);
          }
          break;

      case bcmFieldActionOuterVlanPrioNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
              if (SOC_IS_TD_TT(unit)
                  || SOC_IS_KATANAX(unit)
                  || SOC_IS_TRIUMPH3(unit)) {
                  PolicyCheck(unit, mem, NEW_OUTER_DOT1Pf, fa->param[0]);
              }
#endif /* !BCM_TRIDENT_SUPPORT */
          } else {
          PolicyCheck(unit, mem, R_NEW_DOT1Pf, fa->param[0]);
          PolicyCheck(unit, mem, Y_NEW_DOT1Pf, fa->param[0]);
          PolicyCheck(unit, mem, G_NEW_DOT1Pf, fa->param[0]);
          }
          break;

      case bcmFieldActionInnerVlanPrioNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
              if (SOC_IS_TD_TT(unit)
                  || SOC_IS_KATANAX(unit)
                  || SOC_IS_TRIUMPH3(unit)) {
                  PolicyCheck(unit, mem, NEW_INNER_DOT1Pf, fa->param[0]);
              }
#endif /* !BCM_TRIDENT_SUPPORT */
          } else {
          PolicyCheck(unit, mem, R_NEW_INNER_PRIf, fa->param[0]);
          PolicyCheck(unit, mem, Y_NEW_INNER_PRIf, fa->param[0]);
          PolicyCheck(unit, mem, G_NEW_INNER_PRIf, fa->param[0]);
          }
          break;

      case bcmFieldActionOuterVlanCfiNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
             SOC_IS_TRIUMPH3(unit))
              && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_OUTER_CFIf, fa->param[0]);
          } else
#endif
          {
              PolicyCheck(unit, mem, R_NEW_OUTER_CFIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_NEW_OUTER_CFIf, fa->param[0]);
              PolicyCheck(unit, mem, G_NEW_OUTER_CFIf, fa->param[0]);
          }
          break;

      case bcmFieldActionInnerVlanCfiNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
             SOC_IS_TRIUMPH3(unit))
              && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_INNER_CFIf, fa->param[0]);
          } else
#endif
          {
              PolicyCheck(unit, mem, R_NEW_INNER_CFIf, fa->param[0]);
              PolicyCheck(unit, mem, Y_NEW_INNER_CFIf, fa->param[0]);
              PolicyCheck(unit, mem, G_NEW_INNER_CFIf, fa->param[0]);
          }
          break;

      case bcmFieldActionInnerVlanAdd:
          PolicyCheck(unit, mem, NEW_INNER_VLANf, fa->param[0]);
          break;

      case bcmFieldActionOuterVlanAdd:
          PolicyCheck(unit, mem, NEW_OUTER_VLANf, fa->param[0]);
          break;

      case bcmFieldActionOuterVlanLookup:
          PolicyCheck(unit, mem, NEW_OUTER_VLANf, fa->param[0]);
          break;

      case bcmFieldActionInnerVlanNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_INNER_VLANf, fa->param[0]);
          } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, PID_NEW_INNER_VIDf, fa->param[0]);
          }
          break;

      case bcmFieldActionOuterVlanNew:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, NEW_OUTER_VLANf, fa->param[0]);
          } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, PID_NEW_OUTER_VIDf, fa->param[0]);
          } else {
              if (SOC_IS_TRIUMPH2(unit) || SOC_IS_TD_TT(unit)
                  || SOC_IS_KATANAX(unit) || SOC_IS_APOLLO(unit)
                  || SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit)
                  || SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
                  PolicyCheck(unit, EGR_L3_INTFm, VIDf, fa->param[0]);
              } else {
                  PolicyCheck(unit, EGR_L3_NEXT_HOPm, INTF_NUMf,
                      fa->param[0]);
              }
          }
          break;

      case bcmFieldActionMirrorIngress:
      case bcmFieldActionMirrorEgress:
          rv = _bcm_field_action_dest_check(unit, fa);
          BCM_IF_ERROR_RETURN(rv);
          break;
      case bcmFieldActionOffloadRedirect:
      case bcmFieldActionRedirect:
          rv = _bcm_field_action_dest_check(unit, fa);
          BCM_IF_ERROR_RETURN(rv);
#ifdef BCM_TRIDENT_SUPPORT
          if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
              if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
                  if (BCM_GPORT_IS_MPLS_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_MIM_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_NIV_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_TRILL_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_L2GRE_PORT(fa->param[1]) ||
                      BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) {
                      LOG_ERROR(BSL_LS_BCM_FP,
                       (BSL_META_U(unit,
                        "FP(unit %d) Error: param1=0x%x "
                        "is not a valid port.\n"),
                        unit, fa->param[1]));
                      return (BCM_E_PARAM);
                  }
#ifdef BCM_APACHE_SUPPORT
                  if (SOC_IS_APACHE(unit)) {
                      redir_field = ((fa->param[0] & 0xff) << 8);
                      redir_field |= (fa->param[1] & 0xff);
                  } else
#endif
                  {
                      redir_field = ((fa->param[0] & 0x7f) << 6);
                      redir_field |= (fa->param[1] & 0x3f);
                  }
              } else {
                  if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TD2_TT2(unit)) {
                      if (BCM_GPORT_IS_MPLS_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_MPLS_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else if(BCM_GPORT_IS_MIM_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_MIM_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else if (BCM_GPORT_IS_NIV_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_NIV_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_TRILL_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else if (BCM_GPORT_IS_L2GRE_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_L2GRE_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_VXLAN_PORT_ID_GET((bcm_gport_t)fa->param[1]);
                          redir_field |= (6 << 18);
                      } else {
                          redir_field = ((fa->param[0] & 0xff) << 7);
                          redir_field |= (fa->param[1] & 0x7f);
                      }
                  } else if (SOC_IS_KATANAX(unit)) {
                      if ( (BCM_GPORT_IS_MPLS_PORT(fa->param[1]) ||
                              BCM_GPORT_IS_MIM_PORT(fa->param[1]) ||
                              BCM_GPORT_IS_NIV_PORT(fa->param[1]) ||
                              BCM_GPORT_IS_TRILL_PORT(fa->param[1]) ||
                              BCM_GPORT_IS_L2GRE_PORT(fa->param[1]) ||
                              BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) ) {
                          LOG_ERROR(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                            "FP(unit %d) Error: param1=0x%x "
                            "is not a valid port.\n"),
                            unit, fa->param[1]));
                          return (BCM_E_PARAM);
                      } else {
                          redir_field = ((fa->param[0] & 0xff) << 7);
                          redir_field |= (fa->param[1] & 0x7f);
                      }
                  } else if (SOC_IS_TD_TT(unit)) {
                      if (BCM_GPORT_IS_MPLS_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_MPLS_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (3 << 17);
                      } else if (BCM_GPORT_IS_MIM_PORT(fa->param[1])) {
                          redir_field = BCM_GPORT_MIM_PORT_ID_GET((int)fa->param[1]);
                          redir_field |= (3 << 17);
                      } else {
                          redir_field = ((fa->param[0] & 0xff) << 7);
                          redir_field |= (fa->param[1] & 0x7f);
                      }
                  }
              }
          } else
#endif /* BCM_TRIDENT_SUPPORT */
          {
              redir_field = ((fa->param[0] & 0x7f) << 6);
              redir_field |= (fa->param[1] & 0x3f);
          }
          if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
                      SOC_IS_APACHE(unit)) &&
              (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
              PolicyCheck(unit, mem, REDIRECTION_DESTINATIONf, redir_field);
          }
          else {
              PolicyCheck(unit, mem, REDIRECTIONf, redir_field);
          }
          break;
      case bcmFieldActionRedirectTrunk:    /* param0 = trunk ID */
          redirect_field_type = REDIRECTIONf;
          if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
              SOC_IS_GREYHOUND2(unit)) {
              shift_val = 9;
          } else if (SOC_IS_HURRICANE3(unit)) {
              shift_val = 8;
          } else if (SOC_IS_TR_VL(unit)) {
              shift_val = 7;
          } else {
              shift_val = 8;
          }
          redir_field |= (0x40 << shift_val);  /* Trunk indicator. */
          redir_field |= fa->param[0];
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
          if (soc_feature(unit, soc_feature_vp_lag)) {
              int tid_is_vp_lag = 0;
              int vp = -1;
              int vp_id_min = -1;

              rv = _bcm_esw_trunk_id_is_vp_lag(unit, fa->param[0],
                                               &tid_is_vp_lag);
              BCM_IF_ERROR_RETURN(rv);

              if (tid_is_vp_lag) {

                  rv = _bcm_esw_trunk_tid_to_vp_lag_vp(unit,
                                                       fa->param[0], &vp);
                  BCM_IF_ERROR_RETURN(rv);

                  if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                      rv =_bcm_esw_trunk_chip_info_vp_resource_get(unit,
                                                               &vp_id_min,
                                                               NULL, NULL);
                      BCM_IF_ERROR_RETURN(rv);
                      redir_field = fa->param[0] - vp_id_min;
                      redirect_field_type = REDIRECT_DVPf;
                  } else {
                      return BCM_E_PARAM;
                  }
              }
          }
#endif
          if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
                      SOC_IS_APACHE(unit)) &&
              (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
              PolicyCheck(unit, mem, REDIRECTION_DESTINATIONf, redir_field);
          }
          else {
              PolicyCheck(unit, mem, redirect_field_type, redir_field);
          }
          break;
#ifdef INCLUDE_L3
      case bcmFieldActionRedirectIpmc:
          if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
              if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                  if ((0 == _BCM_MULTICAST_IS_L3(fa->param[0])) &&
                      (0 == _BCM_MULTICAST_IS_WLAN(fa->param[0])) &&
                      (0 == _BCM_MULTICAST_IS_VPLS(fa->param[0]))) {
                      return (BCM_E_PARAM);
                  }
                  redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
              } else {
                  redir_field = fa->param[0];
              }
          } else {
              redir_field = 0;
          }
          /* Assign IPMC action to redirect profile index. */
          if (SOC_IS_TRIUMPH3(unit)
              || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
               SOC_IS_TITAN2X(unit)) {
              shift_val = 16;
          } else {
              shift_val = SOC_IS_TR_VL(unit) ?
                 ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) ? 13 : 12) : 13;
          }
          PolicyCheck(unit, mem, REDIRECTIONf,
                         (redir_field | (3 << shift_val)));
          break;
#endif /* INCLUDE_L3 */
      case bcmFieldActionRedirectMcast:
          if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
              if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                  if (0 == _BCM_MULTICAST_IS_L2(fa->param[0])) {
                      return (BCM_E_PARAM);
                  }
                  redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
              } else {
                  redir_field = fa->param[0];
              }
          } else {
              redir_field = 0;
          }

          if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem,
                          ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) ? REDIRECTION_DESTINATIONf :
                           REDIRECTIONf),
                          redir_field);
          } else {
              /* Assign MCAST action to redirect profile index. */
              if (SOC_IS_TRIUMPH3(unit)
                  || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
                   SOC_IS_TITAN2X(unit)) {
                  shift_val = 16;
              } else {
                  shift_val = SOC_IS_TR_VL(unit) ?
                      ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) ? 13 : 12) : 13;
              }
              PolicyCheck(unit, mem, REDIRECTIONf,
                              (redir_field | (2 << shift_val)));
          }
          break;
      case bcmFieldActionOffloadClassSet:
          PolicyCheck(unit, mem, PPD3_CLASS_TAGf, fa->param[0]);
          break;
      case bcmFieldActionRpDropPrecedence:
          PolicyCheck(unit, mem, R_DROP_PRECEDENCEf, fa->param[0]);
          break;
      case bcmFieldActionRpPrioPktNew:
          PolicyCheck(unit, mem, R_NEW_PKT_PRIf, fa->param[0]);
          break;
      case bcmFieldActionRpEcnNew:
          if ((fa->param[0] <= 0) || (fa->param[0] > 3)) {
              return (BCM_E_PARAM);
          }
          break;
      case bcmFieldActionRpDscpNew:
          PolicyCheck(unit, mem, R_NEW_DSCPf, fa->param[0]);
          break;
      case bcmFieldActionRpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT)
      case bcmFieldActionRpUcastCosQNew:
          if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) &&
              SOC_IS_TD_TT(unit)) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
          } else
#endif /*!BCM_TRIDENT_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_KATANAX(unit)) {
              rv = _bcm_kt_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
          } else
#endif /* !BCM_KATANA_SUPPORT*/
#if defined(BCM_GREYHOUND2_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_GREYHOUND2(unit)) {
              rv = bcmi_gh2_cosq_index_resolve(unit, fa->param[0], &cosq_new);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, QUEUE_EXTENSION_NUMf, (cosq_new >> 3));
              PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new & 0x7);
          } else
#endif /* BCM_GREYHOUND2_SUPPORT */
          {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, fa->param[0]);
          }
          break;
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
      case bcmFieldActionRpMcastCosQNew:
          if (SOC_IS_TD_TT(unit) &&
              BCM_GPORT_IS_MCAST_QUEUE_GROUP(fa->param[0])) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (cosq_new << 4));
          } else {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (fa->param[0] << 4));
          }
          break;
#endif /* !BCM_TRIDENT_SUPPORT */
      case bcmFieldActionRpVlanCosQNew:
          /* Add 8 to the value since VLAN shaping queues are 8..23 */
          PolicyCheck(unit, mem, R_COS_INT_PRIf, fa->param[0] + 8);
          break;
      case bcmFieldActionRpPrioPktAndIntNew:
          PolicyCheck(unit, mem, R_NEW_PKT_PRIf, fa->param[0]);
          PolicyCheck(unit, mem, R_COS_INT_PRIf, (0xf & fa->param[0]));
          break;
      case bcmFieldActionRpOuterVlanPrioNew:
          PolicyCheck(unit, mem, R_NEW_DOT1Pf, fa->param[0]);
          break;
      case bcmFieldActionRpInnerVlanPrioNew:
          PolicyCheck(unit, mem, R_NEW_INNER_PRIf, fa->param[0]);
          break;
      case bcmFieldActionRpOuterVlanCfiNew:
          PolicyCheck(unit, mem, R_NEW_OUTER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionRpInnerVlanCfiNew:
          PolicyCheck(unit, mem, R_NEW_INNER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionRpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
          if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                  && SOC_IS_KATANA2(unit)) {
              PolicyCheck(unit, mem, R_NEW_REDIR_INT_PRIf, fa->param[0]);
          } else
#endif
          {
              PolicyCheck(unit, mem, R_COS_INT_PRIf, (0xf & fa->param[0]));
          }
          break;
      case bcmFieldActionYpDropPrecedence:
          PolicyCheck(unit, mem, Y_DROP_PRECEDENCEf, fa->param[0]);
          break;
      case bcmFieldActionYpPrioPktNew:
          PolicyCheck(unit, mem, Y_NEW_PKT_PRIf, fa->param[0]);
          break;
      case bcmFieldActionYpEcnNew:
          if ((fa->param[0] <= 0) || (fa->param[0] > 3)) {
              return (BCM_E_PARAM);
          }
          break;
      case bcmFieldActionYpDscpNew:
          PolicyCheck(unit, mem, Y_NEW_DSCPf, fa->param[0]);
          break;
      case bcmFieldActionYpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT)
      case bcmFieldActionYpUcastCosQNew:
          if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) &&
              SOC_IS_TD_TT(unit)) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
          } else
#endif  /*!BCM_TRIDENT_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_KATANAX(unit)) {
              rv = _bcm_kt_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
          } else
#endif /* !BCM_KATANA_SUPPORT*/
#if defined(BCM_GREYHOUND2_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_GREYHOUND2(unit)) {
              rv = bcmi_gh2_cosq_index_resolve(unit, fa->param[0], &cosq_new);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, QUEUE_EXTENSION_NUMf, (cosq_new >> 3));
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new & 0x7);
          } else
#endif /* BCM_GREYHOUND2_SUPPORT */
          {
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, fa->param[0]);
          }
          break;
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
      case bcmFieldActionYpMcastCosQNew:
          if (SOC_IS_TD_TT(unit) &&
              BCM_GPORT_IS_MCAST_QUEUE_GROUP(fa->param[0])) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (cosq_new << 4));
          } else
          {
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (fa->param[0] << 4));
          }
          break;
#endif /* !BCM_TRIDENT_SUPPORT */
      case bcmFieldActionYpVlanCosQNew:
          /* Add 8 to the value since VLAN shaping queues are 8..23 */
          PolicyCheck(unit, mem, Y_COS_INT_PRIf, fa->param[0] + 8);
          break;
      case bcmFieldActionYpPrioPktAndIntNew:
          PolicyCheck(unit, mem, Y_NEW_PKT_PRIf, fa->param[0]);
          PolicyCheck(unit, mem, Y_COS_INT_PRIf, (0xf & fa->param[0]));
          break;
      case bcmFieldActionYpOuterVlanPrioNew:
          PolicyCheck(unit, mem, Y_NEW_DOT1Pf, fa->param[0]);
          break;
      case bcmFieldActionYpInnerVlanPrioNew:
          PolicyCheck(unit, mem, Y_NEW_INNER_PRIf, fa->param[0]);
          break;
      case bcmFieldActionYpOuterVlanCfiNew:
          PolicyCheck(unit, mem, Y_NEW_OUTER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionYpInnerVlanCfiNew:
          PolicyCheck(unit, mem, Y_NEW_INNER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionYpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
          if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                  && SOC_IS_KATANA2(unit)) {
              PolicyCheck(unit, mem, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
          } else
#endif
          {
              PolicyCheck(unit, mem, Y_COS_INT_PRIf, (0xf & fa->param[0]));
          }
          break;
      case bcmFieldActionGpDropPrecedence:
          PolicyCheck(unit, mem, G_DROP_PRECEDENCEf, fa->param[0]);
          break;
      case bcmFieldActionGpPrioPktNew:
          PolicyCheck(unit, mem, G_NEW_PKT_PRIf, fa->param[0]);
          break;
      case bcmFieldActionGpEcnNew:
          if ((fa->param[0] <= 0) || (fa->param[0] > 3)) {
              return (BCM_E_PARAM);
          }
          break;
      case bcmFieldActionGpDscpNew:
          if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, G_NEW_DSCPf, fa->param[0]);
          } else {
              PolicyCheck(unit, mem, G_NEW_DSCP_TOSf, fa->param[0]);
          }
          break;
      case bcmFieldActionGpTosPrecedenceNew:
          PolicyCheck(unit, mem, G_NEW_DSCP_TOSf, fa->param[0]);
          break;
      case bcmFieldActionGpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT)
      case bcmFieldActionGpUcastCosQNew:
          if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) &&
              SOC_IS_TD_TT(unit)) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
          } else
#endif /*!BCM_TRIDENT_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]) ||
              BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_KATANAX(unit)) {
              rv = _bcm_kt_cosq_index_resolve(unit, fa->param[0], 0,
                   _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                   &cosq_new, NULL);

              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
          } else
#endif /* !BCM_KATANA_SUPPORT*/
#if defined(BCM_GREYHOUND2_SUPPORT)
          if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]))
              && SOC_IS_GREYHOUND2(unit)) {
              rv = bcmi_gh2_cosq_index_resolve(unit, fa->param[0], &cosq_new);
              BCM_IF_ERROR_RETURN(rv);

              PolicyCheck(unit, mem, QUEUE_EXTENSION_NUMf, (cosq_new >> 3));
              PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new & 0x7);
          } else
#endif /* BCM_GREYHOUND2_SUPPORT */
          {
              PolicyCheck(unit, mem, G_COS_INT_PRIf, fa->param[0]);
          }
          break;

#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
      case bcmFieldActionGpMcastCosQNew:
          if (SOC_IS_TD_TT(unit) &&
              BCM_GPORT_IS_MCAST_QUEUE_GROUP(fa->param[0])) {
              rv = _bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                       &cosq_new, NULL);
              BCM_IF_ERROR_RETURN(rv);
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (cosq_new << 4));
          } else
          {
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (fa->param[0] << 4));
          }
          break;
#endif /* !BCM_TRIDENT_SUPPORT */
      case bcmFieldActionGpVlanCosQNew:
          /* Add 8 to the value since VLAN shaping queues are 8..23 */
          PolicyCheck(unit, mem, G_COS_INT_PRIf, fa->param[0] + 8);
          break;
      case bcmFieldActionGpPrioPktAndIntNew:
          PolicyCheck(unit, mem, G_NEW_PKT_PRIf, fa->param[0]);
          PolicyCheck(unit, mem, G_COS_INT_PRIf, (0xf & fa->param[0]));
          break;
      case bcmFieldActionGpOuterVlanPrioNew:
          PolicyCheck(unit, mem, G_NEW_DOT1Pf, fa->param[0]);
          break;
      case bcmFieldActionGpInnerVlanPrioNew:
          PolicyCheck(unit, mem, G_NEW_INNER_PRIf, fa->param[0]);
          break;
      case bcmFieldActionGpOuterVlanCfiNew:
          PolicyCheck(unit, mem, G_NEW_OUTER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionGpInnerVlanCfiNew:
          PolicyCheck(unit, mem, G_NEW_INNER_CFIf, fa->param[0]);
          break;
      case bcmFieldActionGpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
          if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                  && SOC_IS_KATANA2(unit)) {
              PolicyCheck(unit, mem, G_NEW_REDIR_INT_PRIf, fa->param[0]);
          } else
#endif
          {
              PolicyCheck(unit, mem, G_COS_INT_PRIf, (0xf & fa->param[0]));
          }
          break;
      case bcmFieldActionAddClassTag:
          /*
           * The NEXT_HOP_INDEXf is 14-bits wide in FP_POLICY_TABLEm view.
           * But only 13-bits are valid for this action
           */
#ifdef BCM_TRIUMPH_SUPPORT
          if (SOC_IS_TR_VL(unit)) {
              if (!(fa->param[0] <= ((1 << 13) - 1))) {
                  return BCM_E_PARAM;
              }
          } else
#endif /* (BCM_TRIUMPH_SUPPORT) */
          {
              PolicyCheck(unit, mem, NEXT_HOP_INDEXf, fa->param[0]);
          }
          break;
      case bcmFieldActionFabricQueue:
#if defined(BCM_KATANA_SUPPORT)
          /* For Katana if param1 flags are set then param0 should be
          * ucast/ucast_subscriber group cosq gport */
          if (SOC_IS_KATANAX(unit)) {
              if ((fa->param[1] & BCM_FABRIC_QUEUE_DEST_OFFSET) ||
                  (fa->param[1] & BCM_FABRIC_QUEUE_CUSTOMER)) {
                  if (BCM_GPORT_IS_SET(fa->param[0])) {
                      if(BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0])
                          || BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0])
                          || BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0])){
                          if (fa->param[1] & BCM_FABRIC_QUEUE_DEST_OFFSET) {
                              temp_param = fa->param[1] & _BCM_QOS_MAP_MASK;
                              if (((temp_param >> _BCM_QOS_MAP_TYPE_SHIFT) !=
                                  _BCM_QOS_MAP_TYPE_ING_QUEUE_OFFSET_MAP_TABLE)
                                  || ((temp_param & _BCM_QOS_MAP_OFFSET_MASK) >
                                       _BCM_QOS_MAP_ING_QUEUE_OFFSET_MAX)) {
                                  return BCM_E_PARAM;
                              }
                          }
                      } else {
                          return BCM_E_PARAM;
                      }
                  } else {
                      return BCM_E_PARAM;
                  }
              } else {
                  /* maintail backward compatibility */
                  if ((fa->param[0] & BCM_FABRIC_QUEUE_QOS_BASE)  &&
                      (fa->param[0] & BCM_FABRIC_QUEUE_DEST_OFFSET)) {
                      return (BCM_E_PARAM);
                  }

                  if (fa->param[0] &
                       ~(BCM_FABRIC_QUEUE_CUSTOMER |
                         BCM_FABRIC_QUEUE_QOS_BASE |
                         BCM_FABRIC_QUEUE_DEST_OFFSET |
                         0xffff)) {
                      return (BCM_E_PARAM);
                  }
              }
          } else
#endif
          {
              if ((fa->param[0] & BCM_FABRIC_QUEUE_QOS_BASE)  &&
                  (fa->param[0] & BCM_FABRIC_QUEUE_DEST_OFFSET)) {
                  return (BCM_E_PARAM);
              }

              if (fa->param[0] &
                   ~(BCM_FABRIC_QUEUE_CUSTOMER |
                     BCM_FABRIC_QUEUE_QOS_BASE |
                     BCM_FABRIC_QUEUE_DEST_OFFSET |
                     0xffff)) {
                  return (BCM_E_PARAM);
              }
          }

          break;

#if defined(BCM_TRIDENT_SUPPORT)
        case bcmFieldActionCompressSrcIp6:
        case bcmFieldActionCompressDstIp6:
            if (SOC_IS_TD_TT(unit) &&
                (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) {
                PolicyCheck(unit, mem, IPV6_TO_IPV4_MAP_OFFSET_SETf,
                            fa->param[0]);
            }
            break;
#endif /* !BCM_TRIDENT_SUPPORT */

#ifdef INCLUDE_L3
#if defined(BCM_TRIUMPH_SUPPORT) && defined(BCM_MPLS_SUPPORT)
      case bcmFieldActionIncomingMplsPortSet:
          if (!BCM_GPORT_IS_MPLS_PORT(fa->param[0])) {
              return BCM_E_PARAM;
          }
          PolicyCheck(unit, mem, SVPf,
                      BCM_GPORT_MPLS_PORT_ID_GET((bcm_gport_t)fa->param[0]));
#endif
          break;
      case bcmFieldActionIngressGportSet:

          if (BCM_GPORT_IS_MPLS_PORT(fa->param[0]) &&
              soc_feature(unit, soc_feature_mpls)) {
              svp = BCM_GPORT_MPLS_PORT_ID_GET((bcm_gport_t)fa->param[0]);
          } else if (BCM_GPORT_IS_MIM_PORT(fa->param[0]) &&
                     soc_feature(unit, soc_feature_mim)) {
              svp = BCM_GPORT_MIM_PORT_ID_GET((bcm_gport_t)fa->param[0]);
          } else if (BCM_GPORT_IS_WLAN_PORT(fa->param[0]) &&
                     soc_feature(unit, soc_feature_wlan)) {
              svp = BCM_GPORT_WLAN_PORT_ID_GET((bcm_gport_t)fa->param[0]);
          } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[0]) &&
                     soc_feature(unit, soc_feature_trill)) {
              svp = BCM_GPORT_TRILL_PORT_ID_GET((bcm_gport_t)fa->param[0]);
          } else if (BCM_GPORT_IS_NIV_PORT(fa->param[0]) &&
                     soc_feature(unit, soc_feature_niv)) {
              svp = BCM_GPORT_NIV_PORT_ID_GET((bcm_gport_t)fa->param[0]);
          } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[0]) &&
                     soc_feature(unit, soc_feature_vxlan)) {
              svp = BCM_GPORT_VXLAN_PORT_ID_GET((bcm_gport_t)fa->param[0]);
#if defined(BCM_TRIDENT2_SUPPORT)
              if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                  bcm_vxlan_port_t vxlan_port;
                  sal_memset (&vxlan_port,0,sizeof(bcm_vxlan_port_t));
                  _bcm_td2_vxlan_port_get (unit,BCM_VXLAN_VPN_INVALID,svp,&vxlan_port);

                  if ((vxlan_port.flags & BCM_VXLAN_PORT_NETWORK)) {
                      return BCM_E_PARAM;
                  }
              }
#endif
          } else {
              return BCM_E_PARAM;
          }
          PolicyCheck(unit, mem, SVPf, svp);

          break;
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
      case bcmFieldActionVpnSet:
          if (!(soc_feature(unit, soc_feature_vfi_from_vlan_tables) ||
                soc_feature(unit, soc_feature_vxlan_lite))) {
              return BCM_E_UNAVAIL;
          }
          if (_BCM_VPN_VFI_IS_SET((bcm_vpn_t)fa->param[0])) {
              if (fa->param[0] != BCM_VXLAN_VPN_INVALID) {
                  _BCM_VPN_GET(vfi, _BCM_VPN_TYPE_VFI,
                                        (bcm_vpn_t)fa->param[0]);
              } else {
                  return BCM_E_PARAM;
              }
              PolicyCheck(unit, mem, VFIf, vfi);
          } else {
              return BCM_E_PARAM;
          }
          break;
#endif /* BCM_TRIDENT2PLUS_SUPPORT || BCM_GREYHOUND2_SUPPORT */
      case bcmFieldActionL3IngressSet:

          if (0 == SHR_BITGET(BCM_XGS3_L3_ING_IF_INUSE(unit), fa->param[0])) {
              return BCM_E_PARAM;
          }
          PolicyCheck(unit, mem, L3_IIFf, fa->param[0]);
          break;
      case bcmFieldActionL3ChangeVlan:
      case bcmFieldActionL3ChangeMacDa:
      case bcmFieldActionL3Switch:
          rv = _bcm_field_policy_set_l3_nh_resolve(unit,  fa->param[0],
                                                   &flags, &nh_ecmp_id);
          BCM_IF_ERROR_RETURN(rv);
          if (flags & BCM_L3_MULTIPATH) {
              PolicyCheck(unit, mem, ECMP_PTRf, nh_ecmp_id);
          } else {
              PolicyCheck(unit, mem, NEXT_HOP_INDEXf, nh_ecmp_id);

              /* Egress object range sanity. */
              if (!BCM_XGS3_L3_EGRESS_IDX_VALID(unit, fa->param[0]) &&
                  !BCM_XGS3_DVP_EGRESS_IDX_VALID(unit, fa->param[0])) {
                  return BCM_E_PARAM;
              }
          }
          break;
      case bcmFieldActionNatEgressOverride:
          if (soc_feature(unit, soc_feature_nat)) {
              bcm_l3_nat_egress_t nat_info;
              nat_info.nat_id = fa->param[0];

              rv = bcm_esw_l3_nat_egress_get(unit, &nat_info);
              if(BCM_FAILURE(rv)){
                  return BCM_E_PARAM;
              }
          }
          else {
              return BCM_E_UNAVAIL;
          }
          break;
#endif /* INCLUDE_L3 */
      case bcmFieldActionOamUpMep:
          PolicyCheck(unit, mem, OAM_UP_MEPf, fa->param[0]);
          break;
      case bcmFieldActionOamTx:
          PolicyCheck(unit, mem, OAM_TXf, fa->param[0]);
          break;
      case bcmFieldActionOamLmepMdl:
          PolicyCheck(unit, mem, OAM_LMEP_MDLf, fa->param[0]);
          break;
      case bcmFieldActionOamServicePriMappingPtr:
          PolicyCheck(unit, mem, OAM_SERVICE_PRI_MAPPING_PTRf, fa->param[0]);
          break;
      case bcmFieldActionOamLmBasePtr:
          PolicyCheck(unit, mem, OAM_LM_BASE_PTRf, fa->param[0]);
          break;
      case bcmFieldActionOamDmEnable:
          PolicyCheck(unit, mem, OAM_DM_ENf, fa->param[0]);
          break;
      case bcmFieldActionOamLmEnable:
          PolicyCheck(unit, mem, OAM_LM_ENf, fa->param[0]);
          break;
#if defined(BCM_TRIUMPH3_SUPPORT)
      case bcmFieldActionOamLmDmSampleEnable:
        if( (SOC_IS_SABER2(unit)) || (SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit)) ) {
            PolicyCheck(unit, mem, OAM_ENABLE_LM_DM_SAMPLEf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    case bcmFieldActionOamOlpHeaderAdd:
        if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_oam))) {
            if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                if (fa->param[0] >= bcmFieldOlpHeaderTypeCount) {
                    return (BCM_E_PARAM);
                }
                hw_index = 0;
                rv = _bcm_oam_olp_fp_hw_index_get (unit,fa->param[0],
                                            &hw_index);
                if (BCM_FAILURE(rv)) {
                    return BCM_E_PARAM;
                }
                PolicyCheck(unit, mem, OLP_HDR_ADDf, 1);
                PolicyCheck(unit, mem, OLP_HDR_TYPE_COMPRESSEDf, hw_index);
            }
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
#endif
      case bcmFieldActionOamLmepEnable:
          PolicyCheck(unit, mem, OAM_LMEP_ENf, fa->param[0]);
          break;
      case bcmFieldActionOamPbbteLookupEnable:
          if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
              PolicyCheck(unit, mem, OAM_PBBTE_LOOKUP_ENABLEf, fa->param[0]);
          }
          break;
      case bcmFieldActionOamDmTimeFormat:
          PolicyCheck(unit, mem, OAM_DM_TYPEf, fa->param[0]);
          break;
      case bcmFieldActionOamTagStatusCheck:
          PolicyCheck(unit, mem, OAM_TAG_STATUS_CHECK_CONTROLf, fa->param[0]);
          break;
      case bcmFieldActionServicePoolIdNew:
          if (0 != (fa->param[0] >> 2)) {
             return BCM_E_PARAM;
          }
          break;
      case bcmFieldActionServicePoolIdPrecedenceNew:
          if (0 != ((fa->param[0] >> 2) | (fa->param[1] >> 2) | (!fa->param[1]))) {
             return BCM_E_PARAM;
          }
          break;
      case bcmFieldActionRedirectEgrNextHop:
#ifdef INCLUDE_L3
          {
             int ifp_type = 0;

             if ((!soc_feature(unit, soc_feature_nh_for_ifp_actions)) &&
                 (fa->param[1] == bcmFieldRedirectTypeAll)) {
                return BCM_E_UNAVAIL;
             }

             /* Get next hop info from Egress Object ID param */
             rv = (_bcm_field_l3_egr_object_ifp_type_index_get(unit, fa->param[0],
                                               &ifp_type, &flags, &nh_ecmp_id));

             if (!(((fa->param[1] == bcmFieldRedirectTypeAll) &&
                   (ifp_type == TRUE)) ||
                  ((fa->param[1] == bcmFieldRedirectTypeL3) &&
                   (ifp_type == FALSE)))) {
                 return BCM_E_PARAM;
             }
          }

          if (flags & BCM_L3_MULTIPATH) {
              /* Param0 - ECMP next hop */
              if (0 == soc_feature(unit, soc_feature_field_action_redirect_ecmp)) {
                  return (BCM_E_PARAM);
              }
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x3 << 18)));
              } else {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x3 << 16)));
              }
          } else {
              /* Param0 - Regular next hop */
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x2 << 18)));
              } else if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x2 << 16)));
              } else if (SOC_IS_GREYHOUND2(unit)) {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x1 << 16)));
              } else if (SOC_IS_HURRICANE3(unit)) {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x1 << 15)));
              } else {
                  PolicyCheck(unit, mem, REDIRECTIONf, (nh_ecmp_id | (0x1 << 14)));
              }
          }
          break;
#else
          return BCM_E_UNAVAIL;
#endif /* INCLUDE_L3 */
#if defined(BCM_GREYHOUND_SUPPORT)
      case bcmFieldActionPfcClassNew:
          if (soc_feature(unit, soc_feature_field_action_pfc_class)) {
              PolicyCheck(unit, mem, NEW_INPUT_PRIORITYf, fa->param[0]);
          }
          break;
      case bcmFieldActionRpIntCongestionNotificationNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, R_NEW_INT_CNf, fa->param[0]);
          }
          break;
      case bcmFieldActionYpIntCongestionNotificationNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, Y_NEW_INT_CNf, fa->param[0]);
          }
          break;
      case bcmFieldActionGpIntCongestionNotificationNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, G_NEW_INT_CNf, fa->param[0]);
          }
          break;
#endif
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
      case bcmFieldActionRpHGCongestionClassNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, R_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
          }
          break;
      case bcmFieldActionYpHGCongestionClassNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, Y_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
          }
          break;
      case bcmFieldActionGpHGCongestionClassNew:
          if (soc_feature(unit, soc_feature_ecn_wred)) {
              PolicyCheck(unit, mem, G_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
          }
          break;
#endif /* BCM_GREYHOUND_SUPPORT (or) BCM_TOMAHAWK_SUPPORT*/
#ifdef BCM_TRIUMPH3_SUPPORT
      case bcmFieldActionUnmodifiedPacketRedirectPort:
          if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
              PolicyCheck(unit, mem, REDIRECT_MODIDf,
                                BCM_GPORT_MODPORT_MODID_GET(fa->param[0]));
              PolicyCheck(unit, mem, REDIRECT_PORT_NUMf,
                                BCM_GPORT_MODPORT_PORT_GET(fa->param[0]));
          } else if (BCM_GPORT_IS_TRUNK(fa->param[0])) {
              redir_field = 0x1 << 15;
              redir_field |= BCM_GPORT_TRUNK_GET(fa->param[0]);
              PolicyCheck(unit, mem, REDIRECT_DGLPf, redir_field);
          } else {
              return BCM_E_PARAM;
          }
          break;
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
      case bcmFieldActionRedirDropPrecedence:
          if ((SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, R_REDIR_DROP_PRECEDENCEf)
               || SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, Y_REDIR_DROP_PRECEDENCEf)
               || SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, G_REDIR_DROP_PRECEDENCEf))
               && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
               PolicyCheck(unit, mem, R_REDIR_DROP_PRECEDENCEf, fa->param[0]);
               PolicyCheck(unit, mem, Y_REDIR_DROP_PRECEDENCEf, fa->param[0]);
               PolicyCheck(unit, mem, G_REDIR_DROP_PRECEDENCEf, fa->param[0]);
          } else {
               return BCM_E_UNAVAIL;
          }
          break;
      case bcmFieldActionRpRedirDropPrecedence:
          if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, R_REDIR_DROP_PRECEDENCEf)
              && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
              PolicyCheck(unit, mem, R_REDIR_DROP_PRECEDENCEf, fa->param[0]);
          } else {
               return BCM_E_UNAVAIL;
          }
          break;
      case bcmFieldActionYpRedirDropPrecedence:
          if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, Y_REDIR_DROP_PRECEDENCEf)
              && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
              PolicyCheck(unit, mem, Y_REDIR_DROP_PRECEDENCEf, fa->param[0]);
          } else {
               return BCM_E_UNAVAIL;
          }
          break;
      case bcmFieldActionGpRedirDropPrecedence:
          if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, G_REDIR_DROP_PRECEDENCEf)
              && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
              PolicyCheck(unit, mem, G_REDIR_DROP_PRECEDENCEf, fa->param[0]);
          } else {
               return BCM_E_UNAVAIL;
          }
          break;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
      case bcmFieldActionHiGigClassSelect:
          if (fa->param[0] <= BCM_FIELD_HIGIG_CLASS_SELECT_PORT) {
              PolicyCheck(unit, mem, HG_CLASSID_SELf, fa->param[0]);
          } else {
               return BCM_E_PARAM;
          }
      break;
      case bcmFieldActionNewClassId:
         PolicyCheck(unit, mem, I2E_CLASSIDf, fa->param[0]);
      break;
#endif /* BCM_KATANA2_SUPPORT */

#if defined BCM_KATANA2_SUPPORT || defined BCM_TRIDENT2_SUPPORT
      case bcmFieldActionDscpMapNew:
      hw_index = 0;
#if defined BCM_TRIUMPH2_SUPPORT
      rv = _bcm_tr2_qos_id2idx(unit, fa->param[0], &hw_index);
      if (BCM_FAILURE(rv)) {
          return BCM_E_PARAM;
      }
#endif
      PolicyCheck(unit, mem, TRUST_DSCP_PTRf, hw_index);
      break;
#endif /* BCM_KATANA2_SUPPORT || BCM_TRIDENT2_SUPPORT*/

      case bcmFieldActionChangeL2Fields:
#if defined INCLUDE_L3
           {
              int ifp_type = 0;
              uint32 flags;
              int nh_ecmp_id = 0;

              rv = _bcm_field_l3_egr_object_ifp_type_index_get(unit,
                      fa->param[0], &ifp_type, &flags, &nh_ecmp_id);
              if (ifp_type == TRUE) {
                 return BCM_E_NONE;
              }
              return BCM_E_PARAM;
           }
#endif /* INCLUDE_L3 */
           return BCM_E_UNAVAIL;
           break;
#if defined(BCM_HURRICANE3_SUPPORT)
      case bcmFieldActionPfcTx:
          PolicyCheck(unit, mem, PFC_STREAM_IDf, fa->param[0]);
          PolicyCheck(unit, mem, PFC_TCf, fa->param[1]);
          break;
      case bcmFieldActionSwitchEncap:
          if (soc_feature(unit, soc_feature_miml) ||
              soc_feature(unit, soc_feature_custom_header)) {

              if ((fa->param[0] >> _BCM_SWITCH_ENCAP_SHIFT) ==
                  _BCM_SWITCH_ENCAP_TYPE_MIML) {
                  rv = _bcm_hr3_switch_encap_id2idx(unit, fa->param[0], 2, index_array);
                  if (BCM_FAILURE(rv)) {
                      return BCM_E_PARAM;
                  }

                  PolicyCheck(unit, mem, REDIRECTIONf, (index_array[0] | (0x1 << 15)));
                  PolicyCheck(unit, mem, HEADER_ENCAP_INDEXf, index_array[1]);
              } else if ((fa->param[0] >> _BCM_SWITCH_ENCAP_SHIFT) ==
                  _BCM_SWITCH_ENCAP_TYPE_CUSTOM_HEADER) {
                  rv = _bcm_hr3_switch_encap_id2idx(unit, fa->param[0], 1, index_array);
                  if (BCM_FAILURE(rv)) {
                      return BCM_E_PARAM;
                  }

                  PolicyCheck(unit, mem, HEADER_ENCAP_INDEXf, index_array[0]);
              } else {
                  return BCM_E_PARAM;
              }
          } else {
              return BCM_E_UNAVAIL;
          }

          break;
#endif /* BCM_HURRICANE3_SUPPORT */

#if defined(BCM_GREYHOUND2_SUPPORT)
      case bcmFieldActionUseTunnelPayload:
          if (soc_feature(unit, soc_feature_vxlan_lite)) {
              PolicyCheck(unit, mem, IP_TUNNEL_TERMINATIONf, fa->param[0]);
          } else {
              return BCM_E_UNAVAIL;
          }
          break;
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
      case bcmFieldActionUcastQueueNew:
      _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);

       PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);

        PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
       PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
       break;

       case bcmFieldActionRpUcastQueueNew:
      _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);

       PolicyCheck(unit, mem, R_COS_INT_PRIf, cosq_new);
        break;

       case bcmFieldActionYpUcastQueueNew:
      _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);

       PolicyCheck(unit, mem, Y_COS_INT_PRIf, cosq_new);
       break;

       case bcmFieldActionGpUcastQueueNew:
       _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);

       PolicyCheck(unit, mem, G_COS_INT_PRIf, cosq_new);
       break;

       case bcmFieldActionIntCosUcastQueueNew:
        shift_val = SOC_IS_SABER2(unit) ? 10 :12;
       _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
           PolicyCheck(unit, mem, R_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));

           PolicyCheck(unit, mem, Y_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));
           PolicyCheck(unit, mem, G_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));
           break;

       case bcmFieldActionRpIntCosUcastQueueNew:
       shift_val = SOC_IS_SABER2(unit) ? 10 :12;
       _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
           PolicyCheck(unit, mem, R_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));
        break;

       case bcmFieldActionYpIntCosUcastQueueNew:
       shift_val = SOC_IS_SABER2(unit) ? 10 :12;
       _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
           PolicyCheck(unit, mem, Y_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));

       break;

       case bcmFieldActionGpIntCosUcastQueueNew:
       shift_val = SOC_IS_SABER2(unit) ? 10 :12;
       _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
           PolicyCheck(unit, mem, G_COS_INT_PRIf,
                     (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                      cosq_new));

           break;

#endif

#if defined(BCM_APACHE_SUPPORT)
       case bcmFieldActionRedirectPrioIntNew:
           PolicyCheck(unit, mem, R_NEW_REDIR_INT_PRIf, fa->param[0]);
           PolicyCheck(unit, mem, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
           PolicyCheck(unit, mem, G_NEW_REDIR_INT_PRIf, fa->param[0]);
           return BCM_E_NONE;
           break;
       case bcmFieldActionRpRedirectPrioIntNew:
           PolicyCheck(unit, mem, R_NEW_REDIR_INT_PRIf, fa->param[0]);
           return BCM_E_NONE;
           break;
       case bcmFieldActionYpRedirectPrioIntNew:
           PolicyCheck(unit, mem, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
           return BCM_E_NONE;
           break;
       case bcmFieldActionGpRedirectPrioIntNew:
           PolicyCheck(unit, mem, G_NEW_REDIR_INT_PRIf, fa->param[0]);
           return BCM_E_NONE;
           break;
#endif /* BCM_APACHE_SUPPORT */


#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        case bcmFieldActionPortPrioIntCosQNew:
        case bcmFieldActionRpPortPrioIntCosQNew:
                BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
                if (cosq_new > ((0x1 << ((SOC_IS_KATANA2(unit) || SOC_IS_TD2_TT2(unit)) \
                    ? shift_val - 1 : shift_val))-1)) {
                    return (BCM_E_PARAM);
                }
                PolicyCheck(unit, mem, R_COS_INT_PRIf,
                        (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val | cosq_new));
                break;
        case bcmFieldActionYpPortPrioIntCosQNew:
                BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
                if (cosq_new > ((0x1 << ((SOC_IS_KATANA2(unit) || SOC_IS_TD2_TT2(unit)) \
                    ? shift_val - 1 : shift_val))-1)) {
                    return (BCM_E_PARAM);
                }
                PolicyCheck(unit, mem, Y_COS_INT_PRIf,
                        (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val | cosq_new));
                break;
        case bcmFieldActionGpPortPrioIntCosQNew:
                BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
                if (cosq_new > ((0x1 << ((SOC_IS_KATANA2(unit) || SOC_IS_TD2_TT2(unit)) \
                    ? shift_val - 1 : shift_val))-1)) {
                    return (BCM_E_PARAM);
                }
                PolicyCheck(unit, mem, G_COS_INT_PRIf,
                        (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val | cosq_new));
                break;
#endif
#if defined(BCM_KATANA2_SUPPORT)
        case bcmFieldActionServicePrioIntCosQNew:
        case bcmFieldActionRpServicePrioIntCosQNew:
                shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
                _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
                PolicyCheck(unit, mem, R_COS_INT_PRIf,
                       (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |  0x1 << (shift_val-1) | cosq_new));
                break;
        case bcmFieldActionYpServicePrioIntCosQNew:
                shift_val = SOC_IS_SABER2(unit) ? 10 :12;
                _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
                PolicyCheck(unit, mem, Y_COS_INT_PRIf,
                       (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val | 0x1 << (shift_val-1) | cosq_new));
                break;
        case bcmFieldActionGpServicePrioIntCosQNew:
                _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                       _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                       &cosq_new, NULL);
                shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
                PolicyCheck(unit, mem, G_COS_INT_PRIf,
                       (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |  0x1 << (shift_val-1) | cosq_new));
                break;
#endif

      default:
          return BCM_E_NONE;
    }
    return (BCM_E_NONE);
}

int
_bcm_field_trx_vlan_format_qualify_is_double_tagged(unsigned data, unsigned mask)
{
    if ((mask & (BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED
                 | BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED_VID_ZERO
                 )
         ) == 0
        || (mask & (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED
                    | BCM_FIELD_VLAN_FORMAT_INNER_TAGGED_VID_ZERO
                    )
            ) == 0
        || (data & (BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED
                    | BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED_VID_ZERO
                    )
            ) == 0
        || (data & (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED
                    | BCM_FIELD_VLAN_FORMAT_INNER_TAGGED_VID_ZERO
                    )
            ) == 0
        ) {
        return (FALSE);
    }

    return (TRUE);
}

/*
 * Function:
 *     _bcm_field_trx_action_depends_check
 * Purpose:
 *     Check field action parameters.
 * Parameters:
 *     unit     - BCM device number
 *     f_ent    - Field entry structure.
 *     fa       - field action
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_action_depends_check(int             unit,
                                    _field_entry_t  *f_ent,
                                    _field_action_t *fa
                                    )
{
    return (BCM_E_NONE);
}

#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
/*
 * Function:
 *     _bcm_field_trx_ucast_mcast_action_update
 * Purpose:
 *     Modify Unicast and Multicast queue values
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     mem      - (IN) Policy table memory.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     tcam_idx - (IN) Field policy table entry index.
 *     fa       - (IN) Field action.
 *     buf      - (OUT) Field Policy table entry.
 * Returns:
 *     BCM_E_XXX
 */
STATIC
int _bcm_field_trx_ucast_mcast_action_update(int unit, soc_mem_t mem,
                                            _field_entry_t *f_ent,
                                            int tcam_idx, _field_action_t *fa,
                                            uint32 *buf)
{
    int ucast_cosq_new = BCM_COS_INVALID;   /* Unicast new Queue value */
    int mcast_cosq_new = BCM_COS_INVALID;   /* Muliticast new Queue value */
    int ucosq = BCM_COS_INVALID;            /* Current unicast queue value */
    int mcosq = BCM_COS_INVALID;            /* Current mcast queue value */
    _field_action_t *f_ent_act = NULL;      /* Field entry action */
    uint8 mcast_mode_set = 0;               /* Multicast action is set */
    uint8 ucast_mode_set = 0;               /* Unicast action is set */

    /* Check and return error for invalid cases */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    if (!(SOC_IS_TD_TT(unit))) {
        return BCM_E_UNAVAIL;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: _bcm_field_trx_ucast_mcast_action_update "),
               unit));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "eid=%d, tcam_idx=0x%x\n "),
               f_ent->eid, tcam_idx));

    /* Get Queue value for Unicast actions */
    if ((bcmFieldActionCosQNew == fa->action) ||
        (bcmFieldActionRpCosQNew == fa->action)||
        (bcmFieldActionYpCosQNew == fa->action)||
        (bcmFieldActionGpCosQNew == fa->action)||
        (bcmFieldActionUcastCosQNew == fa->action)||
        (bcmFieldActionRpUcastCosQNew == fa->action) ||
        (bcmFieldActionYpUcastCosQNew == fa->action) ||
        (bcmFieldActionGpUcastCosQNew == fa->action)) {
        /*
         * Check if queue parameter value is of GPORT type.
         */
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0])) {
            BCM_IF_ERROR_RETURN
                (_bcm_td_cosq_index_resolve(unit, fa->param[0], 0,
                    _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                    &ucast_cosq_new, NULL));
        } else {
            ucast_cosq_new = fa->param[0];
        }
    }

    /* Get Queue value for Multicast actions */
    if ((bcmFieldActionMcastCosQNew == fa->action) ||
        (bcmFieldActionRpMcastCosQNew == fa->action) ||
        (bcmFieldActionYpMcastCosQNew == fa->action) ||
        (bcmFieldActionGpMcastCosQNew == fa->action)) {
        /*
         * Check if queue parameter value is of GPORT type.
         */
        if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(fa->param[0])) {
            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                fa->param[0], 0, _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                &mcast_cosq_new, NULL));
        } else {
            mcast_cosq_new = fa->param[0];
        }
    }

    switch (fa->action) {
        case bcmFieldActionCosQNew:
            /* Set mode info for all colors */
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            /* Set queue info for all colors */
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            break;
        case bcmFieldActionRpCosQNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            break;
        case bcmFieldActionYpCosQNew:
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            break;
        case bcmFieldActionGpCosQNew:
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                (_FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new,
                    ucast_cosq_new)));
            break;
        case bcmFieldActionUcastCosQNew:
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionMcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                                &mcosq, NULL));
                        }
                    } else {
                        mcosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == mcast_mode_set) {
                /* Set Unicast packet queue mode */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);

                /* Set Unicast packet queue value */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
            }
            break;
        case bcmFieldActionMcastCosQNew:
            /* Check if corresponding unicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionUcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    ucast_mode_set = 1;
                    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                            f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                                &ucosq, NULL));
                        }
                    } else {
                        ucosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == ucast_mode_set) {
                /* Change Unicast packet queue mode */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);

                /* Change Unicast packet queue value */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));
            }
            break;
        case bcmFieldActionRpUcastCosQNew:
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionRpMcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                                &mcosq, NULL));
                        }
                    } else {
                        mcosq = f_ent_act->param[0];
                    }
                }
            }

            if (0 == mcast_mode_set) {
                /* Set Unicast packet queue mode */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);
                /* Set Unicast packet queue value */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
            }
            break;
        case bcmFieldActionRpMcastCosQNew:
            /* Check if corresponding unicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionRpUcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    ucast_mode_set = 1;
                    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                                &ucosq, NULL));
                        }
                    } else {
                        ucosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == ucast_mode_set) {
                /* Change Unicast packet queue mode */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);

                /* Change Unicast packet queue value */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));
            }
            break;
        case bcmFieldActionYpUcastCosQNew:
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionYpMcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    mcosq = f_ent_act->param[0];
                }
            }
            if (0 == mcast_mode_set) {
                /* Set Unicast packet queue mode */
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);
                /* Set Unicast packet queue value */
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
            }
            break;
        case bcmFieldActionYpMcastCosQNew:
            /* Check if corresponding unicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionYpUcastCosQNew == f_ent_act->param[0]) {
                    /* Get current unicast queue value */
                    ucast_mode_set = 1;
                    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                                &ucosq, NULL));
                        }
                    } else {
                        ucosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == ucast_mode_set) {
                /* Change Unicast packet queue mode */
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);

                /* Change Unicast packet queue value */
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));

            }
            break;
        case bcmFieldActionGpUcastCosQNew:
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionGpMcastCosQNew == f_ent_act->action) {
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_MCAST_QUEUE, NULL,
                                &mcosq, NULL));
                        }
                    } else {
                        mcosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == mcast_mode_set) {
                /* Set Unicast packet queue mode */
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_NEW_MODE);
                /* Set Unicast packet queue value */
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_QUEUE_SET(ucast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucast_cosq_new, mcosq));
            }
            break;
        case bcmFieldActionGpMcastCosQNew:
            /* Check if corresponding unicast action is set for this entry */
            for (f_ent_act = f_ent->actions; fa != NULL; fa = fa->next) {
                if (bcmFieldActionGpUcastCosQNew == f_ent_act->param[0]) {
                    /* Get current unicast queue value */
                    ucast_mode_set = 1;
                    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(f_ent_act->param[0])) {
                        if (SOC_IS_TD_TT(unit)) {
                            BCM_IF_ERROR_RETURN(_bcm_td_cosq_index_resolve(unit,
                                f_ent_act->param[0], 0,
                                _BCM_TD_COSQ_INDEX_STYLE_UCAST_QUEUE, NULL,
                                &ucosq, NULL));
                        }
                    } else {
                        ucosq = f_ent_act->param[0];
                    }
                }
            }
            if (0 == ucast_mode_set) {
                /* Change Unicast packet queue mode */
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_NEW_MODE);

                /* Change Unicast packet queue value */
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_MCAST_QUEUE_SET(mcast_cosq_new));
            } else {
                /* Set Ucast and Mcast queue modes */
                PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_NEW_MODE);

                /* Set Ucast and Mcast queue values */
                PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                    _FP_ACTION_UCAST_MCAST_QUEUE_SET(ucosq, mcast_cosq_new));
            }
            break;
        default:
            return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}
#endif /* !BCM_TRIDENT_SUPPORT */

#if defined(BCM_KATANA_SUPPORT)
/*
 * Function:
 *     _field_kt_action_update
 * Purpose:
 *     Modify action values
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     mem      - (IN) Policy table memory.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     tcam_idx - (IN) Field policy table entry index.
 *     fa       - (IN) Field action.
 *     buf      - (OUT) Field Policy table entry.
 * Returns:
 *     BCM_E_XXX
 */
STATIC
int _field_kt_action_update(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                            int tcam_idx, _field_action_t *fa, uint32 *buf)
{
    int cosq_new = BCM_COS_INVALID;   /* Unicast new Queue value */

    /* Check and return error for invalid cases */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    if (!(SOC_IS_KATANAX(unit))) {
        return BCM_E_UNAVAIL;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: _field_kt_action_update "),
                           unit));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "eid=%d, tcam_idx=0x%x\n "),
                          f_ent->eid, tcam_idx));

    /* Get Queue value for Unicast actions */
    if ((bcmFieldActionCosQNew == fa->action) ||
        (bcmFieldActionRpCosQNew == fa->action)||
        (bcmFieldActionYpCosQNew == fa->action)||
        (bcmFieldActionGpCosQNew == fa->action)||
        (bcmFieldActionUcastCosQNew == fa->action)||
        (bcmFieldActionRpUcastCosQNew == fa->action) ||
        (bcmFieldActionYpUcastCosQNew == fa->action) ||
        (bcmFieldActionGpUcastCosQNew == fa->action)) {
        /*
         * Check if queue parameter value is of GPORT type.
         */
        if (BCM_GPORT_IS_SET(fa->param[0]) &&
            (BCM_GPORT_IS_UCAST_QUEUE_GROUP(fa->param[0]) ||
             BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]) ||
             BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(fa->param[0]))) {
                /* The field x_CHANGE_COS_OR_INT_PRI takes
                 * hardware index number corresponding to the cos queue.
                 * Currently _bcm_kt_cosq_index_resolve() returns hw index
                 * when flag is _BCM_KT_COSQ_INDEX_STYLE_BUCKET.
                 */
                BCM_IF_ERROR_RETURN
                    (_bcm_kt_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL));
        } else {
            cosq_new = fa->param[0];
        }
    }
    switch (fa->action) {
        case bcmFieldActionCosQNew:
        case bcmFieldActionUcastCosQNew:
            /* Set mode info for all colors */
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            /* Set queue info for all colors */
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionRpCosQNew:
        case bcmFieldActionRpUcastCosQNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionYpUcastCosQNew:
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionGpUcastCosQNew:
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf,
                _FP_ACTION_UCAST_QUEUE_NEW_MODE);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        default:
            return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}
#endif  /* !BCM_KATANA_SUPPORT */

#if defined(BCM_GREYHOUND2_SUPPORT)
/*
 * Function:
 *     _field_gh2_action_update
 * Purpose:
 *     Modify action values
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     mem      - (IN) Policy table memory.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     tcam_idx - (IN) Field policy table entry index.
 *     fa       - (IN) Field action.
 *     buf      - (OUT) Field Policy table entry.
 * Returns:
 *     BCM_E_XXX
 */
STATIC
int _field_gh2_action_update(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                             int tcam_idx, _field_action_t *fa, uint32 *buf)
{
    int cosq_new = BCM_COS_INVALID;
    int cosq_ext_num = 0;

    /* Check and return error for invalid cases */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP vverb: _field_gh2_action_update ")));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "eid=%d, tcam_idx=0x%x\n "),
                          f_ent->eid, tcam_idx));

    /* Get Queue value for Unicast actions */
    if ((bcmFieldActionCosQNew == fa->action) ||
        (bcmFieldActionRpCosQNew == fa->action)||
        (bcmFieldActionYpCosQNew == fa->action)||
        (bcmFieldActionGpCosQNew == fa->action)) {
        /*
         * Check if queue parameter value is of GPORT type.
         */
        if (BCM_GPORT_IS_SET(fa->param[0])) {
                BCM_IF_ERROR_RETURN
                    (bcmi_gh2_cosq_index_resolve(unit,
                                                 fa->param[0], &cosq_new));
        } else {
            cosq_new = fa->param[0];
        }
    }

    cosq_ext_num = (cosq_new >> 3) & 0x7;
    cosq_new &= 0x7;

    switch (fa->action) {
        case bcmFieldActionCosQNew:
            /* Set queue extension number */
            PolicySet(unit, mem, buf, QUEUE_EXTENSION_NUMf, cosq_ext_num);
            /* Set mode info */
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x1);
            /* Set queue info for all colors */
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionRpCosQNew:
            /* Set queue extension number */
            PolicySet(unit, mem, buf, QUEUE_EXTENSION_NUMf, cosq_ext_num);
            /* Set mode info */
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x1);
            /* Set queue info */
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionYpCosQNew:
            /* Set queue extension number */
            PolicySet(unit, mem, buf, QUEUE_EXTENSION_NUMf, cosq_ext_num);
            /* Set mode info */
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x1);
            /* Set queue info */
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionGpCosQNew:
            /* Set queue extension number */
            PolicySet(unit, mem, buf, QUEUE_EXTENSION_NUMf, cosq_ext_num);
            /* Set mode info */
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x1);
            /* Set queue info */
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        default:
            return (BCM_E_UNAVAIL);
    }
    return (BCM_E_NONE);
}
#endif  /* BCM_GREYHOUND2_SUPPORT */

#define BCM_FIELD_OAM_SESSION_ID_MAX 0xffff

/*
 * Function:
 *     _bcm_field_trx_action_get
 * Purpose:
 *     Get the actions to be written
 * Parameters:
 *     unit     - BCM device number
 *     mem      - Policy table memory
 *     f_ent    - entry structure to get policy info from
 *     tcam_idx - index into TCAM
 *     fa       - field action
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_trx_action_get(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                          int tcam_idx, _field_action_t *fa, uint32 *buf)
{
    uint32    mode;
    int       rv;
    uint32 value = 0;
    soc_field_t l3sw_or_change_l2 = INVALIDf;
#ifdef INCLUDE_L3
    _field_action_t *fa_temp = NULL;
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    int      shift_val;
#endif
#ifdef INCLUDE_L3
    int       svp = -1;
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    int vfi = 0;
#endif
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint8 src_is_svp = 0; /* Source type.   */
    uint8 mod_id = 0;     /* BCM Module ID. */
    uint8 port_id = 0;    /* BCM Port Id.   */
    int   src_svp = -1;   /* SVP */
#endif
#ifdef BCM_KATANA2_SUPPORT
    uint32 param0 = 0;
    uint32 param1 = 0;
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    int cosq_new = BCM_COS_INVALID;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    int hw_index = 0;
#endif
#ifdef BCM_HURRICANE3_SUPPORT
    int index_array[2] = {0};
#endif
#if defined(BCM_APACHE_SUPPORT)
    int8 flex_stat_pool_id = 0;
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
    uint32 svm_disable = 0;
#endif /* BCM_GREYHOUND2_SUPPORT */

    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: BEGIN _bcm_field_trx_action_get(eid=%d, tcam_idx=0x%x)\n"),
               unit, f_ent->eid, tcam_idx));

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        rv = _bcm_field_tr3_action_get(unit, mem, f_ent, tcam_idx, fa,
                buf);
        if (BCM_SUCCESS(rv)) {
            fa->flags &= ~_FP_ACTION_DIRTY; /* Mark action as installed. */
            return rv;
        }
    }
#endif

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_td2_action_get(unit, mem, f_ent, tcam_idx, fa, buf);
        if (BCM_SUCCESS(rv)) {
            fa->flags &= ~_FP_ACTION_DIRTY; /* Mark action as installed. */
            return rv;
        }
    }
#endif

    if (SOC_MEM_FIELD_VALID(unit, mem, G_L3SW_CHANGE_MACDA_OR_VLANf)) {
        l3sw_or_change_l2 = G_L3SW_CHANGE_MACDA_OR_VLANf;
    } else {
        l3sw_or_change_l2 = G_L3SW_CHANGE_L2_FIELDSf;
    }

    switch (fa->action) {
    case bcmFieldActionMultipathHash:
        PolicySet(unit, mem, buf, ECMP_HASH_SELf, fa->param[0]);
        break;
    case bcmFieldActionCopyToCpu:
    case bcmFieldActionRpCopyToCpu:
    case bcmFieldActionYpCopyToCpu:
    case bcmFieldActionGpCopyToCpu:
    case bcmFieldActionTimeStampToCpu:
    case bcmFieldActionRpTimeStampToCpu:
    case bcmFieldActionYpTimeStampToCpu:
    case bcmFieldActionGpTimeStampToCpu:
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
        } else
#endif
        {
#ifdef BCM_TRIUMPH2_SUPPORT
        if (!soc_feature(unit, soc_feature_internal_loopback) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            /* Loopback port is not available */
            return BCM_E_UNAVAIL;
        }
#endif
        }
        rv = _field_trx_action_copy_to_cpu(unit, mem, f_ent, fa, buf);
        BCM_IF_ERROR_RETURN(rv);
        break;

    case bcmFieldActionCopyToCpuCancel:
    case bcmFieldActionRpCopyToCpuCancel:
    case bcmFieldActionYpCopyToCpuCancel:
    case bcmFieldActionGpCopyToCpuCancel:
    case bcmFieldActionTimeStampToCpuCancel:
    case bcmFieldActionRpTimeStampToCpuCancel:
    case bcmFieldActionYpTimeStampToCpuCancel:
    case bcmFieldActionGpTimeStampToCpuCancel:
        rv = _field_trx_action_copy_to_cpu_cancel(unit, mem, f_ent, fa, buf);
        BCM_IF_ERROR_RETURN(rv);
        break;

    case bcmFieldActionDrop:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, DROPf, 0x1);
        } else {
            PolicySet(unit, mem, buf, R_DROPf, 0x1);
            PolicySet(unit, mem, buf, Y_DROPf, 0x1);
            PolicySet(unit, mem, buf, G_DROPf, 0x1);
        }
        break;

    case bcmFieldActionDropCancel:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, DROPf, 0x2);
        } else {
            PolicySet(unit, mem, buf, R_DROPf, 0x2);
            PolicySet(unit, mem, buf, Y_DROPf, 0x2);
            PolicySet(unit, mem, buf, G_DROPf, 0x2);
        }
        break;

    case bcmFieldActionClassDestSet:
        PolicySet(unit, mem, buf, USE_VFP_CLASS_ID_Lf, 0x1);
        PolicySet(unit, mem, buf, VFP_CLASS_ID_Lf, fa->param[0]);
        break;

    case bcmFieldActionClassSourceSet:
        PolicySet(unit, mem, buf, USE_VFP_CLASS_ID_Hf, 0x1);
        PolicySet(unit, mem, buf, VFP_CLASS_ID_Hf, fa->param[0]);
        break;

    case bcmFieldActionVrfSet:
        if (soc_feature(unit, soc_feature_mpls)) {
            if (SOC_MEM_FIELD_VALID(unit, mem, FIELDS_ACTIONf)) {
                PolicySet(unit, mem, buf, FIELDS_ACTIONf, 0x3);
            } else {
                PolicySet(unit, mem, buf, MPLS_ACTIONf, 0x3);
            }
            PolicySet(unit, mem, buf, VFP_VRF_IDf, fa->param[0]);
        }  else {
            if (SOC_MEM_FIELD_VALID(unit, mem, FIELDS_ACTIONf)) {
                PolicySet(unit, mem, buf, FIELDS_ACTIONf, 0x3);
            } else {
                PolicySet(unit, mem, buf, USE_VFP_VRF_IDf , 0x1);
            }
            PolicySet(unit, mem, buf, VFP_VRF_IDf, fa->param[0]);

        }
        break;

    case bcmFieldActionDropPrecedence:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            uint8 hardware_color;

            /* Convert to hardware color code because the tr2x
               VFP hardware doesn't do it for us */

            switch (fa->param[0])
                {
                case BCM_FIELD_COLOR_GREEN:
                    hardware_color = 0;
                    break;

                case BCM_FIELD_COLOR_RED:
                    hardware_color = 1;
                    break;

                case BCM_FIELD_COLOR_YELLOW:
                    hardware_color = 3;
                    break;

                default:
                    return BCM_E_PARAM;
                }

            PolicySet(unit, mem, buf, CHANGE_CNGf, 0x1);
            PolicySet(unit, mem, buf, NEW_CNGf, hardware_color);
        } else {
            PolicySet(unit, mem, buf, R_DROP_PRECEDENCEf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_DROP_PRECEDENCEf, fa->param[0]);
            PolicySet(unit, mem, buf, G_DROP_PRECEDENCEf, fa->param[0]);
        }
        break;

    case bcmFieldActionPrioPktCopy:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x4);
        break;

    case bcmFieldActionPrioPktNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
            if (soc_mem_field_valid(unit, mem, NEW_OUTER_DOT1Pf)) {
                PolicySet(unit, mem, buf, CHANGE_OUTER_DOT1Pf, 0x1);
                PolicySet(unit, mem, buf, NEW_OUTER_DOT1Pf, fa->param[0]);
            } else
#endif /* !BCM_TRIDENT_SUPPORT */
            {
                PolicySet(unit, mem, buf, CHANGE_PKT_PRIORITYf, 0x1);
                PolicySet(unit, mem, buf, NEW_PKT_PRIORITYf, fa->param[0]);
            }
        } else {
            PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, R_NEW_PKT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, Y_NEW_PKT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, G_NEW_PKT_PRIf, fa->param[0]);
        }
        break;

    case bcmFieldActionPrioPktTos:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x6);
        break;

    case bcmFieldActionPrioPktCancel:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x7);
        break;

    case bcmFieldActionEcnNew:
        BCM_IF_ERROR_RETURN
            (_field_trx_action_ecn_update (unit, mem, f_ent, fa, buf));
        break;

    case bcmFieldActionDscpNew:
        PolicySet(unit, mem, buf, R_CHANGE_DSCPf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_DSCPf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_CHANGE_DSCPf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_DSCPf, fa->param[0]);
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, G_CHANGE_DSCPf, 0x1);
            PolicySet(unit, mem, buf, G_NEW_DSCPf, fa->param[0]);
        } else {
            PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x3);
            PolicySet(unit, mem, buf, G_NEW_DSCP_TOSf, fa->param[0]);
        }
        break;

    case bcmFieldActionDscpCancel:
        PolicySet(unit, mem, buf, R_CHANGE_DSCPf, 0x2);
        PolicySet(unit, mem, buf, Y_CHANGE_DSCPf, 0x2);
        PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x4);
        break;

    case bcmFieldActionCosQNew:
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
        if (SOC_IS_TD_TT(unit)) {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN(
                _field_gh2_action_update(unit, mem, f_ent, tcam_idx, fa, buf));
        } else
#endif
        {
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, fa->param[0]);
        }
        break;

    case bcmFieldActionVlanCosQNew:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x2);
        /* Add 8 to the value since VLAN shaping queues are 8..23 */
        PolicySet(unit, mem, buf, R_COS_INT_PRIf, fa->param[0] + 8);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x2);
        PolicySet(unit, mem, buf, Y_COS_INT_PRIf, fa->param[0] + 8);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x2);
        PolicySet(unit, mem, buf, G_COS_INT_PRIf, fa->param[0] + 8);
        break;

#if defined(BCM_TRIDENT_SUPPORT)
    case bcmFieldActionUcastCosQNew:
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit)) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
        {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        }
        break;
    case bcmFieldActionMcastCosQNew:
        BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit, mem,
                f_ent, tcam_idx, fa, buf));
        break;
#endif /* !BCM_TRIDENT_SUPPORT */

    case bcmFieldActionPrioIntCopy:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x4);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x4);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;

    case bcmFieldActionPrioIntNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_INT_PRIORITYf, 0x1);
            PolicySet(unit, mem, buf, NEW_INT_PRIORITYf,  fa->param[0]);
#if defined BCM_KATANA2_SUPPORT
        } else if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && SOC_IS_KATANA2(unit)) {
            PolicySet(unit, mem, buf, R_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, R_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, Y_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, Y_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, G_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, G_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
#endif
        } else {
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, (0xf & fa->param[0]));
        }
        break;

    case bcmFieldActionPrioIntTos:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x6);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x6);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;

    case bcmFieldActionPrioIntCancel:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x7);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x7);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;

#if defined BCM_KATANA2_SUPPORT
    case bcmFieldActionUcastQueueNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x8);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x8);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x8);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionRpUcastQueueNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x8);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionYpUcastQueueNew:
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x8);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionGpUcastQueueNew:
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x8);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, cosq_new);
            break;
        case bcmFieldActionIntCosUcastQueueNew:
            shift_val = SOC_IS_SABER2(unit) ? 10 :12;
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x9);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x9);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x9);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionRpIntCosUcastQueueNew:
            shift_val = SOC_IS_SABER2(unit) ? 10 :12;
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x9);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionYpIntCosUcastQueueNew:
            shift_val = SOC_IS_SABER2(unit) ? 10 :12;
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x9);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionGpIntCosUcastQueueNew:
            shift_val = SOC_IS_SABER2(unit) ? 10 :12;
            _bcm_kt2_cosq_index_resolve(unit, fa->param[0], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x9);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[1]) << shift_val |
                       cosq_new));
            break;

#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        case bcmFieldActionPortPrioIntCosQNew:
            BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionRpPortPrioIntCosQNew:
            BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionYpPortPrioIntCosQNew:
            BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            break;
        case bcmFieldActionGpPortPrioIntCosQNew:
            BCM_IF_ERROR_RETURN (_field_action_unicast_cosq_get(unit, fa, &shift_val, &cosq_new));
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       cosq_new));
            break;
#endif
#if defined(BCM_KATANA2_SUPPORT)
        case bcmFieldActionServicePrioIntCosQNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 10);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 10);
            shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
            _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                        0x1 << (shift_val-1) | cosq_new));
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                        0x1 << (shift_val-1) | cosq_new));
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       0x1 << (shift_val-1) | cosq_new));
            break;
        case bcmFieldActionRpServicePrioIntCosQNew:
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 10);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
            PolicySet(unit, mem, buf, R_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       0x1 << (shift_val-1) | cosq_new));
            break;
        case bcmFieldActionYpServicePrioIntCosQNew:
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 10);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       0x1 << (shift_val-1) | cosq_new));
            break;
        case bcmFieldActionGpServicePrioIntCosQNew:
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 10);
            _bcm_kt2_cosq_index_resolve(unit, fa->param[1], 0,
                        _BCM_KT_COSQ_INDEX_STYLE_BUCKET, NULL,
                        &cosq_new, NULL);
            shift_val = SOC_IS_SABER2(unit) ? 10 : 12;
            PolicySet(unit, mem, buf, G_COS_INT_PRIf,
                      (_BCM_COSQ_CLASSIFIER_FIELD_GET(fa->param[0]) << shift_val |
                       0x1 << (shift_val-1) | cosq_new));
            break;
#endif

    case bcmFieldActionPrioPktAndIntNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)
                || SOC_IS_KATANAX(unit)
                || SOC_IS_TRIUMPH3(unit)) {
                PolicySet(unit, mem, buf, CHANGE_OUTER_DOT1Pf, 0x1);
                PolicySet(unit, mem, buf, NEW_OUTER_DOT1Pf, fa->param[0]);
            } else
#endif
            {
                PolicySet(unit, mem, buf, CHANGE_PKT_PRIORITYf, 0x1);
                PolicySet(unit, mem, buf, NEW_PKT_PRIORITYf, fa->param[0]);
            }
            PolicySet(unit, mem, buf, CHANGE_INT_PRIORITYf, 0x1);
            PolicySet(unit, mem, buf, NEW_INT_PRIORITYf,  fa->param[0]);
        } else {
            PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, R_NEW_PKT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, Y_NEW_PKT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, (0xf & fa->param[0]));
            PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x5);
            PolicySet(unit, mem, buf, G_NEW_PKT_PRIf, fa->param[0]);
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, (0xf & fa->param[0]));
        }
        break;

    case bcmFieldActionPrioPktAndIntCopy:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x4);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x4);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;

    case bcmFieldActionPrioPktAndIntTos:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x6);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x6);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;

    case bcmFieldActionPrioPktAndIntCancel:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x7);
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x7);
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;

    case bcmFieldActionCosQCpuNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CPU_COSf, fa->param[0]);
        } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            /* Apache EFP doesn't have the control CHANGE_CPU_COS */
            if (!SOC_IS_APACHE(unit)) {
                PolicySet(unit, mem, buf, CHANGE_CPU_COSf, 0x1);
            }
            PolicySet(unit, mem, buf, NEW_CPU_COSf, fa->param[0]);
        } else {
            PolicySet(unit, mem, buf, CHANGE_CPU_COSf, 0x1);
            PolicySet(unit, mem, buf, CPU_COSf, fa->param[0]);
        }
        break;

    case bcmFieldActionOuterVlanPrioNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit))
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_OUTER_DOT1Pf, 0x2);
            PolicySet(unit, mem, buf, NEW_OUTER_DOT1Pf, fa->param[0]);
        } else
#endif
        {
        PolicySet(unit, mem, buf, R_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_DOT1Pf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_DOT1Pf, fa->param[0]);
        PolicySet(unit, mem, buf, G_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_DOT1Pf, fa->param[0]);
        }
        break;

    case bcmFieldActionOuterVlanPrioCopyInner:
        PolicySet(unit, mem, buf, CHANGE_OUTER_DOT1Pf, 3);
        break;

    case bcmFieldActionInnerVlanPrioNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit))
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_INNER_DOT1Pf, 0x2);
            PolicySet(unit, mem, buf, NEW_INNER_DOT1Pf, fa->param[0]);
        } else
#endif
        {
        PolicySet(unit, mem, buf, R_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_INNER_PRIf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_INNER_PRIf, fa->param[0]);
        PolicySet(unit, mem, buf, G_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_INNER_PRIf, fa->param[0]);
        }
        break;

    case bcmFieldActionInnerVlanPrioCopyOuter:
        PolicySet(unit, mem, buf, CHANGE_INNER_DOT1Pf, 3);
        break;

    case bcmFieldActionOuterVlanCfiNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit))
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_OUTER_CFIf, 0x2);
            PolicySet(unit, mem, buf, NEW_OUTER_CFIf, fa->param[0]);
        } else
#endif
#ifdef BCM_KATANA_SUPPORT
        if (SOC_IS_KATANAX(unit)
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_OUTER_CFIf, 0x1);
            PolicySet(unit, mem, buf, NEW_OUTER_CFIf, fa->param[0]);
        } else
#endif
        {
            PolicySet(unit, mem, buf, R_CHANGE_OUTER_CFIf, 0x1);
            PolicySet(unit, mem, buf, R_NEW_OUTER_CFIf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_CHANGE_OUTER_CFIf, 0x1);
            PolicySet(unit, mem, buf, Y_NEW_OUTER_CFIf, fa->param[0]);
            PolicySet(unit, mem, buf, G_CHANGE_OUTER_CFIf, 0x1);
            PolicySet(unit, mem, buf, G_NEW_OUTER_CFIf, fa->param[0]);
        }
        break;

    case bcmFieldActionOuterVlanCfiCopyInner:
        PolicySet(unit, mem, buf, CHANGE_OUTER_CFIf, 3);
        break;

    case bcmFieldActionInnerVlanCfiNew:
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit))
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_INNER_CFIf, 0x2);
            PolicySet(unit, mem, buf, NEW_INNER_CFIf, fa->param[0]);
        } else
#endif
#ifdef BCM_KATANA_SUPPORT
        if (SOC_IS_KATANAX(unit)
            && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, CHANGE_INNER_CFIf, 0x1);
            PolicySet(unit, mem, buf, NEW_INNER_CFIf, fa->param[0]);
        } else
#endif
        {
            PolicySet(unit, mem, buf, R_CHANGE_INNER_CFIf, 0x1);
            PolicySet(unit, mem, buf, R_NEW_INNER_CFIf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_CHANGE_INNER_CFIf, 0x1);
            PolicySet(unit, mem, buf, Y_NEW_INNER_CFIf, fa->param[0]);
            PolicySet(unit, mem, buf, G_CHANGE_INNER_CFIf, 0x1);
            PolicySet(unit, mem, buf, G_NEW_INNER_CFIf, fa->param[0]);
        }
        break;

    case bcmFieldActionInnerVlanCfiCopyOuter:
        PolicySet(unit, mem, buf, CHANGE_INNER_CFIf, 3);
        break;

    case bcmFieldActionSwitchToCpuCancel:
        value = SWITCH_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_KATANA2(unit)) {
            if ((COPY_TO_CPU_CANCEL ==
                 PolicyGet(unit, mem, buf, R_COPY_TO_CPUf)) &&
                (COPY_TO_CPU_CANCEL ==
                 PolicyGet(unit, mem, buf, Y_COPY_TO_CPUf)) &&
                (COPY_TO_CPU_CANCEL ==
                 PolicyGet(unit, mem, buf, G_COPY_TO_CPUf))) {

                 value = COPY_AND_SWITCH_TO_CPU_CANCEL;
            }
        }
#endif
        PolicySet(unit, mem, buf, R_COPY_TO_CPUf, value);
        PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, value);
        PolicySet(unit, mem, buf, G_COPY_TO_CPUf, value);
        break;

    case bcmFieldActionSwitchToCpuReinstate:
        PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x4);
        PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x4);
        PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x4);
        break;

    case bcmFieldActionInnerVlanAdd:
        PolicySet(unit, mem, buf, INNER_VLAN_ACTIONSf, 0x1);
        PolicySet(unit, mem, buf, NEW_INNER_VLANf, fa->param[0]);
        break;

    case bcmFieldActionOuterVlanAdd:
        PolicySet(unit, mem, buf, OUTER_VLAN_ACTIONSf, 0x1);
        PolicySet(unit, mem, buf, NEW_OUTER_VLANf, fa->param[0]);
        break;

    case bcmFieldActionInnerVlanDelete:
        PolicySet(unit, mem, buf, INNER_VLAN_ACTIONSf, 0x3);
        break;

    case bcmFieldActionOuterVlanLookup:
        PolicySet(unit, mem, buf, OUTER_VLAN_ACTIONSf, 0x3);
        PolicySet(unit, mem, buf, NEW_OUTER_VLANf, fa->param[0]);
        break;

    case bcmFieldActionIpFix:
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, PID_IPFIX_ACTIONSf, 0x1);
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
#endif
        } else {
            PolicySet(unit, mem, buf, IPFIX_CONTROLf, 0x1);
        }
        break;

    case bcmFieldActionIpFixCancel:
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, PID_IPFIX_ACTIONSf, 0x2);
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
#endif
        } else {
            PolicySet(unit, mem, buf, IPFIX_CONTROLf, 0x2);
        }
        break;

    case bcmFieldActionDoNotLearn:
        PolicySet(unit, mem, buf, DO_NOT_LEARNf, 0x1);
        break;

    case bcmFieldActionDoNotCheckVlan:
        PolicySet(unit, mem, buf, DISABLE_VLAN_CHECKSf, 0x1);
        break;

    case bcmFieldActionEnableVlanCheck:
        PolicySet(unit, mem, buf, DISABLE_VLAN_CHECKSf, 0);
        break;

#if defined(BCM_TRIUMPH3_SUPPORT)
    case bcmFieldActionEsmSearchKeySrcMac:
        if (soc_feature(unit, soc_feature_esm_support)) {
            PolicySet(unit, mem, buf, ESM_SEARCH_PRIORITYf, 0x7);
            PolicySet(unit, mem, buf, ESM_SEARCH_OFFSETf, 0x1);
        }
        break;
#endif

    case bcmFieldActionInnerVlanNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, INNER_VLAN_ACTIONSf, 0x2);
            PolicySet(unit, mem, buf, NEW_INNER_VLANf, fa->param[0]);
        } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, PID_REPLACE_INNER_VIDf, 0x1);
            PolicySet(unit, mem, buf, PID_NEW_INNER_VIDf, fa->param[0]);
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
#endif
        }
        break;

    case bcmFieldActionInnerVlanCopyOuter:
        PolicySet(unit, mem, buf, INNER_VLAN_ACTIONSf, 4);
        break;

    case bcmFieldActionOuterVlanNew:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, OUTER_VLAN_ACTIONSf, 0x2);
            PolicySet(unit, mem, buf, NEW_OUTER_VLANf, fa->param[0]);
        } else if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, PID_REPLACE_OUTER_VIDf, 0x1);
            PolicySet(unit, mem, buf, PID_NEW_OUTER_VIDf, fa->param[0]);
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
#endif
        } else {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
            if (SOC_MEM_FIELD_VALID(unit, mem, ECMPf)) {
                PolicySet(unit, mem, buf, ECMPf, 0);
            }
            PolicySet(unit, mem, buf, NEXT_HOP_INDEXf, fa->hw_index);
        }
        break;

    case bcmFieldActionOuterVlanCopyInner:
        PolicySet(unit, mem, buf, OUTER_VLAN_ACTIONSf, 4);
        break;

    case bcmFieldActionSrcMacNew:
    case bcmFieldActionDstMacNew:
        if (SOC_IS_TD_TT(unit)
            || SOC_IS_TRIUMPH2(unit)
            || SOC_IS_APOLLO(unit)
            || SOC_IS_KATANAX(unit)
            || SOC_IS_ENDURO(unit)
            || SOC_IS_HURRICANEX(unit)
            || SOC_IS_TRIUMPH3(unit)
            || SOC_IS_GREYHOUND(unit)
            || SOC_IS_GREYHOUND2(unit)
            ) {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
        } else {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x4);
        }
        if (SOC_MEM_FIELD_VALID(unit, mem, ECMPf)) {
            PolicySet(unit, mem, buf, ECMPf, 0);
        }
        PolicySet(unit, mem, buf, NEXT_HOP_INDEXf, fa->hw_index);
        break;
    case bcmFieldActionVnTagNew:
    case bcmFieldActionVnTagDelete:
    case bcmFieldActionEtagNew:
    case bcmFieldActionEtagDelete:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
        if (SOC_MEM_FIELD_VALID(unit, mem, ECMPf)) {
            PolicySet(unit, mem, buf, ECMPf, 0);
        }
        PolicySet(unit, mem, buf, NEXT_HOP_INDEXf, fa->hw_index);
        break;
    case bcmFieldActionOuterTpidNew:
        BCM_IF_ERROR_RETURN(_bcm_field_tpid_hw_encode(unit, fa->param[0], &mode));
        PolicySet(unit, mem, buf, PID_REPLACE_OUTER_TPIDf, 1);
        PolicySet(unit, mem, buf, PID_OUTER_TPID_INDEXf, mode);
#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TD2_TT2(unit)) {
            if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
                PolicySet(unit, mem, buf, VXLAN_ACTIONf, 0);
            }
        }
#endif
        break;

    case bcmFieldActionMirrorOverride:
        PolicySet(unit, mem, buf, MIRROR_OVERRIDEf, 1);
        break;

    case bcmFieldActionDoNotChangeTtl:
        PolicySet(unit, mem, buf, DO_NOT_CHANGE_TTLf, 1);
        break;

    case bcmFieldActionDoNotCheckUrpf:
        PolicySet(unit, mem, buf, DO_NOT_URPFf, 1);
        break;

    case bcmFieldActionCnmCancel:
        PolicySet(unit, mem, buf, DO_NOT_GENERATE_CNMf, 1);
        break;
#if defined(BCM_TRIDENT_SUPPORT)
    case bcmFieldActionDynamicHgTrunkCancel:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)
            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            PolicySet(unit, mem, buf, HGT_DLB_DISABLEf, 1);
        }
#endif
        if (SOC_IS_TRIDENT(unit)) {
        PolicySet(unit, mem, buf, DISABLE_DYNAMIC_LOAD_BALANCINGf, 1);
        }
        break;
#endif
    case bcmFieldActionMirrorIngress:    /* param0=modid, param1=port/tgid */
        BCM_IF_ERROR_RETURN
            (_bcm_field_trx_mirror_ingress_add(unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionMirrorEgress:     /* param0=modid, param1=port/tgid */
        BCM_IF_ERROR_RETURN
            (_bcm_field_trx_mirror_egress_add(unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionOffloadRedirect:
    case bcmFieldActionRedirect:
    case bcmFieldActionRedirectTrunk:
    case bcmFieldActionRedirectCancel:
    case bcmFieldActionRedirectPbmp:
#ifdef INCLUDE_L3
    case bcmFieldActionRedirectIpmc:
#endif /* INCLUDE_L3 */
    case bcmFieldActionRedirectMcast:
    case bcmFieldActionRedirectVlan:
    case bcmFieldActionRedirectBcastPbmp:
    case bcmFieldActionEgressMask:
    case bcmFieldActionEgressPortsAdd:
#if defined(BCM_TRIUMPH3_SUPPORT)
    case bcmFieldActionUnmodifiedPacketRedirectPort:
#endif
        BCM_IF_ERROR_RETURN
            (_field_trx_action_redirect(unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionOffloadDropIndication:
        PolicySet(unit, mem, buf, SPLIT_DROP_RESOLVEf, 0x1);
        break;
    case bcmFieldActionOffloadClassSet:
        if (SOC_MEM_FIELD_VALID(unit, mem, G_L3SW_CHANGE_L2_FIELDSf)) {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x4);
        }
        PolicySet(unit, mem, buf, PPD3_CLASS_TAGf, fa->param[0]);
        break;
    case bcmFieldActionRpDrop:
        PolicySet(unit, mem, buf, R_DROPf, 0x1);
        break;
    case bcmFieldActionRpDropCancel:
        PolicySet(unit, mem, buf, R_DROPf, 0x2);
        break;
    case bcmFieldActionRpDropPrecedence:
        PolicySet(unit, mem, buf, R_DROP_PRECEDENCEf, fa->param[0]);
        break;
    case bcmFieldActionRpSwitchToCpuCancel:
        value = SWITCH_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_KATANA2(unit)) {
            if (COPY_TO_CPU_CANCEL ==
                PolicyGet(unit, mem, buf, R_COPY_TO_CPUf)) {

                value = COPY_AND_SWITCH_TO_CPU_CANCEL;
            }
        }
#endif
        PolicySet(unit, mem, buf, R_COPY_TO_CPUf, value);
        break;
    case bcmFieldActionRpSwitchToCpuReinstate:
        PolicySet(unit, mem, buf, R_COPY_TO_CPUf, 0x4);
        break;
    case bcmFieldActionRpPrioPktCopy:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x4);
        break;
    case bcmFieldActionRpPrioPktNew:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, R_NEW_PKT_PRIf, fa->param[0]);
        break;
    case bcmFieldActionRpPrioPktTos:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x6);
        break;
    case bcmFieldActionRpPrioPktCancel:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x7);
        break;
    case bcmFieldActionRpEcnNew:
        BCM_IF_ERROR_RETURN
            (_field_trx_action_ecn_update (unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionRpDscpNew:
        PolicySet(unit, mem, buf, R_CHANGE_DSCPf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_DSCPf, fa->param[0]);
        break;
    case bcmFieldActionRpDscpCancel:
        PolicySet(unit, mem, buf, R_CHANGE_DSCPf, 0x2);
        break;
    case bcmFieldActionRpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
        if (SOC_IS_TD_TT(unit)) {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN(
                _field_gh2_action_update(unit, mem, f_ent, tcam_idx, fa, buf));
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */
        {
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, fa->param[0]);
        }
        break;
    case bcmFieldActionRpVlanCosQNew:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x2);
        /* Add 8 to the value since VLAN shaping queues are 8..23 */
        PolicySet(unit, mem, buf, R_COS_INT_PRIf, fa->param[0] + 8);
        break;
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
    case bcmFieldActionRpUcastCosQNew:
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit)) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
        {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        }
        break;
    case bcmFieldActionRpMcastCosQNew:
        BCM_IF_ERROR_RETURN(_bcm_field_trx_ucast_mcast_action_update(unit, mem,
            f_ent, tcam_idx, fa, buf));
        break;
#endif /* !BCM_TRIDENT_SUPPORT */
    case bcmFieldActionRpPrioPktAndIntCopy:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionRpPrioPktAndIntNew:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, R_NEW_PKT_PRIf, fa->param[0]);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x5);
        PolicySet(unit, mem, buf, R_COS_INT_PRIf, (0xf & fa->param[0]));
        break;
    case bcmFieldActionRpPrioPktAndIntTos:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionRpPrioPktAndIntCancel:
        PolicySet(unit, mem, buf, R_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionRpOuterVlanPrioNew:
        PolicySet(unit, mem, buf, R_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_DOT1Pf, fa->param[0]);
        break;
    case bcmFieldActionRpInnerVlanPrioNew:
        PolicySet(unit, mem, buf, R_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_INNER_PRIf, fa->param[0]);
        break;
    case bcmFieldActionRpOuterVlanCfiNew:
        PolicySet(unit, mem, buf, R_CHANGE_OUTER_CFIf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_OUTER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionRpInnerVlanCfiNew:
        PolicySet(unit, mem, buf, R_CHANGE_INNER_CFIf, 0x1);
        PolicySet(unit, mem, buf, R_NEW_INNER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionRpPrioIntCopy:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionRpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
        if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && SOC_IS_KATANA2(unit)) {
            PolicySet(unit, mem, buf, R_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, R_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
        } else
#endif
        {
            PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, R_COS_INT_PRIf, (0xf & fa->param[0]));
        }
        break;
    case bcmFieldActionRpPrioIntTos:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionRpPrioIntCancel:
        PolicySet(unit, mem, buf, R_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionYpDrop:
        PolicySet(unit, mem, buf, Y_DROPf, 0x1);
        break;
    case bcmFieldActionYpDropCancel:
        PolicySet(unit, mem, buf, Y_DROPf, 0x2);
        break;
    case bcmFieldActionYpDropPrecedence:
        PolicySet(unit, mem, buf, Y_DROP_PRECEDENCEf, fa->param[0]);
        break;
    case bcmFieldActionYpSwitchToCpuCancel:
        value = SWITCH_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_KATANA2(unit)) {
            if (COPY_TO_CPU_CANCEL ==
                PolicyGet(unit, mem, buf, Y_COPY_TO_CPUf)) {

                value = COPY_AND_SWITCH_TO_CPU_CANCEL;
            }
        }
#endif
        PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, value);
        break;
    case bcmFieldActionYpSwitchToCpuReinstate:
        PolicySet(unit, mem, buf, Y_COPY_TO_CPUf, 0x4);
        break;
    case bcmFieldActionYpPrioPktCopy:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x4);
        break;
    case bcmFieldActionYpPrioPktNew:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, Y_NEW_PKT_PRIf, fa->param[0]);
        break;
    case bcmFieldActionYpPrioPktTos:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x6);
        break;
    case bcmFieldActionYpPrioPktCancel:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x7);
        break;
    case bcmFieldActionYpEcnNew:
        BCM_IF_ERROR_RETURN
            (_field_trx_action_ecn_update (unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionYpDscpNew:
        PolicySet(unit, mem, buf, Y_CHANGE_DSCPf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_DSCPf, fa->param[0]);
        break;
    case bcmFieldActionYpDscpCancel:
        PolicySet(unit, mem, buf, Y_CHANGE_DSCPf, 0x2);
        break;
    case bcmFieldActionYpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
        if (SOC_IS_TD_TT(unit)) {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN(
                _field_gh2_action_update(unit, mem, f_ent, tcam_idx, fa, buf));
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */
        {
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, fa->param[0]);
        }
        break;
    case bcmFieldActionYpVlanCosQNew:
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x2);
        /* Add 8 to the value since VLAN shaping queues are 8..23 */
        PolicySet(unit, mem, buf, Y_COS_INT_PRIf, fa->param[0] + 8);
        break;

#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
    case bcmFieldActionYpUcastCosQNew:
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit)) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
        {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        }
        break;
    case bcmFieldActionYpMcastCosQNew:
        BCM_IF_ERROR_RETURN(_bcm_field_trx_ucast_mcast_action_update(unit, mem,
            f_ent, tcam_idx, fa, buf));
        break;
#endif /* !BCM_TRIDENT_SUPPORT */
    case bcmFieldActionYpPrioPktAndIntCopy:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionYpPrioPktAndIntNew:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, Y_NEW_PKT_PRIf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x5);
        PolicySet(unit, mem, buf, Y_COS_INT_PRIf, (0xf & fa->param[0]));
        break;
    case bcmFieldActionYpPrioPktAndIntTos:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionYpPrioPktAndIntCancel:
        PolicySet(unit, mem, buf, Y_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionYpOuterVlanPrioNew:
        PolicySet(unit, mem, buf, Y_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_DOT1Pf, fa->param[0]);
        break;
    case bcmFieldActionYpInnerVlanPrioNew:
        PolicySet(unit, mem, buf, Y_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_INNER_PRIf, fa->param[0]);
        break;
    case bcmFieldActionYpOuterVlanCfiNew:
        PolicySet(unit, mem, buf, Y_CHANGE_OUTER_CFIf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_OUTER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionYpInnerVlanCfiNew:
        PolicySet(unit, mem, buf, Y_CHANGE_INNER_CFIf, 0x1);
        PolicySet(unit, mem, buf, Y_NEW_INNER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionYpPrioIntCopy:
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionYpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
        if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && SOC_IS_KATANA2(unit)) {
            PolicySet(unit, mem, buf, Y_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, Y_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
        } else
#endif
        {
            PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, Y_COS_INT_PRIf, (0xf & fa->param[0]));
        }
        break;
    case bcmFieldActionYpPrioIntTos:
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionYpPrioIntCancel:
        PolicySet(unit, mem, buf, Y_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionGpDrop:
        PolicySet(unit, mem, buf, G_DROPf, 0x1);
        break;
    case bcmFieldActionGpDropCancel:
        PolicySet(unit, mem, buf, G_DROPf, 0x2);
        break;
    case bcmFieldActionGpDropPrecedence:
        PolicySet(unit, mem, buf, G_DROP_PRECEDENCEf, fa->param[0]);
        break;
    case bcmFieldActionGpSwitchToCpuCancel:
        value = SWITCH_TO_CPU_CANCEL;
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_KATANA2(unit)) {
            if (COPY_TO_CPU_CANCEL ==
                PolicyGet(unit, mem, buf, G_COPY_TO_CPUf)) {

                value = COPY_AND_SWITCH_TO_CPU_CANCEL;
            }
        }
#endif
        PolicySet(unit, mem, buf, G_COPY_TO_CPUf, value);
        break;
    case bcmFieldActionGpSwitchToCpuReinstate:
        PolicySet(unit, mem, buf, G_COPY_TO_CPUf, 0x4);
        break;
    case bcmFieldActionGpPrioPktCopy:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x4);
        break;
    case bcmFieldActionGpPrioPktNew:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, G_NEW_PKT_PRIf, fa->param[0]);
        break;
    case bcmFieldActionGpPrioPktTos:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x6);
        break;
    case bcmFieldActionGpPrioPktCancel:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x7);
        break;
    case bcmFieldActionGpEcnNew:
        BCM_IF_ERROR_RETURN
            (_field_trx_action_ecn_update (unit, mem, f_ent, fa, buf));
        break;
    case bcmFieldActionGpTosPrecedenceNew:
        PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_DSCP_TOSf, fa->param[0]);
        break;
    case bcmFieldActionGpTosPrecedenceCopy:
        PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x2);
        break;
    case bcmFieldActionGpDscpNew:
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, G_CHANGE_DSCPf, 1);
            PolicySet(unit, mem, buf, G_NEW_DSCPf, fa->param[0]);
        } else {
            PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x3);
            PolicySet(unit, mem, buf, G_NEW_DSCP_TOSf, fa->param[0]);
        }
        break;
    case bcmFieldActionGpDscpCancel:
        PolicySet(unit, mem, buf, G_CHANGE_DSCP_TOSf, 0x4);
        break;
    case bcmFieldActionGpCosQNew:
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
        if (SOC_IS_TD_TT(unit)) {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit) && BCM_GPORT_IS_SET(fa->param[0])) {
            BCM_IF_ERROR_RETURN(
                _field_gh2_action_update(unit, mem, f_ent, tcam_idx, fa, buf));
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */
        {
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, fa->param[0]);
        }
        break;
    case bcmFieldActionGpVlanCosQNew:
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x2);
        /* Add 8 to the value since VLAN shaping queues are 8..23 */
        PolicySet(unit, mem, buf, G_COS_INT_PRIf, fa->param[0] + 8);
        break;

#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
    case bcmFieldActionGpUcastCosQNew:
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANAX(unit)) {
            BCM_IF_ERROR_RETURN (_field_kt_action_update(unit, mem,
                    f_ent, tcam_idx, fa, buf));
        } else
#endif
        {
            BCM_IF_ERROR_RETURN (_bcm_field_trx_ucast_mcast_action_update(unit,
                mem, f_ent, tcam_idx, fa, buf));
        }
        break;
    case bcmFieldActionGpMcastCosQNew:
        BCM_IF_ERROR_RETURN(_bcm_field_trx_ucast_mcast_action_update(unit, mem,
            f_ent, tcam_idx, fa, buf));
        break;
#endif /* !BCM_TRIDENT_SUPPORT */
    case bcmFieldActionGpPrioPktAndIntCopy:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x4);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionGpPrioPktAndIntNew:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x5);
        PolicySet(unit, mem, buf, G_NEW_PKT_PRIf, fa->param[0]);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x5);
        PolicySet(unit, mem, buf, G_COS_INT_PRIf, (0xf & fa->param[0]));
        break;
    case bcmFieldActionGpPrioPktAndIntTos:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x6);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionGpPrioPktAndIntCancel:
        PolicySet(unit, mem, buf, G_CHANGE_PKT_PRIf, 0x7);
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionGpOuterVlanPrioNew:
        PolicySet(unit, mem, buf, G_CHANGE_DOT1Pf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_DOT1Pf, fa->param[0]);
        break;
    case bcmFieldActionGpInnerVlanPrioNew:
        PolicySet(unit, mem, buf, G_REPLACE_INNER_PRIf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_INNER_PRIf, fa->param[0]);
        break;
    case bcmFieldActionGpOuterVlanCfiNew:
        PolicySet(unit, mem, buf, G_CHANGE_OUTER_CFIf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_OUTER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionGpInnerVlanCfiNew:
        PolicySet(unit, mem, buf, G_CHANGE_INNER_CFIf, 0x1);
        PolicySet(unit, mem, buf, G_NEW_INNER_CFIf, fa->param[0]);
        break;
    case bcmFieldActionGpPrioIntCopy:
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x4);
        break;
    case bcmFieldActionGpPrioIntNew:
#if defined BCM_KATANA2_SUPPORT
        if ((_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)
                && SOC_IS_KATANA2(unit)) {
            PolicySet(unit, mem, buf, G_CHANGE_REDIR_INT_PRIf, 0x1);
            PolicySet(unit, mem, buf, G_NEW_REDIR_INT_PRIf, (0xf & fa->param[0]));
        } else
#endif
        {
            PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x5);
            PolicySet(unit, mem, buf, G_COS_INT_PRIf, (0xf & fa->param[0]));
        }
        break;
    case bcmFieldActionGpPrioIntTos:
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x6);
        break;
    case bcmFieldActionGpPrioIntCancel:
        PolicySet(unit, mem, buf, G_CHANGE_COS_OR_INT_PRIf, 0x7);
        break;
    case bcmFieldActionAddClassTag:
        if (SOC_MEM_FIELD_VALID(unit, mem, G_L3SW_CHANGE_L2_FIELDSf)) {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x4);
        } else {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x3);
        }
        PolicySet(unit, mem, buf, NEXT_HOP_INDEXf, fa->param[0]);
        break;
    case bcmFieldActionFabricQueue:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x3);
        BCM_IF_ERROR_RETURN
            (_field_trx_action_fabricQueue_actions_set(unit, mem, fa,
                                                       buf));
        break;
#if defined(BCM_TRIDENT_SUPPORT)
    case bcmFieldActionCompressSrcIp6:
            if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
                PolicySet(unit, mem, buf, IPV6_TO_IPV4_MAP_SIP_VALIDf, 0x1);
                PolicySet(unit, mem, buf, IPV6_TO_IPV4_MAP_OFFSET_SETf, fa->param[0]);
        }
        break;
    case bcmFieldActionCompressDstIp6:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
                PolicySet(unit, mem, buf, IPV6_TO_IPV4_MAP_DIP_VALIDf, 0x1);
                PolicySet(unit, mem, buf, IPV6_TO_IPV4_MAP_OFFSET_SETf, fa->param[0]);
        }
        break;
#endif /* !BCM_TRIDENT_SUPPORT */

#ifdef INCLUDE_L3
#if defined(BCM_TRIUMPH_SUPPORT) && defined(BCM_MPLS_SUPPORT)
    case bcmFieldActionIncomingMplsPortSet:
        if (!BCM_GPORT_IS_MPLS_PORT(fa->param[0])) {
            return BCM_E_PARAM;
        }
        if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
            && (!SOC_IS_TOMAHAWKX(unit))) {
            /* FIELDS_ACTIONSf = 1 for SVP is not valid on Trident2X devices */
            if (SOC_MEM_FIELD_VALID(unit, mem, FIELDS_ACTIONf)) {
                PolicySet(unit, mem, buf, FIELDS_ACTIONf, 0x1);
            } else {
                PolicySet(unit, mem, buf, MPLS_ACTIONf, 0x1);
            }
        }
        svp = BCM_GPORT_MPLS_PORT_ID_GET((bcm_gport_t)fa->param[0]);
        PolicySet(unit, mem, buf, SVPf, svp);

        /* Search for Action EnableVlanCheck */
        for (fa_temp = f_ent->actions; (NULL != fa_temp) &&
            (bcmFieldActionEnableVlanCheck != fa_temp->action); fa_temp=fa_temp->next);

        if ((NULL == fa_temp)) {
            /* 
             * Set DISABLE_VLAN_CHECKSf if bcmFieldActionEnableVlanCheck
             * is not being added earlier
             */
            PolicySet(unit, mem, buf, DISABLE_VLAN_CHECKSf, 1);
        }

        if (((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)))
            || (SOC_IS_TOMAHAWKX(unit))) {
            PolicySet(unit, mem, buf, SVP_VALIDf, 1);
        }
        break;
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    case bcmFieldActionVpnSet:
        if(!(soc_feature(unit, soc_feature_vfi_from_vlan_tables) ||
             soc_feature(unit, soc_feature_vxlan_lite))) {
            return BCM_E_UNAVAIL;
        }
        /* for vxlan*/
        if (_BCM_VPN_VFI_IS_SET((bcm_vpn_t)fa->param[0])) {
            _BCM_VPN_GET(vfi, _BCM_VPN_TYPE_VFI,
                                  (bcm_vpn_t)fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, VFIf, vfi);
        break;
#endif
    case bcmFieldActionIngressGportSet:
        if ((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit))
            && !SOC_IS_TOMAHAWKX(unit)) {
            /* FIELDS_ACTIONSf = 1 for SVP is not valid on Trident2 */
            if (SOC_MEM_FIELD_VALID(unit, mem, FIELDS_ACTIONf)) {
                PolicySet(unit, mem, buf, FIELDS_ACTIONf, 0x1);
            } else {
                PolicySet(unit, mem, buf, MPLS_ACTIONf, 0x1);
            }
        }
        {
           uint8 vlan_disable_flg = 0;

           if (BCM_GPORT_IS_MPLS_PORT(fa->param[0])) {
              svp = BCM_GPORT_MPLS_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 1;
           } else if (BCM_GPORT_IS_MIM_PORT(fa->param[0])) {
              svp = BCM_GPORT_MIM_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 1;
           } else if (BCM_GPORT_IS_WLAN_PORT(fa->param[0])) {
              svp = BCM_GPORT_WLAN_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 0;
           } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[0])) {
              svp = BCM_GPORT_TRILL_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 0;
           } else if (BCM_GPORT_IS_NIV_PORT(fa->param[0])) {
              svp = BCM_GPORT_NIV_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 0;
           } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[0])) {
              svp = BCM_GPORT_VXLAN_PORT_ID_GET((bcm_gport_t)fa->param[0]);
              vlan_disable_flg = 0;
           } else {
              return BCM_E_PARAM;
           }
           PolicySet(unit, mem, buf, SVPf, svp);
           if (vlan_disable_flg == 1) {

               /* Search for Action EnableCheckVlan */
               for (fa_temp = f_ent->actions; (NULL != fa_temp) &&
                       (bcmFieldActionEnableVlanCheck != fa_temp->action); fa_temp=fa_temp->next);

               if ((NULL == fa_temp)) {
                   /* 
                    * Set DISABLE_VLAN_CHECKSf if bcmFieldActionEnableVlanCheck
                    * is not being added earlier
                    */
                   PolicySet(unit, mem, buf, DISABLE_VLAN_CHECKSf, 1);
               }
           }

           if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
               || SOC_IS_TOMAHAWKX(unit)) {
              PolicySet(unit, mem, buf, SVP_VALIDf, 1);
           }
        }
        break;
    case bcmFieldActionL3IngressSet:
        if (SOC_MEM_FIELD_VALID(unit, mem, FIELDS_ACTIONf)) {
            PolicySet(unit, mem, buf, FIELDS_ACTIONf, 0x2);
        } else {
            PolicySet(unit, mem, buf, MPLS_ACTIONf, 0x2);
        }
        PolicySet(unit, mem, buf, L3_IIFf, fa->param[0]);
        break;
    case bcmFieldActionL3ChangeVlan:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
        BCM_IF_ERROR_RETURN
            (_field_trx_policy_set_l3_info(unit, mem, fa->param[0], buf));
        break;
    case bcmFieldActionL3ChangeVlanCancel:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x2);
        break;
    case bcmFieldActionL3ChangeMacDa:
        if (SOC_MEM_FIELD_VALID(unit, mem, G_L3SW_CHANGE_L2_FIELDSf)) {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
        } else {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x4);
        }
        BCM_IF_ERROR_RETURN
            (_field_trx_policy_set_l3_info(unit, mem,  fa->param[0], buf));
        break;
    case bcmFieldActionL3ChangeMacDaCancel:
        if (SOC_MEM_FIELD_VALID(unit, mem, G_L3SW_CHANGE_L2_FIELDSf)) {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x2);
        } else {
            PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x5);
        }
        break;
    case bcmFieldActionL3Switch:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x6);
        BCM_IF_ERROR_RETURN
            (_field_trx_policy_set_l3_info(unit, mem, fa->param[0], buf));
        break;
    case bcmFieldActionL3SwitchCancel:
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x7);
        break;
#endif /* INCLUDE_L3 */
    case bcmFieldActionOamUpMep:
        PolicySet(unit, mem, buf, OAM_UP_MEPf, fa->param[0]);
        break;
    case bcmFieldActionOamTx:
        PolicySet(unit, mem, buf, OAM_TXf, fa->param[0]);
        break;
    case bcmFieldActionOamLmepMdl:
        PolicySet(unit, mem, buf, OAM_LMEP_MDLf, fa->param[0]);
        break;
    case bcmFieldActionOamServicePriMappingPtr:
        PolicySet(unit, mem, buf, OAM_SERVICE_PRI_MAPPING_PTRf, fa->param[0]);
        break;
    case bcmFieldActionOamLmBasePtr:
        PolicySet(unit, mem, buf, OAM_LM_BASE_PTRf, fa->param[0]);
        break;
    case bcmFieldActionOamDmEnable:
        PolicySet(unit, mem, buf, OAM_DM_ENf, fa->param[0]);
        break;
#if defined(BCM_KATANA2_SUPPORT)
      case bcmFieldActionOamLmDmSampleEnable:
        if( (SOC_IS_SABER2(unit)) || (SOC_IS_KATANA2(unit)) ) {
            PolicySet(unit, mem, buf, OAM_ENABLE_LM_DM_SAMPLEf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
#endif
    case bcmFieldActionOamLmEnable:
        PolicySet(unit, mem, buf, OAM_LM_ENf, fa->param[0]);
        break;
    case bcmFieldActionOamLmepEnable:
        PolicySet(unit, mem, buf, OAM_LMEP_ENf, fa->param[0]);
        break;
    case bcmFieldActionOamPbbteLookupEnable:
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            PolicySet(unit, mem, buf, OAM_PBBTE_LOOKUP_ENABLEf, fa->param[0]);
        }
        break;
    case bcmFieldActionOamDmTimeFormat:
        {
            unsigned oam_dm_type;

            switch (fa->param[0]) {
                case BCM_FIELD_OAM_DM_TIME_FORMAT_IEEE1588:
                    oam_dm_type = 0;
                    break;
                case BCM_FIELD_OAM_DM_TIME_FORMAT_NTP:
                    oam_dm_type = 1;
                    break;
                default:
                    /* Invalid parameter should have been caught earlier */
                    return (BCM_E_INTERNAL);
            }

            PolicySet(unit, mem, buf, OAM_DM_TYPEf, oam_dm_type);
        }
        break;
    case bcmFieldActionOamTagStatusCheck:
        PolicySet(unit, mem, buf, OAM_TAG_STATUS_CHECK_CONTROLf, fa->param[0]);
        break;

    case bcmFieldActionServicePoolIdNew:
        PolicySet(unit, mem, buf, CHANGE_CPU_COSf, 0x2);
        PolicySet(unit, mem, buf, CPU_COSf, ((fa->param[0] << 2) | 0x20));
        break;
    case bcmFieldActionServicePoolIdPrecedenceNew:
        PolicySet(unit, mem, buf, CHANGE_CPU_COSf, 0x2);
        /* SPAP is 2b'00 for BCM_FIELD_COLOR_GREEN
                   2b'01 for BCM_FIELD_COLOR_RED
                   2b'11 for BCM_FIELD_COLOR_YELLOW
        */
        value = (0x30 | (fa->param[0] << 2) | \
                      ((BCM_FIELD_COLOR_GREEN == fa->param[1]) ? 0 : \
                      ((BCM_FIELD_COLOR_YELLOW == fa->param[1]) ? 3 : 1)));
        PolicySet(unit, mem, buf, CPU_COSf, value);
        break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined (BCM_GREYHOUND2_SUPPORT)
    case bcmFieldActionUseGlobalMeterColor:
        if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
#if defined(BCM_GREYHOUND2_SUPPORT)
            if (soc_feature(unit, soc_feature_global_meter) &&
                SOC_IS_GREYHOUND2(unit)) {
                SOC_IF_ERROR_RETURN(
                    soc_reg32_get(unit, SVM_TSN_CONTROLr,
                                  REG_PORT_ANY, 0, &value));
                svm_disable =
                    soc_reg_field_get(unit, SVM_TSN_CONTROLr,
                                      value, SVM_BLOCK_DISABLEf);
                if (1 != svm_disable) {
                    PolicySet(unit, mem, buf, USE_SVC_METER_COLORf, 1);
                }
            } else
#endif /* BCM_GREYHOUND2_SUPPORT */
            if (soc_feature(unit, soc_feature_global_meter)) {
                PolicySet(unit, mem, buf, USE_SVC_METER_COLORf,1);
            }
        }

        if (SOC_IS_TRIUMPH3(unit)) {
            if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) {
                if (soc_feature(unit, soc_feature_global_meter)) {
                    PolicySet(unit, mem, buf, USE_SVC_METER_COLORf,1);
                }
            }
        }
        break;
#endif
#ifdef INCLUDE_L3
    case bcmFieldActionRedirectEgrNextHop:
        BCM_IF_ERROR_RETURN
            (_field_trx_policy_egr_nexthop_info_set(unit, mem,
                fa->param[0], buf));
        break;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    case bcmFieldActionOamDomain:
        if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_oam))) {
            if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
                switch (fa->param[0]) {
                    case bcmFieldOamDomainCVlan:
                    case bcmFieldOamDomainSVlan:
                    case bcmFieldOamDomainDoubleVlan:
                    case bcmFieldOamDomainPbbTe:
                        param0 = fa->param[0] + 1;
                        break;
#if defined(BCM_SABER2_SUPPORT)
                    case bcmFieldOamDomainMplsLmDmSectionPort:
                        param0 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionInnerVlan:
                        param0 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_CVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionOuterVlan:
                        param0 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_SVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionOuterPlusInnerVlan:
                        param0 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_S_PLUS_CVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmPw:
                        param0 = _BCM_SB2_OAM_DOMAIN_MPLS_LMDM_PW;
                        break;
                    case bcmFieldOamDomainMplsLmDmLspLabel:
                        param0 = _BCM_SB2_OAM_DOMAIN_ING_MPLS_LMDM_LSP;
                        break;
#endif
                    case _FP_INVALID_INDEX:
                        param0 = 0;
                        break;
                    default:
                        return (BCM_E_PARAM);
                }
                switch (fa->param[1]) {
                    case bcmFieldOamDomainCVlan:
                    case bcmFieldOamDomainSVlan:
                    case bcmFieldOamDomainDoubleVlan:
                    case bcmFieldOamDomainPbbTe:
                        param1 = fa->param[1] + 1;
                        break;
#if defined(BCM_SABER2_SUPPORT)
                    case bcmFieldOamDomainMplsLmDmSectionPort:
                        param1 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionInnerVlan:
                        param1 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_CVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionOuterVlan:
                        param1 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_SVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmSectionOuterPlusInnerVlan:
                        param1 = _BCM_SB2_OAM_DOMAIN_MPLS_SECTION_S_PLUS_CVLAN;
                        break;
                    case bcmFieldOamDomainMplsLmDmPw:
                        param1 = _BCM_SB2_OAM_DOMAIN_MPLS_LMDM_PW;
                        break;
                    case bcmFieldOamDomainMplsLmDmLspLabel:
                        param1 = _BCM_SB2_OAM_DOMAIN_ING_MPLS_LMDM_LSP;
                        break;
#endif
                    case _FP_INVALID_INDEX:
                        param1 = 0;
                        break;
                    default:
                        return (BCM_E_PARAM);
                }
                PolicySet(unit, mem, buf, OAM_KEY1f, param0);
                PolicySet(unit, mem, buf, OAM_KEY2f, param1);
            }

        }
        break;

    case bcmFieldActionOamOlpHeaderAdd:
        if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_oam))) {
            if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                if (fa->param[0] >= bcmFieldOlpHeaderTypeCount) {
                    return (BCM_E_PARAM);
                }
                hw_index = 0;
                rv = _bcm_oam_olp_fp_hw_index_get (unit,fa->param[0],
                                            &hw_index);
                if (BCM_FAILURE(rv)) {
                    return BCM_E_PARAM;
                }
                PolicySet(unit, mem, buf, OLP_HDR_ADDf, 1);
                PolicySet(unit, mem, buf, OLP_HDR_TYPE_COMPRESSEDf, hw_index);
            }
        }
        break;

    case bcmFieldActionOamSessionId:
        if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_oam))) {
            if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                if (fa->param[0] > BCM_FIELD_OAM_SESSION_ID_MAX) {
                    return (BCM_E_PARAM);
                }
                PolicySet(unit, mem, buf, OAM_SESSION_IDf, fa->param[0]);
            }
        }
        break;
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)  || defined(BCM_TRIDENT2_SUPPORT)
    case bcmFieldActionDoNotOverride:
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)
                || SOC_IS_APACHE(unit)) {
            PolicySet(unit, mem, buf, ACTION_PRI_MODIFIERf, 1);
            PolicySet(unit, mem, buf, SVC_METER_INDEX_PRIORITYf, 0);
        } else if(SOC_IS_TD2_TT2(unit)) {
            PolicySet(unit, mem, buf, ACTION_PRI_MODIFIERf, 1);
        }
        break;
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
    case bcmFieldActionPfcClassNew:
        if (soc_feature(unit, soc_feature_field_action_pfc_class)) {
            PolicySet(unit, mem, buf, CHANGE_INPUT_PRIORITYf, 1);
            PolicySet(unit, mem, buf, NEW_INPUT_PRIORITYf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
    case bcmFieldActionRpIntCongestionNotificationNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, R_CHANGE_INT_CNf, 1);
            PolicySet(unit, mem, buf, R_NEW_INT_CNf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
    case bcmFieldActionYpIntCongestionNotificationNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, Y_CHANGE_INT_CNf, 1);
            PolicySet(unit, mem, buf, Y_NEW_INT_CNf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
    case bcmFieldActionGpIntCongestionNotificationNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, G_CHANGE_INT_CNf, 1);
            PolicySet(unit, mem, buf, G_NEW_INT_CNf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
#endif
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
    case bcmFieldActionRpHGCongestionClassNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, R_HG_CONGESTION_CLASS_CHANGEf, 1);
            PolicySet(unit, mem, buf, R_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
    case bcmFieldActionYpHGCongestionClassNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, Y_HG_CONGESTION_CLASS_CHANGEf, 1);
            PolicySet(unit, mem, buf, Y_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
    case bcmFieldActionGpHGCongestionClassNew:
        if (soc_feature(unit, soc_feature_ecn_wred)) {
            PolicySet(unit, mem, buf, G_HG_CONGESTION_CLASS_CHANGEf, 1);
            PolicySet(unit, mem, buf, G_HG_CONGESTION_CLASS_NEWf, fa->param[0]);
        } else {
            return (BCM_E_UNAVAIL);
        }
        break;
#endif /* BCM_GREYHOUND_SUPPORT (or) BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
    case bcmFieldActionHiGigDstModuleGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, HG_DST_MODID_CHANGEf, 1);
        PolicySet(unit, mem, buf, HG_DST_MODID_NEWf, mod_id);
        break;
    case bcmFieldActionHiGigDstPortGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, HG_DST_PORT_CHANGEf, 1);
        PolicySet(unit, mem, buf, HG_DST_PORT_NEWf, port_id);
        break;
    case bcmFieldActionHiGigDstGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
            port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, HG_DST_MODID_CHANGEf, 1);
        PolicySet(unit, mem, buf, HG_DST_MODID_NEWf, mod_id);
        PolicySet(unit, mem, buf, HG_DST_PORT_CHANGEf, 1);
        PolicySet(unit, mem, buf, HG_DST_PORT_NEWf, port_id);
        break;
    case bcmFieldActionGpHiGigDropPrecedenceNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, G_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, G_HG_DP_NEWf, fa->param[0]);
        break;
    case bcmFieldActionYpHiGigDropPrecedenceNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, Y_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, Y_HG_DP_NEWf, fa->param[0]);
        break;
    case bcmFieldActionRpHiGigDropPrecedenceNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, R_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, R_HG_DP_NEWf, fa->param[0]);
        break;
    case bcmFieldActionHiGigDropPrecedenceNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, G_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, G_HG_DP_NEWf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, Y_HG_DP_NEWf, fa->param[0]);
        PolicySet(unit, mem, buf, R_HG_DP_CHANGEf, 1);
        PolicySet(unit, mem, buf, R_HG_DP_NEWf, fa->param[0]);
        break;
    case bcmFieldActionGpHiGigIntPriNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, G_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, G_HG_INT_PRI_NEWf, fa->param[0]);
        break;
    case bcmFieldActionYpHiGigIntPriNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, Y_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, Y_HG_INT_PRI_NEWf, fa->param[0]);
        break;
    case bcmFieldActionRpHiGigIntPriNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, R_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, R_HG_INT_PRI_NEWf, fa->param[0]);
        break;
    case bcmFieldActionHiGigIntPriNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 1);
        PolicySet(unit, mem, buf, G_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, G_HG_INT_PRI_NEWf, fa->param[0]);
        PolicySet(unit, mem, buf, Y_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, Y_HG_INT_PRI_NEWf, fa->param[0]);
        PolicySet(unit, mem, buf, R_HG_INT_PRI_CHANGEf, 1);
        PolicySet(unit, mem, buf, R_HG_INT_PRI_NEWf, fa->param[0]);
        break;
    case bcmFieldActionLoopbackSrcModuleGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_SRC_TYPE_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_TYPE_NEWf, 1);
        PolicySet(unit, mem, buf, LB_SRC_MODID_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_MODID_NEWf, mod_id);
        break;
    case bcmFieldActionLoopbackSrcPortGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_SRC_TYPE_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_TYPE_NEWf, 1);
        PolicySet(unit, mem, buf, LB_SRC_PORT_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_PORT_NEWf, port_id);
        break;
    case bcmFieldActionLoopbackSrcGportNew:
        if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
            src_is_svp = 0;
            mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
            port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
        } else if (BCM_GPORT_IS_MIM_PORT(fa->param[0])) {
            src_is_svp = 1;
            src_svp = BCM_GPORT_MIM_PORT_ID_GET(fa->param[0]);
        } else if (BCM_GPORT_IS_L2GRE_PORT(fa->param[0])) {
            src_is_svp = 1;
            src_svp = BCM_GPORT_L2GRE_PORT_ID_GET(fa->param[0]);
        } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[0])) {
            src_is_svp = 1;
            src_svp = BCM_GPORT_VXLAN_PORT_ID_GET(fa->param[0]);
        } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[0])) {
            src_is_svp = 1;
            src_svp = BCM_GPORT_TRILL_PORT_ID_GET(fa->param[0]);
        } else {
            return BCM_E_PARAM;
        }
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_SRC_MODID_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_PORT_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_SRC_TYPE_CHANGEf, 1);
        if (src_is_svp) {
            PolicySet(unit, mem, buf, LB_SRC_TYPE_NEWf, 0);
            PolicySet(unit, mem, buf, LB_SRC_MODID_NEWf,
                      ((src_svp >> 0x8) & 0xff));
            PolicySet(unit, mem, buf, LB_SRC_PORT_NEWf, (src_svp & 0xff));
        } else {
            PolicySet(unit, mem, buf, LB_SRC_TYPE_NEWf, 1);
            PolicySet(unit, mem, buf, LB_SRC_MODID_NEWf, mod_id);
            PolicySet(unit, mem, buf, LB_SRC_PORT_NEWf, port_id);
        }
        break;
    case bcmFieldActionLoopbackCpuMasqueradePktProfileNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_PACKET_PROFILE_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_PACKET_PROFILE_NEWf, fa->param[0]);
        break;
    case bcmFieldActionLoopbackPacketProcessingPortNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_PP_PORT_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_PP_PORT_NEWf, fa->param[0]);
        break;
    case bcmFieldActionLoopBackTypeNew:
        PolicySet(unit, mem, buf, HG_ACTIONf, 0);
        PolicySet(unit, mem, buf, LB_TYPE_CHANGEf, 1);
        PolicySet(unit, mem, buf, LB_TYPE_NEWf, fa->param[0]);
        break;
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    case bcmFieldActionRecoverableDropCancel:
        if (SOC_IS_TD2P_TT2P(unit)
            || SOC_IS_TRIUMPH3(unit)) {
            PolicySet(unit, mem, buf, PROTECTION_SWITCHING_DROP_OVERIDEf, 1);
        }
        break;
#endif
#if defined (BCM_TRX_SUPPORT)
    case bcmFieldActionRedirDropPrecedence:
        if ((SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, R_REDIR_DROP_PRECEDENCEf) ||
             SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, Y_REDIR_DROP_PRECEDENCEf) ||
             SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, G_REDIR_DROP_PRECEDENCEf)) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            PolicySet(unit, mem, buf, R_REDIR_DROP_PRECEDENCEf, fa->param[0]);
            PolicySet(unit, mem, buf, Y_REDIR_DROP_PRECEDENCEf, fa->param[0]);
            PolicySet(unit, mem, buf, G_REDIR_DROP_PRECEDENCEf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case bcmFieldActionRpRedirDropPrecedence:
        if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, R_REDIR_DROP_PRECEDENCEf) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            PolicySet(unit, mem, buf, R_REDIR_DROP_PRECEDENCEf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case bcmFieldActionYpRedirDropPrecedence:
        if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, Y_REDIR_DROP_PRECEDENCEf) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            PolicySet(unit, mem, buf, Y_REDIR_DROP_PRECEDENCEf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case bcmFieldActionGpRedirDropPrecedence:
        if (SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm, G_REDIR_DROP_PRECEDENCEf) &&
            (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            PolicySet(unit, mem, buf, G_REDIR_DROP_PRECEDENCEf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    case bcmFieldActionEgressClassSelect:
    {
        unsigned i2e_cl_sel;

        switch (fa->param[0]) {
            case BCM_FIELD_EGRESS_CLASS_SELECT_PORT:
                i2e_cl_sel = 0x1;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_SVP:
                i2e_cl_sel = 0x2;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_L3_IIF:
                i2e_cl_sel = 0x3;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_SRC:
                i2e_cl_sel = 0x4; /* VFP hi */
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_DST:
                i2e_cl_sel = 0x5; /* VFP lo */
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_L2_SRC:
                i2e_cl_sel = 0x6;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_L2_DST:
                i2e_cl_sel = 0x7;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_L3_SRC:
                i2e_cl_sel = 0x8;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_L3_DST:
                i2e_cl_sel = 0x9;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_VLAN:
                i2e_cl_sel = 0xa;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_VRF:
                i2e_cl_sel = 0xb;
                break;
            case BCM_FIELD_EGRESS_CLASS_SELECT_NEW:
                i2e_cl_sel = 0xf;
                break;
            default:
                /* Invalid parameter should have been caught earlier */
                return (BCM_E_INTERNAL);
        }
        if (SOC_MEM_FIELD_VALID(unit, mem, I2E_CLASSID_SELf) &&
            (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
            PolicySet(unit, mem, buf, I2E_CLASSID_SELf, i2e_cl_sel);
            PolicySet(unit, mem, buf, G_L3SW_CHANGE_L2_FIELDSf, 0x5);
        }
    }
        break;
    case bcmFieldActionHiGigClassSelect:
        {
            unsigned hg_cl_sel;

            switch (fa->param[0]) {
                case BCM_FIELD_HIGIG_CLASS_SELECT_EGRESS:
                    hg_cl_sel = 1;
                    break;
                case BCM_FIELD_HIGIG_CLASS_SELECT_EGR_DVP:
                    hg_cl_sel = 4;
                    break;
                case BCM_FIELD_HIGIG_CLASS_SELECT_EGR_L3_INTERFACE:
                    hg_cl_sel = 3;
                    break;
                case BCM_FIELD_HIGIG_CLASS_SELECT_EGR_NEXT_HOP:
                    hg_cl_sel = 2;
                    break;
                case BCM_FIELD_HIGIG_CLASS_SELECT_PORT:
                    hg_cl_sel = 7;
                    break;
                default:
                    /* Invalid parameter should have been caught earlier */
                    return (BCM_E_INTERNAL);
            }

            PolicySet(unit, mem, buf, HG_CLASSID_SELf, hg_cl_sel);
        }
        break;
   case bcmFieldActionNewClassId:
        PolicySet(unit, mem, buf, I2E_CLASSIDf, fa->param[0]);
        if (SOC_MEM_FIELD_VALID(unit, mem,
                        G_L3SW_CHANGE_L2_FIELDSf)) {
            PolicySet(unit, mem, buf, G_L3SW_CHANGE_L2_FIELDSf, 0x5);
        }
        break;
   case bcmFieldActionDscpMapNew:
        hw_index = 0;
#if defined BCM_TRIUMPH2_SUPPORT
        rv = _bcm_tr2_qos_id2idx(unit, fa->param[0], &hw_index);
        if (BCM_FAILURE(rv)) {
            return BCM_E_PARAM;
        }
#endif
        PolicySet(unit, mem, buf, TRUST_DSCP_PTRf, hw_index);
        PolicySet(unit, mem, buf, TRUST_DSCPf, 1);
        break;
#endif /* BCM_KATANA2_SUPPORT */
    case bcmFieldActionChangeL2Fields:
#if defined INCLUDE_L3
        PolicySet(unit, mem, buf, l3sw_or_change_l2, 0x1);
        BCM_IF_ERROR_RETURN
            (_field_trx_policy_set_l3_info(unit, mem, fa->param[0], buf));
#endif /* INCLUDE_L3 */
        break;
#if defined(BCM_HURRICANE3_SUPPORT)
   case bcmFieldActionPfcTx:
        PolicySet(unit, mem, buf, PFC_TRIGGERf, 1);
        PolicySet(unit, mem, buf, PFC_STREAM_IDf, fa->param[0]);
        PolicySet(unit, mem, buf, PFC_TCf, fa->param[1]);
        break;
   case bcmFieldActionSwitchEncap:
       if (soc_feature(unit, soc_feature_miml) ||
           soc_feature(unit, soc_feature_custom_header)) {

           if ((fa->param[0] >> _BCM_SWITCH_ENCAP_SHIFT) ==
               _BCM_SWITCH_ENCAP_TYPE_MIML) {
               int nhi_offset = SOC_IS_HURRICANE3(unit)? 15: 16;
               rv = _bcm_hr3_switch_encap_id2idx(unit, fa->param[0], 2, index_array);
               if (BCM_FAILURE(rv)) {
                   return BCM_E_PARAM;
               }

               /* Set policy table redirection fields */
               PolicySet(unit, mem, buf, REDIRECTIONf,
                         ((0x1 << nhi_offset) | index_array[0]));
               PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 1);

               PolicySet(unit, mem, buf, HEADER_ENCAP_INDEXf, index_array[1]);
               PolicySet(unit, mem, buf, ASSIGN_HEADER_ENCAP_FIELDSf, 1);

               LOG_DEBUG(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FP(unit %d) vverb: Set MiML Encap \
                                     (Nexthop index: %d, CustomHeader index: %d\n)))"),
                          unit, index_array[0], index_array[1]));
           } else if ((fa->param[0] >> _BCM_SWITCH_ENCAP_SHIFT) ==
               _BCM_SWITCH_ENCAP_TYPE_CUSTOM_HEADER) {
               rv = _bcm_hr3_switch_encap_id2idx(unit, fa->param[0], 1, index_array);
               if (BCM_FAILURE(rv)) {
                   return BCM_E_PARAM;
               }

               /* Set policy table redirection fields */
               PolicySet(unit, mem, buf, HEADER_ENCAP_INDEXf, index_array[0]);
               PolicySet(unit, mem, buf, ASSIGN_HEADER_ENCAP_FIELDSf, 1);
               LOG_DEBUG(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "FP(unit %d) vverb: Set Custom Header Encap \
                                     (CustomHeader index: %d\n)))"),
                          unit, index_array[0]));
           } else {
               return BCM_E_PARAM;
           }
       } else {
           return BCM_E_UNAVAIL;
       }
       break;
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
    case bcmFieldActionDoNotCutThrough:
        PolicySet(unit, mem, buf, DO_NOT_CUT_THROUGHf, 0x1);
        break;
    case bcmFieldActionVxlanTerminate:
        if (soc_feature(unit, soc_feature_vxlan_lite)) {
            PolicySet(unit, mem, buf, VXLAN_DECAPf, 0x1);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case bcmFieldActionUseTunnelPayload:
        if (soc_feature(unit, soc_feature_vxlan_lite)) {
            PolicySet(unit, mem, buf, IP_TUNNEL_TERMINATIONf, fa->param[0]);
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
#endif /* BCM_GREYHOUND2_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
   case bcmFieldActionStrength:
       PolicySet(unit, mem, buf, REDIR_STRENGTHf, fa->param[0]);
       break;
   case bcmFieldActionRedirectBufferPriority:
       PolicySet(unit, mem, buf, REDIR_RDB_PRIORITYf, fa->param[0]);
       break;
   case bcmFieldActionRedirectPrioIntNew:
       PolicySet(unit, mem, buf, R_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, R_CHANGE_REDIR_INT_PRIf, 0x1);
       PolicySet(unit, mem, buf, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, Y_CHANGE_REDIR_INT_PRIf, 0x1);
       PolicySet(unit, mem, buf, G_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, G_CHANGE_REDIR_INT_PRIf, 0x1);
       break;
   case bcmFieldActionRpRedirectPrioIntNew:
       PolicySet(unit, mem, buf, R_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, R_CHANGE_REDIR_INT_PRIf, 0x1);
       break;
   case bcmFieldActionYpRedirectPrioIntNew:
       PolicySet(unit, mem, buf, Y_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, Y_CHANGE_REDIR_INT_PRIf, 0x1);
       break;
   case bcmFieldActionGpRedirectPrioIntNew:
       PolicySet(unit, mem, buf, G_NEW_REDIR_INT_PRIf, fa->param[0]);
       PolicySet(unit, mem, buf, G_CHANGE_REDIR_INT_PRIf, 0x1);
       break;
   case bcmFieldActionOamStatObjectSessionId:
       BCM_IF_ERROR_RETURN(_field_oam_lm_stat_pool_id_get(unit, fa->param[0],
                   0, &flex_stat_pool_id));
       PolicySet(unit, mem, buf, SESSION_ID_POOL_SELECTORf, flex_stat_pool_id);
       break;
   case bcmFieldActionLoopbackOamResponse:
       PolicySet(unit, mem, buf, LOOPBACKf, 0x1);
       break;
   case bcmFieldActionLoopbackSatResponse:
       PolicySet(unit, mem, buf, LOOPBACKf, 0x2);
       break;
#endif /* BCM_APACHE_SUPPORT */

#if defined(BCM_METROLITE_SUPPORT)
   case bcmFieldActionSwapMacDaSa:
       PolicySet(unit, mem, buf, DA_SA_SWAPf, 0x1);
       break;
   case bcmFieldActionSwapSourceIPDestIP:
       PolicySet(unit, mem, buf, SIP_DIP_SWAPf, 0x1);
       break;
   case bcmFieldActionReplaceTtl:
       PolicySet(unit, mem, buf, REPLACE_TTLf, 0x1);
       break;
   case bcmFieldActionPacketIsL3SAT:
       PolicySet(unit, mem, buf, L3SATf, 0x1);
       break;
#endif

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
   case bcmFieldActionProtectionSwitchingDrop:
       if ( (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) &&
                  (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) ) {
           PolicySet(unit, mem, buf, DROP_DATA_ENABLEf, 1);
       }
       break;
#endif
#if defined (BCM_TRIUMPH3_SUPPORT)
        case bcmFieldActionReplaceSrcMac:
        case bcmFieldActionReplaceDstMac:
        case bcmFieldActionReplaceInnerVlan:
        case bcmFieldActionReplaceOuterVlan:
        case bcmFieldActionReplaceInnerVlanPriority:
        case bcmFieldActionReplaceOuterVlanPriority:
           if(f_ent->eid != _FP_INTERNAL_RESERVED_ID) {
               rv = _bcm__field_tr3_action_replaceL2Fields(unit, fa);
               if(rv < 0) {
                   return BCM_E_PARAM;
               }
           }
           PolicySet(unit, mem, buf, L2MOD_TBL_INDEXf, fa->hw_index);
           PolicySet(unit, mem, buf, G_L3SW_CHANGE_L2_FIELDSf, 0x9);
        break;
#endif
    default:
        return (BCM_E_UNAVAIL);
    }


#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Add VFP Class ID to the Policy Table along with CopyToCpu Action.
     */
    if (SOC_INFO(unit).th_ctc_replace_enabled) {
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
           uint8 enable;

           enable = PolicyGet(unit, mem, buf, COPY_TO_CPUf);
           if (enable == 1) {
              PolicySet(unit, mem, buf, USE_VFP_CLASS_ID_Hf, 0x1);
              PolicySet(unit, mem, buf, VFP_CLASS_ID_Hf,
                     _BCM_FIELD_COPYTOCPU_WAR_RESERVED_CLASSID);
           }
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    fa->flags &= ~_FP_ACTION_DIRTY; /* Mark action as installed. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: END _bcm_field_trx_action_get()\n"),
               unit));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_mirror_add
 * Purpose:
 *     Set mirroring destination & enable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     f_ent    - (IN) Entry structure to get policy info from
 *     fa       - (IN) field action
 *     buf      - (IN/OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx2_mirror_add(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                       _field_action_t *fa, uint32 *buf)
{
    int mtp_index;
    uint32 enable;
    int mtp_type_index;
    int flexibleMirror;
    int directedMirror;
    int rv;

    soc_field_t mtp_field[] = {
        MTP_INDEX0f, MTP_INDEX1f,
        MTP_INDEX2f, MTP_INDEX3f};

    /* Input parameters check. */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }
    mtp_index = fa->hw_index;
    mtp_type_index = mtp_index;

    /* shifting the index back since flexible slot shift was done
     * prior to this
     */
    rv = bcm_esw_switch_control_get(unit,bcmSwitchFlexibleMirrorDestinations,
                                    &flexibleMirror);
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_switch_control_get(unit,bcmSwitchDirectedMirroring,
                                    &directedMirror);
    BCM_IF_ERROR_RETURN(rv);

    if (soc_feature(unit, soc_feature_mirror_flexible)
        && flexibleMirror && directedMirror) {
        mtp_index = (fa->hw_index & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
        mtp_type_index = ((fa->hw_index >> BCM_MIRROR_MTP_FLEX_SLOT_SHIFT)
                           & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
    }

    if (mtp_type_index >= COUNTOF(mtp_field)) {
        fa->hw_index = _FP_INVALID_INDEX;
        return (BCM_E_INTERNAL);
    }

    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
            PolicySet(unit, mem, buf,
                      REDIRECTION_DESTINATIONf, 0x1 << mtp_index);
        } else {
            PolicySet(unit, mem, buf, REDIRECTIONf, 0x1 << mtp_index);
        }
        if (SOC_IS_APACHE(unit)) {
            PolicySet(unit, mem, buf, R_REDIRECTf, 0x3);
            PolicySet(unit, mem, buf, G_REDIRECTf, 0x3);
            PolicySet(unit, mem, buf, Y_REDIRECTf, 0x3);
            PolicySet(unit, mem, buf, REDIRECTION_DEST_TYPEf, 0x4);
        } else {
            PolicySet(unit, mem, buf, G_PACKET_REDIRECTIONf, 0x4);
        }
    } else {
        enable = PolicyGet(unit, mem, buf, MIRRORf);
        PolicySet(unit, mem, buf, mtp_field[mtp_type_index], mtp_index);
        PolicySet(unit, mem, buf, MIRRORf, (enable | (0x1 << mtp_type_index)));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_mirror_ingress_add
 * Purpose:
 *     Set ingress mirroring destination & enable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     f_ent    - (IN) Entry structure to get policy info from
 *     fa       - (IN) field action
 *     buf      - (IN/OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_mirror_ingress_add(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                                  _field_action_t *fa, uint32 *buf)
{
    int mtp_index;
    uint32 enable;
    int mtp_slot_check = 0;      /* MTP Slot map status.      */
    int orig_enable_mtp_map = 0; /* Original Ingress enable   */
    int flags = 0;               /* Slot Check Flag           */
    int rv;                      /* Return Status */
    int mirror_ex_en = _BCM_SWITCH_MIRROR_NON_EXCLUSIVE;

    /* Input parameters check. */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

#ifdef BCM_TRIUMPH2_SUPPORT
   if (soc_feature(unit, soc_feature_mirror_flexible)) {
        return _field_trx2_mirror_add(unit, mem, f_ent, fa, buf);
    }
#endif

    /* Allocate mirror to index. */
    mtp_index = fa->hw_index;
    enable = PolicyGet(unit, mem, buf, INGRESS_MIRRORf);

    /* Check if slot container are occupied earlier by other module , ignore if not set*/
    rv = _bcm_esw_mirror_exclusive_get(unit, &mirror_ex_en);

    if(BCM_SUCCESS(rv) && (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE)) {
        orig_enable_mtp_map = enable;
        flags |= (_BCM_MIRROR_SLOT_INGRESS | _BCM_MIRROR_SLOT_FP);
        BCM_IF_ERROR_RETURN
            (_bcm_esw_mtp_slot_valid_get(unit,
                                         flags,
                                         &mtp_slot_check));
        enable = enable | mtp_slot_check;
    }

    /* If destination 0 not in use install new mtp to destination 0. */
     if(0 == (enable & 0x1)) {

         /* Retreive orig enable on port */
         if (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE) {
             enable = orig_enable_mtp_map;
             BCM_IF_ERROR_RETURN
                    (_bcm_esw_mirror_fp_slot_add_ref(unit,
                                                     flags,
                                                     _BCM_MIRROR_SLOT_CONT0));
         }

        PolicySet(unit, mem, buf, IM0_MTP_INDEXf, mtp_index);
        PolicySet(unit, mem, buf, INGRESS_MIRRORf, (enable | 0x1));
        f_ent->ing_mtp_slot_map |= 0x1;
        return (BCM_E_NONE);
    }

    /* If destination 1 not in use install new mtp to destination 1. */
    if(0 == (enable & 0x2) && SOC_MEM_FIELD_VALID(unit, mem, IM1_MTP_INDEXf)) {

        /* Retreive orig enable on port */
        if (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE) {
            enable = orig_enable_mtp_map;
            BCM_IF_ERROR_RETURN
                    (_bcm_esw_mirror_fp_slot_add_ref(unit,
                                                     flags,
                                                     _BCM_MIRROR_SLOT_CONT1));
        }

        PolicySet(unit, mem, buf, IM1_MTP_INDEXf, mtp_index);
        PolicySet(unit, mem, buf, INGRESS_MIRRORf, (enable | 0x2));
        f_ent->ing_mtp_slot_map |= 0x2;
        return (BCM_E_NONE);
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function:
 *     _bcm_field_trx_mirror_egress_add
 * Purpose:
 *     Set ingress mirroring destination & enable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     mem      - (IN) Policy table memory
 *     f_ent    - (IN) Entry structure to get policy info from
 *     fa       - (IN) field action
 *     buf      - (IN/OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_mirror_egress_add(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                                 _field_action_t *fa, uint32 *buf)
{
    int mtp_index;
    int enable;
    int mtp_slot_check = 0;      /* MTP Slot map status.      */
    int orig_enable_mtp_map = 0; /* Original Egress enable   */
    int flags = 0;               /* Slot Check Flag           */
    int mirror_ex_en = _BCM_SWITCH_MIRROR_NON_EXCLUSIVE;
    int rv;

    /* Input parameters check. */
    if (NULL == f_ent || NULL == fa || NULL == buf) {
        return (BCM_E_PARAM);
    }

#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_mirror_flexible)) {
        return _field_trx2_mirror_add(unit, mem, f_ent, fa, buf);
    }
#endif

    /* Allocate mirror to index. */
    mtp_index = fa->hw_index;
    enable = PolicyGet(unit, mem, buf, EGRESS_MIRRORf);

    /* Check if slot container are occupied earlier by other module , ignore if not set*/
    rv = _bcm_esw_mirror_exclusive_get(unit, &mirror_ex_en);

    if(BCM_SUCCESS(rv) && (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE)) {
        orig_enable_mtp_map = enable;
        flags |= (_BCM_MIRROR_SLOT_EGRESS | _BCM_MIRROR_SLOT_FP);
        BCM_IF_ERROR_RETURN
            (_bcm_esw_mtp_slot_valid_get(unit,
                                         flags,
                                         &mtp_slot_check));
        enable = enable | mtp_slot_check;
    }

    /* If destination 0 not in use install new mtp to destination 0. */
     if(0 == (enable & 0x1)) {

         /* Retreive orig enable on port */
         if (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE) {
             enable = orig_enable_mtp_map;
             BCM_IF_ERROR_RETURN
                    (_bcm_esw_mirror_fp_slot_add_ref(unit,
                                                     flags,
                                                     _BCM_MIRROR_SLOT_CONT0));
         }

        PolicySet(unit, mem, buf, EM0_MTP_INDEXf, mtp_index);
        PolicySet(unit, mem, buf, EGRESS_MIRRORf, (enable | 0x1));
        f_ent->egr_mtp_slot_map |= 0x1;
        return (BCM_E_NONE);
    }

    /* If destination 1 not in use install new mtp to destination 1. */
    if(0 == (enable & 0x2) && SOC_MEM_FIELD_VALID(unit, mem, EM1_MTP_INDEXf)) {

        /* Retreive orig enable on port */
        if (mirror_ex_en == _BCM_SWITCH_MIRROR_EXCLUSIVE) {
            enable = orig_enable_mtp_map;
            BCM_IF_ERROR_RETURN
                    (_bcm_esw_mirror_fp_slot_add_ref(unit,
                                                     flags,
                                                     _BCM_MIRROR_SLOT_CONT1));
        }

        PolicySet(unit, mem, buf, EM1_MTP_INDEXf, mtp_index);
        PolicySet(unit, mem, buf, EGRESS_MIRRORf, (enable | 0x2));
        f_ent->egr_mtp_slot_map |= 0x2;
        return (BCM_E_NONE);
    }
    return (BCM_E_RESOURCE);
}

/*
 * Function:
 *     _bcm_field_trx_action_support_check
 *
 * Purpose:
 *     Check if action is supported by device.
 *
 * Parameters:
 *     unit   -(IN) BCM device number
 *     f_ent  -(IN) Field entry structure.
 *     action -(IN) Action to check(bcmFieldActionXXX)
 *     result -(OUT)
 *               TRUE   - action is supported by device
 *               FALSE  - action is NOT supported by device
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_stage_action_support_check(int                unit,
                                          unsigned           stage,
                                          bcm_field_action_t action,
                                          int                *result
                                          )
{
#if defined(BCM_TRIDENT_SUPPORT)
    int vfp_compress_en = 0;
#endif /* !BCM_TRIDENT_SUPPORT */

    if (stage == _BCM_FIELD_STAGE_EGRESS) {
        switch (action) {
          case bcmFieldActionDrop:
          case bcmFieldActionDropCancel:
          case bcmFieldActionInnerVlanNew:
          case bcmFieldActionOuterVlanNew:
          case bcmFieldActionOuterTpidNew:
          case bcmFieldActionOuterVlanPrioNew:
          case bcmFieldActionInnerVlanPrioNew:
          case bcmFieldActionOuterVlanCfiNew:
          case bcmFieldActionInnerVlanCfiNew:
              *result = TRUE;
              break;
          case bcmFieldActionMirrorEgress:
              *result = soc_feature(unit, soc_feature_egr_mirror_true) \
                            ? TRUE : FALSE;
              break;
          case bcmFieldActionIpFix:
          case bcmFieldActionIpFixCancel:
              *result = soc_feature(unit, soc_feature_ipfix) ? TRUE : FALSE;
              break;
          case bcmFieldActionDscpNew:
          case bcmFieldActionRpDrop:
          case bcmFieldActionRpDropCancel:
          case bcmFieldActionRpDscpNew:
          case bcmFieldActionRpOuterVlanPrioNew:
          case bcmFieldActionRpInnerVlanPrioNew:
          case bcmFieldActionRpOuterVlanCfiNew:
          case bcmFieldActionRpInnerVlanCfiNew:

          case bcmFieldActionYpDrop:
          case bcmFieldActionYpDropCancel:
          case bcmFieldActionYpDscpNew:
          case bcmFieldActionYpOuterVlanPrioNew:
          case bcmFieldActionYpInnerVlanPrioNew:
          case bcmFieldActionYpOuterVlanCfiNew:
          case bcmFieldActionYpInnerVlanCfiNew:

          case bcmFieldActionGpDrop:
          case bcmFieldActionGpDropCancel:
          case bcmFieldActionGpDscpNew:
          case bcmFieldActionGpOuterVlanPrioNew:
          case bcmFieldActionGpInnerVlanPrioNew:
          case bcmFieldActionGpOuterVlanCfiNew:
          case bcmFieldActionGpInnerVlanCfiNew:
              *result = TRUE;
              break;
          case bcmFieldActionEcnNew:
          case bcmFieldActionRpEcnNew:
          case bcmFieldActionYpEcnNew:
          case bcmFieldActionGpEcnNew:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                                            G_CHANGE_ECNf) ? TRUE : FALSE;
              break;
          case bcmFieldActionCopyToCpu:
          case bcmFieldActionRpCopyToCpu:
          case bcmFieldActionYpCopyToCpu:
          case bcmFieldActionGpCopyToCpu:
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_APACHE_SUPPORT)
              if (SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
              } else
#endif
              {
#ifdef BCM_TRIUMPH2_SUPPORT
              if (!soc_feature(unit, soc_feature_internal_loopback)) {
                  /* Loopback port is not available */
                  *result = FALSE;
                  break;
              }
#endif
              }
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                                            G_COPY_TO_CPUf) ? TRUE : FALSE;
              break;
          case bcmFieldActionCopyToCpuCancel:
          case bcmFieldActionRpCopyToCpuCancel:
          case bcmFieldActionYpCopyToCpuCancel:
          case bcmFieldActionGpCopyToCpuCancel:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                                            G_COPY_TO_CPUf) ? TRUE : FALSE;
#ifdef BCM_APACHE_SUPPORT
              if (SOC_IS_APACHE(unit)) {
                  *result = FALSE;
              }
#endif
              break;
          case bcmFieldActionCosQCpuNew:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                                                NEW_CPU_COSf) ? TRUE : FALSE;
              break;
          case bcmFieldActionRedirect:
          case bcmFieldActionRedirectTrunk:
          case bcmFieldActionRedirectMcast:
              if (SOC_IS_TRIUMPH3(unit) &&
                   soc_feature(unit, soc_feature_axp)) {
                  *result = TRUE;
              }
              else if (SOC_IS_KATANA2(unit) || SOC_IS_APACHE(unit)) {
                  *result = TRUE;
              }
              else {
                  *result = FALSE;
              }
              break;
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
          case bcmFieldActionRpHGCongestionClassNew:
          case bcmFieldActionYpHGCongestionClassNew:
          case bcmFieldActionGpHGCongestionClassNew:
              if (soc_feature(unit, soc_feature_ecn_wred)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_GREYHOUND_SUPPORT (or) BCM_TOMAHAWK_SUPPORT */
#if defined (BCM_TRX_SUPPORT)
          case bcmFieldActionRedirDropPrecedence:
              *result =
                  (SOC_MEM_FIELD_VALID(unit,
                       EFP_POLICY_TABLEm, R_REDIR_DROP_PRECEDENCEf) ||
                   SOC_MEM_FIELD_VALID(unit,
                       EFP_POLICY_TABLEm, Y_REDIR_DROP_PRECEDENCEf) ||
                   SOC_MEM_FIELD_VALID(unit,
                       EFP_POLICY_TABLEm, G_REDIR_DROP_PRECEDENCEf)) ?
                   TRUE : FALSE;
              break;
          case bcmFieldActionRpRedirDropPrecedence:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                            R_REDIR_DROP_PRECEDENCEf) ? TRUE : FALSE;
              break;
          case bcmFieldActionYpRedirDropPrecedence:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                            Y_REDIR_DROP_PRECEDENCEf) ? TRUE : FALSE;
              break;
          case bcmFieldActionGpRedirDropPrecedence:
              *result = SOC_MEM_FIELD_VALID(unit, EFP_POLICY_TABLEm,
                            G_REDIR_DROP_PRECEDENCEf) ? TRUE : FALSE;
              break;
#endif /* BCM_TRX_SUPPORT */
#if defined (BCM_KATANA2_SUPPORT)
          case bcmFieldActionPrioIntNew:
          case bcmFieldActionGpPrioIntNew:
          case bcmFieldActionRpPrioIntNew:
          case bcmFieldActionYpPrioIntNew:
               *result = SOC_IS_KATANA2(unit) ? TRUE : FALSE;
              break;
#endif
#if defined(BCM_APACHE_SUPPORT)
          case bcmFieldActionRedirectPrioIntNew:
          case bcmFieldActionRpRedirectPrioIntNew:
          case bcmFieldActionYpRedirectPrioIntNew:
          case bcmFieldActionGpRedirectPrioIntNew:
              *result = SOC_IS_APACHE(unit) ? TRUE : FALSE;
              break;
#endif /* BCM_APACHE_SUPPORT */
          default:
              *result = FALSE;
        }
        return (BCM_E_NONE);
    }
    if (stage == _BCM_FIELD_STAGE_LOOKUP) {
        switch (action) {
        case bcmFieldActionDrop:
        case bcmFieldActionDropCancel:
        case bcmFieldActionCopyToCpu:
        case bcmFieldActionCopyToCpuCancel:
        case bcmFieldActionPrioPktNew:
        case bcmFieldActionInnerVlanAdd:
        case bcmFieldActionInnerVlanNew:
        case bcmFieldActionInnerVlanDelete:
        case bcmFieldActionOuterVlanAdd:
        case bcmFieldActionOuterVlanNew:
        case bcmFieldActionOuterVlanLookup:
        case bcmFieldActionCosQCpuNew:
        case bcmFieldActionPrioPktAndIntNew:
        case bcmFieldActionPrioIntNew:
        case bcmFieldActionDropPrecedence:
        case bcmFieldActionDoNotLearn:
        case bcmFieldActionDoNotCheckVlan:
        case bcmFieldActionEnableVlanCheck:
        case bcmFieldActionClassDestSet:
        case bcmFieldActionClassSourceSet:
            *result = TRUE;
            break;
        case bcmFieldActionEsmSearchKeySrcMac:
            *result = (SOC_IS_TRIUMPH3(unit) && soc_feature(unit, soc_feature_esm_support)) ? TRUE : FALSE;
            break;
        case bcmFieldActionVrfSet:
            *result = SOC_IS_HURRICANE2(unit) ? FALSE : TRUE;
            break;
        case bcmFieldActionIncomingMplsPortSet:
            *result = soc_feature(unit, soc_feature_mpls) ? TRUE : FALSE;
            break;
        case bcmFieldActionIngressGportSet:
            *result = ( soc_feature(unit, soc_feature_mpls)   ||
                        soc_feature(unit, soc_feature_mim)    ||
                        soc_feature(unit, soc_feature_trill)  ||
                        soc_feature(unit, soc_feature_niv)    ||
                        soc_feature(unit, soc_feature_wlan) ) ? TRUE : FALSE;
            break;
        case bcmFieldActionVpnSet:
            *result = (soc_feature(unit, soc_feature_vfi_from_vlan_tables) ||
                       soc_feature(unit, soc_feature_vxlan_lite)) ? TRUE : FALSE;
            break;
        case bcmFieldActionL3IngressSet:
            *result = soc_feature(unit, soc_feature_l3_ingress_interface) ? TRUE : FALSE;
             break;
        case bcmFieldActionOamPbbteLookupEnable:
            *result = soc_feature(unit,
                        soc_feature_field_oam_actions) ? TRUE : FALSE;
            break;
        case bcmFieldActionOuterVlanCopyInner:
        case bcmFieldActionOuterVlanPrioCopyInner:
        case bcmFieldActionOuterVlanCfiCopyInner:
        case bcmFieldActionInnerVlanCopyOuter:
        case bcmFieldActionInnerVlanPrioCopyOuter:
        case bcmFieldActionInnerVlanCfiCopyOuter:
        case bcmFieldActionInnerVlanCfiNew:
        case bcmFieldActionOuterVlanCfiNew:
        case bcmFieldActionOuterVlanPrioNew:
        case bcmFieldActionInnerVlanPrioNew:
#ifdef BCM_TRIDENT_SUPPORT
            *result = (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                       SOC_IS_TRIUMPH3(unit));
            break;
        case bcmFieldActionCompressSrcIp6:
        case bcmFieldActionCompressDstIp6:
            if (SOC_IS_TD_TT(unit) &&
                SOC_MEM_FIELD_VALID(unit, VFP_POLICY_TABLEm,
                    IPV6_TO_IPV4_MAP_OFFSET_SETf)) {
                BCM_IF_ERROR_RETURN(bcm_esw_switch_control_get(unit,
                    bcmSwitchIp6CompressEnable, &vfp_compress_en));
                *result = vfp_compress_en ? TRUE : FALSE;
            } else {
                *result = FALSE;
            }
            break;
#endif /* !BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        case bcmFieldActionProtectionSwitchingDrop:
            *result = SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit);
            break;
#endif
        case bcmFieldActionRegexActionCancel:
            *result = soc_feature(unit, soc_feature_regex) ? TRUE : FALSE;
            break;

#if defined(BCM_KATANA2_SUPPORT)
        case bcmFieldActionOamDomain:
            if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_oam))) {
                *result = TRUE;
            } else {
                *result = FALSE;
            }
            break;
#endif /* BCM_KATANA2_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
        case bcmFieldActionDoNotOverride:
            if (SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit) ||
                SOC_IS_APACHE(unit) || SOC_IS_TD2_TT2(unit)) {
                 *result = TRUE;
            } else {
                *result = FALSE;
            }
            break;
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
        case bcmFieldActionDscpMapNew:
            if ((SOC_IS_KATANA2(unit))
                || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                *result = (stage == _BCM_FIELD_STAGE_LOOKUP);
                break;
            }
            *result = FALSE;
            break;
#endif

#if defined(BCM_GREYHOUND2_SUPPORT)
        case bcmFieldActionUseTunnelPayload:
            *result = (soc_feature(unit, soc_feature_vxlan_lite)) ? TRUE : FALSE;
            break;
#endif /* BCM_GREYHOUND2_SUPPORT */

        default:
            *result = FALSE;
        }
        return (BCM_E_NONE);
    }

    if ((stage == _BCM_FIELD_STAGE_INGRESS) ||
        (stage == _BCM_FIELD_STAGE_EXTERNAL)) {
        switch (action) {
          case bcmFieldActionRedirectEgrNextHop:
#if defined(INCLUDE_L3)
              if (soc_feature(unit, soc_feature_field_action_redirect_nexthop)
                  || soc_feature(unit, soc_feature_field_action_redirect_ecmp)) {
                  *result = TRUE;
              } else
#endif
              {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionAddClassTag:
          case bcmFieldActionCopyToCpu:
          case bcmFieldActionCopyToCpuCancel:
          case bcmFieldActionDrop:
          case bcmFieldActionDropCancel:
          case bcmFieldActionDropPrecedence:
          case bcmFieldActionColorIndependent:
          case bcmFieldActionL3ChangeVlan:
          case bcmFieldActionL3ChangeVlanCancel:
          case bcmFieldActionL3ChangeMacDa:
          case bcmFieldActionL3ChangeMacDaCancel:
          case bcmFieldActionPrioPktCopy:
          case bcmFieldActionPrioPktNew:
          case bcmFieldActionPrioPktTos:
          case bcmFieldActionPrioPktCancel:
          case bcmFieldActionEcnNew:
          case bcmFieldActionDscpNew:
          case bcmFieldActionDscpCancel:
          case bcmFieldActionCosQNew:
          case bcmFieldActionCosQCpuNew:
          case bcmFieldActionVlanCosQNew:
          case bcmFieldActionMirrorOverride:
          case bcmFieldActionSwitchToCpuCancel:
          case bcmFieldActionSwitchToCpuReinstate:
          case bcmFieldActionRedirect:
          case bcmFieldActionRedirectTrunk:
          case bcmFieldActionRedirectCancel:
          case bcmFieldActionRedirectPbmp:
          case bcmFieldActionRedirectIpmc:
          case bcmFieldActionRedirectMcast:
              *result = TRUE;
              break;
          case bcmFieldActionL3Switch:
          case bcmFieldActionL3SwitchCancel:
              if (soc_feature(unit,
                              soc_feature_field_action_l3_route_disabled)) {
                  *result = FALSE;
              } else {
                  *result = TRUE;
              }
              break;
          case bcmFieldActionRedirectBcastPbmp:
              if (SOC_IS_TD_TT(unit) || SOC_IS_ENDURO(unit) ||
                  SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH2(unit) ||
                  SOC_IS_TRIUMPH3(unit) || SOC_IS_APOLLO(unit) ||
                  SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                  SOC_IS_GREYHOUND2(unit)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionRedirectVlan:
              if (SOC_IS_TR_VL(unit)) {
                  *result= TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionEgressMask:
          case bcmFieldActionEgressPortsAdd:
          case bcmFieldActionDoNotChangeTtl:
              *result = TRUE;
              break;
          case bcmFieldActionDoNotCheckUrpf:
              *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm, DO_NOT_URPFf);
              break;
          case bcmFieldActionPrioPktAndIntCopy:
          case bcmFieldActionPrioPktAndIntNew:
          case bcmFieldActionPrioPktAndIntTos:
          case bcmFieldActionPrioPktAndIntCancel:
          case bcmFieldActionPrioIntCopy:
          case bcmFieldActionPrioIntNew:
          case bcmFieldActionPrioIntTos:
          case bcmFieldActionPrioIntCancel:
          case bcmFieldActionMirrorIngress:
          case bcmFieldActionMirrorEgress:

          case bcmFieldActionRpDrop:
          case bcmFieldActionRpDropCancel:
          case bcmFieldActionRpDropPrecedence:
          case bcmFieldActionRpCopyToCpu:
          case bcmFieldActionRpCopyToCpuCancel:
          case bcmFieldActionRpPrioPktCopy:
          case bcmFieldActionRpPrioPktNew:
          case bcmFieldActionRpPrioPktTos:
          case bcmFieldActionRpPrioPktCancel:
          case bcmFieldActionRpDscpNew:
          case bcmFieldActionRpDscpCancel:
          case bcmFieldActionRpEcnNew:
          case bcmFieldActionRpCosQNew:
          case bcmFieldActionRpVlanCosQNew:
          case bcmFieldActionRpPrioPktAndIntCopy:
          case bcmFieldActionRpPrioPktAndIntNew:
          case bcmFieldActionRpPrioPktAndIntTos:
          case bcmFieldActionRpPrioPktAndIntCancel:
          case bcmFieldActionRpSwitchToCpuCancel:
          case bcmFieldActionRpSwitchToCpuReinstate:
          case bcmFieldActionRpPrioIntCopy:
          case bcmFieldActionRpPrioIntNew:
          case bcmFieldActionRpPrioIntTos:
          case bcmFieldActionRpPrioIntCancel:

          case bcmFieldActionYpDrop:
          case bcmFieldActionYpDropCancel:
          case bcmFieldActionYpDropPrecedence:
          case bcmFieldActionYpCopyToCpu:
          case bcmFieldActionYpCopyToCpuCancel:
          case bcmFieldActionYpPrioPktCopy:
          case bcmFieldActionYpPrioPktNew:
          case bcmFieldActionYpPrioPktTos:
          case bcmFieldActionYpPrioPktCancel:
          case bcmFieldActionYpDscpNew:
          case bcmFieldActionYpDscpCancel:
          case bcmFieldActionYpEcnNew:
          case bcmFieldActionYpCosQNew:
          case bcmFieldActionYpVlanCosQNew:
          case bcmFieldActionYpPrioPktAndIntCopy:
          case bcmFieldActionYpPrioPktAndIntNew:
          case bcmFieldActionYpPrioPktAndIntTos:
          case bcmFieldActionYpPrioPktAndIntCancel:
          case bcmFieldActionYpSwitchToCpuCancel:
          case bcmFieldActionYpSwitchToCpuReinstate:
          case bcmFieldActionYpPrioIntCopy:
          case bcmFieldActionYpPrioIntNew:
          case bcmFieldActionYpPrioIntTos:
          case bcmFieldActionYpPrioIntCancel:

          case bcmFieldActionGpDrop:
          case bcmFieldActionGpDropCancel:
          case bcmFieldActionGpDropPrecedence:
          case bcmFieldActionGpCopyToCpu:
          case bcmFieldActionGpCopyToCpuCancel:
          case bcmFieldActionGpPrioPktCopy:
          case bcmFieldActionGpPrioPktNew:
          case bcmFieldActionGpPrioPktTos:
          case bcmFieldActionGpPrioPktCancel:
          case bcmFieldActionGpDscpNew:
          case bcmFieldActionGpTosPrecedenceNew:
          case bcmFieldActionGpTosPrecedenceCopy:
          case bcmFieldActionGpDscpCancel:
          case bcmFieldActionGpEcnNew:
          case bcmFieldActionGpCosQNew:
          case bcmFieldActionGpVlanCosQNew:
          case bcmFieldActionGpPrioPktAndIntCopy:
          case bcmFieldActionGpPrioPktAndIntNew:
          case bcmFieldActionGpPrioPktAndIntTos:
          case bcmFieldActionGpPrioPktAndIntCancel:
          case bcmFieldActionGpSwitchToCpuCancel:
          case bcmFieldActionGpSwitchToCpuReinstate:
          case bcmFieldActionGpPrioIntCopy:
          case bcmFieldActionGpPrioIntNew:
          case bcmFieldActionGpPrioIntTos:
          case bcmFieldActionGpPrioIntCancel:
              *result = TRUE;
              break;
          case bcmFieldActionMultipathHash:
              *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm, ECMP_HASH_SELf);
              break;
          case bcmFieldActionIpFix:
          case bcmFieldActionIpFixCancel:
              *result = soc_feature(unit, soc_feature_ipfix) ? TRUE : FALSE;
              break;
          case bcmFieldActionOamUpMep:
          case bcmFieldActionOamTx:
          case bcmFieldActionOamLmepMdl:
          case bcmFieldActionOamServicePriMappingPtr:
          case bcmFieldActionOamLmBasePtr:
          case bcmFieldActionOamDmEnable:
          case bcmFieldActionOamLmEnable:
          case bcmFieldActionOamLmepEnable:
              *result = soc_feature(unit,
                            soc_feature_field_oam_actions) ? TRUE : FALSE;
              break;
#if defined(BCM_KATANA2_SUPPORT)
          case bcmFieldActionOamLmDmSampleEnable:
              *result = (soc_feature(unit,
                          soc_feature_field_oam_actions)
                          && ((SOC_IS_SABER2(unit)) || (SOC_IS_KATANA2(unit))))
                          ? TRUE : FALSE;
              break;
#endif
          case bcmFieldActionOamDmTimeFormat:
              *result = SOC_MEM_FIELD_VALID(unit,
                        FP_POLICY_TABLEm, OAM_DM_TYPEf);
              break;
          case bcmFieldActionOamTagStatusCheck:
              *result = SOC_MEM_FIELD_VALID(unit,
                        FP_POLICY_TABLEm, OAM_TAG_STATUS_CHECK_CONTROLf);
              break;
          case bcmFieldActionTimeStampToCpu:
          case bcmFieldActionRpTimeStampToCpu:
          case bcmFieldActionYpTimeStampToCpu:
          case bcmFieldActionGpTimeStampToCpu:
          case bcmFieldActionTimeStampToCpuCancel:
          case bcmFieldActionRpTimeStampToCpuCancel:
          case bcmFieldActionYpTimeStampToCpuCancel:
          case bcmFieldActionGpTimeStampToCpuCancel:
              *result = soc_feature(unit, soc_feature_field_action_timestamp) ? \
                        TRUE : FALSE;
              break;
          case bcmFieldActionOffloadRedirect:
          case bcmFieldActionOffloadClassSet:
          case bcmFieldActionOffloadDropIndication:
              *result = (SOC_MEM_FIELD_VALID(unit,
                            FP_POLICY_TABLEm, HI_PRI_ACTION_CONTROLf)
                            && (stage == _BCM_FIELD_STAGE_INGRESS));
              break;
          case bcmFieldActionFabricQueue:
              *result = (soc_feature(unit,
                            soc_feature_field_action_fabric_queue)
                            && (stage == _BCM_FIELD_STAGE_INGRESS))
                            ? TRUE : FALSE;
              break;

        case bcmFieldActionUcastQueueNew:
        case bcmFieldActionRpUcastQueueNew:
        case bcmFieldActionYpUcastQueueNew:
        case bcmFieldActionGpUcastQueueNew:
            *result = ((stage == _BCM_FIELD_STAGE_INGRESS) && (SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit)));
            break;
        case bcmFieldActionIntCosUcastQueueNew:
        case bcmFieldActionRpIntCosUcastQueueNew:
        case bcmFieldActionYpIntCosUcastQueueNew:
        case bcmFieldActionGpIntCosUcastQueueNew:
            *result = ((stage == _BCM_FIELD_STAGE_INGRESS) && (SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit)));
            break;

        case bcmFieldActionPortPrioIntCosQNew:
        case bcmFieldActionRpPortPrioIntCosQNew:
        case bcmFieldActionYpPortPrioIntCosQNew:
        case bcmFieldActionGpPortPrioIntCosQNew:
            *result = (soc_feature(unit,
                                   soc_feature_field_ingress_cosq_override)
                       &&  (SOC_IS_KATANA2(unit)
                            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                            || SOC_IS_TRIUMPH3(unit)));
            break;
        case bcmFieldActionServicePrioIntCosQNew:
        case bcmFieldActionRpServicePrioIntCosQNew:
        case bcmFieldActionYpServicePrioIntCosQNew:
        case bcmFieldActionGpServicePrioIntCosQNew:
            *result = (soc_feature(unit,
                                   soc_feature_field_ingress_cosq_override)
                       &&  SOC_IS_KATANA2(unit));
        break;

          case bcmFieldActionSrcMacNew:
#if defined(INCLUDE_L3)
              if ((stage == _BCM_FIELD_STAGE_INGRESS)
                  && (SOC_IS_TD_TT(unit)
                      || SOC_IS_TRIUMPH2(unit)
                      || SOC_IS_APOLLO(unit)
                      || SOC_IS_KATANAX(unit)
                      || SOC_IS_ENDURO(unit)
                      || SOC_IS_HURRICANEX(unit)
                      || SOC_IS_TRIUMPH3(unit)
                      || SOC_IS_GREYHOUND(unit)
                      || SOC_IS_GREYHOUND2(unit)
                      )
                  ) {
                  *result = (soc_feature(unit,
                                soc_feature_field_action_l2_change) &&
                             soc_feature(unit,
                                soc_feature_l3)) ? TRUE : FALSE;
              } else {
                *result = FALSE;
              }
#else /* INCLUDE_L3 */
              *result = FALSE;
#endif /* !INCLUDE_L3 */
              break;
          case bcmFieldActionDstMacNew:
          case bcmFieldActionOuterVlanNew:
#if defined(INCLUDE_L3)
              if (stage == _BCM_FIELD_STAGE_INGRESS) {
                  *result = (soc_feature(unit,
                                soc_feature_field_action_l2_change) &&
                             soc_feature(unit,
                                soc_feature_l3)) ? TRUE : FALSE;
              } else {
                  *result = FALSE;
              }
#else /* INCLUDE_L3 */
              *result = FALSE;
#endif /* !INCLUDE_L3 */
              break;
          case bcmFieldActionVnTagNew:
          case bcmFieldActionVnTagDelete:
#if defined(INCLUDE_L3)
              if (stage == _BCM_FIELD_STAGE_INGRESS) {
                  *result = (soc_feature(unit,
                                soc_feature_field_action_l2_change) &&
                             soc_feature(unit,
                                soc_feature_l3) &&
                             soc_feature(unit,
                                soc_feature_niv)) ? TRUE : FALSE;
              } else
#endif
              {
                  *result = soc_feature(unit, soc_feature_niv) ? TRUE : FALSE;
              }
              break;
          case bcmFieldActionEtagNew:
          case bcmFieldActionEtagDelete:
#if defined(INCLUDE_L3)
              if (stage == _BCM_FIELD_STAGE_INGRESS) {
                  *result = (soc_feature(unit,
                                soc_feature_field_action_l2_change) &&
                             soc_feature(unit,
                                soc_feature_l3) &&
                             soc_feature(unit,
                                soc_feature_port_extension)) ? TRUE : FALSE;
              } else
#endif
              {
                  *result = soc_feature(unit, soc_feature_port_extension) ? TRUE : FALSE;
              }
              break;
          case bcmFieldActionCnmCancel:
              *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm,
                                            DO_NOT_GENERATE_CNMf);
              break;
#if defined(BCM_TRIDENT_SUPPORT)
          case bcmFieldActionDynamicHgTrunkCancel:
              if (SOC_IS_TRIUMPH3(unit) || SOC_IS_TRIDENT(unit) ||
                  (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif
          case bcmFieldActionUcastCosQNew:
          case bcmFieldActionGpUcastCosQNew:
          case bcmFieldActionYpUcastCosQNew:
          case bcmFieldActionRpUcastCosQNew:
              *result = (soc_feature(unit, soc_feature_ets) ||
                             SOC_IS_KATANAX(unit)) ? TRUE : FALSE;
              break;
          case bcmFieldActionMcastCosQNew:
          case bcmFieldActionGpMcastCosQNew:
          case bcmFieldActionYpMcastCosQNew:
          case bcmFieldActionRpMcastCosQNew:
              *result = soc_feature(unit, soc_feature_ets) ? TRUE : FALSE;
              break;
          case bcmFieldActionServicePoolIdPrecedenceNew:
          case bcmFieldActionServicePoolIdNew:
              if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                  SOC_IS_TD_TT(unit) || SOC_IS_VALKYRIE2(unit)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionNatCancel:
          case bcmFieldActionNat:
          case bcmFieldActionNatEgressOverride:
              if (0 == soc_feature(unit, soc_feature_nat)) {
                  *result = FALSE;
              }
              else {
                  *result = TRUE;
              }
              break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined (BCM_GREYHOUND2_SUPPORT)
          case bcmFieldActionUseGlobalMeterColor:
              *result = soc_feature(unit, soc_feature_global_meter) ? TRUE : FALSE;
              break;
#endif /* BCM_KATANA_SUPPORT or BCM_TRIUMPH3_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
          case bcmFieldActionOamOlpHeaderAdd:
              if (SOC_IS_KATANA2(unit) &&
                  (soc_feature(unit, soc_feature_oam))) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionOamSessionId:
              if (SOC_IS_KATANA2(unit) &&
                  (soc_feature(unit, soc_feature_oam))) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionEgressClassSelect:
              if (SOC_IS_KATANA2(unit)) {
                   if (stage == _BCM_FIELD_STAGE_INGRESS) {
                   *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm,
                                            I2E_CLASSID_SELf) ? \
                             TRUE : FALSE;
                   }
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionHiGigClassSelect:
             if (SOC_IS_KATANA2(unit) && (stage == _BCM_FIELD_STAGE_INGRESS)) {
                  *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm,
                                                HG_CLASSID_SELf) ? \
                                                TRUE : FALSE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionNewClassId:
             if (SOC_IS_KATANA2(unit) && (stage == _BCM_FIELD_STAGE_INGRESS)) {
                  *result = SOC_MEM_FIELD_VALID(unit, FP_POLICY_TABLEm,
                                                I2E_CLASSIDf) ? \
                                                TRUE : FALSE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_KATANA2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
          case bcmFieldActionTrunkResilientHashCancel:
          case bcmFieldActionHgTrunkResilientHashCancel:
          case bcmFieldActionEcmpResilientHashCancel:
              if (SOC_IS_TD2_TT2(unit)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
          case bcmFieldActionPfcClassNew:
              if (soc_feature(unit, soc_feature_field_action_pfc_class)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionRpIntCongestionNotificationNew:
          case bcmFieldActionYpIntCongestionNotificationNew:
          case bcmFieldActionGpIntCongestionNotificationNew:
              if (soc_feature(unit, soc_feature_ecn_wred)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
          case bcmFieldActionUnmodifiedPacketRedirectPort:
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
        case bcmFieldActionRecoverableDropCancel:
            if (SOC_IS_TD2P_TT2P(unit)
                || SOC_IS_TRIUMPH3(unit)) {
                *result = (stage == _BCM_FIELD_STAGE_INGRESS);
            } else {
                *result = FALSE;
            }
            return (BCM_E_NONE);
            break;
#endif
        case bcmFieldActionChangeL2Fields:
#if defined(INCLUDE_L3)
              if (stage == _BCM_FIELD_STAGE_INGRESS) {
                  *result =
                      (soc_feature(unit, soc_feature_field_action_l2_change) &&
                       soc_feature(unit, soc_feature_nh_for_ifp_actions) &&
                       soc_feature(unit, soc_feature_l3)) ? TRUE : FALSE;
              } else {
                  *result = FALSE;
              }
#else /* INCLUDE_L3 */
              *result = FALSE;
#endif /* !INCLUDE_L3 */
              break;

#if defined(BCM_HURRICANE3_SUPPORT)
          case bcmFieldActionPfcTx:
             if ((SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) &&
                 (stage == _BCM_FIELD_STAGE_INGRESS)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionSwitchEncap:
             if (stage == _BCM_FIELD_STAGE_INGRESS) {
                  *result = (soc_feature(unit, soc_feature_miml) ||
                                 soc_feature(unit, soc_feature_custom_header)) ? TRUE : FALSE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
          case bcmFieldActionDoNotCutThrough:
              if (soc_feature(unit, soc_feature_asf) &&
                  (stage == _BCM_FIELD_STAGE_INGRESS)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
          case bcmFieldActionVxlanTerminate:
              if (soc_feature(unit, soc_feature_vxlan_lite) &&
                  (stage == _BCM_FIELD_STAGE_INGRESS)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_METROLITE_SUPPORT)
          case bcmFieldActionSwapMacDaSa:
          case bcmFieldActionSwapSourceIPDestIP:
          case bcmFieldActionReplaceTtl:
          case bcmFieldActionPacketIsL3SAT:
              if (SOC_IS_METROLITE(unit)) {
                  *result = TRUE;
              } else {
                  *result = FALSE;
              }
              break;
#endif /* BCM_METROLITE_SUPPORT */

          default:
              *result = FALSE;
        }
    }
    return (BCM_E_NONE);
}


int
_bcm_field_trx_action_support_check(int unit, _field_entry_t *f_ent,
                                    bcm_field_action_t action, int *result)
{
    /* Input parameters check */
    if ((NULL == f_ent) || (NULL == result)) {
        return (BCM_E_PARAM);
    }
    if (NULL == f_ent->group) {
        return (BCM_E_PARAM);
    }

    return (_bcm_field_trx_stage_action_support_check(unit, f_ent->group->stage_id,
                                                      action, result));
}
#if defined(BCM_TRIDENT_SUPPORT)
/*
 * Function:
 *     _bcm_field_trx_multiwide_group_action_conflict_check
 *
 * Purpose:
 *     Check if two action not conflicting in
 *     multi wide mode
 * Parameters:
 *     unit    -(IN)BCM device number
 *     f_ent   -(IN)Field entry structure.
 *     action -(IN) Action to check(bcmFieldActionXXX)
 *     action1 -(IN) Action to check(bcmFieldActionXXX)
 *
 * Returns:
 *     BCM_E_CONFIG - if actions do conflict
 *     BCM_E_NONE   - if there is no conflict
 */
int
_bcm_field_trx_multiwide_group_action_conflict_check(
                                                     int      unit,
                                                unsigned      stage,
                                           bcm_field_action_t action1,
                                           bcm_field_action_t action
                                           )
{
    int rv = BCM_E_CONFIG;

    if (stage == _BCM_FIELD_STAGE_INGRESS) {
        switch (action1) {
          case bcmFieldActionCosQCpuNew:
              if ((action == bcmFieldActionServicePoolIdNew) || (action == bcmFieldActionServicePoolIdPrecedenceNew)) {
                  rv = BCM_E_NONE;
              }
              break;
          case bcmFieldActionServicePoolIdNew:
              if ((action == bcmFieldActionCosQCpuNew) || (action != bcmFieldActionServicePoolIdPrecedenceNew)) {
                  rv = BCM_E_NONE;
              }
              break;
          case bcmFieldActionServicePoolIdPrecedenceNew:
              if ((action == bcmFieldActionCosQCpuNew) || (action != bcmFieldActionServicePoolIdNew)) {
                  rv = BCM_E_NONE;
              }
              break;
          default:
              break;
        }
    }

    return rv;
}
#endif
/*
 * Function:
 *     _bcm_field_trx_action_conflict_check
 *
 * Purpose:
 *     Check if two action conflict (occupy the same field in FP policy table)
 *
 * Parameters:
 *     unit    -(IN)BCM device number
 *     f_ent   -(IN)Field entry structure.
 *     action -(IN) Action to check(bcmFieldActionXXX)
 *     action1 -(IN) Action to check(bcmFieldActionXXX)
 *
 * Returns:
 *     BCM_E_CONFIG - if actions do conflict
 *     BCM_E_NONE   - if there is no conflict
 */
int
_bcm_field_trx_stage_action_conflict_check(int                unit,
                                           unsigned           stage,
                                           bcm_field_action_t action1,
                                           bcm_field_action_t action
                                           )
{
    /* Two identical actions are forbidden. */
    if (action1 == action) {
        if ((action != bcmFieldActionMirrorIngress) &&
            (action != bcmFieldActionMirrorEgress)) {
            return (BCM_E_CONFIG);
        }
    }

    if (stage == _BCM_FIELD_STAGE_EGRESS) {
        switch (action1) {
            case bcmFieldActionDrop:
            case bcmFieldActionDropCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
                break;
            case bcmFieldActionRpDrop:
            case bcmFieldActionRpDropCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
                break;
            case bcmFieldActionYpDrop:
            case bcmFieldActionYpDropCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
                break;
            case bcmFieldActionGpDrop:
            case bcmFieldActionGpDropCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
                break;
            case bcmFieldActionCopyToCpu:
            case bcmFieldActionCopyToCpuCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                break;
            case bcmFieldActionRpCopyToCpu:
            case bcmFieldActionRpCopyToCpuCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                break;
            case bcmFieldActionYpCopyToCpu:
            case bcmFieldActionYpCopyToCpuCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                break;
            case bcmFieldActionGpCopyToCpu:
            case bcmFieldActionGpCopyToCpuCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                break;
            case bcmFieldActionOuterVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpOuterVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpOuterVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpOuterVlanPrioNew);
                break;
            case bcmFieldActionRpOuterVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpOuterVlanPrioNew);
                break;
            case bcmFieldActionYpOuterVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpOuterVlanPrioNew);
                break;
            case bcmFieldActionGpOuterVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpOuterVlanPrioNew);
                break;
            case bcmFieldActionInnerVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpInnerVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpInnerVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpInnerVlanPrioNew);
                break;
            case bcmFieldActionRpInnerVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpInnerVlanPrioNew);
                break;
            case bcmFieldActionYpInnerVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpInnerVlanPrioNew);
                break;
            case bcmFieldActionGpInnerVlanPrioNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanPrioNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpInnerVlanPrioNew);
                break;
            case bcmFieldActionIpFix:
            case bcmFieldActionIpFixCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionIpFix);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIpFixCancel);
                break;
            case bcmFieldActionOuterVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpOuterVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpOuterVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpOuterVlanCfiNew);
                break;
            case bcmFieldActionRpOuterVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpOuterVlanCfiNew);
                break;
            case bcmFieldActionYpOuterVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpOuterVlanCfiNew);
                break;
            case bcmFieldActionGpOuterVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpOuterVlanCfiNew);
                break;
            case bcmFieldActionInnerVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpInnerVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpInnerVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpInnerVlanCfiNew);
                break;
            case bcmFieldActionRpInnerVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpInnerVlanCfiNew);
                break;
            case bcmFieldActionYpInnerVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpInnerVlanCfiNew);
                break;
            case bcmFieldActionGpInnerVlanCfiNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanCfiNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpInnerVlanCfiNew);
                break;
            case bcmFieldActionInnerVlanNew:
            case bcmFieldActionOuterVlanNew:
            case bcmFieldActionOuterTpidNew:
            case bcmFieldActionRpDscpNew:
            case bcmFieldActionYpDscpNew:
            case bcmFieldActionGpDscpNew:
                break;
            case bcmFieldActionRedirDropPrecedence:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpRedirDropPrecedence);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpRedirDropPrecedence);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpRedirDropPrecedence);
                break;
            case bcmFieldActionRpRedirDropPrecedence:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirDropPrecedence);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpRedirDropPrecedence);
                break;
            case bcmFieldActionYpRedirDropPrecedence:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirDropPrecedence);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpRedirDropPrecedence);
                break;
            case bcmFieldActionGpRedirDropPrecedence:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirDropPrecedence);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpRedirDropPrecedence);
                break;
            case bcmFieldActionLoopbackSrcModuleGportNew:
            case bcmFieldActionLoopbackSrcPortGportNew:
            case bcmFieldActionLoopbackSrcGportNew:
            case bcmFieldActionLoopbackCpuMasqueradePktProfileNew:
            case bcmFieldActionLoopbackPacketProcessingPortNew:
            case bcmFieldActionLoopBackTypeNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigIntPriNew);
                break;
            case bcmFieldActionHiGigDstModuleGportNew:
            case bcmFieldActionHiGigDstPortGportNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionHiGigDstGportNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDstPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionGpHiGigDropPrecedenceNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionYpHiGigDropPrecedenceNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionRpHiGigDropPrecedenceNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionHiGigDropPrecedenceNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigDropPrecedenceNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionGpHiGigIntPriNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionYpHiGigIntPriNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionRpHiGigIntPriNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
            case bcmFieldActionHiGigIntPriNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpHiGigIntPriNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcModuleGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcPortGportNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSrcGportNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackCpuMasqueradePktProfileNew);
                _FP_ACTIONS_CONFLICT(
                              bcmFieldActionLoopbackPacketProcessingPortNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopBackTypeNew);
                break;
#if defined(BCM_APACHE_SUPPORT)
            case bcmFieldActionRedirectPrioIntNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpRedirectPrioIntNew);
                break;
            case bcmFieldActionRpRedirectPrioIntNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpRedirectPrioIntNew);
                break;
            case bcmFieldActionYpRedirectPrioIntNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpRedirectPrioIntNew);
                break;
            case bcmFieldActionGpRedirectPrioIntNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpRedirectPrioIntNew);
                break;
#endif /* BCM_APACHE_SUPPORT */
            default:
                break;
        }
        return (BCM_E_NONE);
    }
    if (stage == _BCM_FIELD_STAGE_LOOKUP) {
        switch (action1) {
        case bcmFieldActionDrop:
        case bcmFieldActionDropCancel:
            _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
            _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
            break;
        case bcmFieldActionCopyToCpu:
        case bcmFieldActionCopyToCpuCancel:
            _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
            _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
            break;
        case bcmFieldActionInnerVlanAdd:
        case bcmFieldActionInnerVlanNew:
        case bcmFieldActionInnerVlanDelete:
#if defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit)
                                     || SOC_IS_SCORPION(unit)) {
                /* VFP_VRF_ID and NEW_INNER_VLAN fields in VFP_POLICY_TABLE are
                   overlaying bits, leading to conflicting actions */
                _FP_ACTIONS_CONFLICT(bcmFieldActionVrfSet);
            }
#endif
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanAdd);
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanDelete);
            break;
        case bcmFieldActionOuterVlanAdd:
        case bcmFieldActionOuterVlanNew:
        case bcmFieldActionOuterVlanLookup:
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanAdd);
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanLookup);
            break;
        case bcmFieldActionPrioPktNew:
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
            break;
        case bcmFieldActionPrioIntNew:
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
            break;
        case bcmFieldActionPrioPktAndIntNew:
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
            break;
        case bcmFieldActionCosQCpuNew:
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdNew);
            _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdPrecedenceNew);
            break;
        case bcmFieldActionVrfSet:
#if defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TRIUMPH(unit) || SOC_IS_VALKYRIE(unit)
                                     || SOC_IS_SCORPION(unit)) {
                /* VFP_VRF_ID and NEW_INNER_VLAN fields in VFP_POLICY_TABLE are
                   overlaying bits, leading to conflicting actions */
                _FP_ACTIONS_CONFLICT(bcmFieldActionVrfSet);
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanAdd);
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanDelete);
            }
#endif
        case bcmFieldActionDropPrecedence:
        case bcmFieldActionDoNotLearn:
        case bcmFieldActionClassDestSet:
        case bcmFieldActionClassSourceSet:
        case bcmFieldActionOamPbbteLookupEnable:
            break;
        case bcmFieldActionEnableVlanCheck:
            _FP_ACTIONS_CONFLICT(bcmFieldActionEnableVlanCheck);
            _FP_ACTIONS_CONFLICT(bcmFieldActionDoNotCheckVlan);
            break;
        case bcmFieldActionDoNotCheckVlan:
            _FP_ACTIONS_CONFLICT(bcmFieldActionEnableVlanCheck);
          /*
           * coverity[fallthrough]
           * This is intentional as the rest of the statements should be
           * executed for this case also
           */
        case bcmFieldActionIncomingMplsPortSet:
        case bcmFieldActionIngressGportSet:
        case bcmFieldActionL3IngressSet:
            _FP_ACTIONS_CONFLICT(bcmFieldActionDoNotCheckVlan);
            _FP_ACTIONS_CONFLICT(bcmFieldActionIncomingMplsPortSet);
            _FP_ACTIONS_CONFLICT(bcmFieldActionIngressGportSet);
            _FP_ACTIONS_CONFLICT(bcmFieldActionL3IngressSet);
            break;
        case bcmFieldActionOuterVlanCopyInner:
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanCopyOuter);
            break;
        case bcmFieldActionOuterVlanPrioCopyInner:
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanPrioCopyOuter);
            break;
        case bcmFieldActionOuterVlanCfiCopyInner:
            _FP_ACTIONS_CONFLICT(bcmFieldActionInnerVlanCfiCopyOuter);
            break;
        case bcmFieldActionInnerVlanCopyOuter:
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanCopyInner);
            break;
        case bcmFieldActionInnerVlanPrioCopyOuter:
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanPrioCopyInner);
            break;
        case bcmFieldActionInnerVlanCfiCopyOuter:
            _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanCfiCopyInner);
            break;
        default:
            break;
        }
        return (BCM_E_NONE);
    }

    if ((stage == _BCM_FIELD_STAGE_INGRESS) ||
        (stage == _BCM_FIELD_STAGE_EXTERNAL)) {
        switch (action1) {

          case bcmFieldActionCopyToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              }
              break;
          case bcmFieldActionSwitchToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionCopyToCpu:
          case bcmFieldActionSwitchToCpuReinstate:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              break;
          case bcmFieldActionRpCopyToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              }
              break;
          case bcmFieldActionRpSwitchToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionRpCopyToCpu:
          case bcmFieldActionRpSwitchToCpuReinstate:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              break;
          case bcmFieldActionYpCopyToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              }
              break;
          case bcmFieldActionYpSwitchToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionYpCopyToCpu:
          case bcmFieldActionYpSwitchToCpuReinstate:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              break;
          case bcmFieldActionGpCopyToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              }
              break;
          case bcmFieldActionGpSwitchToCpuCancel:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit) ||
                  SOC_IS_KATANA2(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              } else
#endif
              {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionGpCopyToCpu:
          case bcmFieldActionGpSwitchToCpuReinstate:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              break;
          case bcmFieldActionDrop:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionDropCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              }
              break;
          case bcmFieldActionRpDrop:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionRpDropCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              }
              break;
          case bcmFieldActionYpDrop:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionYpDropCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              }
              break;
          case bcmFieldActionGpDrop:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              }
              break;
          case bcmFieldActionGpDropCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              }
              break;
          case bcmFieldActionL3ChangeVlan:
          case bcmFieldActionL3ChangeVlanCancel:
          case bcmFieldActionL3ChangeMacDa:
          case bcmFieldActionL3ChangeMacDaCancel:
          case bcmFieldActionFabricQueue:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionAddClassTag:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionL3SwitchCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionL3Switch:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionOuterVlanNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionVnTagDelete:
          case bcmFieldActionVnTagNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionEtagDelete:
          case bcmFieldActionEtagNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined (BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionSrcMacNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionDstMacNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined (BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionNewClassId:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionEgressClassSelect:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;
          case bcmFieldActionHiGigClassSelect:
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              break;
          case bcmFieldActionRedirect:
          case bcmFieldActionRedirectTrunk:
          case bcmFieldActionRedirectPbmp:
          case bcmFieldActionRedirectMcast:
          case bcmFieldActionRedirectVlan:
          case bcmFieldActionRedirectBcastPbmp:
          case bcmFieldActionOffloadRedirect:
          case bcmFieldActionEgressMask:
          case bcmFieldActionEgressPortsAdd:
          case bcmFieldActionUnmodifiedPacketRedirectPort:
              _FP_ACTIONS_CONFLICT(bcmFieldActionOffloadRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              break;
          case bcmFieldActionRedirectCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionOffloadRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              break;
          case bcmFieldActionRedirectEgrNextHop:
          case bcmFieldActionRedirectIpmc:
              _FP_ACTIONS_CONFLICT(bcmFieldActionOffloadRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              break;
          case bcmFieldActionReplaceSrcMac:
          case bcmFieldActionReplaceDstMac:
          case bcmFieldActionReplaceInnerVlan:
          case bcmFieldActionReplaceOuterVlan:
          case bcmFieldActionReplaceInnerVlanPriority:
          case bcmFieldActionReplaceOuterVlanPriority:
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
             }
#endif
              break;
          case bcmFieldActionPrioPktCopy:
          case bcmFieldActionPrioPktNew:
          case bcmFieldActionPrioPktTos:
          case bcmFieldActionPrioPktCancel:
          case bcmFieldActionDot1pPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDot1pPreserve);
              break;
          case bcmFieldActionPrioPktAndIntCopy:
          case bcmFieldActionPrioPktAndIntNew:
          case bcmFieldActionPrioPktAndIntTos:
          case bcmFieldActionPrioPktAndIntCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionUcastQueueNew:
          case bcmFieldActionIntCosUcastQueueNew:
          case bcmFieldActionPrioIntNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
          /*
           * coverity[fallthrough]
           * This is intentional as the rest of the statements should be
           * executed for this case also
           */
          case bcmFieldActionPrioIntCopy:
          case bcmFieldActionPrioIntTos:
          case bcmFieldActionPrioIntCancel:
          case bcmFieldActionVlanCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionUcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionMcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionRpPrioPktCopy:
          case bcmFieldActionRpPrioPktNew:
          case bcmFieldActionRpPrioPktTos:
          case bcmFieldActionRpPrioPktCancel:
          case bcmFieldActionRpDot1pPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDot1pPreserve);
              break;
          case bcmFieldActionRpPrioPktAndIntCopy:
          case bcmFieldActionRpPrioPktAndIntNew:
          case bcmFieldActionRpPrioPktAndIntTos:
          case bcmFieldActionRpPrioPktAndIntCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              break;
          case bcmFieldActionRpPrioIntCopy:
          case bcmFieldActionRpUcastQueueNew:
          case bcmFieldActionRpIntCosUcastQueueNew:
          case bcmFieldActionRpPrioIntNew:
          case bcmFieldActionRpPrioIntTos:
          case bcmFieldActionRpPrioIntCancel:
          case bcmFieldActionRpCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              break;
          case bcmFieldActionRpUcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              break;
          case bcmFieldActionRpMcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              break;
          case bcmFieldActionYpPrioPktCopy:
          case bcmFieldActionYpPrioPktNew:
          case bcmFieldActionYpPrioPktTos:
          case bcmFieldActionYpPrioPktCancel:
          case bcmFieldActionYpDot1pPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDot1pPreserve);
              break;
          case bcmFieldActionYpPrioPktAndIntCopy:
          case bcmFieldActionYpPrioPktAndIntNew:
          case bcmFieldActionYpPrioPktAndIntTos:
          case bcmFieldActionYpPrioPktAndIntCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              break;
          case bcmFieldActionYpPrioIntCopy:
          case bcmFieldActionYpUcastQueueNew:
          case bcmFieldActionYpIntCosUcastQueueNew:
          case bcmFieldActionYpPrioIntNew:
          case bcmFieldActionYpPrioIntTos:
          case bcmFieldActionYpPrioIntCancel:
          case bcmFieldActionYpCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              break;
          case bcmFieldActionYpUcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              break;
          case bcmFieldActionYpMcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpPrioPktCopy:
          case bcmFieldActionGpPrioPktNew:
          case bcmFieldActionGpPrioPktTos:
          case bcmFieldActionGpPrioPktCancel:
          case bcmFieldActionGpDot1pPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDot1pPreserve);
              break;
          case bcmFieldActionGpPrioPktAndIntCopy:
          case bcmFieldActionGpPrioPktAndIntNew:
          case bcmFieldActionGpPrioPktAndIntTos:
          case bcmFieldActionGpPrioPktAndIntCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDot1pPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpPrioIntCopy:
          case bcmFieldActionGpUcastQueueNew:
          case bcmFieldActionGpIntCosUcastQueueNew:
          case bcmFieldActionGpPrioIntNew:
          case bcmFieldActionGpPrioIntTos:
          case bcmFieldActionGpPrioIntCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpUcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpMcastCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionDropPrecedence:
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropPrecedence);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropPrecedence);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropPrecedence);
              break;
          case bcmFieldActionRpDropPrecedence:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropPrecedence);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropPrecedence);
              break;
          case bcmFieldActionYpDropPrecedence:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropPrecedence);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropPrecedence);
              break;
          case bcmFieldActionGpDropPrecedence:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDropPrecedence);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropPrecedence);
              break;
          case bcmFieldActionTimeStampToCpu:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              }
              break;
          case bcmFieldActionTimeStampToCpuCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              }
              break;
          case bcmFieldActionRpTimeStampToCpu:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpDropCancel);
              }
              break;
          case bcmFieldActionRpTimeStampToCpuCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionRpDrop);
              }
              break;
          case bcmFieldActionYpTimeStampToCpu:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpDropCancel);
              }
              break;
          case bcmFieldActionYpTimeStampToCpuCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionYpDrop);
              }
              break;
          case bcmFieldActionGpTimeStampToCpu:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDropCancel);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpDropCancel);
              }
              break;
          case bcmFieldActionGpTimeStampToCpuCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTimeStampToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuReinstate);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCopyToCpu);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpSwitchToCpuReinstate);
              if (!soc_feature(unit, soc_feature_ifp_timestamptocpu_optimized)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionDrop);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionGpDrop);
              }
              break;
          case bcmFieldActionIpFix:
          case bcmFieldActionIpFixCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionIpFix);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIpFixCancel);
              break;
          case bcmFieldActionDscpNew:
          case bcmFieldActionDscpCancel:
          case bcmFieldActionOamSessionId:
          case bcmFieldActionDscpPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTosPrecedenceNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTosPrecedenceCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOamSessionId);
              break;
          case bcmFieldActionRpDscpNew:
          case bcmFieldActionRpDscpCancel:
          case bcmFieldActionRpDscpPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOamSessionId);
              break;
          case bcmFieldActionYpDscpNew:
          case bcmFieldActionYpDscpCancel:
          case bcmFieldActionYpDscpPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOamSessionId);
              break;
          case bcmFieldActionGpDscpNew:
          case bcmFieldActionGpDscpCancel:
          case bcmFieldActionGpTosPrecedenceNew:
          case bcmFieldActionGpTosPrecedenceCopy:
          case bcmFieldActionGpDscpPreserve:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTosPrecedenceNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpTosPrecedenceCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpDscpPreserve);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOamSessionId);
              break;
          case bcmFieldActionEcnNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpEcnNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpEcnNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpEcnNew);
              break;
          case bcmFieldActionRpEcnNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionEcnNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpEcnNew);
              break;
          case bcmFieldActionYpEcnNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionEcnNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpEcnNew);
              break;
          case bcmFieldActionGpEcnNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionEcnNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpEcnNew);
              break;
          case bcmFieldActionMirrorIngress:
              _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorOverride);
              break;
          case bcmFieldActionMirrorEgress:
              _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorOverride);
              break;
          case bcmFieldActionMirrorOverride:
              _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorIngress);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
              break;
          case bcmFieldActionPortPrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionRpPortPrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpServicePrioIntCosQNew);
              break;
          case bcmFieldActionYpPortPrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpServicePrioIntCosQNew);
              break;
          case bcmFieldActionGpPortPrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpServicePrioIntCosQNew);
              break;
          case bcmFieldActionServicePrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              break;
          case bcmFieldActionRpServicePrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRpPortPrioIntCosQNew);
              break;
          case bcmFieldActionYpServicePrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionYpPortPrioIntCosQNew);
              break;
          case bcmFieldActionGpServicePrioIntCosQNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpVlanCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCopy);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntTos);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioPktAndIntCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCosUcastQueueNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionPortPrioIntCosQNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionGpPortPrioIntCosQNew);
              break;
          case bcmFieldActionColorIndependent:
              _FP_ACTIONS_CONFLICT(bcmFieldActionColorIndependent);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOffloadRedirect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
              _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
             break;
          case bcmFieldActionDynamicHgTrunkCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTrunkLoadBalanceCancel);
             break;
          case bcmFieldActionTrunkLoadBalanceCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicHgTrunkCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionTrunkResilientHashCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHgTrunkResilientHashCancel);
              break;
          case bcmFieldActionHgTrunkResilientHashCancel:
          case bcmFieldActionTrunkResilientHashCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionTrunkLoadBalanceCancel);
             break;
          case bcmFieldActionCosQCpuNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdPrecedenceNew);
              break;
          case bcmFieldActionServicePoolIdNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdPrecedenceNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdNew);
              break;
          case bcmFieldActionServicePoolIdPrecedenceNew:
              _FP_ACTIONS_CONFLICT(bcmFieldActionCosQCpuNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionServicePoolIdPrecedenceNew);
              break;
          case bcmFieldActionNatCancel:
              _FP_ACTIONS_CONFLICT(bcmFieldActionNatCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNat);
              break;
          case bcmFieldActionNat:
              _FP_ACTIONS_CONFLICT(bcmFieldActionNatCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNat);
              break;
          case bcmFieldActionMultipathHash:
              _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              break;
          case bcmFieldActionDoNotChangeTtl:
          case bcmFieldActionDoNotCheckUrpf:
          case bcmFieldActionOamUpMep:
          case bcmFieldActionOamTx:
          case bcmFieldActionOamLmepMdl:
          case bcmFieldActionOamServicePriMappingPtr:
          case bcmFieldActionOamLmBasePtr:
          case bcmFieldActionOamDmEnable:
          case bcmFieldActionOamLmEnable:
          case bcmFieldActionOamLmepEnable:
          case bcmFieldActionOffloadClassSet:
          case bcmFieldActionOffloadDropIndication:
          case bcmFieldActionCnmCancel:
              break;
          case bcmFieldActionChangeL2Fields:
              _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
              _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
              _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
              _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
              _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
              _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
              _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigClassSelect);
              _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
#if defined(BCM_TRIUMPH3_SUPPORT)
              if (SOC_IS_TRIUMPH3(unit)) {
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceSrcMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceDstMac);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlan);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceInnerVlanPriority);
                  _FP_ACTIONS_CONFLICT(bcmFieldActionReplaceOuterVlanPriority);
              }
#endif
              break;

          default:
              break;
        }
    }
    return (BCM_E_NONE);
}


int
_bcm_field_trx_action_conflict_check(int                unit,
                                     _field_entry_t     *f_ent,
                                     bcm_field_action_t action1,
                                     bcm_field_action_t action
                                     )
{
    /* Input parameters check */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }
    if (NULL == f_ent->group) {
        return (BCM_E_PARAM);
    }
#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit)) {
        /* Allow action install in secondary/ternary parts for default
           action resolution id groups */
        if (((f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) ||
            (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) &&
            (f_ent->group->action_res_id == BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT)){
            if (BCM_E_NONE ==
                _bcm_field_trx_multiwide_group_action_conflict_check(unit,
                                  f_ent->group->stage_id, action1, action)) {
                return BCM_E_NONE;
            }
        }
    }
#endif
    return (_bcm_field_trx_stage_action_conflict_check(unit, f_ent->group->stage_id, action1, action));
}

/*
 * Function:
 *     _bcm_field_trx_egress_key_match_type_set
 *
 * Purpose:
 *     Set key match type based on entry group.
 *     NOTE: For double wide entries key type must be the same for
 *           both parts of the entry.
 * Parameters:
 *     unit   - (IN) BCM device number
 *     f_ent  - (IN) Slice number to enable
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_egress_key_match_type_set (int unit, _field_entry_t *f_ent)
{
    _field_group_t           *fg;   /* Field group entry belongs to. */
    uint32                   data;  /* Key match type.               */
    uint32                   mask;  /* Key match type mask.          */
    uint32                   default_data;  /* Key match type.       */
    int                      rv;      /* Operation return status.    */

    /* Key match type offset.        */
    _bcm_field_qual_offset_t q_offset;
    {
       sal_memset(&q_offset, 0, sizeof(q_offset));
       q_offset.field = KEYf;
       q_offset.num_offsets = 1;
       q_offset.offset[0] = 207;
       q_offset.width[0] = 3;
    }

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }
    if (NULL == (fg = f_ent->group)) {
        return (BCM_E_PARAM);
    }

    if (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        switch (fg->sel_codes[0].fpf3) {
          case _BCM_FIELD_EFP_KEY1:
              data = _BCM_FIELD_EFP_KEY1_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
          case _BCM_FIELD_EFP_KEY2:
              data = _BCM_FIELD_EFP_KEY2_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
          case _BCM_FIELD_EFP_KEY4:
              data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
          case _BCM_FIELD_EFP_KEY1_NO_V4:
              data = _BCM_FIELD_EFP_KEY1_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
#if defined(BCM_APACHE_SUPPORT)
          case _BCM_FIELD_EFP_KEY5:
              data = _BCM_FIELD_EFP_KEY5_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
          case _BCM_FIELD_EFP_KEY6:
              data = _BCM_FIELD_EFP_KEY6_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY4_MATCH_TYPE;
              break;
#endif
          default:
              return (BCM_E_INTERNAL);
        }
    } else {
        switch (fg->sel_codes[1].fpf3) {
          case _BCM_FIELD_EFP_KEY2:
              data = _BCM_FIELD_EFP_KEY2_KEY3_MATCH_TYPE;
              default_data = _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE;
              break;
          case _BCM_FIELD_EFP_KEY4:
              if ((_BCM_FIELD_EFP_KEY1 == fg->sel_codes[0].fpf3) ||
                  (_BCM_FIELD_EFP_KEY1_NO_V4 == fg->sel_codes[0].fpf3)) {
                  data = _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE;
              }
#if defined(BCM_APACHE_SUPPORT)
              else if (_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3) {
                  data = _BCM_FIELD_EFP_KEY5_KEY4_MATCH_TYPE;
              }
#endif
              else {
                  data = _BCM_FIELD_EFP_KEY2_KEY4_MATCH_TYPE;
              }
              default_data = _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE;
              break;
          default:
              return (BCM_E_INTERNAL);
        }
    }

    if (SOC_IS_TD2_TT2(unit)) {
        q_offset.offset[0] += 23;
        q_offset.width[0] += 1;
    } else if (SOC_IS_GREYHOUND2(unit)) {
        q_offset.offset[0] += 7;
    }
    else if (SOC_IS_TR_VL(unit)) {
        q_offset.offset[0] += 4;
    }

    if (SOC_IS_TD2_TT2(unit)) {
        mask = 0xf;
    }
    else {
        mask = 0x7;
    }

    /*
     * COVERITY
     *
     * This flow takes care of the  Out-of-bounds access issue
     * for data and mask.
     */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set_by_entry_type(unit, &q_offset, f_ent,
                                            &data, &mask, _FP_ENTRY_TYPE_0);
    if (SOC_IS_TD2_TT2(unit)) {
        if (BCM_SUCCESS(rv)) {
            /*
             * COVERITY
             *
             *This flow takes care of the  Out-of-bounds access issue
             * for data and mask.
             */
            /* coverity[callee_ptr_arith : FALSE] */
            rv = _bcm_field_qual_value_set_by_entry_type(unit, &q_offset, f_ent,
                                                    &default_data, &mask,
                                                    _FP_ENTRY_TYPE_1);
        }
    }
    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_qualify_ip_type
 * Purpose:
 *     Install ip type qualifier into TCAM
 * Parameters:
 *     unit  - (IN) BCM device number
 *     entry - (IN) Field entry Index.
 *     type  - (IN) Ip Type.
 *     qual  - (IN) Qualifier(IpType/InnerIpType)
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_bcm_field_trx_qualify_ip_type(int unit, bcm_field_entry_t entry,
                               bcm_field_IpType_t type,
                               bcm_field_qualify_t qual)
{
    uint32              data = 0x0,
                        mask = 0x0;

    switch (type) {
      case bcmFieldIpTypeAny:
          data = 0x0;
          mask = 0x0;
          break;
      case bcmFieldIpTypeNonIp:
          data = 0xf;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIp:
          data = 0x0;
          mask = 0x8;
          break;
          break;
      case bcmFieldIpTypeIpv4NoOpts:
          data = 0x0;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIpv4WithOpts:
          data = 0x1;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIpv4Any:
          data = 0x0;
          mask = 0xe;
          break;
      case bcmFieldIpTypeIpv6NoExtHdr:
          data = 0x4;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIpv6OneExtHdr:
          data = 0x5;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIpv6TwoExtHdr:
          data = 0x6;
          mask = 0xf;
          break;
      case bcmFieldIpTypeIpv6:
          data = 0x4;
          mask = 0xc;
          break;
      case bcmFieldIpTypeArp:
          data = 0x8;
          mask = 0xe;
          break;
      case bcmFieldIpTypeArpRequest:
          data = 0x8;
          mask = 0xf;
          break;
      case bcmFieldIpTypeArpReply:
          data = 0x9;
          mask = 0xf;
          break;
      case bcmFieldIpTypeTrill:
          data = 0xa;
          mask = 0xf;
          break;
      case bcmFieldIpTypeMplsUnicast:
          data = 0xc;
          mask = 0xf;
          break;
      case bcmFieldIpTypeMplsMulticast:
          data = 0xd;
          mask = 0xf;
          break;
      case bcmFieldIpTypeMim:
          data = 0xe;
          mask = 0xf;
          break;
      default:
          return (BCM_E_UNAVAIL);
          break;
    }
    LOG_DEBUG(BSL_LS_BCM_FP,
             (BSL_META_U(unit,
              "FP(unit %d) qualifying on Iptype, data=%#x, mask=%#x\n))"),
               unit, data, mask));

    return _field_qualify32(unit, entry, qual,
                            data, mask);
}

/*
 * Function:
 *     _bcm_field_trx_qualify_ip_type_get
 * Purpose:
 *     Read ip type qualifier match criteria from the HW.
 * Parameters:
 *     unit  - (IN) BCM device number
 *     entry - (IN) Field entry index
 *     type  - (OUT) Ip Type.
 *     qual  - (IN) Qualifier(IpType/InnerIpType)
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_bcm_field_trx_qualify_ip_type_get(int unit, bcm_field_entry_t entry,
                              bcm_field_IpType_t *type,
                              bcm_field_qualify_t qual)
{
    uint32 hw_data;          /* HW encoded qualifier data.  */
    uint32 hw_mask;          /* HW encoding qualifier mask. */
    int rv;                  /* Operation return status.    */

    /* Input parameters checks. */
    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               qual,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    /* Read IpType encoding for qualifier data and mask */
    rv = _bcm_field_trx_qualify_ip_type_encode_get(unit, hw_data,
                                                   hw_mask, type);
    return rv;

}
/*
 * Function:
 *     _bcm_field_trx_qualify_ip_type_encode_get
 * Purpose:
 *     Get ip type qualifier encode value for given data and mask.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     data     - (IN) qualifier data.
 *     mask     - (IN) qualifier mask.
 *     type     - (OUT) Ip Type.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_bcm_field_trx_qualify_ip_type_encode_get(int unit,
                                          uint32 hw_data,
                                          uint32 hw_mask,
                                          bcm_field_IpType_t *type)
{

    if ((0 == hw_data) && (0 == hw_mask)) {
        *type = bcmFieldIpTypeAny;
    } else if ((0xf == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeNonIp;
    } else if ((0x0 == hw_data) && (0x8 == hw_mask)) {
        *type = bcmFieldIpTypeIp;
    } else if ((0x0 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeIpv4NoOpts;
    } else if ((0x1 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeIpv4WithOpts;
    } else if ((0x0 == hw_data) && (0xe == hw_mask)) {
        *type = bcmFieldIpTypeIpv4Any;
    } else if ((0x4 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeIpv6NoExtHdr;
    } else if ((0x5 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeIpv6OneExtHdr;
    } else if ((0x6 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeIpv6TwoExtHdr;
    } else if ((0x4 == hw_data) && (0xc == hw_mask)) {
        *type = bcmFieldIpTypeIpv6;
    } else if ((0x8 == hw_data) && (0xe == hw_mask)) {
        *type = bcmFieldIpTypeArp;
    } else if ((0x8 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeArpRequest;
    } else if ((0x9 == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeArpReply;
    } else if ((0xa == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeTrill;
    } else if ((0xc == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeMplsUnicast;
    } else if ((0xd == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeMplsMulticast;
    } else if ((0xe == hw_data) && (0xf == hw_mask)) {
        *type = bcmFieldIpTypeMim;
    } else
    {
        return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_range_check_set
 * Purpose:
 *     Write the group's range checking parameters into the
 *     FP_RANGE_CHECK  memory.
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     range  - (IN) Range HW index
 *     flags  - (IN) One of more of the BCM_FIELD_RANGE_* flags
 *     enable - (IN) TRUE or FALSE
 *     min    - (IN) Lower bounds of port range to be checked
 *     max    - (IN) Upper bounds of port range to be checked
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_range_check_set(int unit, int range, uint32 flags, int enable,
                               bcm_l4_port_t min, bcm_l4_port_t max)
{
                            /* Range table entry buffer. */
    uint32                  tbl_entry[SOC_MAX_MEM_FIELD_WORDS];

    soc_mem_t               fp_range_check_mem;     /* Range table memory. */
    uint32                  range_type_encoded = 0; /* Range type encoded. */
    uint32                  range_type = 0;         /* Range type.         */

#if defined(BCM_TRIUMPH_SUPPORT)
    if (flags & BCM_FIELD_RANGE_EXTERNAL) {
        fp_range_check_mem = ESM_RANGE_CHECKm;
    } else
#endif /* BCM_TRIUMPH_SUPPORT */
    {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            fp_range_check_mem = IFP_RANGE_CHECKm;
        } else
#endif
        {
           fp_range_check_mem = FP_RANGE_CHECKm;
        }
    }

    /* Index sanity check. */
    if (!soc_mem_index_valid(unit, fp_range_check_mem, range)) {
        return (BCM_E_PARAM);
    }

    if (enable) {
        range_type = flags & (BCM_FIELD_RANGE_SRCPORT |    \
                              BCM_FIELD_RANGE_DSTPORT |    \
                              BCM_FIELD_RANGE_OUTER_VLAN | \
                              BCM_FIELD_RANGE_PACKET_LENGTH);
        switch (range_type) {
          case BCM_FIELD_RANGE_SRCPORT:
              range_type_encoded = 0x0;
              break;
          case BCM_FIELD_RANGE_DSTPORT:
              range_type_encoded = 0x1;
              break;
          case BCM_FIELD_RANGE_OUTER_VLAN:
              range_type_encoded = 0x2;
              break;
          case BCM_FIELD_RANGE_PACKET_LENGTH:
              range_type_encoded = 0x3;
              break;
          default:
              LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: unsupported flags %#x\n"),
                         unit, flags));
              return (BCM_E_PARAM);
        }
    }

    /* read/modify/write range check memory */
    sal_memset(tbl_entry, 0, SOC_MAX_MEM_FIELD_WORDS * sizeof(uint32));

    /* Set source/destination port selection. */
    soc_mem_field_set(unit, fp_range_check_mem, tbl_entry,
                      FIELD_SELECTf, &range_type_encoded);

    if (SOC_MEM_FIELD_VALID(unit, fp_range_check_mem, ENABLEf)) {
        soc_mem_field_set(unit, fp_range_check_mem, tbl_entry,
                          ENABLEf, (uint32 *) &enable);
    }

    /* Set range min value. */
    soc_mem_field_set(unit, fp_range_check_mem, tbl_entry,
                      LOWER_BOUNDSf, (uint32 *) &min);

    /* Set range max value. */
    soc_mem_field_set(unit, fp_range_check_mem, tbl_entry,
                      UPPER_BOUNDSf, (uint32 *) &max);

    /* Write entry back to hw. */
    BCM_IF_ERROR_RETURN(soc_mem_write(unit, fp_range_check_mem,
                                      MEM_BLOCK_ALL, range, tbl_entry));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_udf_index_to_flags
 * Purpose:
 *     Translate the FP_UDF_OFFSETm  table index to API flags.
 * Parameters:
 *     tbl_idx - (IN) Index into FP_UDF_OFFSET table
 *     flags   - (OUT) Client specified flags.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
_bcm_field_trx_udf_index_to_flags(int unit, uint32 tbl_idx, int *flags)
{
    int                 index;

    /* Input parameters check. */
    if (NULL == flags) {
        return (BCM_E_PARAM);
    }

    if (SOC_IS_TR_VL(unit)) {
        index = tbl_idx & 0x1f;
    } else if  (SOC_IS_SC_CQ(unit)) {
        index = tbl_idx & 0xf;
    } else {
        index = tbl_idx & 0x1f; /* TRX */
    }

    switch (index) {
      case 0x0:
          *flags |= _BCM_FIELD_USER_IP4_HDR_ONLY;
          break;
      case 0x1:
          *flags |= _BCM_FIELD_USER_IP6_HDR_ONLY;
          break;
      case 0x2:
          *flags |= _BCM_FIELD_USER_IP4_OVER_IP4;
          break;
      case 0x3:
          *flags |= _BCM_FIELD_USER_IP6_OVER_IP4;
          break;
      case 0x4:
          *flags |= _BCM_FIELD_USER_IP4_OVER_IP6;
          break;
      case 0x5:
          *flags |= _BCM_FIELD_USER_IP6_OVER_IP6;
          break;
      case 0x6:
          *flags |= _BCM_FIELD_USER_GRE_IP4_OVER_IP4;
          break;
      case 0x7:
          *flags |= _BCM_FIELD_USER_GRE_IP6_OVER_IP4;
          break;
      case 0x8:
          *flags |= _BCM_FIELD_USER_GRE_IP4_OVER_IP6;
          break;
      case 0x9:
          *flags |= _BCM_FIELD_USER_GRE_IP6_OVER_IP6;
          break;
      case 0xa:
          if (SOC_IS_SC_CQ(unit)) {
              *flags |= _BCM_FIELD_USER_IP_NOTUSED;
          } else {
              *flags |= _BCM_FIELD_USER_ONE_MPLS_LABEL;
          }
          break;
      case 0xb:
          if (SOC_IS_SC_CQ(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP4_PROTOCOL0 */
          } else {
              *flags |= _BCM_FIELD_USER_TWO_MPLS_LABELS;
          }
          break;
      case 0xc:
          if (SOC_IS_SC_CQ(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP4_PROTOCOL1 */
          } else {
              *flags |= _BCM_FIELD_USER_IP_NOTUSED;
          }
          break;
      case 0xd:
          if (SOC_IS_SC_CQ(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP6_PROTOCOL0 */
          } else {
                /* _BCM_FIELD_DATA_FORMAT_IP4_PROTOCOL0 */
          }
      case 0xe:
          if (SOC_IS_SC_CQ(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP6_PROTOCOL1 */
          } else {
                /* _BCM_FIELD_DATA_FORMAT_IP4_PROTOCOL1 */
          }
      case 0xf:
          if (SOC_IS_TR_VL(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP6_PROTOCOL0 */
          }
      case 0x10:
          if (SOC_IS_TR_VL(unit)) {
                /* _BCM_FIELD_DATA_FORMAT_IP6_PROTOCOL0 */
          }
      default:
          return (BCM_E_INTERNAL);
    }

    index = (tbl_idx >> (SOC_IS_SC_CQ(unit) ?  4 : 5)) & 0x3;
    switch (index) {
      case 0x0:
          *flags |= _BCM_FIELD_USER_L2_ETHERNET2;
          break;
      case 0x1:
          *flags |= _BCM_FIELD_USER_L2_SNAP;
          break;
      case 0x2:
          *flags |= _BCM_FIELD_USER_L2_LLC;
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    index =  (tbl_idx >> (SOC_IS_SC_CQ(unit) ?  6 : 7));
    switch (index) {
      case 0x0:
          *flags |= _BCM_FIELD_USER_VLAN_NOTAG;
          break;
      case 0x1:
          *flags |= _BCM_FIELD_USER_VLAN_ONETAG;
          break;
      case 0x2:
          *flags |= _BCM_FIELD_USER_VLAN_TWOTAG;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

int
_bcm_field_trx_control_arp_set(int unit,  bcm_field_control_t control, uint32 state)
{
    uint64 regval;
    uint32 enable;

    BCM_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &regval));

    enable = soc_reg64_field32_get(unit, ING_CONFIG_64r,
                                   regval, ARP_RARP_TO_FPf);

    switch (control) {
      case bcmFieldControlArpAsIp:
          if (state) {
              enable |= (0x1);
          } else {
              enable &= ~(0x1);
          }
          break;
      case bcmFieldControlRarpAsIp:
          if (state) {
              enable |= (0x2);
          } else {
              enable &= ~(0x2);
          }
          break;
      default:
          return (BCM_E_UNAVAIL);
    }

    soc_reg64_field32_set(unit, ING_CONFIG_64r, &regval, ARP_RARP_TO_FPf, enable);
    BCM_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, regval));
    return (BCM_E_NONE);
}

/*
 * Function:
 *   _bcm_field_trx_stat_hw_mode_to_bmap
 *
 * Description:
 *      HW counter mode to statistics bitmap.
 * Parameters:
 *      unit           - (IN) BCM device number.
 *      mode           - (IN) HW counter mode.
 *      stage_id       - (IN) Stage id.
 *      hw_bmap        - (OUT) Statistics bitmap.
 *      hw_entry_count - (OUT) Number of counters required.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx_stat_hw_mode_to_bmap(int unit, uint16 mode,
                                    _field_stage_id_t stage_id,
                                    uint32 *hw_bmap, uint8 *hw_entry_count)
{
    uint32 value = 0;
    /* Input parameters check. */
    if ((NULL == hw_bmap) || (NULL == hw_entry_count)) {
        return (BCM_E_PARAM);
    }
    switch (mode) {
      case 1:
          value |= (1 << (int)bcmFieldStatPackets);
          value |= (1 << (int)bcmFieldStatBytes);
          *hw_entry_count = 1;
          break;
      case 2:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatGreenBytes);
              value |= (1 << (int)bcmFieldStatGreenPackets);
          } else {
              value |= (1 << (int)bcmFieldStatPackets);
              value |= (1 << (int)bcmFieldStatBytes);
          }
          *hw_entry_count = 1;
          break;
      case 3:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatYellowBytes);
              value |= (1 << (int)bcmFieldStatYellowPackets);
              *hw_entry_count = 1;
          } else {
              value |= (1 << (int)bcmFieldStatRedBytes);
              value |= (1 << (int)bcmFieldStatRedPackets);
              value |= (1 << (int)bcmFieldStatNotRedBytes);
              value |= (1 << (int)bcmFieldStatNotRedPackets);
              *hw_entry_count = 2;
          }
          break;
      case 4:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatRedBytes);
              value |= (1 << (int)bcmFieldStatRedPackets);
              *hw_entry_count = 1;
          } else {
              value |= (1 << (int)bcmFieldStatGreenBytes);
              value |= (1 << (int)bcmFieldStatGreenPackets);
              value |= (1 << (int)bcmFieldStatNotGreenBytes);
              value |= (1 << (int)bcmFieldStatNotGreenPackets);
              *hw_entry_count = 2;
          }
          break;
      case 5:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatNotGreenBytes);
              value |= (1 << (int)bcmFieldStatNotGreenPackets);
              *hw_entry_count = 1;
          } else {
              value |= (1 << (int)bcmFieldStatGreenBytes);
              value |= (1 << (int)bcmFieldStatGreenPackets);
              value |= (1 << (int)bcmFieldStatRedBytes);
              value |= (1 << (int)bcmFieldStatRedPackets);
              value |= (1 << (int)bcmFieldStatNotYellowBytes);
              value |= (1 << (int)bcmFieldStatNotYellowPackets);
              *hw_entry_count = 2;
          }
          break;
      case 6:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatNotYellowBytes);
              value |= (1 << (int)bcmFieldStatNotYellowPackets);
              *hw_entry_count = 1;
          } else {
              value |= (1 << (int)bcmFieldStatGreenBytes);
              value |= (1 << (int)bcmFieldStatGreenPackets);
              value |= (1 << (int)bcmFieldStatYellowBytes);
              value |= (1 << (int)bcmFieldStatYellowPackets);
              value |= (1 << (int)bcmFieldStatNotRedBytes);
              value |= (1 << (int)bcmFieldStatNotRedPackets);
              *hw_entry_count = 2;
          }
          break;
      case 7:
          if (_BCM_FIELD_STAGE_EXTERNAL == stage_id) {
              value |= (1 << (int)bcmFieldStatNotRedBytes);
              value |= (1 << (int)bcmFieldStatNotRedPackets);
              *hw_entry_count = 1;
          } else {
              value |= (1 << (int)bcmFieldStatRedBytes);
              value |= (1 << (int)bcmFieldStatRedPackets);
              value |= (1 << (int)bcmFieldStatYellowBytes);
              value |= (1 << (int)bcmFieldStatYellowPackets);
              value |= (1 << (int)bcmFieldStatNotGreenBytes);
              value |= (1 << (int)bcmFieldStatNotGreenPackets);
              *hw_entry_count = 2;
          }
          break;
      default:
              *hw_entry_count = 0;
    }
    *hw_bmap = value;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_meter_table_get
 * Purpose:
 *     Get policer table name.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     stage_id  - (IN) Field entry pipeline stage.
 *     mem_x     - (OUT) Policer table name X pipeline.
 *     mem_y     - (OUT) Policer table name Y pipeline.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_meter_table_get(int unit, _field_stage_id_t stage_id,
                           soc_mem_t *mem_x, soc_mem_t *mem_y)
{
    if ((NULL == mem_x) || (NULL == mem_y)) {
        return (BCM_E_PARAM);
    }

    *mem_x = *mem_y = INVALIDm;

    /* Resolve meter table name. */
    switch (stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
      case _BCM_FIELD_STAGE_EXTERNAL:
          *mem_x = FP_METER_TABLEm;
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          if (SOC_IS_APACHE(unit)) {
              *mem_x = EFP_METER_TABLEm;
          } else if (SOC_IS_SC_CQ(unit) ||
                SOC_IS_TD_TT(unit)) {
              *mem_x = EFP_METER_TABLE_Xm;
              *mem_y = EFP_METER_TABLE_Ym;
          } else {
              *mem_x = EFP_METER_TABLEm;
          }
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_policer_hw_update
 * Purpose:
 *     Update (Install) the policer parameters
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_ent         - (IN) Field entry policer attached to.
 *     index_mtr     - (IN) Peak/Committed
 *     bucket_size   - (IN) Encoded bucket size.
 *     refresh_rate  - (IN) Tokens refresh rate.
 *     granularity   - (IN) Tokens granularity.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_policer_hw_update(int unit, _field_entry_t *f_ent,
                             _field_policer_t *f_pl, uint8 index_mtr,
                             uint32 bucket_size, uint32 refresh_rate,
                             uint32 granularity, soc_mem_t meter_table)
{
    uint32          meter_entry[SOC_MAX_MEM_FIELD_WORDS]; /* HW entry buffer.*/
    int             bucket_cnt_bitsize;      /* Bucket count field bit size. */
    int             bucket_max_bitsize;      /* Bucket size field bit size.  */
    int             meter_hw_idx;            /* Meter table index.           */
    uint32          bucketcount;             /* Bucket count initial value.  */
    int             meter_offset;            /* Peak/Comm meter selection.   */
    _field_stage_t  *stage_fc;               /* Field stage control.         */
    int             rv;                      /* Operation return status.     */
    uint32          set_bucket_size;
    _field_stage_id_t      stage_id;         /* Stage id used for metering.  */

    if ((NULL == f_pl) || (NULL == f_ent) || (INVALIDm == meter_table)) {
        return (BCM_E_PARAM);
    }

    stage_id = (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->fs->stage_id) ? \
               _BCM_FIELD_STAGE_INGRESS : f_ent->fs->stage_id;

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);


    /* Calculate initial backet count.
     * bucket size << (bit count diff - 1(sign) -1 (overflow))  - 1
     */
    if (bucket_size) {
        bucket_cnt_bitsize = soc_mem_field_length(unit, meter_table,
                                                  BUCKETCOUNTf);
        bucket_max_bitsize = soc_mem_field_length(unit, meter_table,
                                                  BUCKETSIZEf);
        bucketcount = (bucket_size
                        << (bucket_cnt_bitsize - bucket_max_bitsize - 2))  - 1;
        bucketcount &= ((1 << bucket_cnt_bitsize) - 1);
    } else {
        bucketcount = 0;
    }

    meter_offset = (BCM_FIELD_METER_PEAK == index_mtr) ? 0 : 1;

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /*
         * Hw index is:
         * ((Pool number * pool_size) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx = (f_pl->pool_index *
            stage_fc->meter_pool[f_ent->group->instance]
                                [f_pl->pool_index]->pool_size)
                                + (2 * f_pl->hw_index) + meter_offset;
        LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
            "FP(unit %d) vverb: pool_idx:%d pool_sz:%d pair_num:%d"
            " hw_idx:%d\n"), unit, f_pl->pool_index,
            stage_fc->meter_pool[f_ent->group->instance]
                                [f_pl->pool_index]->pool_size,
            f_pl->hw_index,
            meter_hw_idx));
    } else {
        /*
         * Hw index is:
         * ((slice index) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx =
        stage_fc->slices[f_ent->group->instance]
                        [f_pl->pool_index].start_tcam_idx + \
                        (2 * f_pl->hw_index) + meter_offset;

        LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
            "FP(unit %d) vverb: slice_num:%d tcam_idx:%d pair_num:%d"
            " hw_idx%d\n"), unit, f_pl->pool_index,
            stage_fc->slices[f_ent->group->instance]
                            [f_pl->pool_index].start_tcam_idx,
            f_pl->hw_index,
            meter_hw_idx));
    }

    if (meter_hw_idx < soc_mem_index_min(unit, meter_table) ||
        meter_hw_idx > soc_mem_index_max(unit, meter_table)) {
        return (BCM_E_INTERNAL);
    }

    /* Update meter config in hw. */
    rv = soc_mem_read(unit, meter_table, MEM_BLOCK_ANY,
                      meter_hw_idx, &meter_entry);
    BCM_IF_ERROR_RETURN(rv);

    if ((f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (SOC_IS_KATANA2(unit))) {
            /* Poilcer is used as packet counter
               bucket count is set to max value
               meter test odd/even is set to 0
               set refresh count to 0
               set bucket size to 0
             */
            refresh_rate = 0;
            bucket_size = 0xfff;
            granularity = 7; /* Max gran of 250 token per packet */
            bucketcount = bucket_size << 16;
    }

    soc_mem_field32_set(unit, meter_table, &meter_entry, REFRESHCOUNTf,
                        refresh_rate);
    soc_mem_field32_set(unit, meter_table, &meter_entry, METER_GRANf,
                        granularity);

    soc_mem_field_get(unit, meter_table, meter_entry, BUCKETSIZEf, &set_bucket_size);

    if (bucket_size != set_bucket_size) {
        soc_mem_field32_set(unit, meter_table, &meter_entry, BUCKETCOUNTf,
                            bucketcount);
        soc_mem_field32_set(unit, meter_table, &meter_entry, BUCKETSIZEf,
                            bucket_size);
    }

    /* Refresh mode is only set to 1 for Single Rate. Other modes get 0 */
    if (f_pl->cfg.mode  == bcmPolicerModeSrTcm) {
        soc_mem_field32_set(unit, meter_table, &meter_entry, REFRESH_MODEf, 1);
    } else if (f_pl->cfg.mode  == bcmPolicerModeCoupledTrTcmDs) {
        soc_mem_field32_set(unit, meter_table, &meter_entry, REFRESH_MODEf, 2);
    } else {
        soc_mem_field32_set(unit, meter_table, &meter_entry, REFRESH_MODEf, 0);
    }

    if (soc_feature(unit, soc_feature_field_packet_based_metering)
        && (soc_mem_field_valid(unit, meter_table, PKTS_BYTESf))) {
        if (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) {
           soc_mem_field32_set(unit, meter_table, &meter_entry, PKTS_BYTESf, 1);
        } else {
           soc_mem_field32_set(unit, meter_table, &meter_entry, PKTS_BYTESf, 0);
        }
    }
#if defined(BCM_GREYHOUND2_SUPPORT)
    /*
     * Enable TSN Metering: register METER_MODE_TSN_MODIFIER
     * 0 = DEFAULT (backward compatible) ; 1 = TSN Metering
     */
    if (SOC_MEM_FIELD_VALID(unit, meter_table, METER_MODE_TSN_MODIFIERf)) {
        if (f_pl->cfg.mode  == bcmPolicerModeSrTcmTsn) {
           soc_mem_field32_set(unit, meter_table,
                               &meter_entry, REFRESH_MODEf, 1);
           soc_mem_field32_set(unit, meter_table,
                               &meter_entry, METER_MODE_TSN_MODIFIERf, 1);
        } else {
           soc_mem_field32_set(unit, meter_table,
                               &meter_entry, METER_MODE_TSN_MODIFIERf, 0);
        }
    }
#endif /* BCM_GREYHOUND2_SUPPORT */
    rv = soc_mem_write(unit, meter_table, MEM_BLOCK_ALL,
                       meter_hw_idx, meter_entry);

    return (rv);
}

/*
 * Function:
 *     _bcm_field_trx_policer_hw_update
 * Purpose:
 *     Update (Install) the policer parameters
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_ent         - (IN) Field entry policer attached to.
 *     index_mtr     - (IN) Peak/Committed
 *     bucket_size   - (IN) Encoded bucket size.
 *     refresh_rate  - (IN) Tokens refresh rate.
 *     granularity   - (IN) Tokens granularity.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_policer_hw_update(int unit, _field_entry_t *f_ent,
                             _field_policer_t *f_pl, uint8 index_mtr,
                             uint32 bucket_size, uint32 refresh_rate,
                             uint32 granularity, soc_mem_t meter_table)
{
    return _field_trx_policer_hw_update(unit, f_ent, f_pl, index_mtr,
                                        bucket_size, refresh_rate,
                                        granularity, meter_table);
}
/*
 * Function:
 *     _field_trx_default_policer_set
 *
 * Purpose:
 *     Get metering portion of Policy Table.
 *
 * Parameters:
 *     unit      - (IN)BCM device number.
 *     stage_fc  - (IN)Stage control structure.
 *     level     - (IN)Policer level.
 *     mem       - (IN)Policy table memory.
 *     buf       - (IN/OUT)Hardware policy entry
 *
 * Returns:
 *     BCM_E_NONE  - Success
 *
 */
STATIC int
_field_trx_default_policer_set(int unit, _field_stage_t *stage_fc,
                               int level, soc_mem_t mem, uint32 *buf)
{
    soc_field_t             pair_mode_field;/* Hw field for pair mode.   */
    soc_field_t             modifier_field; /* Hw field for meter update.*/

    /* Input parameter check. */
    if ((NULL == stage_fc) || (NULL == buf))  {
        return (BCM_E_PARAM);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        if (level) {
            pair_mode_field = METER_SHARING_MODEf;
            modifier_field = METER_SHARING_MODE_MODIFIERf;
        } else {
            pair_mode_field = METER_PAIR_MODEf;
            modifier_field = METER_PAIR_MODE_MODIFIERf;
        }

        /* Set the meter mode to default. */
        soc_mem_field32_set(unit, mem, buf, pair_mode_field, 0);
        /* Preserve packet color. */
        soc_mem_field32_set(unit, mem, buf, modifier_field, 1);
    } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        if (0 == level) {
            /* Set the meter mode to default. */
            soc_mem_field32_set(unit, mem, buf, METER_PAIR_MODEf, 0);
            /* Preserve packet color. */
            soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 1);
        }
    } else {
        return BCM_E_PARAM;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx_policer_action_set
 *
 * Purpose:
 *     Get metering portion of Policy Table.
 *
 * Parameters:
 *     unit      - (IN)BCM device number.
 *     f_ent     - (IN)Software entry structure to get tcam info from.
 *     mem       - (IN)Policy table memory.
 *     buf       - (IN/OUT)Hardware policy entry
 *
 * Returns:
 *     BCM_E_NONE  - Success
 *
 */
int
_bcm_field_trx_policer_action_set(int unit, _field_entry_t *f_ent,
                                  soc_mem_t mem, uint32 *buf)
{
    _field_entry_policer_t  *f_ent_pl; /* Field entry policer descriptor.*/
    _field_stage_t          *stage_fc; /* Stage field control structure. */
    bcm_field_stage_t       stage_id;  /* Stage that contains meter.     */
    _field_policer_t        *f_pl;     /* Field policer descriptor.      */
    int                     idx;       /* Policers levels iterator.      */
    uint32                  meter_pair_mode = BCM_FIELD_METER_MODE_DEFAULT;
                                       /* Hw meter usage bits.      */
    soc_field_t             pair_mode_field;/* Hw field for pair mode.   */
    soc_field_t             index_field;    /* Hw field for meter index. */
    soc_field_t             modifier_field; /* Hw field for meter update.*/
    int                     meter_pair_idx; /* Meter pair index.         */
    uint32                  meter_merge = 0;/* Meter merge mode.         */
    int                     rv;             /* Operation return status.  */


    /* Input parameter check. */
    if ((NULL == f_ent) || (NULL == buf))  {
        return (BCM_E_PARAM);
    }
    if (NULL == f_ent->group) {
        return (BCM_E_PARAM);
    }

    stage_id = (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXTERNAL)
                ? _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

    /* No policers at lookup stage. */
    if (_BCM_FIELD_STAGE_LOOKUP == stage_id) {
        return (BCM_E_NONE);
    }

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;

#ifdef BCM_TRIDENT_SUPPORT
        if (SOC_IS_TD_TT(unit) && (idx > 0)) {
            /* Trident device does not support Level1 policers */
            break;
        }
#endif
        if (0 == (f_ent_pl->flags & _FP_POLICER_INSTALLED)) {
            /* Install preserve the color policer. */
            rv = _field_trx_default_policer_set(unit, stage_fc, idx,
                                                mem, buf);
            BCM_IF_ERROR_RETURN(rv);
            continue;
        }

        /* Get policer config. */
        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);

        if (0 == f_pl->level) {
            /* Get hw encoding for meter mode. */
            rv = _bcm_field_meter_pair_mode_get(unit, f_pl, &meter_pair_mode);
            BCM_IF_ERROR_RETURN(rv);
            /* If level 0 policer is Modified trTcm ->
             * meter sharing mode is dual.
             */
            if ((f_pl->cfg.mode == bcmPolicerModeTrTcmDs) ||
                (f_pl->cfg.mode == bcmPolicerModeCoupledTrTcmDs)) {
                meter_merge = 3;
            }
        }

       if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
           /* Pair index is (Pool number * Pairs in Pool + Pair number) */
            meter_pair_idx = (f_pl->pool_index *
            (stage_fc->meter_pool[f_ent->group->instance]
                                 [f_pl->pool_index]->num_meter_pairs))
                                 + (f_pl->hw_index);
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                soc_mem_field32_set(unit, mem, buf, METER_PAIR_INDEX_ODDf,
                                    meter_pair_idx);
                soc_mem_field32_set(unit, mem, buf, METER_PAIR_INDEX_EVENf,
                                    meter_pair_idx);
                soc_mem_field32_set(unit, mem, buf, METER_PAIR_MODEf,
                                    meter_pair_mode);

                /*
                 * Flow mode is the only one that cares about the test and
                 * update bits.
                 */
                if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                    /* Excess meter - even index. */
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_ODDf, 0);
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 1);
                    soc_mem_field32_set(unit, mem, buf, METER_UPDATE_ODDf, 0);
                    soc_mem_field32_set(unit, mem, buf, METER_UPDATE_EVENf, 1);
                } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
                    /* Committed meter - odd index. */
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_ODDf, 1);
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 0);
                    soc_mem_field32_set(unit, mem, buf, METER_UPDATE_ODDf, 1);
                    soc_mem_field32_set(unit, mem, buf, METER_UPDATE_EVENf, 0);
                }

                if ((f_pl->cfg.mode == bcmPolicerModePassThrough) ||
                    (f_pl->cfg.mode == bcmPolicerModeSrTcmModified)) {
                    soc_mem_field32_set(unit, mem, buf,
                                        METER_PAIR_MODE_MODIFIERf, 1);
                }
                return (BCM_E_NONE);
            } else
#endif
            {
                /*
                 * Get the meter index in the global meter pool
                 * IMP: This is the meter pair index, not the individual meter's
                 * which will be 2x (+1) (see _field_triumph_meter_install)
                 */
                if (f_pl->level) {
                    pair_mode_field = METER_SHARING_MODEf;
                    index_field = SHARED_METER_PAIR_INDEXf;
                    modifier_field = METER_SHARING_MODE_MODIFIERf;
                    meter_pair_mode = (meter_merge) ? meter_merge
                                        : ((f_pl->cfg.flags
                                            & BCM_POLICER_COLOR_MERGE_OR)
                                            ? 1 : 2);
                } else {
                    pair_mode_field = METER_PAIR_MODEf;
                    index_field = METER_PAIR_INDEXf;
                    modifier_field = METER_PAIR_MODE_MODIFIERf;
                }

                soc_mem_field32_set(unit, mem, buf, index_field,
                                    meter_pair_idx);

                /* Set the meter mode */
                soc_mem_field32_set(unit, mem, buf, pair_mode_field,
                                    meter_pair_mode);

                /*
                 * Flow mode cares about the MODIFIER field
                 *     Excess (Even): 0
                 *     COMMITTED/PASS THROUGH (Odd): 1
                 */
                if ((f_pl->cfg.mode == bcmPolicerModePassThrough)
                    || (f_pl->cfg.mode == bcmPolicerModeSrTcmModified)
                    || (_FP_POLICER_COMMITTED_HW_METER(f_pl))) {
                    soc_mem_field32_set(unit, mem, buf, modifier_field, 1);
                } else if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                    soc_mem_field32_set(unit, mem, buf, modifier_field, 0);
                }
            }
        } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) {
            /* Get the even and odd indexes from the entry. The even and odd
             * meter indices are the same.
             */
            soc_mem_field32_set(unit, mem, buf, METER_INDEX_EVENf,
                                f_pl->hw_index);
            soc_mem_field32_set(unit, mem, buf, METER_INDEX_ODDf,
                                f_pl->hw_index);

            /* Get the meter mode */
            
            soc_mem_field32_set(unit, mem, buf, METER_PAIR_MODEf,
                                meter_pair_mode);

            /*
             * Flow mode is the only one that cares about the test and
             * update bits.
             */
            if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                /* Excess meter - even index. */
                soc_mem_field32_set(unit, mem, buf, METER_TEST_ODDf, 0);
                if (SOC_IS_KATANA2(unit) &&
                    (f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER)) {
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 0);
                } else {
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 1);
                }
                soc_mem_field32_set(unit, mem, buf, METER_UPDATE_ODDf, 0);
                soc_mem_field32_set(unit, mem, buf, METER_UPDATE_EVENf, 1);
            } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
                /* Committed meter - odd index. */
                if (SOC_IS_KATANA2(unit) &&
                    (f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER)) {
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_ODDf, 0);
                } else {
                    soc_mem_field32_set(unit, mem, buf, METER_TEST_ODDf, 1);
                }
                soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 0);
                soc_mem_field32_set(unit, mem, buf, METER_UPDATE_ODDf, 1);
                soc_mem_field32_set(unit, mem, buf, METER_UPDATE_EVENf, 0);
            } else if (f_pl->cfg.mode == bcmPolicerModePassThrough) {
                soc_mem_field32_set(unit, mem, buf, METER_TEST_EVENf, 1);
            }
#if defined(BCM_TRIDENT2_SUPPORT)
            else if (f_pl->cfg.mode == bcmPolicerModeSrTcmModified
                       && (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                soc_mem_field32_set(unit, mem, buf,
                                    METER_MODE_MODIFIERf, 1);
            }
#endif
        } else {
            return BCM_E_PARAM;
        }
    }
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_trx_policer_install
 * Purpose:
 *     Install a meter pair into the hardware tables.
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     f_ent  - (IN) Field entry.
 *     f_pl   - (IN) Field policer descriptor.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_policer_install(int unit, _field_entry_t *f_ent,
                               _field_policer_t *f_pl)
{
    uint32    bucketsize_peak = 0;      /* Bucket size.             */
    uint32    refresh_rate_peak = 0;    /* Policer refresh rate.    */
    uint32    granularity_peak = 0;     /* Policer granularity.     */
    uint32    bucketsize_commit = 0;    /* Bucket size.             */
    uint32    refresh_rate_commit = 0;  /* Policer refresh rate.    */
    uint32    granularity_commit = 0;   /* Policer granularity.     */
    int       refresh_bitsize;          /* Number of bits for the
                                           refresh rate field.      */
    int       bucket_max_bitsize;       /* Number of bits for the
                                           bucket max field.        */
    int       rv;                       /* Operation return status. */
    soc_mem_t meter_table_x;            /* Meter table name.        */
    soc_mem_t meter_table_y;            /* Meter table name.        */
    uint32    flags;                    /* Policer flags.           */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    if (NULL == f_ent->group || NULL == f_ent->fs) {
        return (BCM_E_INTERNAL);
    }

    if (0 == (f_pl->hw_flags & _FP_POLICER_DIRTY)) {
        return (BCM_E_NONE);
    }

    /* Resolve meter table name. */
    rv = _field_trx_meter_table_get(unit, f_ent->fs->stage_id,
                                    &meter_table_x, &meter_table_y);
    BCM_IF_ERROR_RETURN(rv);

    refresh_bitsize = soc_mem_field_length(unit, meter_table_x, REFRESHCOUNTf);
    bucket_max_bitsize = soc_mem_field_length(unit, meter_table_x, BUCKETSIZEf);

    /* lookup bucket size from tables */
    flags = _BCM_XGS_METER_FLAG_GRANULARITY | _BCM_XGS_METER_FLAG_FP_POLICER;


    /* TD2 has change in granularity calculation */
    if ((SOC_IS_TD2_TT2(unit)) &&
        (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS)) {
        flags = flags | _BCM_XGS_METER_FLAG_FP_TD2_POLICER;
    }

    /* Set packet mode flags setting */
    if (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) {
        flags |= _BCM_XGS_METER_FLAG_PACKET_MODE;
    } else {
        flags &= ~_BCM_XGS_METER_FLAG_PACKET_MODE;
    }

    if (f_pl->cfg.mode  != bcmPolicerModeSrTcm) {
        if (f_pl->hw_flags & _FP_POLICER_COMMITTED_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.ckbits_sec,
                                                   f_pl->cfg.ckbits_burst,
                                                   flags, refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_commit,
                                                   &bucketsize_commit,
                                                   &granularity_commit);
            BCM_IF_ERROR_RETURN(rv);
            /* Programm policer parameters into hw. */
            rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                               BCM_FIELD_METER_COMMITTED,
                                               bucketsize_commit,
                                               refresh_rate_commit,
                                               granularity_commit, meter_table_x);

            if (BCM_SUCCESS(rv) && (INVALIDm != meter_table_y)) {
                rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                   BCM_FIELD_METER_COMMITTED,
                                                   bucketsize_commit,
                                                   refresh_rate_commit,
                                                   granularity_commit,
                                                   meter_table_y);
            }
            BCM_IF_ERROR_RETURN(rv);
            f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;
        }

        if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {

            if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                /*
                 * Rates are always set in committed variables,
                 * for flow meters.
                 */
                f_pl->cfg.pkbits_sec = f_pl->cfg.ckbits_sec;
                f_pl->cfg.pkbits_burst = f_pl->cfg.ckbits_burst;
            }

            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.pkbits_sec,
                                                   f_pl->cfg.pkbits_burst,
                                                   flags,
                                                   refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_peak,
                                                   &bucketsize_peak,
                                                   &granularity_peak);
            BCM_IF_ERROR_RETURN(rv);
            /* Programm policer parameters into hw. */
            rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                               BCM_FIELD_METER_PEAK,
                                               bucketsize_peak, refresh_rate_peak,
                                               granularity_peak, meter_table_x);

            if (BCM_SUCCESS(rv) && (INVALIDm != meter_table_y)) {
                rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                   BCM_FIELD_METER_PEAK,
                                                   bucketsize_peak,
                                                   refresh_rate_peak,
                                                   granularity_peak,
                                                   meter_table_y);
            }
            BCM_IF_ERROR_RETURN(rv);
            f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;

            if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                /* Reset peak meter rates. */
                f_pl->cfg.pkbits_sec = 0;
                f_pl->cfg.pkbits_burst = 0;
            }
        }
    } else {
        if (f_pl->hw_flags & _FP_POLICER_COMMITTED_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.ckbits_sec,
                                                   f_pl->cfg.ckbits_burst,
                                                   flags, refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_commit,
                                                   &bucketsize_commit,
                                                   &granularity_commit);
            BCM_IF_ERROR_RETURN(rv);
        }

        if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.pkbits_sec,
                                                   f_pl->cfg.pkbits_burst,
                                                   flags,
                                                   refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_peak,
                                                   &bucketsize_peak,
                                                   &granularity_peak);
            BCM_IF_ERROR_RETURN(rv);
        }

        if (granularity_commit != granularity_peak) {
            if (granularity_commit < granularity_peak) {
                rv = _bcm_xgs_kbits_to_dual_bucket_encoding(f_pl->cfg.ckbits_sec,
                                                            f_pl->cfg.ckbits_burst,
                                                            flags,
                                                            refresh_bitsize,
                                                            bucket_max_bitsize,
                                                            granularity_peak,
                                                            &refresh_rate_commit,
                                                            &bucketsize_commit,
                                                            &granularity_commit);
            } else if (granularity_commit > granularity_peak) {
                rv = _bcm_xgs_kbits_to_dual_bucket_encoding(f_pl->cfg.pkbits_sec,
                                                            f_pl->cfg.pkbits_burst,
                                                            flags,
                                                            refresh_bitsize,
                                                            bucket_max_bitsize,
                                                            granularity_commit,
                                                            &refresh_rate_peak,
                                                            &bucketsize_peak,
                                                            &granularity_peak);
            }
            BCM_IF_ERROR_RETURN(rv);
        }
        /* Programm policer parameters into hw. */
        rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                           BCM_FIELD_METER_COMMITTED,
                                           bucketsize_commit,
                                           refresh_rate_commit,
                                           granularity_commit, meter_table_x);

        if (BCM_SUCCESS(rv) && (INVALIDm != meter_table_y)) {
            rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                               BCM_FIELD_METER_COMMITTED,
                                               bucketsize_commit,
                                               refresh_rate_commit,
                                               granularity_commit,
                                               meter_table_y);
        }
        BCM_IF_ERROR_RETURN(rv);
        f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;

        /* Programm policer parameters into hw. */
        rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                           BCM_FIELD_METER_PEAK,
                                           bucketsize_peak, refresh_rate_peak,
                                           granularity_peak, meter_table_x);

        if (BCM_SUCCESS(rv) && (INVALIDm != meter_table_y)) {
            rv =  _field_trx_policer_hw_update(unit, f_ent, f_pl,
                                               BCM_FIELD_METER_PEAK,
                                               bucketsize_peak,
                                               refresh_rate_peak,
                                               granularity_peak,
                                               meter_table_y);
        }

        f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;
    }

    BCM_IF_ERROR_RETURN(rv);
    /* Update current policer counters from hw */
    rv = _field_entry_policer_update_actual_hw_rates(unit, meter_table_x,
            _FP_DEF_INST, f_ent, f_pl);

    return rv;
}

/*
 * Function:
 *     _field_trx_policer_packet_counter_hw_get
 * Purpose:
 *     Get the policer token bucket parameters
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_pl          - (IN) Field policer descriptor.
 *     Count         - (OUT) Token bucket count.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_policer_packet_counter_hw_get(int unit, _field_policer_t *f_pl,
                                                soc_mem_t meter_table,
                                                uint32 *count)
{
    uint32          meter_entry[SOC_MAX_MEM_FIELD_WORDS]; /* HW entry buffer.*/
    int             meter_hw_idx;            /* Meter table index.           */
    int             meter_offset;            /* Peak/Comm meter selection.   */
    _field_stage_t  *stage_fc;               /* Field stage control.         */
    int             rv;                      /* Operation return status.     */

    if ((NULL == f_pl) || (INVALIDm == meter_table) || (NULL == count)) {
        return (BCM_E_PARAM);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, f_pl->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
        meter_offset = 0;
    } else {
        meter_offset = 1;
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /*
         * Hw index is:
         * ((Pool number * pool_size) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx = (f_pl->pool_index *
                stage_fc->meter_pool[_FP_DEF_INST]
                [f_pl->pool_index]->pool_size) + \
            (2 * f_pl->hw_index) + meter_offset;
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) vverb: pool_idx:%d pool_sz:%d pair_num:%d"
                            " hw_idx:%d\n"), unit, f_pl->pool_index,
                 stage_fc->meter_pool[_FP_DEF_INST]
                 [f_pl->pool_index]->pool_size,
                 f_pl->hw_index,
                 meter_hw_idx));
    } else {
        /*
         * Hw index is:
         * ((slice index) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx = stage_fc->slices[_FP_DEF_INST]
            [f_pl->pool_index].start_tcam_idx + \
            (2 * f_pl->hw_index) + meter_offset;

        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) vverb: slice_num:%d tcam_idx:%d pair_num:%d"
                            " hw_idx%d\n"), unit, f_pl->pool_index,
                 stage_fc->slices[_FP_DEF_INST]
                 [f_pl->pool_index].start_tcam_idx,
                 f_pl->hw_index,
                 meter_hw_idx));
    }

    if (meter_hw_idx < soc_mem_index_min(unit, meter_table) ||
            meter_hw_idx > soc_mem_index_max(unit, meter_table)) {
        return (BCM_E_INTERNAL);
    }

    /* Update meter config in hw. */
    rv = soc_mem_read(unit, meter_table, MEM_BLOCK_ANY,
            meter_hw_idx, &meter_entry);

    BCM_IF_ERROR_RETURN(rv);

    *count = soc_mem_field32_get(unit, meter_table,
                           &meter_entry, BUCKETCOUNTf);

    return rv;
}

/*
 * Function:
 *     _field_trx_policer_packet_counter_hw_set
 * Purpose:
 *     Reset & Get the policer token bucket parameters
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     f_pl          - (IN) Field policer descriptor.
 *     Count         - (IN) Token bucket count.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_policer_packet_counter_hw_set(int unit, _field_policer_t *f_pl,
                                                soc_mem_t meter_table,
                                                uint32 count)
{
    uint32          meter_entry[SOC_MAX_MEM_FIELD_WORDS]; /* HW entry buffer.*/
    int             meter_hw_idx;            /* Meter table index.           */
    int             meter_offset;            /* Peak/Comm meter selection.   */
    _field_stage_t  *stage_fc;               /* Field stage control.         */
    int             rv;                      /* Operation return status.     */

    if ((NULL == f_pl) || (INVALIDm == meter_table)) {
        return (BCM_E_PARAM);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, f_pl->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
        meter_offset = 0;
    } else {
        meter_offset = 1;
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /*
         * Hw index is:
         * ((Pool number * pool_size) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx = (f_pl->pool_index *
                stage_fc->meter_pool[_FP_DEF_INST]
                [f_pl->pool_index]->pool_size) + \
            (2 * f_pl->hw_index) + meter_offset;
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) vverb: pool_idx:%d pool_sz:%d pair_num:%d"
                            " hw_idx:%d\n"), unit, f_pl->pool_index,
                 stage_fc->meter_pool[_FP_DEF_INST]
                 [f_pl->pool_index]->pool_size,
                 f_pl->hw_index,
                 meter_hw_idx));
    } else {
        /*
         * Hw index is:
         * ((slice index) + (2 * pair number) + meter_offset)
         */
        meter_hw_idx = stage_fc->slices[_FP_DEF_INST]
            [f_pl->pool_index].start_tcam_idx + \
            (2 * f_pl->hw_index) + meter_offset;

        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) vverb: slice_num:%d tcam_idx:%d pair_num:%d"
                            " hw_idx%d\n"), unit, f_pl->pool_index,
                 stage_fc->slices[_FP_DEF_INST]
                 [f_pl->pool_index].start_tcam_idx,
                 f_pl->hw_index,
                 meter_hw_idx));
    }

    if (meter_hw_idx < soc_mem_index_min(unit, meter_table) ||
            meter_hw_idx > soc_mem_index_max(unit, meter_table)) {
        return (BCM_E_INTERNAL);
    }

    /* Update meter config in hw. */
    rv = soc_mem_read(unit, meter_table, MEM_BLOCK_ANY,
            meter_hw_idx, &meter_entry);

    BCM_IF_ERROR_RETURN(rv);

    soc_mem_field32_set(unit, meter_table, &meter_entry, BUCKETCOUNTf,
            count);

    rv = soc_mem_write(unit, meter_table, MEM_BLOCK_ALL,
            meter_hw_idx, meter_entry);

    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_policer_packet_counter_get
 * Purpose:
 *     Get the policer token bucket parameters
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     f_pl   - (IN) Field policer descriptor.
 *     count  - (OUT) Packet count
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_policer_packet_counter_get(int unit, _field_policer_t *f_pl, uint32 *count)
{
    int       rv;                       /* Operation return status. */
    soc_mem_t meter_table_x;            /* Meter table name.        */
    soc_mem_t meter_table_y;            /* Meter table name.        */

    /* Input parameters check. */
    if ((NULL == f_pl) || (NULL == count)) {
        return (BCM_E_PARAM);
    }

    /* Entry should not be dirty */
    if (0 != (f_pl->hw_flags & _FP_POLICER_DIRTY)) {
        return (BCM_E_NONE);
    }

    if (!((f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER) &&
                (f_pl->cfg.mode == bcmPolicerModeCommitted) &&
                (SOC_IS_KATANA2(unit)))) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_EGRESS != f_pl->stage_id) {
        return (BCM_E_PARAM);
    }

    /* Resolve meter table name. */
    rv = _field_trx_meter_table_get(unit, f_pl->stage_id,
            &meter_table_x, &meter_table_y);

    BCM_IF_ERROR_RETURN(rv);

    /* For Katana2 EFP only Meter x is valid*/
    /* Programm policer parameters from hw. */
    rv =  _field_trx_policer_packet_counter_hw_get(unit, f_pl,
            meter_table_x, count);

    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_policer_packet_reset_counter_get
 * Purpose:
 *     Reset & Get the policer token bucket parameters
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     f_pl   - (IN) Field policer descriptor.
 *     count  - (OUT) Packet count
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_policer_packet_reset_counter_get(int unit, _field_policer_t *f_pl, uint32 *count)
{
    int       rv;                       /* Operation return status. */
    soc_mem_t meter_table_x;            /* Meter table name.        */
    soc_mem_t meter_table_y;            /* Meter table name.        */

    /* Input parameters check. */
    if ((NULL == f_pl) || (NULL == count)) {
        return (BCM_E_PARAM);
    }

    /* Entry is not dirty */
    if (0 != (f_pl->hw_flags & _FP_POLICER_DIRTY)) {
        return (BCM_E_NONE);
    }

    if (!((f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER) &&
                (f_pl->cfg.mode == bcmPolicerModeCommitted) &&
                (SOC_IS_KATANA2(unit)))) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_EGRESS != f_pl->stage_id) {
        return (BCM_E_PARAM);
    }

    /* Resolve meter table name. */
    rv = _field_trx_meter_table_get(unit, f_pl->stage_id,
            &meter_table_x, &meter_table_y);
    BCM_IF_ERROR_RETURN(rv);

    /* For Katana2 EFP only Meter x is valid*/
    /* Programm policer parameters into hw. */
    *count = 0xfff0000;
    rv =  _field_trx_policer_packet_counter_hw_set(unit, f_pl,
            meter_table_x, *count);
    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_stat_index_get
 * Purpose:
 *      Get hw indexes and flags needed to compose requested statistic.
 *
 * Parameters:
 *   unit          - (IN)  BCM device number.
 *   f_st          - (IN)  Field statistics entity.
 *   stat          - (IN)  Counter type.
 *   idx1          - (OUT)  Primary counter index.
 *   idx2          - (OUT)  Secondary counter index.
 *   out_flags     - (OUT)  Counter flags.
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_trx_stat_index_get(int unit, _field_stat_t *f_st,
                             bcm_field_stat_t stat,
                             int *idx1, int *idx2, int *idx3, uint32 *out_flags)
{
    _field_stage_t *stage_fc;        /* Stage field control structure. */
    int            rv;               /* Operation return status.       */
    uint32         flags = 0;        /* _FP_STAT_XXX flags.            */
    uint32         counter_tbl_idx;  /* Counter table index.           */
    int            index1  = _FP_INVALID_INDEX;
    int            index2  = _FP_INVALID_INDEX;
#if defined(BCM_TRIDENT_SUPPORT)
    int lower_cntr_mode = 0;
    int upper_cntr_mode = 0;
#endif

    /* Input parameters check. */
    if ((NULL == idx1) || (NULL == idx2) ||
        (NULL == out_flags) || (NULL == f_st)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    *idx1 = *idx2 = *idx3 = _FP_INVALID_INDEX;

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, f_st->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

#if defined (BCM_TRIUMPH_SUPPORT)
    /* External stage counter index translation. */
    if (_BCM_FIELD_STAGE_EXTERNAL == f_st->stage_id) {
        rv = _bcm_field_tr_external_counter_idx_get(unit, f_st->pool_index,
                                                    f_st->hw_index, idx1);
        switch (stat) {
          case bcmFieldStatBytes:
          case bcmFieldStatGreenBytes:
          case bcmFieldStatYellowBytes:
          case bcmFieldStatRedBytes:
          case bcmFieldStatNotGreenBytes:
          case bcmFieldStatNotYellowBytes:
          case bcmFieldStatNotRedBytes:
              flags |= _FP_STAT_BYTES;
              break;
          default:
              break;
        }
        *out_flags = flags;
        return (rv);
    }
#endif /* BCM_TRIUMPH_SUPPORT */

    /* Stat entity indexes are adjusted for policy table counter pairs. */
    counter_tbl_idx = f_st->hw_index << 1;

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
        (f_st->stage_id == _BCM_FIELD_STAGE_INGRESS)) {

        lower_cntr_mode = (f_st->hw_mode & 0x7);
        upper_cntr_mode = ((f_st->hw_mode & (0x7 << 3)) >> 3);
        switch ((int)stat) {
            case bcmFieldStatGreenBytes:
                flags |= _FP_STAT_BYTES;
            case bcmFieldStatGreenPackets:
                if (upper_cntr_mode & 0x1) {
                    index1 = counter_tbl_idx + 1;
                } else if (lower_cntr_mode & 0x1) {
                    index1 = counter_tbl_idx;
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

            case bcmFieldStatYellowBytes:
                flags |= _FP_STAT_BYTES;
            case bcmFieldStatYellowPackets:
                if (upper_cntr_mode & 0x2) {
                    index1 = counter_tbl_idx + 1;
                } else if (lower_cntr_mode & 0x2) {
                    index1 = counter_tbl_idx;
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

            case bcmFieldStatRedBytes:
                flags |= _FP_STAT_BYTES;
            case bcmFieldStatRedPackets:
                if (upper_cntr_mode & 0x4) {
                    index1 = counter_tbl_idx + 1;
                } else if (lower_cntr_mode & 0x4) {
                    index1 = counter_tbl_idx;
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

          case bcmFieldStatNotGreenBytes:
                flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotGreenPackets:
                if (upper_cntr_mode & 0x6) {
                    index1 = counter_tbl_idx + 1;
                } else if (((upper_cntr_mode & 0x6) == 0) ||
                            (upper_cntr_mode & 0x1)) {
                    switch (lower_cntr_mode) {
                        case 0x2:
                        case 0x4:
                        case 0x6:
                            index1 = counter_tbl_idx;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else if (((upper_cntr_mode & 0x2) && (lower_cntr_mode & 0x4)) ||
                            ((upper_cntr_mode & 0x4) && (lower_cntr_mode & 0x2))) {
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags = _FP_STAT_ADD;
                } else if ((lower_cntr_mode & 0x6) == 0) {
                    switch (upper_cntr_mode) {
                        case 0x2:
                        case 0x4:
                        case 0x6:
                            index1 = counter_tbl_idx + 1;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

          case bcmFieldStatNotYellowBytes:
                flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotYellowPackets:
                if (upper_cntr_mode & 0x5) {
                    index1 = counter_tbl_idx + 1;
                } else if (((upper_cntr_mode & 0x5) == 0) ||
                        ((upper_cntr_mode & 0x2))) {
                    switch (lower_cntr_mode) {
                        case 0x1:
                        case 0x4:
                        case 0x5:
                            index1 = counter_tbl_idx;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else if (((upper_cntr_mode & 0x1) && (lower_cntr_mode & 0x4)) ||
                            ((upper_cntr_mode & 0x4) && (lower_cntr_mode & 0x1))) {
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags = _FP_STAT_ADD;
                }  else if ((lower_cntr_mode & 0x5) == 0) {
                    switch (upper_cntr_mode) {
                        case 0x1:
                        case 0x4:
                        case 0x5:
                            index1 = counter_tbl_idx + 1;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

          case bcmFieldStatNotRedBytes:
                flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotRedPackets:
                if (upper_cntr_mode & 0x3) {
                    index1 = counter_tbl_idx + 1;
                } else if (((upper_cntr_mode & 0x3) == 0) ||
                        ((upper_cntr_mode & 0x4))) {
                    switch (lower_cntr_mode) {
                        case 0x1:
                        case 0x2:
                        case 0x3:
                            index1 = counter_tbl_idx;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else if (((upper_cntr_mode & 0x1) && (lower_cntr_mode & 0x2)) ||
                            ((upper_cntr_mode & 0x2) && (lower_cntr_mode & 0x1))) {
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags = _FP_STAT_ADD;
                } else if ((lower_cntr_mode & 0x3) == 0) {
                    switch (upper_cntr_mode) {
                        case 0x1:
                        case 0x2:
                        case 0x3:
                            index1 = counter_tbl_idx + 1;
                            break;
                        default:
                            return BCM_E_INTERNAL;
                    }
                } else {
                    return BCM_E_INTERNAL;
                }
                break;

          case bcmFieldStatBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatPackets:
                          if ((lower_cntr_mode ^ upper_cntr_mode) &&
                                          ((lower_cntr_mode != 0) &&
                                           (upper_cntr_mode != 0))) {
                                  index1 = counter_tbl_idx;
                                  index2 = counter_tbl_idx + 1;
                                  flags = _FP_STAT_ADD;
                          } else if (upper_cntr_mode &&
                                          (lower_cntr_mode & 0x7) == 0) {
                                  index1 = counter_tbl_idx + 1;
                          } else if (upper_cntr_mode == 0 && lower_cntr_mode) {
                                  index1 = counter_tbl_idx;
                          } else if ((lower_cntr_mode == 0x7) &&
                                          (upper_cntr_mode == 0x7)) {
                                  index1 = counter_tbl_idx + 1;
                          } else {
                                  return BCM_E_INTERNAL;
                          }
                          break;

          default:
              return (BCM_E_INTERNAL);
        }
        } else
#endif /* BCM_TRIDENT_SUPPORT || BCM_KATANA_SUPPORT*/
    {
        switch ((int)stat) {
          case bcmFieldStatBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatPackets:
              switch (f_st->hw_mode) {
                case (0x2):
                    index1 = counter_tbl_idx + 1;
                    break;
                case (0x1):
                    index1 = counter_tbl_idx;
                    break;
                default:
                    return (BCM_E_INTERNAL);
              }
              break;
          case bcmFieldStatGreenBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatGreenPackets:
              index1 = counter_tbl_idx + 1;
              break;

          case bcmFieldStatYellowBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatYellowPackets:
              index1 = counter_tbl_idx;
              break;

          case bcmFieldStatRedBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatRedPackets:
              switch (f_st->hw_mode) {
                case 0x3:
                case 0x7:
                    index1 = counter_tbl_idx + 1;
                    break;
                case 0x5:
                    index1 = counter_tbl_idx;
                    break;
                default:
                    return (BCM_E_INTERNAL);
              }
              break;

          case bcmFieldStatNotGreenBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotGreenPackets:
              switch (f_st->hw_mode) {
                case 0x4:
                    index1 = counter_tbl_idx;
                    break;
                case 0x7:
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags |= _FP_STAT_ADD;
                    break;
                default:
                    return (BCM_E_INTERNAL);
              }
              break;

          case bcmFieldStatNotYellowBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotYellowPackets:
              switch (f_st->hw_mode) {
                case 0x5:
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags |= _FP_STAT_ADD;
                    break;
                default:
                    return (BCM_E_INTERNAL);
              }
              break;

          case bcmFieldStatNotRedBytes:
              flags |= _FP_STAT_BYTES;
          case bcmFieldStatNotRedPackets:
              switch (f_st->hw_mode) {
                case (0x3):
                    index1 = counter_tbl_idx;
                    break;
                case (0x6):
                    index1 = counter_tbl_idx;
                    index2 = counter_tbl_idx + 1;
                    flags |= _FP_STAT_ADD;
                    break;
                default:
                    return (BCM_E_INTERNAL);
              }
              break;
          default:
              return (BCM_E_INTERNAL);
        }
    }


    /* Calculate  counter table entry index. */
    if (_FP_INVALID_INDEX != index1) {
        if (stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS) {
            *idx1 = index1;
        } else {
            *idx1 =
            stage_fc->slices[_FP_DEF_INST][f_st->pool_index].start_tcam_idx
                + index1;
        }
    } else {
        *idx1 = _FP_INVALID_INDEX;
    }

    if (_FP_INVALID_INDEX != index2) {
        if (stage_fc->flags & _FP_STAGE_GLOBAL_COUNTERS) {
            *idx2 = index2;
        } else {
            *idx2 =
            stage_fc->slices[_FP_DEF_INST][f_st->pool_index].start_tcam_idx
            + index2;
        }
    } else {
        *idx2 = _FP_INVALID_INDEX;
    }
    *out_flags = flags;
    return (BCM_E_NONE);
}

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
/*
 * Function:
 *     _field_trx2_udf_tcam_entry_move
 * Purpose:
 *     Move a single entry in  udf tcam and offset tables.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     data_ctrl - (IN) Data control structure.
 *     dest      - (IN) Insertion target index.
 *     free_slot - (IN) Free slot.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_move(int unit,
                               _field_data_control_t *data_ctrl,
                               int src, int dst)
{
    uint32 hw_buf[SOC_MAX_MEM_FIELD_WORDS]; /* Buffer to read hw entry.   */
    int rv;                                 /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == data_ctrl) {
        return (BCM_E_PARAM);
    }

    rv = soc_mem_read(unit, FP_UDF_OFFSETm, MEM_BLOCK_ANY, src, hw_buf);
    BCM_IF_ERROR_RETURN(rv);
    rv = soc_mem_write(unit, FP_UDF_OFFSETm, MEM_BLOCK_ALL, dst, hw_buf);
    BCM_IF_ERROR_RETURN(rv);
    rv = soc_mem_read(unit, FP_UDF_TCAMm, MEM_BLOCK_ANY, src, hw_buf);
    BCM_IF_ERROR_RETURN(rv);
    rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, dst, hw_buf);
    BCM_IF_ERROR_RETURN(rv);

    /* Clear entries at old index. */
    rv = soc_mem_write(unit, FP_UDF_OFFSETm, MEM_BLOCK_ALL, src,
                       soc_mem_entry_null(unit, FP_UDF_OFFSETm));
    BCM_IF_ERROR_RETURN(rv);

    rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, src,
                       soc_mem_entry_null(unit, FP_UDF_TCAMm));
    BCM_IF_ERROR_RETURN(rv);

    /* Update sw structure tracking entry use. */
    sal_memcpy(data_ctrl->tcam_entry_arr + dst,
               data_ctrl->tcam_entry_arr + src,
               sizeof(_field_data_tcam_entry_t));
    sal_memset(data_ctrl->tcam_entry_arr + src, 0,
               sizeof(_field_data_tcam_entry_t));
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_move_down
 * Purpose:
 *     Moved udf tcam entries down
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     data_ctrl - (IN) Data control structure.
 *     dest      - (IN) Insertion target index.
 *     free_slot - (IN) Free slot.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_move_down(int unit,
                              _field_data_control_t *data_ctrl,
                              int dest, int free_slot)
{
    int idx;          /* Entries iterator.        */
    int rv;           /* Operation return status. */

    /* Input parameters check. */
    if (NULL == data_ctrl) {
        return (BCM_E_PARAM);
    }

    for (idx = free_slot; idx < dest; idx ++) {
        rv = _field_trx2_udf_tcam_entry_move(unit, data_ctrl, idx + 1, idx);
        BCM_IF_ERROR_RETURN(rv);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_move_up
 * Purpose:
 *     Moved udf tcam entries up.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     data_ctrl - (IN) Data control structure.
 *     dest      - (IN) Insertion target index.
 *     free_slot - (IN) Free slot.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_move_up(int unit,
                            _field_data_control_t *data_ctrl,
                            int dest, int free_slot)
{
    int idx;          /* Entries iterator.        */
    int rv;           /* Operation return status. */

    /* Input parameters check. */
    if (NULL == data_ctrl) {
        return (BCM_E_PARAM);
    }

    for (idx = free_slot; idx > dest; idx --) {
        rv = _field_trx2_udf_tcam_entry_move(unit, data_ctrl, idx - 1, idx);
        BCM_IF_ERROR_RETURN(rv);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entries_compare
 * Purpose:
 *     To find out if a duplicate entry already exists.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     hw_entry  - (IN) Hardware entry.
 *     sw_entry  - (IN) Software entry to be matched.
 *     flags_hw  - (IN) Flag bits denote hadware entry details.
 *     flags_sw  - (IN) Flag bits denote software entry details.
 * Returns:
 *     TRUE or FALSE
 */

STATIC int
_field_trx2_udf_tcam_entries_compare(int unit, uint32 *hw_entry,
                                     uint32 *sw_entry, uint32 flags_hw,
                                     uint32 flags_sw)
{
    uint16 hw_etype_mask = 0;
    uint16 hw_etype = 0;
    uint16 sw_etype_mask = 0;
    uint16 sw_etype = 0;

    uint32 hw_ipproto_mask = 0;
    uint32 hw_ipproto= 0;
    uint32 sw_ipproto_mask = 0;
    uint32 sw_ipproto= 0;

    if (0 == (flags_hw  ^ flags_sw)) {
        /* Ip Protocol is the higher 8 bits of the L3_FIELDSf(bits 16:23).
         * Check if the Hw and Sw has different IP protocol value, then
         * return False, to create new Hardware Index for the incoming values.
         */
        if ((hw_ipproto_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_entry,
                                                   L3_FIELDS_MASKf))) {
            hw_ipproto = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_entry,
                                             L3_FIELDSf);
        }
        if ((sw_ipproto_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, sw_entry,
                                                   L3_FIELDS_MASKf))) {
            sw_ipproto = soc_mem_field32_get(unit, FP_UDF_TCAMm, sw_entry,
                                             L3_FIELDSf);
        }

        hw_ipproto_mask = (hw_ipproto_mask >> 16) & 0xff;
        hw_ipproto = (hw_ipproto >> 16) & 0xff;
        sw_ipproto_mask = (sw_ipproto_mask >> 16) & 0xff;
        sw_ipproto = (sw_ipproto >> 16) & 0xff;

        if (hw_ipproto_mask && sw_ipproto_mask) {
            if ((hw_ipproto_mask & hw_ipproto) != (sw_ipproto_mask & sw_ipproto)) {
                return (FALSE);
            }
        }

        if ((hw_etype_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_entry,
                                              L2_ETHER_TYPE_MASKf))) {
            hw_etype = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_entry,
                                           L2_ETHER_TYPEf);
        }

        if ((sw_etype_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, sw_entry,
                                              L2_ETHER_TYPE_MASKf))) {
            sw_etype = soc_mem_field32_get(unit, FP_UDF_TCAMm, sw_entry,
                                           L2_ETHER_TYPEf);
        }

        /*
         * Perform slow protocol PDU Ethertype match.
         * Examples:
         *  Case 1:
         *    if (0x800 or 0x86DD or 0x8847 or 0x8906 or 0x8914) != (0x8809)
         *          return FALSE;
         *  Case 2:
         *    if (0x8809 == 0x8809) then check VLAN Tag match.
         */
        if ((hw_etype_mask && sw_etype_mask)
             && (hw_etype == 0x8809 || sw_etype == 0x8809)) {

            /*
             * For Ethertype == 0x8809.
             * Compare number of VLAN tags in hardware entry vs new entry.
             */
            if ((hw_etype == sw_etype)
                && ((flags_hw & _BCM_FIELD_USER_VLAN_MASK)
                    == (flags_sw & _BCM_FIELD_USER_VLAN_MASK))) {

                /* Matching entry already exists. */
                return (TRUE);

            } else {
                /*
                 * Ethertype vales are not same or Number of VLAN Tags
                 * are different.
                 */
                return (FALSE);
            }
        }
        if ((hw_etype_mask & hw_etype) != (sw_etype_mask & sw_etype)) {
            /*
             * Ethertype vales are not same.
             */
            return (FALSE);
        }
        /* Matching entry already exists. */
        return (TRUE);
    } else {
        /* Matching entry does not exist. */
        return (FALSE);
    }
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_match
 * Purpose:
 *     Match tcam entry against currently instllaed ones
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Stage field control structure.
 *     hw_buf   - (IN) Hw buffer.
 *     tcam_idx - (IN) Allocated tcam index.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_match(int unit, _field_stage_t *stage_fc,
                                uint32 *hw_buf, int *tcam_idx)
{
    uint32 *buffer;      /* Hw buffer to dma udf tcam. */
    uint32 *entry_ptr = 0;   /* Tcam entry pointer.        */
    int alloc_size;      /* Memory allocation size.    */
    int entry_size;      /* Single tcam entry size.    */
    soc_mem_t mem;       /* Udf tcam memory id.        */
    int idx_count;       /* Tcam entry count.          */
    int idx;             /* Tcam entries iterator.     */
    int rv;              /* Operation return status.   */
        uint32 flags_hw = 0; /* UDF entry in Hw */
        uint32 flags_sw = 0; /* UDF entry in Sw */

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == stage_fc) || (NULL == tcam_idx)) {
        return (BCM_E_PARAM);
    }

    mem = FP_UDF_TCAMm;
    idx_count = soc_mem_index_count(unit, mem);
    entry_size = sizeof(fp_udf_tcam_entry_t);
    alloc_size = entry_size * idx_count;

    /* Allocate memory buffer. */
    buffer = soc_cm_salloc(unit, alloc_size, "Udf tcam");
    if (buffer == NULL) {
        return (BCM_E_MEMORY);
    }

    sal_memset(buffer, 0, alloc_size);

    /* Read table to the buffer. */
    rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY,
                            soc_mem_index_min(unit, mem),
                            soc_mem_index_max(unit, mem), buffer);
    if (BCM_FAILURE(rv)) {
        soc_cm_sfree(unit, buffer);
        return (BCM_E_INTERNAL);
    }

    for (idx = 0; idx < idx_count; idx++) {
        if (stage_fc->data_ctrl->tcam_entry_arr[idx].ref_count) {
            entry_ptr = soc_mem_table_idx_to_pointer(unit, mem, uint32 *,
                                                     buffer, idx);
            /* Parse entry key to udf flags. */
            rv = _bcm_field_trx2_udf_tcam_entry_parse(unit, entry_ptr,
                                                      &flags_hw);
            if (BCM_FAILURE(rv)) {
                soc_cm_sfree(unit, buffer);
                return rv;
            }

            /* Parse entry key to udf flags. */
            rv = _bcm_field_trx2_udf_tcam_entry_parse(unit, hw_buf, &flags_sw);
            if (BCM_FAILURE(rv)) {
                soc_cm_sfree(unit, buffer);
                return rv;
            }

            /*
             * Compare hardware entry with new entry to be inserted.
             * If an entry already exists for this packet match format,
             * then return the hardware index of existing entry to increment
             * its reference count.
             */
            if (_field_trx2_udf_tcam_entries_compare(unit, entry_ptr, hw_buf,
                                                     flags_hw, flags_sw)) {
                *tcam_idx = idx;
                break;
            }
        }
    }
    soc_cm_sfree(unit, buffer);
    return (idx < idx_count) ? BCM_E_NONE : BCM_E_NOT_FOUND;
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_insert
 * Purpose:
 *     Insert udf tcam entry into the tcam.
 *     No actual write happens in this routine
 *     only tcam reorganization and index allocation.
 *     SW must write FP_UDF_OFFSET table before inserting
 *     valid tcam entry.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     priority - (IN) Inserted rule priority.
 *     tcam_idx - (IN) Allocated tcam index.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_insert(int unit, uint32 *hw_buf,
                                 uint8 priority, int *tcam_idx)
{
    _field_data_tcam_entry_t *tcam_entry_arr; /* Tcam entries array.  */
    _field_stage_t *stage_fc;      /* Stage field contral structure.  */
    int unused_entry_min;          /* Unused entry before the range.  */
    int unused_entry_max;          /* Unused entry after the range.   */
    int range_min;                 /* Index min for entry insertion.  */
    int range_max;                 /* Index max for entry insertion.  */
    int idx_max;                   /* FP UDF tcam table index max.    */
    int idx;                       /* FP UDF tcam table interator.    */
    int rv;                        /* Operation return status.        */

    /* Input parameters check. */
    if (NULL == tcam_idx) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    idx_max = soc_mem_index_max(unit, FP_UDF_TCAMm);
    range_min = soc_mem_index_min(unit, FP_UDF_TCAMm);
    range_max = idx_max;
    unused_entry_min = unused_entry_max = -1;


    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);
    tcam_entry_arr = stage_fc->data_ctrl->tcam_entry_arr;


    /* Check if identical entry already exists. */
    rv = _field_trx2_udf_tcam_entry_match(unit, stage_fc, hw_buf, tcam_idx);
    if (BCM_SUCCESS(rv)) {
        if (tcam_entry_arr[*tcam_idx].priority != priority) {
            return (BCM_E_RESOURCE);
        }
        tcam_entry_arr[*tcam_idx].ref_count++;
        return (BCM_E_NONE);
    } else if (rv != BCM_E_NOT_FOUND) {
        return (rv);
    }

    /* No identical entry found try to allocate an unused entry and
     * reshuffle tcam if necessary to organize entries by priority.
     */
    for (idx = 0; idx <= idx_max; idx++) {
        if (0 == stage_fc->data_ctrl->tcam_entry_arr[idx].ref_count) {
            if (idx <= range_max) {
                /* Any free index below range max can be used for insertion. */
                unused_entry_min = idx;
            } else {
                /* There is no point to continue after first
                 * free index above range max.
                 */
                unused_entry_max = idx;
                break;
            }
            continue;
        }
        /* Identify insertion range. */
        if (tcam_entry_arr[idx].priority > priority) {
            range_min = idx;
        } else if (tcam_entry_arr[idx].priority < priority) {
            if (idx < range_max) {
                range_max = idx;
            }
        }
    }

    /* Check if tcam is completely full. */
    if ((unused_entry_min == -1) && (unused_entry_max == -1)) {
        return (BCM_E_FULL);
    }

    /*  Tcam entries shuffling. */
    if (unused_entry_min > range_min) {
        *tcam_idx = unused_entry_min;
    } else if (unused_entry_min == -1) {
        rv = _field_trx2_udf_tcam_move_up(unit, stage_fc->data_ctrl,
                                         range_max, unused_entry_max);

        BCM_IF_ERROR_RETURN(rv);
        *tcam_idx = range_max;
    } else if (unused_entry_max == -1) {
        rv = _field_trx2_udf_tcam_move_down(unit, stage_fc->data_ctrl,
                                           range_min, unused_entry_min);
        BCM_IF_ERROR_RETURN(rv);
        *tcam_idx = range_min;
    } else if ((range_min - unused_entry_min) >
               (unused_entry_max - range_max)) {
        rv = _field_trx2_udf_tcam_move_up(unit, stage_fc->data_ctrl,
                                         range_max, unused_entry_max);
        BCM_IF_ERROR_RETURN(rv);
        *tcam_idx = range_max;
    } else {
        rv = _field_trx2_udf_tcam_move_down(unit, stage_fc->data_ctrl,
                                           range_min, unused_entry_min);
        BCM_IF_ERROR_RETURN(rv);
        *tcam_idx = range_min;
    }

    /* Index was successfully allocated. */
    tcam_entry_arr[*tcam_idx].ref_count = 1;
    tcam_entry_arr[*tcam_idx].priority = priority;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_offset_entry_write
 * Purpose:
 *     Write the udf offsets to FP_UDF_OFFSETm
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     flag         - (IN) TRUE for delete, FALSE for others
 *     entry_idx    - (IN) Entry index in FP_UDF_OFFSETm.
 *     udf_num      - (IN) 0 for UDF1_xxx, 1 for UDF2_xxx.
 *     user_num     - (IN) 0 for UDFx_OFFSET0, 1 for UDFx_OFFSET1, ...
 *     offset_base  - (IN) Offset number base point.
 *     offset_value - (IN) Offset word number.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_offset_entry_write(int unit, uint8 flag, int entry_idx,
                                   int udf_num, int user_num,
                                   bcm_field_data_offset_base_t offset_base,
                                   uint32 offset_value)
{
    fp_udf_offset_entry_t offset_buf;    /* Udf offset entry.             */
    int offset_base_encoding;            /* Hw udf offset base encodings. */
    int rv;                              /* Operation return status.      */

    offset_value &= ~_BCM_FIELD_USER_OFFSET_FLAGS;

    /* Maximum Offset value can be 63 */
    if ((offset_value >=
        ((uint32)1 << soc_mem_field_length(unit, FP_UDF_OFFSETm,
                                   _trx2_offset_field[udf_num][user_num]))) ||
            (offset_value > 63)) {
        return BCM_E_PARAM;
    }

    soc_mem_field32_set(unit, FP_UDF_OFFSETm, (uint32 *)&offset_buf,
                        _trx2_offset_field[udf_num][user_num], offset_value);

    rv = soc_mem_read(unit, FP_UDF_OFFSETm, MEM_BLOCK_ANY,
                      entry_idx, (uint32 *)&offset_buf);
    BCM_IF_ERROR_RETURN(rv);

    /* Set udf offset base. */
    switch (offset_base) {
      case bcmFieldDataOffsetBaseHigigHeader:
      case bcmFieldDataOffsetBaseHigig2Header:
          offset_base_encoding = 0;
          break;
      case bcmFieldDataOffsetBasePacketStart:
          offset_base_encoding = 1;
          /* Offset value 126 (2bytes). Offset value 0 pkt offset 2 */
          break;
      case bcmFieldDataOffsetBaseTrillHeader:
      case bcmFieldDataOffsetBaseOuterL3Header:
      case bcmFieldDataOffsetBaseFcoeHeader:
          offset_base_encoding = 2;
          break;
      case bcmFieldDataOffsetBaseInnerL3Header:
      case bcmFieldDataOffsetBaseOuterL4Header:
          offset_base_encoding = 3;
          break;
      case bcmFieldDataOffsetBaseTrillPayload:
      case bcmFieldDataOffsetBaseInnerL4Header:
          offset_base_encoding = 4;
          break;
      default:
          return (BCM_E_PARAM);
    }

    if (flag) {
        /* For delete reset value to 0*/
        offset_base_encoding = 0;
    }

    /* Set udf offset. */
    soc_mem_field32_set(unit, FP_UDF_OFFSETm, (uint32 *)&offset_buf,
                        _trx2_offset_field[udf_num][user_num], offset_value);
    soc_mem_field32_set(unit, FP_UDF_OFFSETm, (uint32 *)&offset_buf,
                        _trx2_base_field[udf_num][user_num],
                        offset_base_encoding);
    /* Write udf offset entry back to HW. */
    rv = soc_mem_write(unit, FP_UDF_OFFSETm, MEM_BLOCK_ALL,
                       entry_idx, (uint32 *)&offset_buf);
    return (rv);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_l3_parse
 * Purpose:
 *     Parse udf tcam entry l3 format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     pkt_fmt  - (OUT) Packet format structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx2_udf_tcam_entry_l3_parse(int unit, uint32 *hw_buf,
                                   bcm_field_data_packet_format_t *pkt_fmt)
{
    uint32 ethertype = -1;
    uint32 inner_iptype = -1;
    uint32 ethertype_mask = -1;
    uint32 outer_iptype = -1;
    uint32 outer_iptype_ip4_val = -1;
    uint32 outer_iptype_ip6_val = -1;
    uint32 outer_iptype_mask = -1;
    uint32 inner_iptype_mask = -1;
    uint32 l3fields = -1;
    uint32 l3fields_mask = -1;
    soc_mem_t mem = FP_UDF_TCAMm;
    uint32 iptype_none_val = 0;
    uint8  fc_header_encode = 0;
    uint8  fc_hdr_encode_mask = 0;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == pkt_fmt)) {
        return (BCM_E_PARAM);
    }
    if (SOC_IS_TD_TT(unit)
        || SOC_IS_KATANAX(unit)
        || SOC_IS_TRIUMPH3(unit)) {
        iptype_none_val = 2;
    }

    if ((ethertype_mask =
            soc_mem_field32_get(unit, mem, hw_buf, L2_ETHER_TYPE_MASKf))) {
        ethertype = soc_mem_field32_get(unit, mem, hw_buf, L2_ETHER_TYPEf);
    }

    if ((inner_iptype_mask =
            soc_mem_field32_get(unit, mem, hw_buf, INNER_IP_TYPE_MASKf))) {
        inner_iptype = soc_mem_field32_get(unit, mem, hw_buf, INNER_IP_TYPEf);
    }

    outer_iptype = soc_mem_field32_get(unit, mem, hw_buf, OUTER_IP_TYPEf);
    outer_iptype_mask =  soc_mem_field32_get(unit, mem,
                                          hw_buf, OUTER_IP_TYPE_MASKf);

    if ((l3fields_mask =
            soc_mem_field32_get(unit, mem, hw_buf, L3_FIELDS_MASKf))) {
        l3fields = soc_mem_field32_get(unit, mem, hw_buf, L3_FIELDSf);
    } else if (0x8847 == ethertype) {
        /* MPLS_ANY has L3_FIELDSf == 0 */
        l3fields = soc_mem_field32_get(unit, mem, hw_buf, L3_FIELDSf);
    }

    outer_iptype_ip4_val = 2;
    outer_iptype_ip6_val = 4;
#if defined(BCM_TRIDENT_SUPPORT)
   if (SOC_IS_TRIUMPH3(unit)
       || SOC_IS_TD_TT(unit)) {
       outer_iptype_ip4_val = 1;
       outer_iptype_ip6_val = 5;
   }
#endif

    /*
     * Logic below implicitly checks Ethertype value for IP, MPLS and FCoE
     * frames.
     * 0x0800 - IPv4, 0x86DD - IPv6, 0x8847 - MPLS , 0x8906 + 0x8914 - FCoE
     */

    if ((ethertype == 0x800) && (outer_iptype == outer_iptype_ip4_val)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4_WITH_OPTIONS;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else if ((ethertype == 0x86dd) &&
               (outer_iptype == outer_iptype_ip6_val)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6_WITH_OPTIONS;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else if ((ethertype == 0x800) && (inner_iptype ==  iptype_none_val)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else if ((ethertype == 0x86dd) && (inner_iptype ==  iptype_none_val)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else if ((ethertype == 0x800) && (l3fields ==  0x40000)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP4;
    } else if ((ethertype == 0x800) && (l3fields ==  0x290000)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP6;
    } else if ((ethertype == 0x86dd) && (l3fields ==  0x40000)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP4;
    } else if ((ethertype == 0x86dd) && (l3fields ==  0x290000)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP6;
    } else if ((ethertype == 0x800) && (l3fields ==  0x2f0800)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_GRE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP4;
    } else if ((ethertype == 0x800) && (l3fields ==  0x2f86dd)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_GRE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP4;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP6;
    } else if ((ethertype == 0x86dd) && (l3fields ==  0x2f0800)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_GRE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP4;
    } else if ((ethertype == 0x86dd) && (l3fields ==  0x2f86dd)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_GRE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP6;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP6;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x1)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_ONE_LABEL;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x2)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_TWO_LABELS;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x3)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_THREE_LABELS;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x4)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_FOUR_LABELS;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x5)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_FIVE_LABELS;
    } else if ((ethertype == 0x8847) && (l3fields ==  0x0)) {
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS;
        pkt_fmt->mpls = BCM_FIELD_DATA_FORMAT_MPLS_ANY;
    } else if (ethertype == 0x8906 || ethertype == 0x8914) {
        pkt_fmt->tunnel = (ethertype == 0x8906)
            ? BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE
            : BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE_INIT;


        fc_header_encode = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                FC_HDR_ENCODE_1f);
        fc_hdr_encode_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                FC_HDR_ENCODE_1_MASKf);


        switch (fc_header_encode & fc_hdr_encode_mask) {
            case 0:
                pkt_fmt->fibre_chan_outer
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY;
                break;
            case 1:
                pkt_fmt->fibre_chan_outer
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN;
                break;
            case 2:
                pkt_fmt->fibre_chan_outer
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_VIRTUAL;
                break;
            case 3:
                pkt_fmt->fibre_chan_outer
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ENCAP;
                break;
            case 4:
                pkt_fmt->fibre_chan_outer
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ROUTED;
                break;
            default:
                return (BCM_E_INTERNAL);
        }

        fc_header_encode = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                FC_HDR_ENCODE_2f);
        fc_hdr_encode_mask = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                FC_HDR_ENCODE_2_MASKf);


        switch (fc_header_encode & fc_hdr_encode_mask) {
            case 0:
                pkt_fmt->fibre_chan_inner
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY;
                break;
            case 1:
                pkt_fmt->fibre_chan_inner
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN;
                break;
            case 2:
                pkt_fmt->fibre_chan_inner
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_VIRTUAL;
                break;
            case 3:
                pkt_fmt->fibre_chan_inner
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ENCAP;
                break;
            case 4:
                pkt_fmt->fibre_chan_inner
                    = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ROUTED;
                break;
            default:
                return (BCM_E_INTERNAL);
        }
    } else if (outer_iptype_mask == 0x7) {
        /*
         * For Non-IP traffic: OUTER_IP_TYPE_MASK = 0x7 and
         * OUTER_IP_TYPE = 0 (TR2) or 2 (Trident, Katana).
         */
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else if (0x0 == ethertype_mask && 0x0 == inner_iptype_mask
                && 0x0 == outer_iptype_mask && 0x0 == l3fields_mask) {
        /*
         * Do not care about IP headers and Tunnel Type.
         */
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_ANY;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP_ANY;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_ANY;
    } else if ((outer_iptype_mask == 0x0) &&
                (inner_iptype_mask == 0x7)){
        /*
         * Do not care about Outer IP. Inner IP is not valid
         * as its not a Tunnel.
         */
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP_ANY;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_ANY;
    } else if (((0xffff == ethertype_mask) ||
                (0xff0000 == l3fields_mask)) &&
               (outer_iptype_mask == 0x0 &&
                inner_iptype_mask == 0x0)) {
        /* since l3_init is not done in UDF
           bcm_field_data_qualifier_ip_protocol_add()
           bcm_field_data_qualifier_ethertype_add().
           Just a place holder to detect UDF
           bcm_field_data_qualifier_packet_format_add() */
        pkt_fmt->tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
        pkt_fmt->outer_ip = BCM_FIELD_DATA_FORMAT_IP_ANY;
        pkt_fmt->inner_ip = BCM_FIELD_DATA_FORMAT_IP_NONE;
    } else {
        return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_l3_init
 * Purpose:
 *     Initialize udf tcam entry l2 format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     pkt_fmt  - (IN) Packet format structure.
 *     hw_buf   - (IN/OUT) Hw buffer.
 *     priority - (IN/OUT) udf tcam entry priority.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_l3_init(int unit,
                                  bcm_field_data_packet_format_t *pkt_fmt,
                                  uint32 *hw_buf, uint8 *priority)
{
    int key;
    int mask;
    uint32 iptype_none_val = 0;
    uint32 outer_iptype_ip4_val = 0;
    uint32 outer_iptype_ip6_val = 0;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    if (SOC_IS_TD_TT(unit)
        || SOC_IS_KATANAX(unit)
        || SOC_IS_TRIUMPH3(unit)) {
        iptype_none_val = 2;
    }

    outer_iptype_ip4_val = 2;
    outer_iptype_ip6_val = 4;
#if defined(BCM_TRIDENT_SUPPORT)
   if (SOC_IS_TRIUMPH3(unit)
       || SOC_IS_TD_TT(unit)) {
       outer_iptype_ip4_val = 1;
       outer_iptype_ip6_val = 5;
   }
#endif

    if (pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_NONE) {

        *priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;
        /* inner ip type (none). */
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                            INNER_IP_TYPEf, iptype_none_val);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                            INNER_IP_TYPE_MASKf, 0x7);

        if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP4_WITH_OPTIONS) {
            /* L2 ether type 0x800 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x800);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPEf, outer_iptype_ip4_val);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPE_MASKf, 0x7);
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP6_WITH_OPTIONS) {
            /* L2 ether type 0x86dd */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x86dd);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPEf, outer_iptype_ip6_val);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPE_MASKf, 0x7);
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP4) {
            /* L2 ether type 0x800 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x800);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP6) {
            /* L2 ether type 0x86dd */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x86dd);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP_NONE) {
            /* Non IP traffic only */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPEf, iptype_none_val);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPE_MASKf, 0x7);
        } else {
            /* Outer ip type don't care */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                OUTER_IP_TYPE_MASKf, 0x0);
        }
    } else if (pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP) {
        *priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;
        if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP4) {
            /* L2 ether type 0x800 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x800);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);

            if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP4) {
                /* Inner ip protocol v4. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x40000);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xff0000);
            } else if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP6) {
                /* Inner ip protocol v6. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x290000);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xff0000);
            } else {
                return (BCM_E_UNAVAIL);
            }
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP6) {
            /* L2 ether type 0x86dd */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x86dd);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);

            if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP4) {
                /* Inner ip protocol v4. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x40000);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xff0000);
            } else if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP6) {
                /* Inner ip protocol v6. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x290000);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xff0000);
            } else {
                return (BCM_E_UNAVAIL);
            }
        } else {
            return (BCM_E_UNAVAIL);
        }
    } else if (pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_GRE) {

        *priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;
        if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP4) {
            /* L2 ether type 0x800 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x800);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);

            if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP4) {
                /* Inner ip protocol gre, gre ethertype 0x800. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x02f0800);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xffffff);
            } else if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP6) {
                /* Inner ip protocol gre, gre ethertype 0x86dd. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x02f86dd);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xffffff);
            } else {
                return (BCM_E_UNAVAIL);
            }
        } else if (pkt_fmt->outer_ip == BCM_FIELD_DATA_FORMAT_IP6) {
            /* L2 ether type 0x86dd */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPEf, 0x86dd);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L2_ETHER_TYPE_MASKf, 0xffff);

            if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP4) {
                /* Inner ip protocol gre, gre ethertype 0x800. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x02f0800);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xffffff);
            } else if (pkt_fmt->inner_ip == BCM_FIELD_DATA_FORMAT_IP6) {
                /* Inner ip protocol gre, gre ethertype 0x86dd. */
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDSf, 0x02f86dd);
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                    L3_FIELDS_MASKf, 0xffffff);
            } else {
                return (BCM_E_UNAVAIL);
            }
        } else {
            return (BCM_E_UNAVAIL);
        }
    } else if (pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS) {

                *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FORMAT;

        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                            L2_ETHER_TYPEf, 0x8847);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                            L2_ETHER_TYPE_MASKf, 0xffff);
        if (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_ONE_LABEL) {

            *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_ONE_LABEL;

            /* L2 ether type 0x8847, outer label1 bos == 1 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x1);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0xffffff);
        } else if (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_TWO_LABELS) {

            *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_TWO_LABEL;

            /* L2 ether type 0x8847, outer label1 bos == 0 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x2);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0xffffff);
        }
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
        else if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) &&
                 (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_THREE_LABELS)) {

            *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_THREE_LABEL;

            /* L2 ether type 0x8847, outer label1 bos == 0 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x3);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0xffffff);
        } else if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) &&
                   (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_FOUR_LABELS)) {

            *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FOUR_LABEL;

            /* L2 ether type 0x8847, outer label1 bos == 0 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x4);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0xffffff);
        } else if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) &&
                   (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_FIVE_LABELS)) {

            *priority += _FP_DATA_QUALIFIER_PRIO_MPLS_FIVE_LABEL;

            /* L2 ether type 0x8847, outer label1 bos == 0 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x5);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0xffffff);
        }
#endif /* BCM_TRIUMPH3_SUPPORT || BCM_KATANA2_SUPPORT */
        else if (pkt_fmt->mpls == BCM_FIELD_DATA_FORMAT_MPLS_ANY) {
            /* L2 ether type 0x8847 */
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDSf, 0x0);
            soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                                L3_FIELDS_MASKf, 0x0);
        } else {
            return (BCM_E_UNAVAIL);
        }
    } else if (pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE ||
               pkt_fmt->tunnel == BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE_INIT) {
        if (!SOC_MEM_FIELD_VALID(unit, FP_UDF_TCAMm, FC_HDR_ENCODE_1f)) {
            return BCM_E_UNAVAIL;
        }

        *priority += _FP_DATA_QUALIFIER_PRIO_FCOE_FORMAT;

        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L2_ETHER_TYPEf,
                            pkt_fmt->tunnel ==
                            BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE ?
                            0x8906 : 0x8914);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L2_ETHER_TYPE_MASKf,
                            0xffff);

        mask = 0x7;
        switch (pkt_fmt->fibre_chan_outer) {
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN:
                key = 1;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ENCAP:
                key = 3;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_VIRTUAL:
                key = 2;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ROUTED:
                key = 4;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY:
                key = 0;
                mask = 0;
                break;
            default:
                return BCM_E_UNAVAIL;
        }
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_1f,
            key);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_1_MASKf,
            mask);

        /* Entry matching on two extended headers has higher priority */
        if ((pkt_fmt->fibre_chan_outer != BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY) &&
                (pkt_fmt->fibre_chan_inner != BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY)) {
            *priority += _FP_DATA_QUALIFIER_PRIO_FCOE_FORMAT;
        }
        mask = 0x07;

        switch (pkt_fmt->fibre_chan_inner) {
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN:
                key = 1;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ENCAP:
                key = 3;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_VIRTUAL:
                key = 2;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ROUTED:
                key = 4;
                break;
            case BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY:
                key = 0;
                mask = 0;
                break;
            default:
                return BCM_E_UNAVAIL;
        }
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                FC_HDR_ENCODE_2f, key);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                FC_HDR_ENCODE_2_MASKf, mask);
    } else if (BCM_FIELD_DATA_FORMAT_TUNNEL_ANY == pkt_fmt->tunnel
                && BCM_FIELD_DATA_FORMAT_IP_ANY == pkt_fmt->outer_ip
                && BCM_FIELD_DATA_FORMAT_IP_ANY == pkt_fmt->inner_ip) {
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L2_ETHER_TYPEf, 0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L2_ETHER_TYPE_MASKf,
            0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L3_FIELDSf, 0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, L3_FIELDS_MASKf, 0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, OUTER_IP_TYPEf, 0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, OUTER_IP_TYPE_MASKf,
            0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, INNER_IP_TYPEf, 0x0);
        soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, INNER_IP_TYPE_MASKf,
            0x0);
        if (SOC_MEM_FIELD_VALID(unit,FP_UDF_TCAMm,FC_HDR_ENCODE_1f)) {
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_1f, 0);
        }
        if (SOC_MEM_FIELD_VALID(unit,FP_UDF_TCAMm,FC_HDR_ENCODE_1_MASKf)) {
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_1_MASKf, 0x0);
        }
        if (SOC_MEM_FIELD_VALID(unit,FP_UDF_TCAMm,FC_HDR_ENCODE_2f)) {
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_2f, 0);
        }
        if (SOC_MEM_FIELD_VALID(unit,FP_UDF_TCAMm,FC_HDR_ENCODE_2_MASKf)) {
                soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, FC_HDR_ENCODE_2_MASKf, 0x0);
        }
    } else {
        return (BCM_E_UNAVAIL);
    }

    *priority += _FP_DATA_QUALIFIER_PRIO_L3_FORMAT;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_vlanformat_parse
 * Purpose:
 *     Parse udf tcam entry l2 format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     vlanformat - (OUT) BCM_FIELD_DATA_FORMAT_L2_XXX
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx2_udf_tcam_entry_vlanformat_parse(int unit, uint32 *hw_buf,
                                           uint16 *vlanformat)
{
    uint32 tag_status;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == vlanformat)) {
        return (BCM_E_PARAM);
    }

    if (soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf, L2_TAG_STATUS_MASKf)) {
        tag_status = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                         L2_TAG_STATUSf);
        switch (tag_status) {
          case 0:
              *vlanformat = BCM_FIELD_DATA_FORMAT_VLAN_NO_TAG;
              break;
          case 1:
              *vlanformat = BCM_FIELD_DATA_FORMAT_VLAN_SINGLE_TAGGED;
              break;
          case 2:
              *vlanformat = BCM_FIELD_DATA_FORMAT_VLAN_DOUBLE_TAGGED;
              break;
          default:
              break;
        }
    } else {
        *vlanformat = BCM_FIELD_DATA_FORMAT_VLAN_TAG_ANY;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_vlanformat_init
 * Purpose:
 *     Initialize udf tcam entry vlan tag format match key.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     vlanformat - (IN) BCM_FIELD_DATA_FORMAT_L2_XXX
 *     hw_buf     - (IN/OUT) Hw buffer.
 *     priority   - (OUT) tcam entry priority.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_vlanformat_init(int unit, uint16 vlanformat,
                                          uint32 *hw_buf, uint8 *priority)
{
    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    /* Translate L2 flag bits to index */
    switch (vlanformat) {
      case BCM_FIELD_DATA_FORMAT_VLAN_NO_TAG:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUSf, 0);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUS_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_VLAN_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_VLAN_SINGLE_TAGGED:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUSf, 1);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUS_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_VLAN_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_VLAN_DOUBLE_TAGGED:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUSf, 2);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUS_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_VLAN_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_VLAN_TAG_ANY:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUSf, 0);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TAG_STATUS_MASKf, 0);
          break;
      default:
          return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_l2format_parse
 * Purpose:
 *     Parse udf tcam entry l2 format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     l2format - (OUT) BCM_FIELD_DATA_FORMAT_L2_XXX
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx2_udf_tcam_entry_l2format_parse(int unit, uint32 *hw_buf,
                                         uint16 *l2format)
{
    uint32 l2type;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == l2format)) {
        return (BCM_E_PARAM);
    }

    if (soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf, L2_TYPE_MASKf)) {
        l2type = soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf, L2_TYPEf);
        switch (l2type) {
          case 0:
              *l2format = BCM_FIELD_DATA_FORMAT_L2_ETH_II;
              break;
          case 1:
              *l2format = BCM_FIELD_DATA_FORMAT_L2_SNAP;
              break;
          case 2:
              *l2format = BCM_FIELD_DATA_FORMAT_L2_LLC;
              break;
          default:
              break;
        }
    } else {
        *l2format = BCM_FIELD_DATA_FORMAT_L2_ANY;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_flags_parse
 * Purpose:
 *     Parse udf tcam entry flags format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     flags    - (OUT) BCM_FIELD_DATA_FORMAT_F_XXX
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx2_udf_tcam_entry_flags_parse(int unit, uint32 *hw_buf,
                                       uint32 *flags)
{
    uint32 type;
    uint32 field_mask = 0;
    uint32 field = 1;
    uint32 flag = 2;
    uint32 no_flag = 3;
    uint32 ct;


    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == flags)) {
        return (BCM_E_PARAM);
    }

    for (ct = 0; ; ct++) {
        if (udf_fields_f[ct][field] == INVALIDf) {
           break;
        }
        /* Validate udf field flags */
        if (soc_mem_field_valid(unit, FP_UDF_TCAMm,
                                 udf_fields_f[ct][field]) == FALSE) {
           continue;
        }

        if (soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf,
                                udf_fields_f[ct][field_mask])) {
            type = soc_mem_field32_get(unit, FP_UDF_TCAMm,
                                       hw_buf,
                                       udf_fields_f[ct][field]);
            switch (type) {
                 case 0:
                    *flags |= udf_fields_f[ct][no_flag];
                     break;
                 case 1:
                    *flags |= udf_fields_f[ct][flag];
                     break;
                 default:
                     break;
            }
        }
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_trx2_udf_tcam_entry_l2format_init
 * Purpose:
 *     Initialize udf tcam entry l2 format match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     l2format - (IN) BCM_FIELD_DATA_FORMAT_L2_XXX
 *     hw_buf   - (OUT) Hw buffer.
 *     priority - (OUT) Tcam entry priority
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_l2format_init(int unit, uint16 l2format,
                                        uint32 *hw_buf, uint8 *priority)
{
    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    /* Translate L2 flag bits to index */
    switch (l2format) {
      case BCM_FIELD_DATA_FORMAT_L2_ETH_II:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPEf, 0);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPE_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_L2_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_L2_SNAP:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPEf, 1);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPE_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_L2_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_L2_LLC:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPEf, 2);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPE_MASKf, 0x3);
          *priority += _FP_DATA_QUALIFIER_PRIO_L2_FORMAT;
          break;
      case BCM_FIELD_DATA_FORMAT_L2_ANY:
          /* L2 Format . */
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPEf, 0);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              L2_TYPE_MASKf, 0);
          break;
      default:
          return (BCM_E_PARAM);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_udf_tcam_entry_flags_init
 * Purpose:
 *     Initialize udf tcam entry flags match key.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     flags    - (IN) BCM_FIELD_DATA_FORMAT_F_XXX
 *     hw_buf   - (OUT) Hw buffer.
 *     priority - (OUT) Tcam entry priority
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_udf_tcam_entry_flags_init(int unit, uint32 flags,
                                      uint32 *hw_buf, uint8 *priority)
{
    int8 valid = 0;
    uint32 field_mask = 0;
    uint32 field = 1;
    uint32 flag = 2;
    uint32 no_flag = 3;
    uint32 ct, data, mask;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    for (ct = 0; ; ct++) {
       if (udf_fields_f[ct][field] == INVALIDf) {
          break;
       }
       /* Validate udf field flags */
       valid = soc_mem_field_valid(unit, FP_UDF_TCAMm,
                                   udf_fields_f[ct][field]);
       if (valid == TRUE) {
          if (flags & udf_fields_f[ct][flag]) {
              data = 1;
              mask = 1;
              *priority += _FP_DATA_QUALIFIER_PRIO_FLAGS;
          } else if (flags & udf_fields_f[ct][no_flag]) {
              data = 0;
              mask = 1;
              *priority += _FP_DATA_QUALIFIER_PRIO_FLAGS;
          } else {
              continue;
          }
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              udf_fields_f[ct][field], data);
          soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                              udf_fields_f[ct][field_mask], mask);
       } else if (flags & udf_fields_f[ct][flag]) {
          return (BCM_E_UNAVAIL);
       }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_trx2_udf_tcam_entry_parse
 * Purpose:
 *     Parse udf tcam entry key
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     hw_buf   - (IN) Hw buffer.
 *     flags    - (OUT) Udf spec index (encoded flags).
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx2_udf_tcam_entry_parse(int unit, uint32 *hw_buf, uint32 *flags)
{
    bcm_field_data_packet_format_t pkt_fmt;
    int rv;

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == flags)) {
        return (BCM_E_PARAM);
    }
    bcm_field_data_packet_format_t_init(&pkt_fmt);

    /* Get valid bit. */
    if (soc_mem_field32_get(unit, FP_UDF_TCAMm, hw_buf, VALIDf)) {
        *flags = _BCM_FIELD_USER_OFFSET_VALID;
    } else {
        *flags = 0;
        return (BCM_E_NONE);
    }

    /* Parse vlan_tag format.*/
    rv = _field_trx2_udf_tcam_entry_vlanformat_parse(unit, hw_buf,
                                                    &pkt_fmt.vlan_tag);
    BCM_IF_ERROR_RETURN(rv);

    /* Parse l2 format.*/
    rv = _field_trx2_udf_tcam_entry_l2format_parse(unit, hw_buf, &pkt_fmt.l2);
    BCM_IF_ERROR_RETURN(rv);

    /* Parse l3 fields.*/
    rv = _field_trx2_udf_tcam_entry_l3_parse(unit, hw_buf, &pkt_fmt);
    BCM_IF_ERROR_RETURN(rv);

    /* Parse Flags fields */
    rv = _field_trx2_udf_tcam_entry_flags_parse(unit, hw_buf, &pkt_fmt.flags);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * Translate Data qualifier representation to UDF flag bits value.
     */

    /* IPv4, IPv6, MPLS and FCoE packet formats are taken care below. */
    if (BCM_FIELD_DATA_FORMAT_TUNNEL_NONE == pkt_fmt.tunnel) {
        if (BCM_FIELD_DATA_FORMAT_IP4_WITH_OPTIONS == pkt_fmt.outer_ip) {
            *flags |=  (_BCM_FIELD_USER_IP4_HDR_ONLY |
                        _BCM_FIELD_USER_OPTION_ADJUST);
        } else if (BCM_FIELD_DATA_FORMAT_IP6_WITH_OPTIONS == pkt_fmt.outer_ip) {
            *flags |=  (_BCM_FIELD_USER_IP6_HDR_ONLY |
                        _BCM_FIELD_USER_OPTION_ADJUST);
        } else if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.outer_ip) {
            *flags |= _BCM_FIELD_USER_IP4_HDR_ONLY;
        } else  if (BCM_FIELD_DATA_FORMAT_IP6 ==  pkt_fmt.outer_ip) {
            *flags |= _BCM_FIELD_USER_IP6_HDR_ONLY;
        } else {
            *flags |= _BCM_FIELD_USER_IP_NOTUSED;
        }
    } else if (BCM_FIELD_DATA_FORMAT_TUNNEL_IP_IN_IP == pkt_fmt.tunnel) {
        if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.outer_ip) {
            if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_IP4_OVER_IP4;
            } else if (BCM_FIELD_DATA_FORMAT_IP6 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_IP6_OVER_IP4;
            }
        } else {
            if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_IP4_OVER_IP6;
            } else if (BCM_FIELD_DATA_FORMAT_IP6 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_IP6_OVER_IP6;
            }
        }
    } else if (BCM_FIELD_DATA_FORMAT_TUNNEL_GRE == pkt_fmt.tunnel) {
        if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.outer_ip) {
            if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_GRE_IP4_OVER_IP4;
            } else if (BCM_FIELD_DATA_FORMAT_IP6 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_GRE_IP6_OVER_IP4;
            }
        } else {
            if (BCM_FIELD_DATA_FORMAT_IP4 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_GRE_IP4_OVER_IP6;
            } else if (BCM_FIELD_DATA_FORMAT_IP6 ==  pkt_fmt.inner_ip) {
                *flags |= _BCM_FIELD_USER_GRE_IP6_OVER_IP6;
            }
        }
    } else if (BCM_FIELD_DATA_FORMAT_TUNNEL_MPLS == pkt_fmt.tunnel) {
        if (BCM_FIELD_DATA_FORMAT_MPLS_ONE_LABEL ==  pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_ONE_MPLS_LABEL;
        } else if (BCM_FIELD_DATA_FORMAT_MPLS_TWO_LABELS == pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_TWO_MPLS_LABELS;
        } else if (BCM_FIELD_DATA_FORMAT_MPLS_THREE_LABELS == pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_THREE_MPLS_LABELS;
        } else if (BCM_FIELD_DATA_FORMAT_MPLS_FOUR_LABELS == pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_FOUR_MPLS_LABELS;
        } else if (BCM_FIELD_DATA_FORMAT_MPLS_FIVE_LABELS == pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_FIVE_MPLS_LABELS;
        } else if (BCM_FIELD_DATA_FORMAT_MPLS_ANY == pkt_fmt.mpls) {
            *flags |= _BCM_FIELD_USER_ANY_MPLS_LABELS;
        }
    } else if ((BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE == pkt_fmt.tunnel)
                || (BCM_FIELD_DATA_FORMAT_TUNNEL_FCOE_INIT == pkt_fmt.tunnel)) {
        if ((BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY != pkt_fmt.fibre_chan_inner) &&
            (BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY !=  pkt_fmt.fibre_chan_outer)) {
            *flags |= _BCM_FIELD_USER_TWO_FCOE_HEADER;
        } else if ((BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY
                    !=  pkt_fmt.fibre_chan_outer)
                   && (BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY
                       == pkt_fmt.fibre_chan_inner)) {
            *flags |= _BCM_FIELD_USER_ONE_FCOE_HEADER;
        }
    }


    /* Get VLAN tag format flags. */
    switch (pkt_fmt.vlan_tag) {
      case BCM_FIELD_DATA_FORMAT_VLAN_NO_TAG:
          *flags |= _BCM_FIELD_USER_VLAN_NOTAG;
          break;
      case BCM_FIELD_DATA_FORMAT_VLAN_SINGLE_TAGGED:
          *flags |= _BCM_FIELD_USER_VLAN_ONETAG;
          break;
      case BCM_FIELD_DATA_FORMAT_VLAN_DOUBLE_TAGGED:
          *flags |= _BCM_FIELD_USER_VLAN_TWOTAG;
          break;
      default:
          /* For VLAN Tag Any. */
          *flags |= _BCM_FIELD_USER_VLAN_NOTUSED;
          break;
    }

    /* Get L2 format flags. */
    switch (pkt_fmt.l2) {
      case BCM_FIELD_DATA_FORMAT_L2_ETH_II:
          *flags |= _BCM_FIELD_USER_L2_ETHERNET2;
          break;
      case BCM_FIELD_DATA_FORMAT_L2_SNAP:
          *flags |= _BCM_FIELD_USER_L2_SNAP;
          break;
      case BCM_FIELD_DATA_FORMAT_L2_LLC:
          *flags |= _BCM_FIELD_USER_L2_LLC;
          break;
      default:
          /* For L2 Tag Any. */
          *flags |= _BCM_FIELD_USER_L2_OTHER;
          break;
    }

    /* Get UDF flags format */
    if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_ENCAP_STACK) {
       *flags |= _BCM_FIELD_USER_F_ENCAP_STACK;
    } else if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_NO_ENCAP_STACK) {
       *flags |= _BCM_FIELD_USER_F_NO_ENCAP_STACK;
    } else {
       *flags |= _BCM_FIELD_USER_F_ENCAP_STACK_ANY;
    }

    if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_VNTAG) {
       *flags |= _BCM_FIELD_USER_F_VNTAG;
    } else if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_NO_VNTAG) {
       *flags |= _BCM_FIELD_USER_F_NO_VNTAG;
    } else {
       *flags |= _BCM_FIELD_USER_F_VNTAG_ANY;
    }

    if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_CNTAG) {
       *flags |= _BCM_FIELD_USER_F_CNTAG;
    } else if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_NO_CNTAG) {
       *flags |= _BCM_FIELD_USER_F_NO_CNTAG;
    } else {
       *flags |= _BCM_FIELD_USER_F_CNTAG_ANY;
    }

    if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_ETAG) {
       *flags |= _BCM_FIELD_USER_F_ETAG;
    } else if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_NO_ETAG) {
       *flags |= _BCM_FIELD_USER_F_NO_ETAG;
    } else {
       *flags |= _BCM_FIELD_USER_F_ETAG_ANY;
    }

    if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_ICNM) {
       *flags |= _BCM_FIELD_USER_F_ICNM;
    } else if (pkt_fmt.flags & BCM_FIELD_DATA_FORMAT_F_NO_ICNM) {
       *flags |= _BCM_FIELD_USER_F_NO_ICNM;
    } else {
       *flags |= _BCM_FIELD_USER_F_ICNM_ANY;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx2_data_offset_install
 * Purpose:
 *     Write the info in udf_tcam/udf_offset to the hardware
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     flag     - (IN) TRUE for delete, FALSE for others
 *     tbl_idx  - (IN) FP_UDF_OFFSET table index.
 *     f_dq     - (IN) Data qualifier structure.
 *     offset   - (IN) Word offset value FP_UDF_OFFSETm.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_data_tcam_offset_install(int unit, uint8 flag,
                                    _field_data_qualifier_t *f_dq,
                                    int tbl_idx, int offset)
{
    _field_stage_t *stage_fc;
    uint32  word_offset; /* Offset iterator.              */
    int     udf_idx, user_idx;
    int     rv;          /* Operation return status.      */

    /* Input parameters check. */
    if (NULL == f_dq) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    word_offset = (offset < 0) ? 0 : (uint32)offset;

    /* Find a proper word to insert the data. */
    for (udf_idx = 0; udf_idx < 2; udf_idx++) {
        for (user_idx = 0; user_idx < stage_fc->data_ctrl->num_elems;
             user_idx++) {
            if (!(f_dq->hw_bmap &
                  (1 << (udf_idx *
                         stage_fc->data_ctrl->num_elems + user_idx)))) {
                continue;
            }

            rv = _field_trx2_udf_offset_entry_write(unit, flag, tbl_idx, udf_idx,
                                                    user_idx,
                                                    f_dq->offset_base,
                                                    word_offset);
            BCM_IF_ERROR_RETURN(rv);

            if (offset >= 0) {
                word_offset++;
            }
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_trx2_data_elem_offset_calc
 * Purpose:
 *     Calculate element offset based on data qualifier
 *     relative offset, base offset and common offset.
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     f_dq             - (IN) Data qualifier structure.
 *     reltive_offset   - (IN) Word offset value FP_UDF_OFFSETm.
 *     elem_offset       - (OUT) Calculated index value.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx2_data_elem_offset_calc(int unit, _field_data_qualifier_t *f_dq,
                                  int relative_offset, int *elem_offset)
{
    _field_stage_t *stage_fc;
    int offset;

    /* Input parameters check. */
    if ((NULL == f_dq) || (NULL == elem_offset)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    offset = f_dq->offset + relative_offset;

    if (stage_fc->data_ctrl->elem_size <= 2) { /* no wrap around needed */
        offset = (offset % 128) / stage_fc->data_ctrl->elem_size;
    } else {
        switch (f_dq->offset_base) {
        case bcmFieldDataOffsetBaseHigigHeader:
        case bcmFieldDataOffsetBaseHigig2Header:
            offset = ((offset + 2) % 128) / 4;
            break;
        case bcmFieldDataOffsetBasePacketStart:
            offset = ((offset + 2) % 128) / 4;
            break;
        default:
            offset = (offset % 128) / 4;
            break;
        }
    }

    *elem_offset = offset;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _field_trx2_data_qualifier_etype_tcam_key_init
 * Purpose:
 *      Initialize ethertype based udf tcam entry.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      etype      - (IN) Ethertype based offset specification.
 *      hw_buf     - (OUT) Hardware buffer.
 *      priority   - (OUT) Tcam entry priority
 * Returns:
 *      BCM_E_XXX
 */
int
_field_trx2_data_qualifier_etype_tcam_key_init(int unit,
                                              bcm_field_data_ethertype_t *etype,
                                              uint32 *hw_buf, uint8 *priority)
{
    int rv;               /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    *priority = 0;

    /* Set valid bit. */
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, VALIDf, 1);

    /* Set l2 format. */
    rv = _field_trx2_udf_tcam_entry_l2format_init(unit, etype->l2,
                                                 hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set vlan tag format. */
    rv = _field_trx2_udf_tcam_entry_vlanformat_init(unit, etype->vlan_tag,
                                                   hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set Flags packet format */
    BCM_IF_ERROR_RETURN(_field_trx2_udf_tcam_entry_flags_init(unit,
                                                              etype->flags,
                                                              hw_buf,
                                                              priority));
    /* Set ethertype value. */
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                        L2_ETHER_TYPEf, etype->ethertype);
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                        L2_ETHER_TYPE_MASKf, 0xffff);
    *priority += _FP_DATA_QUALIFIER_PRIO_MISC;

    return (rv);
}

/*
 * Function:
 *      _field_trx2_data_qualifier_ip_proto_tcam_key_init
 * Purpose:
 *      Initialize ethertype based udf tcam entry.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      ip_proto   - (IN) Ip Protocol based offset specification.
 *      hw_buf     - (OUT) Hardware buffer.
 *      priority   - (OUT) Tcam entry priority
 * Returns:
 *      BCM_E_XXX
 */
int
_field_trx2_data_qualifier_ip_proto_tcam_key_init(int unit,
                                 bcm_field_data_ip_protocol_t *ip_proto,
                                 uint32 *hw_buf, uint8 *priority)
{
    int rv;               /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    *priority = 0;

    /* Set valid bit. */
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, VALIDf, 1);

    /* Set l2 format. */
    rv = _field_trx2_udf_tcam_entry_l2format_init(unit, ip_proto->l2,
                                                 hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set vlan tag format. */
    rv = _field_trx2_udf_tcam_entry_vlanformat_init(unit, ip_proto->vlan_tag,
                                                   hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set ethertype value. */
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                        L3_FIELDSf, (ip_proto->ip << 16));
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf,
                        L3_FIELDS_MASKf, 0xff0000);
    if (ip_proto->ip) {
        *priority += _FP_DATA_QUALIFIER_PRIO_IPPROTO;
    }
    *priority += _FP_DATA_QUALIFIER_PRIO_MISC;

    return (rv);
}

/*
 * Function:
 *      _field_trx2_data_qualifier_pkt_format_tcam_key_init
 * Purpose:
 *      Initialize ethertype based udf tcam entry.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      pkt_format - (IN) Packet format based offset specification.
 *      hw_buf     - (OUT) Hardware buffer.
 *      priority   - (OUT) Tcam entry priority
 * Returns:
 *      BCM_E_XXX
 */
int
_field_trx2_data_qualifier_pkt_format_tcam_key_init(int unit,
                                 bcm_field_data_packet_format_t *pkt_format,
                                 uint32 *hw_buf, uint8 *priority)
{
    int rv;               /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == hw_buf) || (NULL == priority)) {
        return (BCM_E_PARAM);
    }

    *priority = 0;

    /* Set valid bit. */
    soc_mem_field32_set(unit, FP_UDF_TCAMm, hw_buf, VALIDf, 1);

    /* Set l2 format. */
    rv = _field_trx2_udf_tcam_entry_l2format_init(unit, pkt_format->l2,
                                                 hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set vlan tag format. */
    rv = _field_trx2_udf_tcam_entry_vlanformat_init(unit, pkt_format->vlan_tag,
                                                   hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set l3 packet format. */
    rv = _field_trx2_udf_tcam_entry_l3_init(unit, pkt_format, hw_buf, priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Set Flags packet format */
    rv = _field_trx2_udf_tcam_entry_flags_init(unit, pkt_format->flags, hw_buf,
                                               priority);
    return (rv);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_ethertype_add
 * Purpose:
 *      Add ethertype based offset to data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      etype      - (IN) Ethertype based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_ethertype_add(int unit,  int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    fp_udf_tcam_entry_t     tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t          *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t *f_dq;        /* Data qualifier descriptor. */
    uint8                   priority;     /* Udf tcam entry priority.   */
    int                     tcam_idx;     /* Tcam insertion index.      */
    int                     offset;       /* Qualifier tcam offset.     */
    int                     rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == etype) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize ethertype data qualifier key. */
    rv = _field_trx2_data_qualifier_etype_tcam_key_init(unit, etype,
                                                       (uint32 *)&tcam_buf,
                                                       &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Reorganize the tcam and reserve an index for the entry. */
    rv = _field_trx2_udf_tcam_entry_insert(unit, (uint32*)&tcam_buf,
                                          priority, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    /* Calculate element offset. */
    rv = _field_trx2_data_elem_offset_calc(unit, f_dq,
                                           etype->relative_offset, &offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, FALSE, f_dq, tcam_idx, offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Insert udf tcam entry. */
    rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx, &tcam_buf);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_ethertype_delete
 * Purpose:
 *      Remove ethertype based offset from data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      etype      - (IN) Ethertype based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_ethertype_delete(int unit, int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    _field_data_tcam_entry_t *tcam_entry_arr; /* Tcam entries array.     */
    fp_udf_tcam_entry_t      tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t           *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t  *f_dq;        /* Data qualifier descriptor. */
    uint8                    priority;     /* Udf tcam entry priority.   */
    int                      tcam_idx;     /* Tcam insertion index.      */
    int                      rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == etype) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);


    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize ethertype data qualifier key. */
    rv = _field_trx2_data_qualifier_etype_tcam_key_init(unit, etype,
                                                       (uint32 *)&tcam_buf,
                                                       &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Match the tcam entry. */
    rv = _field_trx2_udf_tcam_entry_match(unit, stage_fc,
                               (uint32*)&tcam_buf, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    tcam_entry_arr = stage_fc->data_ctrl->tcam_entry_arr;
    if (tcam_entry_arr[tcam_idx].ref_count > 0) {
        tcam_entry_arr[tcam_idx].ref_count--;
    }

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, TRUE, f_dq, tcam_idx, -1);
    BCM_IF_ERROR_RETURN(rv);

    if (0 == tcam_entry_arr[tcam_idx].ref_count) {
        /* Reset udf tcam entry. */
        rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx,
                           &soc_mem_entry_null(unit, FP_UDF_TCAMm));
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_ip_protocol_add
 * Purpose:
 *      Add ipprotocol based offset to data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      ip_proto   - (IN) Ip protocol based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_ip_protocol_add(int unit,  int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_proto)
{
    fp_udf_tcam_entry_t     tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t          *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t *f_dq;        /* Data qualifier descriptor. */
    uint8                   priority;     /* Udf tcam entry priority.   */
    int                     tcam_idx;     /* Tcam insertion index.      */
    int                     offset;       /* Qualifier tcam offset.     */
    int                     rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == ip_proto) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize ipprotocol data qualifier key. */
    rv = _field_trx2_data_qualifier_ip_proto_tcam_key_init(unit, ip_proto,
                                                          (uint32 *)&tcam_buf,
                                                          &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Reorganize the tcam and reserve an index for the entry. */
    rv = _field_trx2_udf_tcam_entry_insert(unit, (uint32*)&tcam_buf,
                                          priority, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    /* Calculate elem offset. */
    rv = _field_trx2_data_elem_offset_calc(unit, f_dq,
                                           ip_proto->relative_offset, &offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, FALSE, f_dq, tcam_idx, offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Insert udf tcam entry. */
    rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx, &tcam_buf);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_ip_protocol_delete
 * Purpose:
 *      Remove ipprotocol based offset from data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      ip_proto   - (IN) Ip protocol based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_ip_protocol_delete(int unit, int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_proto)
{
    _field_data_tcam_entry_t *tcam_entry_arr; /* Tcam entries array.     */
    fp_udf_tcam_entry_t      tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t           *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t  *f_dq;        /* Data qualifier descriptor. */
    uint8                    priority;     /* Udf tcam entry priority.   */
    int                      tcam_idx;     /* Tcam insertion index.      */
    int                      rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == ip_proto) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize ipprotocol data qualifier key. */
    rv = _field_trx2_data_qualifier_ip_proto_tcam_key_init(unit, ip_proto,
                                                          (uint32 *)&tcam_buf,
                                                          &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Match the tcam entry. */
    rv = _field_trx2_udf_tcam_entry_match(unit, stage_fc,
                                         (uint32*)&tcam_buf, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    tcam_entry_arr = stage_fc->data_ctrl->tcam_entry_arr;
    if (tcam_entry_arr[tcam_idx].ref_count > 0) {
        tcam_entry_arr[tcam_idx].ref_count--;
    }

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, TRUE, f_dq, tcam_idx, -1);
    BCM_IF_ERROR_RETURN(rv);

    if (0 == tcam_entry_arr[tcam_idx].ref_count) {
        /* Reset udf tcam entry. */
        rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx,
                           &soc_mem_entry_null(unit, FP_UDF_TCAMm));
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_packet_format_add
 * Purpose:
 *      Add ipprotocol based offset to data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      pkt_format - (IN) Packet format based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_packet_format_add(int unit,  int qual_id,
                                 bcm_field_data_packet_format_t *pkt_format)
{
    fp_udf_tcam_entry_t     tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t          *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t *f_dq;        /* Data qualifier descriptor. */
    uint8                   priority;     /* Udf tcam entry priority.   */
    int                     tcam_idx;     /* Tcam insertion index.      */
    int                     offset;       /* Qualifier tcam offset.     */
    int                     rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == pkt_format) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize packet format data qualifier key. */
    rv = _field_trx2_data_qualifier_pkt_format_tcam_key_init(unit, pkt_format,
                                                          (uint32 *)&tcam_buf,
                                                          &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Reorganize the tcam and reserve an index for the entry. */
    rv = _field_trx2_udf_tcam_entry_insert(unit, (uint32*)&tcam_buf,
                                          priority, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    /* Calculate elem offset. */
    rv = _field_trx2_data_elem_offset_calc(unit, f_dq,
                                           pkt_format->relative_offset,
                                           &offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, FALSE, f_dq, tcam_idx, offset);
    BCM_IF_ERROR_RETURN(rv);

    /* Insert udf tcam entry. */
    rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx, &tcam_buf);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_trx2_data_qualifier_packet_format_delete
 * Purpose:
 *      Remove ipprotocol based offset from data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      pkt_format - (IN) Packet format based udf offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_trx2_data_qualifier_packet_format_delete(int unit, int qual_id,
                                 bcm_field_data_packet_format_t *pkt_format)
{
    _field_data_tcam_entry_t *tcam_entry_arr; /* Tcam entries array.     */
    fp_udf_tcam_entry_t      tcam_buf;     /* Udf tcam entry.            */
    _field_stage_t           *stage_fc;    /* Stage field control.       */
    _field_data_qualifier_t  *f_dq;        /* Data qualifier descriptor. */
    uint8                    priority;     /* Udf tcam entry priority.   */
    int                      tcam_idx;     /* Tcam insertion index.      */
    int                      rv;           /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == pkt_format) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(&tcam_buf, 0, sizeof(fp_udf_tcam_entry_t));

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    BCM_IF_ERROR_RETURN(rv);

    /* Initialize packet_format data qualifier key. */
    rv = _field_trx2_data_qualifier_pkt_format_tcam_key_init(unit, pkt_format,
                                                          (uint32 *)&tcam_buf,
                                                          &priority);
    BCM_IF_ERROR_RETURN(rv);

    /* Match the tcam entry. */
    rv = _field_trx2_udf_tcam_entry_match(unit, stage_fc,
                                         (uint32*)&tcam_buf, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    tcam_entry_arr = stage_fc->data_ctrl->tcam_entry_arr;
    if (tcam_entry_arr[tcam_idx].ref_count > 0) {
        tcam_entry_arr[tcam_idx].ref_count--;
    }

    /* Initialize udf offset entry. */
    rv = _field_trx2_data_tcam_offset_install(unit, TRUE, f_dq, tcam_idx, -1);
    BCM_IF_ERROR_RETURN(rv);

    if (0 == tcam_entry_arr[tcam_idx].ref_count) {
        /* Reset udf tcam entry. */
        rv = soc_mem_write(unit, FP_UDF_TCAMm, MEM_BLOCK_ALL, tcam_idx,
                           &soc_mem_entry_null(unit, FP_UDF_TCAMm));
        BCM_IF_ERROR_RETURN(rv);
    }

    return (BCM_E_NONE);
}
#endif /* BCM_TRIUMPH2_SUPPORT || BCM_TRIDENT_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT

STATIC soc_field_t _vfp_slice_wide_mode_field[4] = {
    SLICE_0_DOUBLE_WIDE_MODEf,
    SLICE_1_DOUBLE_WIDE_MODEf,
    SLICE_2_DOUBLE_WIDE_MODEf,
    SLICE_3_DOUBLE_WIDE_MODEf};

#if defined (BCM_KATANA_SUPPORT) || defined (BCM_TRIUMPH3_SUPPORT) \
    || defined (BCM_TRIDENT2_SUPPORT) || defined (BCM_TRIUMPH2_SUPPORT)
static _field_flex_stat_info_t flex_info[BCM_LOCAL_UNITS_MAX] = {{0}};
#endif

int
_bcm_field_trx_meter_rate_burst_recover(uint32 unit,
                                        uint32 meter_table,
                                        uint32 mem_idx,
                                        uint32 *prate,
                                        uint32 *pburst,
                                        uint32 *cfg_flags
                                        )
{
    uint32 ent[SOC_MAX_MEM_FIELD_WORDS];
    uint32 refresh_rate, granularity, bucket_max;
    uint32 flags = (_BCM_XGS_METER_FLAG_GRANULARITY
                    | _BCM_XGS_METER_FLAG_FP_POLICER);

    BCM_IF_ERROR_RETURN(soc_mem_read(unit, meter_table, MEM_BLOCK_ANY,
                                     mem_idx, ent));

    refresh_rate = soc_mem_field32_get(unit, meter_table, ent, REFRESHCOUNTf);
    granularity = soc_mem_field32_get(unit, meter_table, ent, METER_GRANf);
    bucket_max = soc_mem_field32_get(unit, meter_table, ent, BUCKETSIZEf);

    if (SOC_MEM_FIELD_VALID(unit, meter_table, PKTS_BYTESf)) {
        if ((soc_mem_field32_get(unit, meter_table, ent, PKTS_BYTESf) == 0x1)) {
             flags |= _BCM_XGS_METER_FLAG_PACKET_MODE;
             if (SOC_IS_TD2_TT2(unit)) {
                 flags |= _BCM_XGS_METER_FLAG_FP_TD2_POLICER;
             }
             *cfg_flags |= BCM_POLICER_MODE_PACKETS;
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_xgs_bucket_encoding_to_kbits
        (refresh_rate, bucket_max, granularity, flags,
         prate, pburst));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_trx_meter_pool_resolve
 * Purpose:
 *     Given meter pair index, determine meter pool number and meter index
 *     in meter pool.
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     stage_fc         - (IN) FP stage control info.
 *     meter_pair_idx   - (IN) Global meter pair index value.
 *     pool_num         - (OUT) Meter pool number.
 *     meter_idx        - (OUT) Meter pair index in pool number context.
 * Returns:
 *     BCM_E_XXX
 */

int _field_trx_meter_pool_resolve(int unit, _field_stage_t *stage_fc,
                                  int meter_pair_idx, int *pool_num,
                                  int *meter_idx)
{
    int pool_idx = _FP_INVALID_INDEX;       /* Meter pool number. */
    int meter_index  = _FP_INVALID_INDEX;   /* Meter index.       */

    /* Input parameter check. */
    if (NULL == stage_fc || NULL == pool_num || NULL == meter_idx) {
        return (BCM_E_INTERNAL);
    }

    /* Calculate pool_index and hw_index */
    for (meter_index = meter_pair_idx, pool_idx = 0;
         meter_index
         >= (stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->num_meter_pairs);
         meter_index
         -= (stage_fc->meter_pool[_FP_DEF_INST][pool_idx]->num_meter_pairs),
                         ++pool_idx);
    *pool_num = pool_idx;
    *meter_idx = meter_index;
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_trx_meter_index_in_use
 * Purpose:
 *    Returns success if meter index/meter pair is in use.
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     stage_fc         - (IN) FP stage control info.
 *     fs               - (IN) Slice where meter resides.
 *     f_mp             - (IN) Meter pool info.
 *     meter_pair_mode  - (IN) Meter mode.
 *     meter_offset     - (IN) Odd/Even meter offset value.
 *     idx              - (IN) Meter pair index.
 * Returns:
 *     BCM_E_XXX
 */
int _field_trx_meter_index_in_use(int unit, _field_stage_t *stage_fc,
                                _field_slice_t *fs,
                                _field_meter_pool_t *f_mp,
                                uint32 meter_pair_mode,
                                uint32 meter_offset,
                                int idx)
{
    /* Input parameter check. */
    if (NULL == stage_fc || NULL == fs) {
        return (BCM_E_INTERNAL);
    }

    if ((stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) &&
        (NULL == f_mp)) {
        return (BCM_E_INTERNAL);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        /* Device stage supports global meter pools. */
        if (meter_pair_mode == BCM_FIELD_METER_MODE_FLOW
            && _FP_METER_BMP_TEST(f_mp->meter_bmp, ((idx * 2) + meter_offset))) {
            /* Flow mode meter index in use. */
            return (BCM_E_NONE);
        } else if (_FP_METER_BMP_TEST(f_mp->meter_bmp, (idx * 2))
                    && _FP_METER_BMP_TEST(f_mp->meter_bmp, ((idx * 2) + 1))) {
            /* Non-Flow mode meter pair index in use. */
            return (BCM_E_NONE);
        }
    } else {
        /* Meters are per-slice resource. */
        if (meter_pair_mode == BCM_FIELD_METER_MODE_FLOW
            && _FP_METER_BMP_TEST(fs->meter_bmp, ((idx * 2) + meter_offset))) {
            /* Flow mode meter index in use. */
            return (BCM_E_NONE);
        } else if (_FP_METER_BMP_TEST(fs->meter_bmp, (idx * 2))
                    && _FP_METER_BMP_TEST(fs->meter_bmp, ((idx * 2) + 1))) {
            /* Non-Flow mode meter pair index in use. */
            return (BCM_E_NONE);
        }
    }

    return (BCM_E_NOT_FOUND);
}

/*
 * Function:
 *    _field_trx_meter_recover
 * Purpose:
 *    Recover field entry polier configuration.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     f_ent      - (IN) Field entry structure.
 *     part       - (IN) Field entry part number.
 *     pid        - (IN) Policer identifier.
 *     level      - (IN) Policer level (0/1).
 *     polic_mem  - (IN) Policy table memory name.
 *     policy_buf - (IN) Policy table entry pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_trx_meter_recover(int             unit,
                         _field_entry_t  *f_ent,
                         int             part,
                         bcm_policer_t   pid,
                         uint32          level,
                         soc_mem_t       policy_mem,
                         uint32          *policy_buf,
                         uint8          *already_recovered
                         )
{
    _field_group_t *fg;                 /* Field group information.         */
    _field_stage_t *stage_fc;           /* Field stage information.         */
    _field_control_t *fc;               /* Unit field control information.  */
    _field_slice_t *fs;                 /* Field slice information.         */
    _field_policer_t *f_pl = NULL;      /* Policer descriptor pointer type. */
    _field_entry_policer_t *f_ent_pl;   /* Policer attached to entry.       */
    int rv, policer_id, meter_hw_idx;   /* Meter pair/flow meter hw index.  */
    int pair_index = _FP_INVALID_INDEX; /* Global meter pair index value.   */
    int pool_index = _FP_INVALID_INDEX; /* Meter pool number.               */
    int hw_index = _FP_INVALID_INDEX;   /* Pool local meter pair index.     */
    soc_field_t mpair_idx_f;            /* Meter pair index field.          */
    soc_field_t modifier_f;             /* Meter modifier field.            */
    uint32 idx, found = 0;              /* Policer hash idx; Policer found. */
    uint32 flags = 0;                   /* Policer flags.                   */
    uint32 meter_pair_mode = 0;         /* Flow/SrTcm/TrTcm meter modes.    */
    uint32 modifier_mode = 0;           /* Committed - 1/Excess meter - 0.  */
    uint32 meter_offset = 0;            /* Even or Odd meter index.         */
    _field_meter_pool_t *f_mp = NULL;   /* Meter pool information.          */
    _meter_config_t meter_conf;         /* Meter configuration in hardware. */
    soc_mem_t meter_mem = INVALIDm;            /* Meter memory name.        */
    uint32 meter_sharing_mode = -1;      /* Meter BW sharing mode */
#if defined(BCM_GREYHOUND2_SUPPORT)
    uint32 ent[SOC_MAX_MEM_FIELD_WORDS];
    uint32 meter_mode_tsn_modifier = 0;  /* TSN srTCM mode enable or not    */
#endif /* BCM_GREYHOUND2_SUPPORT */
    fg = f_ent->group;
    fs = f_ent[part].fs;

    sal_memset(&meter_conf, 0, sizeof(_meter_config_t));

    /* Get field control */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get stage control */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Retrieve meter config parameters from policy table and meter table. */
    switch (fg->stage_id) {
        case  _BCM_FIELD_STAGE_INGRESS:
            meter_mem = FP_METER_TABLEm;
            /* Get - Flow/SrTcm/TrTcm mode. */
            if (level == 1) {
                /* meter BW/Sharing mode 0=OFF, 1=MIN, 2=MAX, 3=MIN+MAX */
                if ((meter_sharing_mode = soc_mem_field32_get(
                                             unit, policy_mem,
                                             policy_buf,
                                             METER_SHARING_MODEf))
                    == 0) {
                    return (BCM_E_NONE);
                }

                if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                                        SHARED_METER_PAIR_MODEf)){
                    meter_pair_mode = soc_mem_field32_get
                                      (unit, policy_mem,
                                      policy_buf, SHARED_METER_PAIR_MODEf);
                }

                /* Mode - Flow/TrTcmDs */
                switch (meter_pair_mode) {
                    case 0:
                        meter_pair_mode = BCM_FIELD_METER_MODE_FLOW;
                        break;
                    case 1:
                        meter_pair_mode = 4;
                                          /* no macro created yet */
                        break;
                    default:
                        return BCM_E_NONE;
                }
                mpair_idx_f = SHARED_METER_PAIR_INDEXf;
                modifier_f = METER_SHARING_MODE_MODIFIERf;
            } else {
                if ((meter_pair_mode = soc_mem_field32_get
                                        (unit, policy_mem,
                                         policy_buf, METER_PAIR_MODEf))
                    == 0) {
                    return (BCM_E_NONE);
                }
                mpair_idx_f = SOC_IS_TD_TT(unit) ? METER_PAIR_INDEX_EVENf
                                : METER_PAIR_INDEXf;
                modifier_f = METER_PAIR_MODE_MODIFIERf;
            }

            /* Get meter pair index value from policy table. */
            pair_index = soc_mem_field32_get(unit, policy_mem, policy_buf,
                                             mpair_idx_f);

            /* modifier_mode: 0 = Excess Meter, 1 = Committed Meter. */
            modifier_mode = soc_mem_field32_get(unit, policy_mem, policy_buf,
                                                modifier_f);

            /* Determine meter offset value for flow meters. */
            if (BCM_FIELD_METER_MODE_FLOW == meter_pair_mode) {
                /* Trident device supports only Level0 policer mode. */
                if (SOC_IS_TD_TT(unit) && (0 == level)) {
                    meter_offset = (1 == soc_mem_field32_get(unit,
                                            policy_mem, policy_buf,
                                            METER_TEST_EVENf)) ? 0 : 1;
                } else {
                    meter_offset = (0 == modifier_mode) ? 0 : 1;
                }
            }

            /* Get meter pool number and meter pair index in pool context. */
            BCM_IF_ERROR_RETURN
                (_field_trx_meter_pool_resolve(unit, stage_fc, pair_index,
                                               &pool_index, &hw_index));

            /* Get meter pool info pointer. */
            f_mp = stage_fc->meter_pool[_FP_DEF_INST][pool_index];

            /* Setup meter pool to entry slice mapping. */
            if (_FP_INVALID_INDEX == f_mp->slice_id) {
                f_mp->slice_id = fg->slices->slice_number;
                f_mp->level = level;
            }
            break;

        case _BCM_FIELD_STAGE_EGRESS:

             if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                 meter_mem = EFP_METER_TABLEm;
             } else if (stage_fc->oper_mode == bcmFieldGroupOperModePipeLocal) {
                 if (f_ent->group->instance == 0) {
                    meter_mem = EFP_METER_TABLE_PIPE0m;
                 } else if (f_ent->group->instance == 1) {
                    meter_mem = EFP_METER_TABLE_PIPE1m;
                 } else if (f_ent->group->instance == 2) {
                    meter_mem = EFP_METER_TABLE_PIPE2m;
                 } else if (f_ent->group->instance == 3) {
                    meter_mem = EFP_METER_TABLE_PIPE3m;
                 } else {
                    return BCM_E_INTERNAL;
                 }
             } else {
                 return BCM_E_INTERNAL;
             }

            meter_conf.meter_mode = soc_mem_field32_get(unit, policy_mem,
                                                        policy_buf,
                                                        METER_PAIR_MODEf);
            meter_conf.meter_idx = soc_mem_field32_get(unit, policy_mem,
                                                       policy_buf,
                                                       METER_INDEX_EVENf);
            meter_conf.meter_update_odd = soc_mem_field32_get(unit,
                                            policy_mem, policy_buf,
                                            METER_UPDATE_ODDf);
            meter_conf.meter_test_odd = soc_mem_field32_get(unit, policy_mem,
                                                            policy_buf,
                                                            METER_TEST_ODDf);
            meter_conf.meter_update_even = soc_mem_field32_get(unit,
                                            policy_mem, policy_buf,
                                            METER_UPDATE_EVENf);
            meter_conf.meter_test_even = soc_mem_field32_get(unit,
                                                             policy_mem,
                                                             policy_buf,
                                                             METER_TEST_EVENf);

#if defined(BCM_TRIDENT2_SUPPORT)
            if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            modifier_mode = soc_mem_field32_get(unit, policy_mem, policy_buf,
                                                METER_MODE_MODIFIERf);
            }
#endif
            /* Get - Flow/SrTcm/TrTcm mode. */
            meter_pair_mode = meter_conf.meter_mode;

            /* modifier_mode: 0 = Excess Meter, 1 = Committed Meter. */
            if (BCM_FIELD_METER_MODE_FLOW == meter_pair_mode) {
                if (SOC_IS_KATANA2(unit)) {
                    /* test mode will be set 0 when EFP WAR is enabled */
                    modifier_mode = (meter_conf.meter_update_even) ? 0 : 1;
                } else {
                    modifier_mode = (meter_conf.meter_update_even
                            && meter_conf.meter_test_even) ? 0 : 1;
                }
                meter_offset = (0 == modifier_mode) ? 0 : 1;
            }

            /* Slice in which meter config resides. */
            pool_index = fs->slice_number;

            /* Slice meter pair index. */
            hw_index = meter_conf.meter_idx;

            if ((BCM_FIELD_METER_MODE_DEFAULT == meter_pair_mode)
                && (0 == hw_index)) {
                /* bcmPolicerModePassThrough */
                return BCM_E_NONE;
            }
            break;

        case _BCM_FIELD_STAGE_EXTERNAL:
            meter_mem = FP_METER_TABLEm;

            /* Get - Flow/SrTcm/TrTcm mode. */
            if (level == 1) {
                if ((meter_pair_mode = soc_mem_field32_get
                                        (unit, policy_mem, policy_buf,
                                         METER_SHARING_MODEf))
                    == 0) {
                    return (BCM_E_NONE);
                }
                mpair_idx_f = METER_PAIR_INDEXf;
                modifier_f = METER_SHARING_MODE_MODIFIERf;
            } else {
                if ((meter_pair_mode = soc_mem_field32_get(unit, policy_mem,
                                                           policy_buf,
                                                           METER_PAIR_MODEf))
                    == 0) {
                    return (BCM_E_NONE);
                }

                mpair_idx_f = METER_PAIR_INDEXf;
                modifier_f = METER_PAIR_MODE_MODIFIERf;
            }

            pair_index = soc_mem_field32_get(unit, policy_mem, policy_buf,
                                             mpair_idx_f);

            /* modifier_mode: 0 = Excess Meter, 1 = Committed Meter. */
            modifier_mode = soc_mem_field32_get(unit, policy_mem, policy_buf,
                                                modifier_f);

            /* Determine meter offset value for flow meters. */
            if (BCM_FIELD_METER_MODE_FLOW == meter_pair_mode) {
                meter_offset = (0 == modifier_mode) ? 0 : 1;
            }

            /* Get meter pool number and meter index. */
            BCM_IF_ERROR_RETURN
                (_field_trx_meter_pool_resolve(unit, stage_fc, pair_index,
                                               &pool_index, &hw_index));
            f_mp = stage_fc->meter_pool[_FP_DEF_INST][pool_index];
            if (_FP_INVALID_INDEX == f_mp->slice_id) {
                f_mp->slice_id = stage_fc->tcam_slices;
                f_mp->level = level;
            }
            break;

        default:
            /* Must be a valid stage. */
            return (BCM_E_INTERNAL);
    }

    /* Check if meter index is already in use. */
    if (BCM_SUCCESS(_field_trx_meter_index_in_use(unit, stage_fc, fs, f_mp,
                                                  meter_pair_mode,
                                                  meter_offset,
                                                  hw_index))) {
        found = 0;
        /*
         * Check and increment reference count for poliers that are
         * attached to more than one entry.
         */
        for (idx = 0; idx < _FP_HASH_SZ(fc); idx++) {
            f_pl = fc->policer_hash[idx];
            while (f_pl != NULL) {
                if ((f_pl->hw_index == hw_index) &&
                    (f_pl->pool_index == pool_index) &&
                    (f_pl->stage_id == fg->stage_id)) {
                    found = 1;
                    break;
                }
                f_pl = f_pl->next;
            }
            if (found) {
                break;
            }
        }
        if (!found) {
            return BCM_E_INTERNAL;
        }
        f_pl->hw_ref_count++;
        f_pl->sw_ref_count++;
    } else {
        /* Policer does not exist => Allocate new policer object */
        if (fc->l2warm) {
            policer_id = pid;
        } else {
            BCM_IF_ERROR_RETURN(_field_policer_id_alloc(unit, &policer_id));
        }

        _FP_XGS3_ALLOC(f_pl, sizeof (_field_policer_t), "Field policer entity");
        if (f_pl == NULL) {
            return (BCM_E_MEMORY);
        }

        flags |= _FP_POLICER_INSTALLED;
        if ((f_pl->level = level) == 1 && meter_sharing_mode == 1) {
            f_pl->cfg.flags |= BCM_POLICER_COLOR_MERGE_OR;
        }
        f_pl->sw_ref_count = 2;
        f_pl->hw_ref_count = 1;
        f_pl->pid          = policer_id;
        f_pl->stage_id     = fg->stage_id;
        f_pl->pool_index   = pool_index;
        f_pl->hw_index     = hw_index;

        /* Calculate hardware meter index. */
        if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
            /*
             * Hw index is:
             * ((Pool number * pool_size) + (2 * pair number)
             */
            meter_hw_idx = (pool_index *
                stage_fc->meter_pool[_FP_DEF_INST][pool_index]->size)
                            + (2 * hw_index);
        } else {
            /*
             * Hw index is:
             * (slice index) + (2 * pair number)
             */
            meter_hw_idx =
                stage_fc->slices[_FP_DEF_INST][pool_index].start_tcam_idx
                            + (2 * hw_index);
        }

        switch (meter_pair_mode) {
            case BCM_FIELD_METER_MODE_DEFAULT: /* 0 */
                f_pl->cfg.mode = bcmPolicerModeGreen;
                break;

            case BCM_FIELD_METER_MODE_FLOW: /* 1 */
                switch (fg->stage_id) {
                    case _BCM_FIELD_STAGE_INGRESS:
                    case _BCM_FIELD_STAGE_EXTERNAL:
                        if (SOC_IS_TD_TT(unit)) {
                            f_pl->cfg.mode = bcmPolicerModeCommitted;
                            if (meter_offset) {
                                /* Flow mode using committed hardware meter. */
                                _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
                            } else {
                                /* Flow mode using excess hardware meter. */
                                _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
                            }
                        } else {
                            f_pl->cfg.mode = bcmPolicerModeCommitted;
                            if (1 == modifier_mode) {
                                /* Flow mode using committed hardware meter. */
                                _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
                            } else if (0 == modifier_mode) {
                                /* Flow mode using excess hardware meter. */
                                _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
                            } else {
                                sal_free(f_pl);
                                return BCM_E_INTERNAL;
                            }
                        }

                        /* Update with meter_offset for flow mode meters. */
                        meter_hw_idx += meter_offset;

                        /* Get policer rates. */
                        _bcm_field_trx_meter_rate_burst_recover(unit,
                            FP_METER_TABLEm, meter_hw_idx,
                            &f_pl->cfg.ckbits_sec,
                            &f_pl->cfg.ckbits_burst,
                            &f_pl->cfg.flags);
                        break;

                    case _BCM_FIELD_STAGE_EGRESS:
                        f_pl->cfg.mode = bcmPolicerModeCommitted;
                        if (1 == modifier_mode) {
                            /* Flow mode using committed hardware meter. */
                            _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
                        } else if (0 == modifier_mode) {
                            /* Flow mode using excess hardware meter. */
                            _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
                        } else {
                            sal_free(f_pl);
                            return BCM_E_INTERNAL;
                        }

                        /* Update with meter_offset for flow mode meters. */
                        meter_hw_idx += meter_offset;

                        _bcm_field_trx_meter_rate_burst_recover(unit,
                            meter_mem, meter_hw_idx,
                            &f_pl->cfg.ckbits_sec,
                            &f_pl->cfg.ckbits_burst,
                            &f_pl->cfg.flags);

                        if (SOC_IS_KATANA2(unit) &&
                            ((_FP_POLICER_EXCESS_HW_METER(f_pl) &&
                              (0 == meter_conf.meter_test_even)) ||
                             (_FP_POLICER_COMMITTED_HW_METER(f_pl) &&
                              (0 == meter_conf.meter_test_odd)))) {
                            f_pl->cfg.flags |= BCM_POLICER_AS_PACKET_COUNTER;
                            f_pl->cfg.flags |=  BCM_POLICER_MODE_PACKETS;
                            f_pl->cfg.ckbits_sec = 0;
                            f_pl->cfg.ckbits_burst = 0;
                            f_pl->cfg.bucket_width = 30;
                            f_pl->cfg.token_gran = 250;
                            f_pl->cfg.bucket_init_val = 0xFFF << 16;
                            f_pl->cfg.bucket_rollover_val = 0x20000052;
                        }
                        break;
                    default:
                        /* Must be a valid pipeline stage. */
                        return (BCM_E_INTERNAL);
                }
                break;

            case BCM_FIELD_METER_MODE_trTCM_COLOR_BLIND: /* 2 */
                f_pl->cfg.flags |= BCM_POLICER_COLOR_BLIND;
                /* Fall through */
            case BCM_FIELD_METER_MODE_trTCM_COLOR_AWARE: /* 3 */
                f_pl->cfg.mode = bcmPolicerModeTrTcm;
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx, &f_pl->cfg.pkbits_sec,
                    &f_pl->cfg.pkbits_burst,
                    &f_pl->cfg.flags);

                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx + 1, &f_pl->cfg.ckbits_sec,
                    &f_pl->cfg.ckbits_burst,
                    &f_pl->cfg.flags);
                break;

            case BCM_FIELD_METER_MODE_srTCM_COLOR_BLIND: /* 6 */
                f_pl->cfg.flags |= BCM_POLICER_COLOR_BLIND;
                /* Fall through */
            case BCM_FIELD_METER_MODE_srTCM_COLOR_AWARE: /* 7 */
                 f_pl->cfg.mode = modifier_mode
                                  ? bcmPolicerModeSrTcmModified
                                  : bcmPolicerModeSrTcm;
#if defined(BCM_GREYHOUND2_SUPPORT)
                if (SOC_IS_GREYHOUND2(unit)) {
                    /* Update with meter_offset for flow mode meters. */
                    meter_hw_idx += meter_offset;
                    if (SOC_MEM_FIELD_VALID(unit, meter_mem,
                                            METER_MODE_TSN_MODIFIERf)) {
                        BCM_IF_ERROR_RETURN(soc_mem_read(unit,
                                                         meter_mem,
                                                         MEM_BLOCK_ANY,
                                                         meter_hw_idx,
                                                         ent));
                        meter_mode_tsn_modifier =
                            soc_mem_field32_get(unit, meter_mem,
                                                ent, METER_MODE_TSN_MODIFIERf);
                        if (1 == meter_mode_tsn_modifier) {
                            f_pl->cfg.mode = bcmPolicerModeSrTcmTsn;
                        }
                    }
                }
#endif /* BCM_GREYHOUND2_SUPPORT */
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx, &f_pl->cfg.pkbits_sec,
                    &f_pl->cfg.pkbits_burst,
                    &f_pl->cfg.flags);

                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx + 1, &f_pl->cfg.ckbits_sec,
                    &f_pl->cfg.ckbits_burst,
                    &f_pl->cfg.flags);
                break;
            case 4:
                if (fg->stage_id == _BCM_FIELD_STAGE_EGRESS) {
                    f_pl->cfg.mode = bcmPolicerModePassThrough;
                    break;
                } else {
                    f_pl->cfg.flags |= BCM_POLICER_COLOR_BLIND;
                }
                if (fg->stage_id != _BCM_FIELD_STAGE_EGRESS) {
                    f_pl->cfg.mode = modifier_mode
                                        ? bcmPolicerModeCoupledTrTcmDs
                                        : bcmPolicerModeTrTcmDs;
                }
                break;
            case 5:
                f_pl->cfg.mode = modifier_mode
                    ? bcmPolicerModeCoupledTrTcmDs
                    : bcmPolicerModeTrTcmDs;
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                        meter_hw_idx, &f_pl->cfg.pkbits_sec,
                        &f_pl->cfg.pkbits_burst,
                        &f_pl->cfg.flags);

                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                        meter_hw_idx + 1, &f_pl->cfg.ckbits_sec,
                        &f_pl->cfg.ckbits_burst,
                        &f_pl->cfg.flags);
                break;
            default:
                ;
        }

        /* In Tomahawk EFP metering, Refresh tick duration has changed from
         * 7.8125us to 15.625us ,but the RTL does not double the REFRESHCOUNT
         * while putting the tokens into the bucket which is causing 50% lesser
         * traffic rate than expected. So the work around is the value programmed
         * from software in EFP meters needs to be doubled.
         */
        
        if ((SOC_IS_TOMAHAWKX(unit)) && (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id)) {
            f_pl->cfg.ckbits_sec = (f_pl->cfg.ckbits_sec / 2) ;
            f_pl->cfg.pkbits_sec = (f_pl->cfg.pkbits_sec / 2) ;
        }

        /* Assume policer was created using the policer_create API */
        if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
            if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                if ((part == 2) || (part == 3)) {
                    f_ent->flags |= _FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
                }
            } else {
                if (part == 1) {
                    f_ent->flags |= _FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
                }
            }
        }

        _FP_HASH_INSERT(fc->policer_hash, f_pl,
            (policer_id & _FP_HASH_INDEX_MASK(fc)));
        fc->policer_count++;

        /* Mark meter index as used in slice/pool */
        if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS
            && (_BCM_FIELD_STAGE_EGRESS != fg->stage_id)) {
            if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
                _FP_METER_BMP_ADD(f_mp->meter_bmp, (hw_index * 2));
                _FP_METER_BMP_ADD(f_mp->meter_bmp, ((hw_index * 2) + 1));
                f_mp->free_meters -= 2;
            } else {
                _FP_METER_BMP_ADD(f_mp->meter_bmp,
                                  ((hw_index * 2) + meter_offset));
                f_mp->free_meters--;
            }
        } else {
            if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
                _FP_METER_BMP_ADD(fs->meter_bmp, (hw_index * 2));
                _FP_METER_BMP_ADD(fs->meter_bmp, ((hw_index * 2) + 1));
            } else {
                _FP_METER_BMP_ADD(fs->meter_bmp,
                                  ((hw_index * 2) + meter_offset));
            }
        }
        fg->group_status.meter_count++;
    }

    /* Associate the policer object with the entry */
    f_ent_pl = &f_ent->policer[level];
    f_ent_pl->flags |= (_FP_POLICER_VALID | flags);
    f_ent_pl->pid = f_pl->pid;
    *already_recovered = 1;

    return BCM_E_NONE;
}

/*
 * Function:
 *    _field_sc_cq_meter_recover
 * Purpose:
 *    Recover field entry polier configuration.
 * Parameters:
 *     unit              - (IN) BCM device number.
 *     f_ent             - (IN) Field entry structure.
 *     part              - (IN) Field entry part number.
 *     pid               - (IN) Policer identifier.
 *     policy_buf        - (IN) Policy table entry pointer.
 *     already_recovered - (IN) Flag to check already recovered policers
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_sc_cq_meter_recover(int            unit,
                           _field_entry_t *f_ent,
                           int            part,
                           bcm_policer_t  pid,
                           uint32         *policy_buf,
                           uint8         *already_recovered
                           )
{
    int rv, policer_id;                    /* Policer identifier.           */
    int pair_index = _FP_INVALID_INDEX;    /* Global meter pair index.      */
    int meter_hw_idx = _FP_INVALID_INDEX;  /* Meter index value.            */
    int pool_index = _FP_INVALID_INDEX;    /* Meter pool index.             */
    int hw_index = _FP_INVALID_INDEX;      /* Pool local meter pair index.  */
    uint32 ent_pl_flags = 0;               /* Entry policer flags.          */
    uint32 stage_id;                       /* Field processor Stage ID.     */
    uint32 meter_pair_mode = 0;            /* Flow/SrTcm/TrTcm meter modes. */
    uint32 modifier_mode = 0;              /* Committed(1)/Excess(0) meter. */
    uint32 meter_offset = 0;               /* Even or Odd meter index.      */
    _field_group_t *fg;                    /* Field group information.      */
    _field_stage_t *stage_fc;              /* Field stage information.      */
    _field_control_t *fc;                  /* Field control information.    */
    _field_slice_t *fs;                    /* Field slice information.      */
    _field_policer_t *f_pl = NULL;         /* Policer descriptor info.      */
    _field_entry_policer_t *f_ent_pl;      /* Policer attached to entry.    */
    _field_meter_pool_t *f_mp = NULL;      /* Meter pool information.       */
    _meter_config_t meter_conf;            /* Meter config in hardware.     */
    soc_mem_t meter_mem;                   /* Meter memory name.            */

    fg = f_ent->group;
    fs = f_ent[part].fs;

    /* Get field control handle. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    stage_id = f_ent->group->stage_id;

    /* Get unit stage control handle. */
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    switch (stage_id) {
        /* Ingress stage */
        case _BCM_FIELD_STAGE_INGRESS:
            meter_mem = FP_METER_TABLEm;
            meter_conf.meter_mode
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_PAIR_MODEf);
            meter_conf.meter_mode_modifier
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_PAIR_MODE_MODIFIERf);
            meter_conf.meter_idx
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_INDEX_EVENf);
            meter_conf.meter_update_odd
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_UPDATE_ODDf);
            meter_conf.meter_test_odd
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_TEST_ODDf);
            meter_conf.meter_update_even
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_UPDATE_EVENf);
            meter_conf.meter_test_even
                = soc_mem_field32_get(unit, FP_POLICY_TABLEm, policy_buf,
                                      METER_TEST_EVENf);

            meter_pair_mode = meter_conf.meter_mode;
            pair_index = meter_conf.meter_idx;
            if ((meter_pair_mode == 0) && (pair_index == 0)) {
                return BCM_E_NONE;
            }

            if (BCM_FIELD_METER_MODE_FLOW == meter_pair_mode) {
                /* modifier_mode: 0 = Excess Meter, 1 = Committed Meter. */
                modifier_mode = meter_conf.meter_mode_modifier;
                /* Determine meter offset value for flow meters. */
                meter_offset = (0 == modifier_mode) ? 0 : 1;
            }

            /* Get meter pool number and meter index. */
            BCM_IF_ERROR_RETURN
                (_field_trx_meter_pool_resolve(unit, stage_fc, pair_index,
                                               &pool_index, &hw_index));

            f_mp = stage_fc->meter_pool[_FP_DEF_INST][pool_index];
            if (_FP_INVALID_INDEX == f_mp->slice_id) {
                f_mp->slice_id = fg->slices->slice_number;
                f_mp->level = 0;
            }
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            /* Egress stage */
            meter_mem = EFP_METER_TABLEm;
            meter_conf.meter_mode = soc_mem_field32_get(unit, EFP_POLICY_TABLEm,
                                                        policy_buf,
                                                        METER_PAIR_MODEf);
            meter_conf.meter_idx = soc_mem_field32_get(unit, EFP_POLICY_TABLEm,
                                                       policy_buf,
                                                       METER_INDEX_EVENf);
            meter_conf.meter_update_odd = soc_mem_field32_get(unit,
                                            EFP_POLICY_TABLEm, policy_buf,
                                            METER_UPDATE_ODDf);
            meter_conf.meter_test_odd = soc_mem_field32_get(unit,
                                            EFP_POLICY_TABLEm, policy_buf,
                                            METER_TEST_ODDf);
            meter_conf.meter_update_even = soc_mem_field32_get(unit,
                                            EFP_POLICY_TABLEm, policy_buf,
                                            METER_UPDATE_EVENf);
            meter_conf.meter_test_even = soc_mem_field32_get(unit,
                                            EFP_POLICY_TABLEm, policy_buf,
                                            METER_TEST_EVENf);
            meter_pair_mode = meter_conf.meter_mode;
            pool_index = fs->slice_number;
            hw_index = meter_conf.meter_idx;
            if ((meter_pair_mode == 0) && (hw_index == 0)) {
                return BCM_E_NONE;
            }

            if (BCM_FIELD_METER_MODE_FLOW == meter_pair_mode) {
                /* modifier_mode: 0 = Excess Meter, 1 = Committed Meter. */
                modifier_mode = (meter_conf.meter_update_even
                                    && meter_conf.meter_test_even) ? 0 : 1;
                /* Determine meter offset value for flow meters. */
                meter_offset = (0 == modifier_mode) ? 0 : 1;
            }
            break;
        default:
            /* Must be a valid stage. */
            return (BCM_E_INTERNAL);
    }

    /* Check if meter index is already in use. */
    if (BCM_SUCCESS(_field_trx_meter_index_in_use(unit, stage_fc, fs, f_mp,
                                                  meter_pair_mode,
                                                  meter_offset,
                                                  hw_index))) {
        uint32 idx, found = 0;

        for (idx = 0; idx < _FP_HASH_SZ(fc); idx++) {
            f_pl = fc->policer_hash[idx];
            while (f_pl != NULL) {
                if ((f_pl->hw_index == hw_index) &&
                    (f_pl->pool_index == pool_index) &&
                    (f_pl->stage_id == stage_id)) {
                    found = 1;
                    break;
                }
                f_pl = f_pl->next;
            }
            if (found) {
                break;
            }
        }
        if (!found) {
            return BCM_E_INTERNAL;
        }
        f_pl->hw_ref_count++;
        f_pl->sw_ref_count++;
    } else {
        /* Policer does not exist => Allocate new policer object */
        if (fc->l2warm) {
            policer_id = pid;
        } else {
            BCM_IF_ERROR_RETURN(_field_policer_id_alloc(unit, &policer_id));
        }

        _FP_XGS3_ALLOC(f_pl, sizeof (_field_policer_t), "Field policer entity");
        if (f_pl == NULL) {
            return (BCM_E_MEMORY);
        }

        ent_pl_flags       |= _FP_POLICER_INSTALLED;
        f_pl->sw_ref_count = 2;
        f_pl->hw_ref_count = 1;
        f_pl->pid          = policer_id;
        f_pl->stage_id     = fg->stage_id;
        f_pl->pool_index   = pool_index;
        f_pl->hw_index     = hw_index;

        /* Calculate hardware meter index. */
        if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
            /*
             * Hw index is:
             * ((Pool number * pool_size) + (2 * pair number)
             */
            meter_hw_idx = (pool_index *
                stage_fc->meter_pool[_FP_DEF_INST][pool_index]->size)
                            + (2 * hw_index);
        } else {
            /*
             * Hw index is:
             * (slice index) + (2 * pair number)
             */
            meter_hw_idx =
                stage_fc->slices[_FP_DEF_INST][pool_index].start_tcam_idx
                            + (2 * hw_index);
        }

        switch (meter_pair_mode) {
            case BCM_FIELD_METER_MODE_DEFAULT:
                f_pl->cfg.mode = bcmPolicerModeGreen;
                break;

            case BCM_FIELD_METER_MODE_FLOW:
                f_pl->cfg.mode = bcmPolicerModeCommitted;
                if (meter_offset) {
                    /* Flow mode using committed hardware meter. */
                    _FP_POLICER_EXCESS_HW_METER_CLEAR(f_pl);
                } else {
                    /* Flow mode using excess hardware meter. */
                    _FP_POLICER_EXCESS_HW_METER_SET(f_pl);
                }
                meter_hw_idx += meter_offset;
                _bcm_field_trx_meter_rate_burst_recover(unit,
                    meter_mem, meter_hw_idx, &f_pl->cfg.ckbits_sec,
                    &f_pl->cfg.ckbits_burst,
                    &f_pl->cfg.flags);
                break;

            case BCM_FIELD_METER_MODE_trTCM_COLOR_BLIND:
                f_pl->cfg.flags |= BCM_POLICER_COLOR_BLIND;
                /* Fall through */
            case BCM_FIELD_METER_MODE_trTCM_COLOR_AWARE:
                f_pl->cfg.mode = bcmPolicerModeTrTcm;

                /* Get excess meter config from hardware. */
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx, &f_pl->cfg.pkbits_sec,
                    &f_pl->cfg.pkbits_burst,
                    &f_pl->cfg.flags);

                /* Get committed meter config from hardware. */
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    (meter_hw_idx + 1), &f_pl->cfg.ckbits_sec,
                    &f_pl->cfg.ckbits_burst,
                    &f_pl->cfg.flags);

                break;
            case 4:
                if (fg->stage_id == _BCM_FIELD_STAGE_EGRESS) {
                    f_pl->cfg.mode = bcmPolicerModePassThrough;
                }
                break;
            case 5:
                break;
            case BCM_FIELD_METER_MODE_srTCM_COLOR_BLIND:
                f_pl->cfg.flags |= BCM_POLICER_COLOR_BLIND;
                /* Fall through */
            case BCM_FIELD_METER_MODE_srTCM_COLOR_AWARE:
                f_pl->cfg.mode = bcmPolicerModeSrTcm;

                /* Get excess meter config from hardware. */
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    meter_hw_idx, &f_pl->cfg.pkbits_sec,
                    &f_pl->cfg.pkbits_burst,
                    &f_pl->cfg.flags);

                /* Get committed meter config from hardware. */
                _bcm_field_trx_meter_rate_burst_recover(unit, meter_mem,
                    (meter_hw_idx + 1), &f_pl->cfg.ckbits_sec,
                    &f_pl->cfg.ckbits_burst,
                    &f_pl->cfg.flags);

                break;
            default:
                break;
        }

        /* Assume policer was created using the policer_create API */
        if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
            if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                if ((part == 2) || (part == 3)) {
                    f_ent->flags |= _FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
                }
            } else {
                if (part == 1) {
                    f_ent->flags |= _FP_ENTRY_POLICER_IN_SECONDARY_SLICE;
                }
            }
        }
        _FP_HASH_INSERT(fc->policer_hash, f_pl,
                        (policer_id & _FP_HASH_INDEX_MASK(fc)));
        fc->policer_count++;

        /* Mark meter index as used in slice/pool */
        if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS
            && (_BCM_FIELD_STAGE_EGRESS != stage_id)) {
            if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
                _FP_METER_BMP_ADD(f_mp->meter_bmp, (hw_index * 2));
                _FP_METER_BMP_ADD(f_mp->meter_bmp, ((hw_index * 2) + 1));
                f_mp->free_meters -= 2;
            } else {
                _FP_METER_BMP_ADD(f_mp->meter_bmp,
                                  ((hw_index * 2) + meter_offset));
                f_mp->free_meters--;
            }
        } else {
            if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
                _FP_METER_BMP_ADD(fs->meter_bmp, (hw_index * 2));
                _FP_METER_BMP_ADD(fs->meter_bmp, ((hw_index * 2) + 1));
            } else {
                _FP_METER_BMP_ADD(fs->meter_bmp,
                                  ((hw_index * 2) + meter_offset));
            }
        }
        fg->group_status.meter_count++;
    }

    /* Associate the policer object with the entry */
    f_ent_pl = &f_ent->policer[0];
    f_ent_pl->flags |= (_FP_POLICER_VALID | ent_pl_flags);
    f_ent_pl->pid = f_pl->pid;
    *already_recovered = 1;

    return BCM_E_NONE;
}

STATIC int
_field_tr2_counter_recover(int              unit,
                           _field_entry_t   *f_ent,
                           uint32           ctr_mode,
                           uint32           ctr_idx,
                           int              part,
                           bcm_field_stat_t sid
                           )
{
    _field_group_t *fg;
    _field_stage_t *stage_fc;
    _field_stage_id_t stage_id;
    _field_control_t *fc;
    _field_slice_t *fs;
    _field_stat_t *f_st = NULL;
    _field_entry_stat_t *f_ent_st = NULL;
    int rv, idx, stat_id, found;
    uint32 sub_mode = 0, ent_st_flags = 0;
    bcm_field_stat_t stat_arr[4];
    uint8 nstat = 2;
    uint8 hw_entry_count = 1;
#if defined(BCM_TRIDENT_SUPPORT)
    int index = 0, rshift = 0;
#endif

    fg = f_ent->group;
    fs = f_ent[part].fs;

    /* Get field control and stage control */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    stage_id = f_ent->group->stage_id;
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(stat_arr, 0, sizeof(stat_arr));

    /* Search if counter has already been detected */
    /* Go over the counter in the slice */
#if defined(BCM_TRIDENT_SUPPORT)
    if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
    (stage_id == _BCM_FIELD_STAGE_INGRESS)){
        hw_entry_count =
            ((ctr_mode & (0x7)) ? 1 : 0) + ((ctr_mode & (0x7 << 3)) ? 1 : 0);
    } else
#endif
    {
        sub_mode = ctr_mode & ~BCM_FIELD_COUNTER_MODE_BYTES;
        if ((sub_mode == BCM_FIELD_COUNTER_MODE_RED) ||
            (sub_mode == BCM_FIELD_COUNTER_MODE_YELLOW) ||
            (sub_mode == BCM_FIELD_COUNTER_MODE_GREEN) ||
            (sub_mode == BCM_FIELD_COUNTER_MODE_YES_NO) ||
            (sub_mode == BCM_FIELD_COUNTER_MODE_DEFAULT)) {
            hw_entry_count = 1;
        } else {
            hw_entry_count = 2;
        }
    }

    found = 0;
    if (stage_id != _BCM_FIELD_STAGE_EXTERNAL) {
        if (((_FP_COUNTER_BMP_TEST(fs->counter_bmp, 2 * ctr_idx)) &&
             (_FP_COUNTER_BMP_TEST(fs->counter_bmp, 2 * ctr_idx + 1)) &&
             (hw_entry_count == 2)) ||
            ((_FP_COUNTER_BMP_TEST(fs->counter_bmp, 2 * ctr_idx + 1)) &&
             (hw_entry_count == 1) && (ctr_mode % 2 == 0)) ||
            ((_FP_COUNTER_BMP_TEST(fs->counter_bmp, 2 * ctr_idx)) &&
             (hw_entry_count == 1) && (ctr_mode % 2))) {
            /* Counter has been detected - increment reference count */
            /* Happens when counter is shared by different entries */
            /* Search the hash to match against the HW index */

            for (idx = 0; idx < _FP_HASH_SZ(fc); idx++) {
                f_st = fc->stat_hash[idx];
                while (f_st != NULL) {
                    if ((f_st->hw_index == ctr_idx) &&
                        (f_st->pool_index == fs->slice_number) &&
                        (f_st->hw_mode == ctr_mode) &&
                        (f_st->stage_id == stage_id)) {
                        found = 1;
                        break;
                    }
                    f_st = f_st->next;
                }
                if (found) {
                    break;
                }
            }
            if (!found) {
                return BCM_E_INTERNAL;
            }
            f_st->hw_ref_count++;
            f_st->sw_ref_count++;
            f_ent_st = &f_ent->statistic;
        }
    }

    if (!found) {
        /* Allocate new stat object */
        if (fc->l2warm) {
            stat_id = sid;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_field_stat_id_alloc(unit, &stat_id));
        }
        _FP_XGS3_ALLOC(f_st, sizeof (_field_stat_t), "Field stat entity");
        if (NULL == f_st) {
            return (BCM_E_MEMORY);
        }
        ent_st_flags |= _FP_ENTRY_STAT_INSTALLED;
        f_st->sw_ref_count = 2;
        f_st->hw_ref_count = 1;
        f_st->pool_index = fs->slice_number;
        f_st->hw_index = ctr_idx;
        f_st->sid = stat_id;
        f_st->stage_id = fg->stage_id;
        f_st->gid = fg->gid;
        f_st->hw_mode = ctr_mode;
        f_ent_st = &f_ent->statistic;
#if defined(BCM_TRIDENT_SUPPORT)
        if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) &&
                (stage_id == _BCM_FIELD_STAGE_INGRESS)){
            while (hw_entry_count >= 1) {

                /* Lower counter is not used */
                if ((1 == hw_entry_count) &&
                    (2 == nstat) &&
                    (0 == ((ctr_mode) & 0x7))) {
                    rshift += 3;
                }

                switch ((ctr_mode >> rshift) & 0x7) {
                    case 1:
                        /* TR Mode = 4 */
                        /* 001 */
                        stat_arr[index++] = bcmFieldStatGreenBytes;
                        stat_arr[index++] = bcmFieldStatGreenPackets;
                        break;
                    case 2:
                        /* 010 */
                        stat_arr[index++] = bcmFieldStatYellowBytes;
                        stat_arr[index++] = bcmFieldStatYellowPackets;
                        break;
                    case 3:
                        /* TR Mode = 3 */
                        /* TR Mode = 6 */
                        /* 011 */
                        stat_arr[index++] = bcmFieldStatNotRedBytes;
                        stat_arr[index++] = bcmFieldStatNotRedPackets;
                        break;
                    case 4:
                        /* TR Mode = 3 */
                        /* 100 */
                        stat_arr[index++] = bcmFieldStatRedBytes;
                        stat_arr[index++] = bcmFieldStatRedPackets;
                        break;
                    case 5:
                        /* TR Mode = 5 */
                        /* 101 */
                        stat_arr[index++] = bcmFieldStatNotYellowBytes;
                        stat_arr[index++] = bcmFieldStatNotYellowPackets;
                        break;
                    case 6:
                        /* TR Mode = 4 */
                        /* TR Mode = 7 */
                        /* 110 */
                        stat_arr[index++] = bcmFieldStatNotGreenBytes;
                        stat_arr[index++] = bcmFieldStatNotGreenPackets;
                        break;
                    case 7:
                        /* TR Mode = 1 */
                        /* 111 */
                        stat_arr[index++] = bcmFieldStatBytes;
                        stat_arr[index++] = bcmFieldStatPackets;
                        break;
                    default:
                        break;
                }
                hw_entry_count--;
                /* Get Upper counter mode */
                rshift += 3;
                /* Upper and Lower both counters used */
                if (1 == hw_entry_count) {
                    nstat += 2;
                }
            }
        } else
#endif
        {
            switch (sub_mode) {
                case BCM_FIELD_COUNTER_MODE_DEFAULT:
                    stat_arr[0] = bcmFieldStatBytes;
                    stat_arr[1] = bcmFieldStatPackets;
                    nstat = 2;
                    break;
                case BCM_FIELD_COUNTER_MODE_YES_NO:
                    stat_arr[0] = bcmFieldStatBytes;
                    stat_arr[1] = bcmFieldStatPackets;
                    nstat = 2;
                    break;
                case BCM_FIELD_COUNTER_MODE_RED_NOTRED:
                    stat_arr[0] = bcmFieldStatRedBytes;
                    stat_arr[1] = bcmFieldStatRedPackets;
                    stat_arr[2] = bcmFieldStatNotRedBytes;
                    stat_arr[3] = bcmFieldStatNotRedPackets;
                    nstat = 4;
                    break;
                case BCM_FIELD_COUNTER_MODE_GREEN_NOTGREEN:
                    stat_arr[0] = bcmFieldStatGreenBytes;
                    stat_arr[1] = bcmFieldStatGreenPackets;
                    stat_arr[2] = bcmFieldStatNotGreenBytes;
                    stat_arr[3] = bcmFieldStatNotGreenPackets;
                    nstat = 4;
                    break;
                case BCM_FIELD_COUNTER_MODE_GREEN_RED:
                    stat_arr[0] = bcmFieldStatGreenBytes;
                    stat_arr[1] = bcmFieldStatGreenPackets;
                    stat_arr[2] = bcmFieldStatRedBytes;
                    stat_arr[3] = bcmFieldStatRedPackets;
                    nstat = 4;
                    break;
                case BCM_FIELD_COUNTER_MODE_GREEN_YELLOW:
                    stat_arr[0] = bcmFieldStatGreenBytes;
                    stat_arr[1] = bcmFieldStatGreenPackets;
                    stat_arr[2] = bcmFieldStatYellowBytes;
                    stat_arr[3] = bcmFieldStatYellowPackets;
                    nstat = 4;
                    break;
                case BCM_FIELD_COUNTER_MODE_RED_YELLOW:
                    stat_arr[0] = bcmFieldStatRedBytes;
                    stat_arr[1] = bcmFieldStatRedPackets;
                    stat_arr[2] = bcmFieldStatYellowBytes;
                    stat_arr[3] = bcmFieldStatYellowPackets;
                    nstat = 4;
                    break;
                default:
                    break;
            }
        }
        rv = _bcm_field_stat_array_init(unit, fc, f_st, nstat, stat_arr);
        if (BCM_FAILURE(rv)) {
            sal_free(f_st);
            return rv;
        }

        if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
            if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                if ((part == 2) || (part == 3)) {
                    f_ent->flags |= _FP_ENTRY_STAT_IN_SECONDARY_SLICE;
                }
            } else {
                if (part == 1) {
                    f_ent->flags |= _FP_ENTRY_STAT_IN_SECONDARY_SLICE;
                }
            }
        }
        _FP_HASH_INSERT(fc->stat_hash, f_st,
                        (stat_id & _FP_HASH_INDEX_MASK(fc)));
        fc->stat_count++;

        if (stage_id != _BCM_FIELD_STAGE_EXTERNAL) {
            /* Mark as used in the slice */
            if (2 == f_st->hw_entry_count) {
                _FP_COUNTER_BMP_ADD(fs->counter_bmp, 2 * ctr_idx);
                _FP_COUNTER_BMP_ADD(fs->counter_bmp, 2 * ctr_idx + 1);
            } else {
                if ((ctr_mode % 2) == 0) {
                    _FP_COUNTER_BMP_ADD(fs->counter_bmp, 2 * ctr_idx + 1);
                } else {
                    _FP_COUNTER_BMP_ADD(fs->counter_bmp, 2 * ctr_idx);
                }
            }
        }

        fg->group_status.counter_count =
             fg->group_status.counter_count + f_st->hw_entry_count;
    }

    /* Associate the stat object with the entry */
    f_ent_st->flags |= (_FP_ENTRY_STAT_VALID | ent_st_flags);
    f_ent_st->sid = f_st->sid;

    return (BCM_E_NONE);
}


int
_field_trx_actions_recover_action_add(int                unit,
                                      _field_entry_t     *f_ent,
                                      bcm_field_action_t action,
                                      uint32             param0,
                                      uint32             param1,
                                      uint32             param2,
                                      uint32             param3,
                                      uint32             param4,
                                      uint32             param5,
                                      uint32             hw_index
                                      )
{
    int             rv;
    _field_action_t *fa = NULL;

    rv = _field_action_alloc(unit, action,
             param0, param1, param2, param3, param4, param5, &fa);
    if (BCM_FAILURE(rv)) {
        return rv;
    }

    fa->hw_index = hw_index;

    fa->flags &= ~_FP_ACTION_DIRTY; /* Mark action as installed. */

    /* Add action to front of entry's linked-list. */
    fa->next = f_ent->actions;
    f_ent->actions  = fa;

    return (BCM_E_NONE);
}

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
/*
 * Function:
 *     _field_flex_counter_recover
 * Purpose:
 *     Recovers flex counter stat entry in warm-boot stage
 *
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     f_ent     - (IN) Field entry.
 *     part      - (IN) Field entry part
 *     sid       - (IN) stat id
 *
 * Returns:
 *     BCM_E_XXX
 */
int _field_flex_counter_recover(int            unit,
                                _field_entry_t *f_ent,
                                int            part,
                                int            sid)
{
    _field_group_t      *fg=NULL;
    _field_stage_t      *stage_fc=NULL;
    _field_stage_id_t   stage_id;
    _field_control_t    *fc=NULL;
    _field_stat_t       *f_st = NULL;
    _field_entry_stat_t *f_ent_st = NULL;
    int                 rv=0;
    int                 stat_id=0;
    bcm_field_stat_t    stat_arr[2]={bcmFieldStatBytes, bcmFieldStatPackets};
    uint8               nstat = 2;

    fg = f_ent->group;

    /* Get field control and stage control */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    stage_id = f_ent->group->stage_id;
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv  = _bcm_field_stat_get(unit, sid, &f_st);
    if (!((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_NONE))) {
        return rv;
    }
    if (rv == BCM_E_NOT_FOUND) {
        BCM_IF_ERROR_RETURN(_bcm_field_stat_id_alloc(unit, &stat_id));
        _FP_XGS3_ALLOC(f_st, sizeof (_field_stat_t), "Field stat entity");
        if (NULL == f_st) {
            return (BCM_E_MEMORY);
        }
        f_st->hw_ref_count = 0;
        f_st->sw_ref_count = 1;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_index = _FP_INVALID_INDEX;
        f_st->sid = sid;
        f_st->hw_flags = 0; /* INTERNAL */
        f_st->stage_id = fg->stage_id;
        f_st->gid      = fg->gid;
        /* Allocate counters array. */
        if (flex_info[unit].valid == 1) {
            switch(flex_info[unit].flex_stat_map) {
            case 1:
                nstat = 1;
                stat_arr[0] = bcmFieldStatBytes;
                LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                                        "_field_flex_counter_recover: StatBytes \n")));
                break;
            case 2:
                nstat = 1;
                stat_arr[0] = bcmFieldStatPackets;
                LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                                        "_field_flex_counter_recover: StatPackets \n")));
                break;
            case 3:
                LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                                        "_field_flex_counter_recover:StatBytes & Packets\n")));
                break;
            default:
                LOG_WARN(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "_field_flex_counter_recover:Default Bytes&Pkts.\n")));
                break;
            }
        } else {
            LOG_WARN(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "_field_flex_counter_recover:   flex info not valid!.\n")));
        }
        rv = _bcm_field_stat_array_init(unit, fc, f_st, nstat, stat_arr);
        if (BCM_FAILURE(rv)) {
            sal_free(f_st);
            return (rv);
        }
        f_st->hw_entry_count = 1;
        _FP_HASH_INSERT(fc->stat_hash, f_st,
                        (sid & _FP_HASH_INDEX_MASK(fc)));
        fc->stat_count++;
    }
    f_ent_st = &f_ent->statistic;
    f_st->hw_ref_count++;
    f_st->sw_ref_count++;
    /* Associate the stat object with the entry */
    f_ent_st->flags |= (_FP_ENTRY_STAT_VALID | _FP_ENTRY_STAT_INSTALLED);
    f_ent_st->sid = f_st->sid;
    return BCM_E_NONE;
}
#endif

#if defined(BCM_TRIUMPH2_SUPPORT)
/*
 * Function:
 *     _field_vfp_flex_counter_recover
 * Purpose:
 *     Recovers flex counter stat entry in warm-boot stage
 *
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     f_ent     - (IN) Field entry.
 *     part      - (IN) Field entry part
 *     cntr_idx  - (IN) counter HW index
 *     sid       - (IN) stat id
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC
int _field_vfp_flex_counter_recover(int            unit,
                                _field_entry_t *f_ent,
                                int            part,
                                int            cntr_idx,
                                int            sid)
{
    _field_stat_t       *f_st = NULL;
    int                 rv=0;

    BCM_IF_ERROR_RETURN(_field_flex_counter_recover(
                unit, f_ent, part, sid));

    rv  = _bcm_field_stat_get(unit, sid, &f_st);

    if (BCM_SUCCESS(rv) &&
            (f_st->hw_index == _FP_INVALID_INDEX)) {
        f_st->hw_index = cntr_idx;
    }

    return rv;
}
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
/*
 * Function:
 *     _field_flowcnt_counter_recover
 * Purpose:
 *     Recovers flowcnt counter stat entry in warm-boot stage
 *
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     f_ent     - (IN) Field entry.
 *     part      - (IN) Field entry part
 *     sid       - (IN) stat id
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC
int _field_flowcnt_counter_recover(int            unit,
                                _field_entry_t *f_ent,
                                int            part,
                                int            sid)
{
    _field_group_t      *fg=NULL;
    _field_stage_t      *stage_fc=NULL;
    _field_stage_id_t   stage_id;
    _field_control_t    *fc=NULL;
    _field_stat_t       *f_st = NULL;
    _field_entry_stat_t *f_ent_st = NULL;
    int                 rv=0;
    int                 stat_id=0;
    bcm_field_stat_t    stat_arr[1]={bcmFieldStatBytes};
    uint8               nstat = 1;

    fg = f_ent->group;

    /* Get field control and stage control */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    stage_id = f_ent->group->stage_id;
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv  = _bcm_field_stat_get(unit, sid, &f_st);
    if (!((rv == BCM_E_NOT_FOUND) || (rv == BCM_E_NONE))) {
        return rv;
    }
    if (rv == BCM_E_NOT_FOUND) {
        BCM_IF_ERROR_RETURN(_bcm_field_stat_id_alloc(unit, &stat_id));
        _FP_XGS3_ALLOC(f_st, sizeof (_field_stat_t), "Field stat entity");
        if (NULL == f_st) {
            return (BCM_E_MEMORY);
        }
        f_st->hw_ref_count = 0;
        f_st->sw_ref_count = 1;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_index = _FP_INVALID_INDEX;
        f_st->sid = sid;
        f_st->hw_flags = 0; /* INTERNAL */
        f_st->stage_id = fg->stage_id;
        f_st->gid      = fg->gid;
        /* Allocate counters array. */
        if (flex_info[unit].valid == 1) {
            switch(flex_info[unit].flex_stat_map) {
            case 1:
                nstat = 1;
                stat_arr[0] = bcmFieldStatBytes;
                LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                                        "_field_flowcnt_counter_recover: StatBytes \n")));
                break;
            case 2:
                nstat = 1;
                stat_arr[0] = bcmFieldStatPackets;
                LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,
                                        "_field_flowcnt_counter_recover: StatPackets \n")));
                break;
            default:
                LOG_WARN(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "_field_flowcnt_counter_recover:Default Bytes.\n")));
                break;
            }
        } else {
            LOG_WARN(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "_field_flowcnt_counter_recover:   flex info not valid!.\n")));
        }
        rv = _bcm_field_stat_array_init(unit, fc, f_st, nstat, stat_arr);
        if (BCM_FAILURE(rv)) {
            sal_free(f_st);
            return (rv);
        }
        f_st->hw_entry_count = 1;
        _FP_HASH_INSERT(fc->stat_hash, f_st,
                        (sid & _FP_HASH_INDEX_MASK(fc)));
        fc->stat_count++;
    }
    f_ent_st = &f_ent->statistic;
    f_st->hw_ref_count++;
    f_st->sw_ref_count++;
    /* Associate the stat object with the entry */
    f_ent_st->flags |= (_FP_ENTRY_STAT_VALID | _FP_ENTRY_STAT_INSTALLED);
    f_ent_st->sid = f_st->sid;
    return BCM_E_NONE;
}
#endif

#if defined(INCLUDE_L3)
/*
 * Function:
 *     _bcm_field_l3_recover_callback
 * Purpose:
 *     Callback routine from L3 reinit to recover field actions dependant on
 *     L3 module.
 *
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *
 * Returns:
 *     BCM_E_XXX
 */
int _bcm_field_l3_recover_callback(int unit)
{
   _bcm_field_l3_callback_recover_t *l3_cb = NULL;
   egr_l3_next_hop_entry_t egr_l3_next_hop_entry;
   unsigned                if_idx;
   egr_l3_intf_entry_t     egr_l3_intf_entry;
   sal_mac_addr_t          mac_addr;
   uint32                  mac_addr_words[2];
   soc_field_t             fp_action_fld;
   _field_entry_t          *f_ent = NULL;
   int                     rv, hw_index;
   bcm_l3_egress_t         l3_egr;

   if (_field_l3_cb == NULL) {
      return BCM_E_NONE;
   }

   l3_cb = _field_l3_cb;
   while (l3_cb != NULL) {
      switch (l3_cb->action) {
         case bcmFieldActionChangeL2Fields:

         /* Fetch L3 next-hop and interface records */
         hw_index = l3_cb->hw_index;
         f_ent = l3_cb->f_ent;

         /* Get next hop info from Egress Object ID param */
         rv = bcm_esw_l3_egress_get(unit, l3_cb->param0, &l3_egr);
         if (BCM_SUCCESS(rv)) {
             /*
              * Action bcmFieldActionChangeL2Fields is set for all actions which
              * were programmed in G_L3SW_CHANGE_L2_FIELDSf
              * In order to differentiate between bcmFieldActionChangeL2Fields and
              * others BCM_L3_FLAGS2_FIELD_ONLY flag will be set in L3
              */
             if (l3_egr.flags2 & BCM_L3_FLAGS2_FIELD_ONLY) {
                rv = _field_trx_actions_recover_action_add(
                          unit, l3_cb->f_ent, l3_cb->action,
                          l3_cb->param0, 0, 0, 0, 0, 0, hw_index);
                if (BCM_FAILURE(rv)) {
                   return (rv);
                }
                break;
             }
         } else {
             LOG_ERROR(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "FP(unit %d) Error: Getting next hop info failed"
                                 "from Egress Object ID param : %d\n"),
                      unit, l3_cb->param0));
             return (rv);
         }
         rv = soc_mem_read(unit,
                           EGR_L3_NEXT_HOPm,
                           MEM_BLOCK_ANY,
                           hw_index,
                           egr_l3_next_hop_entry.entry_data);

         if (BCM_FAILURE(rv)) {
             return (rv);
         }

         if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
             if (soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                    egr_l3_next_hop_entry.entry_data,
                                    ENTRY_TYPEf) != 6) {
                 return (BCM_E_INTERNAL) ;
             }

             if_idx = soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                egr_l3_next_hop_entry.entry_data,
                                         IFP_ACTIONS__INTF_NUMf);

             rv = soc_mem_read(unit,
                               EGR_L3_INTFm,
                               MEM_BLOCK_ANY,
                               if_idx,
                               egr_l3_intf_entry.entry_data);

             if (BCM_FAILURE(rv)) {
                 return (rv);
             }

             /* Inform L3 module these interface and next-hop
                records are in use.
             */

             /* L3 module is not initialized yet;
                L3 to supply function calls for reference count accounting,
                callable at this point.

             BCM_L3_INTF_USED_SET(unit, if_idx);
             _bcm_xgs3_nh_ref_cnt_incr(unit, hw_index);
             */
             if (SOC_IS_KATANA2(unit)) {
                 fp_action_fld = IFP_ACTIONS__L3_DA_DISABLEf;
             } else {
                 fp_action_fld = IFP_ACTIONS__L3_UC_DA_DISABLEf;
             }
             if (soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                           egr_l3_next_hop_entry.entry_data,
                           fp_action_fld) == 0) {
                 /* Replace MACDA not disabled => Recover value for new MAC DA */
                 soc_mem_mac_addr_get(unit,
                                      EGR_L3_NEXT_HOPm,
                                      egr_l3_next_hop_entry.entry_data,
                                      IFP_ACTIONS__MAC_ADDRESSf,
                                      mac_addr);

                 SAL_MAC_ADDR_TO_UINT32(mac_addr, mac_addr_words);
                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent, bcmFieldActionDstMacNew,
                          mac_addr_words[0], mac_addr_words[1],
                          0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }
             if (SOC_IS_KATANA2(unit)) {
                 fp_action_fld = IFP_ACTIONS__L3_SA_DISABLEf;
             } else {
                 fp_action_fld = IFP_ACTIONS__L3_UC_SA_DISABLEf;
             }

             if (soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                     egr_l3_next_hop_entry.entry_data,
                                     fp_action_fld) == 0) {
                 /* Replace MACSA not disabled => Recover value for new MAC SA */
                 soc_mem_mac_addr_get(unit, EGR_L3_INTFm,
                                      egr_l3_intf_entry.entry_data,
                                      MAC_ADDRESSf, mac_addr);

                 SAL_MAC_ADDR_TO_UINT32(mac_addr, mac_addr_words);

                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent, bcmFieldActionSrcMacNew,
                          mac_addr_words[0], mac_addr_words[1],
                          0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }
             if (SOC_IS_KATANA2(unit)) {
                 fp_action_fld = IFP_ACTIONS__L3_VLAN_DISABLEf;
             } else {
                 fp_action_fld = IFP_ACTIONS__L3_UC_VLAN_DISABLEf;
             }

             if (soc_mem_field32_get(
                     unit, EGR_L3_NEXT_HOPm,
                     egr_l3_next_hop_entry.entry_data,
                     fp_action_fld) == 0) {
                 /* Replace outer VID not disabled => Recover value for new outer VID */

                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent, bcmFieldActionOuterVlanNew,
                          soc_mem_field32_get(unit, EGR_L3_INTFm,
                              egr_l3_intf_entry.entry_data, VIDf),
                              0, 0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }

             if (SOC_MEM_FIELD_VALID(unit, EGR_L3_NEXT_HOPm,
                                     IFP_ACTIONS__VNTAG_ACTIONf)) {
                 switch (soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                   egr_l3_next_hop_entry.entry_data,
                                   IFP_ACTIONS__VNTAG_ACTIONf)) {
                 case 1:
                     /* Replace VNTAG => Recover value for new VNTAG */
                     rv = _field_trx_actions_recover_action_add(
                              unit,
                              f_ent,
                              bcmFieldActionVnTagNew,
                              soc_mem_field32_get(
                                  unit,
                                  EGR_L3_NEXT_HOPm,
                                  egr_l3_next_hop_entry.entry_data,
                                  IFP_ACTIONS__VNTAGf),
                                  0, 0, 0, 0, 0, hw_index);
                     if (BCM_FAILURE(rv)) {
                         return (rv);
                     }
                     break;

                 case 2:
                     /* Replace ETAG => Recover value for new ETAG */
                     rv = _field_trx_actions_recover_action_add(
                              unit,
                              f_ent,
                              bcmFieldActionEtagNew,
                              soc_mem_field32_get(
                                  unit,
                                  EGR_L3_NEXT_HOPm,
                                  egr_l3_next_hop_entry.entry_data,
                                  IFP_ACTIONS__VNTAGf),
                                  0, 0, 0, 0, 0, hw_index);
                     if (BCM_FAILURE(rv)) {
                         return (rv);
                     }
                     break;

                 case 3:
                     /* VNTAG delete */
                     rv = _field_trx_actions_recover_action_add(
                              unit,
                              f_ent,
                              bcmFieldActionVnTagDelete,
                              0, 0, 0, 0, 0, 0, hw_index);
                     if (BCM_FAILURE(rv)) {
                         return (rv);
                     }
                     break;

                 default:
                     ;

                 }
             }
         } else {
             /* Non-Trident */
             if_idx = soc_mem_field32_get(
                          unit,
                          EGR_L3_NEXT_HOPm,
                          egr_l3_next_hop_entry.entry_data,
                          L3__INTF_NUMf);
             rv = soc_mem_read(unit,
                               EGR_L3_INTFm,
                               MEM_BLOCK_ANY,
                               if_idx,
                               egr_l3_intf_entry.entry_data);
             if (BCM_FAILURE(rv)) {
                 return (rv);
             }

             /* Inform L3 module these interface and next-hop
                records are in use.
             */

             /* L3 module is not initialized yet;
                L3 to supply function calls for reference count accounting,
                callable at this point.

             BCM_L3_INTF_USED_SET(unit, if_idx);
             _bcm_xgs3_nh_ref_cnt_incr(unit, hw_index);
             */

             if (soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                           egr_l3_next_hop_entry.entry_data,
                           L3__L3_UC_DA_DISABLEf) == 0) {
                 /* Replace MAC DA not disabled
                    => Recover value for new MAC DA
                 */
                 soc_mem_mac_addr_get(unit, EGR_L3_NEXT_HOPm,
                            egr_l3_next_hop_entry.entry_data,
                            L3__MAC_ADDRESSf, mac_addr);

                 SAL_MAC_ADDR_TO_UINT32(mac_addr, mac_addr_words);

                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent, bcmFieldActionDstMacNew,
                          mac_addr_words[0], mac_addr_words[1],
                          0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }

             if (soc_mem_field32_get(
                     unit, EGR_L3_NEXT_HOPm,
                     egr_l3_next_hop_entry.entry_data,
                     L3__L3_UC_SA_DISABLEf) == 0) {
                 /* Replace MAC SA not disabled
                    => Recover value for new MAC SA
                 */

                 soc_mem_mac_addr_get(unit,
                                      EGR_L3_INTFm,
                                      egr_l3_intf_entry.entry_data,
                                      MAC_ADDRESSf,
                                      mac_addr);

                 SAL_MAC_ADDR_TO_UINT32(mac_addr, mac_addr_words);

                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent, bcmFieldActionSrcMacNew,
                          mac_addr_words[0], mac_addr_words[1],
                          0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }

             if (soc_mem_field32_get(
                     unit, EGR_L3_NEXT_HOPm,
                     egr_l3_next_hop_entry.entry_data,
                     L3__L3_UC_VLAN_DISABLEf) == 0) {
                 /* Replace outer VID not disabled
                    => Recover value for new outer VID
                 */

                 rv = _field_trx_actions_recover_action_add(
                          unit, f_ent,
                          bcmFieldActionOuterVlanNew,
                          soc_mem_field32_get(
                              unit,
                              EGR_L3_INTFm,
                              egr_l3_intf_entry.entry_data,
                              VIDf),
                          0, 0, 0, 0, 0, hw_index);
                 if (BCM_FAILURE(rv)) {
                     return (rv);
                 }
             }
            #if defined(BCM_TRIUMPH3_SUPPORT)
            if ((SOC_MEM_FIELD_VALID(unit, EGR_L3_NEXT_HOPm,
                                      L2_ACTIONS__VNTAG_ACTIONf))
                                      & (SOC_IS_TRIUMPH3(unit))) {
                 switch (soc_mem_field32_get(
                         unit,
                         EGR_L3_NEXT_HOPm,
                         egr_l3_next_hop_entry.entry_data,
                         L2_ACTIONS__VNTAG_ACTIONf)) {

                 case 2:
                     /* Replace ETAG
                        => Recover value for new ETAG
                     */

                     rv = _field_trx_actions_recover_action_add(
                              unit,
                              f_ent,
                              bcmFieldActionEtagNew,
                              soc_mem_field32_get(
                                  unit, EGR_L3_NEXT_HOPm,
                                  egr_l3_next_hop_entry.entry_data,
                                  L2_ACTIONS__VNTAGf),
                                  0, 0, 0, 0, 0, hw_index);
                     if (BCM_FAILURE(rv)) {
                         return (rv);
                     }
                     break;

                 case 3:
                     /* ETAG delete */

                     rv = _field_trx_actions_recover_action_add(
                              unit, f_ent, bcmFieldActionEtagDelete,
                              0, 0, 0, 0, 0, 0, hw_index);
                     if (BCM_FAILURE(rv)) {
                         return (rv);
                     }
                     break;

                 default:
                     ;

                 }
             }
             #endif /* BCM_TRIUMPH3_SUPPORT */
          }

          break;

         default:
           return BCM_E_INTERNAL;
      }

      /* Remove the callback and de-allocate it from the list */
      _field_l3_cb = l3_cb->next;
      sal_free(l3_cb);
      l3_cb = _field_l3_cb;
   }

   return BCM_E_NONE;
}
#endif /* INCLUDE_L3 */

int
_field_tr2_actions_recover(int              unit,
                           soc_mem_t        policy_mem,
                           uint32           *policy_entry,
                           _field_entry_t   *f_ent,
                           int              part,
                           _field_entry_wb_info_t *f_ent_wb_info
                           )
{
    soc_field_t fld;                    /* Policy table field info */
    uint32 fldval, hw_index, append;
    uint32 param0, param1, param2 = 0, param3 = 0, param4 = 0, param5 = 0;
    uint32 ctr_mode, ctr_idx;           /* Counter mode and index info */
    bcm_field_action_t action;          /* Action type */
    int rv, i, num_fields;              /* Number of fields in policy table info */
    int ecmp_paths, nh_ecmp;
    soc_mem_t profile_mem = IFP_REDIRECTION_PROFILEm; /* Redirection profile
                                                       *  table */
    ifp_redirection_profile_entry_t entry_arr[2]; /* Redirection profile entry */
    uint32 *entry_ptr[2];                /* Redirection profile pointer */
    soc_profile_mem_t *redirect_profile; /* Redirect Profile info */
    bcm_pbmp_t pbmp;                     /* Port bitmap info */
    uint8 pkt_int_new = 0;               /* Packet and Internal Priority info */
    bcm_module_t modid;                  /* Modid Info */
    bcm_gport_t  gport;                  /* GPORT info */
    uint32 mirror_pbm;                   /* Mirror bitmap info */
    uint16 bit_pos;                      /* Bit position info*/
    int mtp_index;                       /* Mirror to port index */
    egr_l3_next_hop_entry_t egr_l3_next_hop_entry; /* Egress Next Hop table
                                                    * entry info */
    sal_mac_addr_t mac_addr;             /* MAC address info */
    uint32 mac_addr_words[2];            /* MAC address info for Param[0], Param[1] */
    uint16 vlan_id;                      /* VLAN ID info */
    int8   uc_cosq = -1;                 /* Unicast COS Queue value */
    int8   mc_cosq = -1;                 /* Multicast COS Queue value */
    soc_field_t tmp_fld;
#if defined (BCM_KATANA_SUPPORT)
    uint32 cosq_idx = 0;
    int tag_type = 0;
#endif
#if defined BCM_TRIDENT2PLUS_SUPPORT
    _field_oam_action_recover_t  oam_action[3]; /* Oam Actions */
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    /* lookup hash selection profile table */
    soc_mem_t hash_select_profile_mem[2] = { VFP_HASH_FIELD_BMAP_TABLE_Am,
                                             VFP_HASH_FIELD_BMAP_TABLE_Bm};
    vfp_hash_field_bmap_table_a_entry_t hash_select_entry_arr[2]; /* hash select
                                                                   * profile
                                                                   * entry*/
    uint32            *hash_select_entry_ptr[2];
    soc_profile_mem_t *hash_select_profile[2];

#endif /* BCM_TRIDENT2_SUPPORT */
#if defined (BCM_TRIUMPH3_SUPPORT)
    int index;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint8 modid_new;                      /* ModId Info                       */
    uint8 portid_new;                     /* Physical Port Info               */
    uint8 change_modid;                   /* Flag to indicate change in ModId */
    uint8 change_portid;                  /* Flag to indicate change in
                                                              Physical PortId */
    uint8 is_not_svp;                     /* Flag to indicate port type       */
    uint32 svp;                           /* SVP ID                           */
#endif
    bcm_field_stat_action_t stat_action;
#if defined BCM_TRIUMPH2_SUPPORT
    _field_dscp_map_new_eid_list_t *dscp_map_new_eid_node = NULL;
#endif
#if defined INCLUDE_L3
    _bcm_field_l3_callback_recover_t *l3_cb = NULL;
#endif
    int action_sync = 1;
    int val = 0;
    _field_control_t     *fc = NULL;             /* Pointer to field control  */

    if (f_ent_wb_info == NULL) {
        return BCM_E_INTERNAL;
    }
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    entry_ptr[0] = (uint32 *)(&entry_arr[0]);
    entry_ptr[1] = (uint32 *)(&entry_arr[1]);

    sal_memset (&stat_action, 0, sizeof (stat_action));

    /* Reset redirection profile entry. */
    sal_memset(entry_arr, 0, 2*sizeof(ifp_redirection_profile_entry_t));

    /* Get the redirect profile */
    rv = _field_trx_redirect_profile_get(unit, &redirect_profile);
    BCM_IF_ERROR_RETURN(rv);

    SOC_PBMP_CLEAR(pbmp);
#if defined(BCM_TRIDENT2_SUPPORT)
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        hash_select_entry_ptr[0] = (uint32 *)hash_select_entry_arr;
        hash_select_entry_ptr[1] =  hash_select_entry_ptr[0] +
                                    soc_mem_entry_words(unit,
                                    hash_select_profile_mem[0]);

        /* Reset hash select profile entry. */
        sal_memcpy(hash_select_entry_ptr[0],
                   soc_mem_entry_null(unit, hash_select_profile_mem[0]),
                   soc_mem_entry_words(unit, hash_select_profile_mem[0]) *
                                       sizeof(uint32));
        sal_memcpy(hash_select_entry_ptr[1],
                   soc_mem_entry_null(unit, hash_select_profile_mem[0]),
                   soc_mem_entry_words(unit, hash_select_profile_mem[0]) *
                                       sizeof(uint32));

        /* Get the hash select profile */
        rv = _bcm_field_td2_hash_select_profile_get(unit,
                                                    hash_select_profile_mem[0],
                                                    &hash_select_profile[0]);
        BCM_IF_ERROR_RETURN(rv);

        rv = _bcm_field_td2_hash_select_profile_get(unit,
                                                    hash_select_profile_mem[1],
                                                    &hash_select_profile[1]);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined BCM_TRIDENT2PLUS_SUPPORT
    sal_memset (oam_action, 0, sizeof (oam_action) );
#endif

    num_fields = SOC_MEM_INFO(unit, policy_mem).nFields;

    if (f_ent_wb_info->action_bmp == NULL || f_ent_wb_info->action_bmp->w == NULL) {
       action_sync = 0;
    }
    for (i = 0; i < num_fields; i++) {
        uint8 already_recovered = 0;
        fld = SOC_MEM_INFO(unit, policy_mem).fields[i].field;

        /* Skip FP_POLICY_TABLE_A/B, PROFILE_SET fields. */
        if (soc_mem_field_length(unit, policy_mem, fld) > 32){
            continue;
        }

        fldval = PolicyGet(unit, policy_mem, policy_entry, fld);
        action = param0 = param1 = param2 = param3 = param4 = param5 = hw_index = append = 0;
        uc_cosq = mc_cosq = -1;

        switch (fld) {
        case ECMP_HASH_SELf:
            /* MultipathHash is overlayed with other actions(like NewClassId)  which set
               G_L3SW_CHANGE_L2_FIELDSf */
            if ((fldval != 0) &&
                    (PolicyGet(unit, policy_mem,
                               policy_entry,G_L3SW_CHANGE_L2_FIELDSf) == 0)) {
                if ((action_sync == 1) &&
                         SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamFabricQueue)) {
                    break;
                }
                action = bcmFieldActionMultipathHash;
                param0 = fldval;
                append = 1;
            }

            break;

        case GREEN_TO_PIDf:
            if (fldval) {
                f_ent->flags |= _FP_ENTRY_COLOR_INDEPENDENT;
            }
            break;
        case ECN_CNGf:
            if (fldval) {
                action = bcmFieldActionEcnNew;
                append = 1;
            }
            break;
        case RP_CHANGE_DSCPf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionRpDscpNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, RP_DSCPf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case YP_CHANGE_DSCPf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionYpDscpNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, YP_DSCPf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case COPY_TO_CPUf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionCopyToCpu;
                    if ((fldval = PolicyGet(unit,
                                            policy_mem,
                                            policy_entry,
                                            VFP_MATCHED_RULEf
                                            )
                         )
                        != 0
                        ) {
                        param0 = 1;
                        param1 = fldval;
                    }

                    append = 1;

                    break;

                case 2:
                    action = bcmFieldActionCopyToCpuCancel;
                    append = 1;

                    break;

                default:
                    break; /* Do nothing */
                }
            break;
        case G_COPY_TO_CPUf:
#ifdef BCM_APACHE_SUPPORT
            if (fldval && f_ent_wb_info->action_copytocpu_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_GREEN_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_GREEN_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_GREEN_PACKET;
                }
                break;
            }
#endif

            switch (fldval) {
                case 1:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionCopyToCpu;
                    } else {
                       action = bcmFieldActionGpCopyToCpu;
                    }
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 2:
                    val = PolicyGet(unit, policy_mem, policy_entry, G_DROPf);
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                        action = (val == 2)
                                  ? bcmFieldActionTimeStampToCpuCancel
                                  : bcmFieldActionCopyToCpuCancel;
                    } else {
                        action = (val == 2)
                                 ? bcmFieldActionGpTimeStampToCpuCancel
                                 : bcmFieldActionGpCopyToCpuCancel;
                    }
                    append = 1;
                    break;
                case 3:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionSwitchToCpuCancel;
                    } else {
                       action = bcmFieldActionGpSwitchToCpuCancel;
                    }
                    append = 1;
                    break;
                case 4:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionSwitchToCpuReinstate;
                    } else {
                       action = bcmFieldActionGpSwitchToCpuReinstate;
                    }
                    append = 1;
                    break;
                case 5:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionTimeStampToCpu;
                    } else {
                       action = bcmFieldActionGpTimeStampToCpu;
                    }
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 6:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionCopyToCpuCancel;
                    } else {
                       action = bcmFieldActionGpCopyToCpuCancel;
                    }
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }

                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       action = bcmFieldActionSwitchToCpuCancel;
                    } else {
                       action = bcmFieldActionGpSwitchToCpuCancel;
                    }
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                    append = 0;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case Y_COPY_TO_CPUf:
#ifdef BCM_APACHE_SUPPORT
            if (fldval && f_ent_wb_info->action_copytocpu_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_YELLOW_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_YELLOW_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_YELLOW_PACKET;
                }
                break;
            }
#endif
            switch (fldval) {
                case 1:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionYpCopyToCpu;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamYpCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 2:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = PolicyGet(unit, policy_mem, policy_entry, Y_DROPf) == 2
                        ? bcmFieldActionYpTimeStampToCpuCancel
                        : bcmFieldActionYpCopyToCpuCancel;
                    append = 1;
                    break;
                case 3:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionYpSwitchToCpuCancel;
                    append = 1;
                    break;
                case 4:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionYpSwitchToCpuReinstate;
                    append = 1;
                    break;
                case 5:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionYpTimeStampToCpu;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamYpCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 6:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionYpCopyToCpuCancel;
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }

                    action = bcmFieldActionYpSwitchToCpuCancel;
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                    append = 0;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case R_COPY_TO_CPUf:
#ifdef BCM_APACHE_SUPPORT
            if (fldval && f_ent_wb_info->action_copytocpu_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_RED_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_RED_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_copytocpu_wb.params.flags |=
                        BCM_FIELD_COPYTOCPU_RED_PACKET;
                }
                break;
            }
#endif
            switch (fldval) {
                case 1:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionRpCopyToCpu;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamRpCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 2:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = PolicyGet(unit, policy_mem, policy_entry, R_DROPf) == 2
                        ? bcmFieldActionRpTimeStampToCpuCancel
                        : bcmFieldActionRpCopyToCpuCancel;
                    append = 1;
                    break;
                case 3:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionRpSwitchToCpuCancel;
                    append = 1;
                    break;
                case 4:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionRpSwitchToCpuReinstate;
                    append = 1;
                    break;
                case 5:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionRpTimeStampToCpu;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, MATCHED_RULEf);
                    if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamRpCopyToCpuZeroParam1)) ||
                        (param1 != 0)) {
                       param0 = 1;
                    }
                    append = 1;
                    break;
                case 6:
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                      _bcmFieldActionNoParamCopyToCpuNoColor)) {
                       break;
                    }
                    action = bcmFieldActionRpCopyToCpuCancel;
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }

                    action = bcmFieldActionRpSwitchToCpuCancel;
                    rv = _field_trx_actions_recover_action_add(unit,
                                                               f_ent,
                                                               action,
                                                               param0,
                                                               param1,
                                                               param2,
                                                               param3,
                                                               param4,
                                                               param5,
                                                               hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                    append = 0;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case PACKET_REDIRECTIONf:
            switch (fldval) {
                case 1:
                    if (PolicyGet(unit, policy_mem, policy_entry,
                                  REDIRECTIONf) & 0x20) {
                        action = bcmFieldActionRedirectTrunk;
                        param0 = PolicyGet(unit, policy_mem, policy_entry,
                                           REDIRECTIONf) & 0x1f;
                    } else {
                        action = bcmFieldActionRedirect;
                        if (SOC_IS_GREYHOUND2(unit)) {
                            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                               REDIRECTIONf) >> 7;
                            param1 = PolicyGet(unit, policy_mem, policy_entry,
                                               REDIRECTIONf) & 0x7f;
                        } else {
                            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                               REDIRECTIONf) >> 6;
                            param1 = PolicyGet(unit, policy_mem, policy_entry,
                                               REDIRECTIONf) & 0x3f;
                        }
                    }
                    append = 1;
                    break;
                case 2:
                    action = bcmFieldActionRedirectCancel;
                    append = 1;
                    break;
                case 3:
                    action = bcmFieldActionRedirectPbmp;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, REDIRECTIONf);
                    append = 1;
                    break;
                case 4:
                    action = bcmFieldActionEgressMask;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, REDIRECTIONf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case DROPf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionDrop;
                    append = 1;
                    break;
                case 2:
                    action = bcmFieldActionDropCancel;
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;

        case R_DROPf:
            switch (fldval) {
            case 1:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 R_COPY_TO_CPUf
                                 )
                    == 5
                    ) {
                    break;
                }

                action = bcmFieldActionRpDrop;
                append = 1;

                break;

            case 2:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 R_COPY_TO_CPUf
                                 )
                    == 2
                    ) {
                    break;
                }

                action = bcmFieldActionRpDropCancel;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case Y_DROPf:
            switch (fldval) {
            case 1:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 Y_COPY_TO_CPUf
                                 )
                    == 5
                    ) {
                    break;
                }

                action = bcmFieldActionYpDrop;
                append = 1;

                break;

            case 2:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 Y_COPY_TO_CPUf
                                 )
                    == 2
                    ) {
                    break;
                }

                action = bcmFieldActionYpDropCancel;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case G_DROPf:
            switch (fldval) {
            case 1:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    action = bcmFieldActionDrop;
                    append = 1;
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 G_COPY_TO_CPUf
                                 )
                    == 5
                    ) {
                    break;
                }

                action = bcmFieldActionGpDrop;
                append = 1;

                break;

            case 2:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamDropNoColor)) {
                    action = bcmFieldActionDropCancel;
                    append = 1;
                    break;
                }
                if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS
                    && PolicyGet(unit,
                                 policy_mem,
                                 policy_entry,
                                 G_COPY_TO_CPUf
                                 )
                    == 2
                    ) {
                    break;
                }

                action = bcmFieldActionGpDropCancel;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case MIRROR_OVERRIDEf:
            if (fldval) {
                action = bcmFieldActionMirrorOverride;
                append = 1;
            }

            break;
        case G_L3SW_CHANGE_MACDA_OR_VLANf:
            /* Some chips (e.g. TR2, Apollo) have 2 names for the same field */
            if (soc_mem_field_valid(unit, policy_mem,
                    G_L3SW_CHANGE_MACDA_OR_VLANf)
                && soc_mem_field_valid(unit, policy_mem,
                    G_L3SW_CHANGE_L2_FIELDSf)
                && fld == G_L3SW_CHANGE_MACDA_OR_VLANf) {
                /* Both names valid
                 *   => Skip the second (older) name of this field
                 */
                continue;
            }
            switch (fldval) {
                case 1:
                    action = bcmFieldActionL3ChangeVlan;
                    if (PolicyGet(unit, policy_mem, policy_entry, ECMPf)) {
                        ecmp_paths = PolicyGet(unit, policy_mem,
                                               policy_entry, ECMP_COUNTf) + 1;
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                            policy_entry, ECMP_PTRf);
                        param0 = _FP_L3_ACTION_PACK_ECMP(nh_ecmp, ecmp_paths);
                    } else {
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                            policy_entry, NEXT_HOP_INDEXf);
                        param0 = _FP_L3_ACTION_PACK_NEXT_HOP(nh_ecmp);
                    }
                    append = 1;

                    if (PolicyGet(unit, policy_mem, policy_entry, ECMPf) == 0) {

                        /* Get the Next Hop Index value */
                        hw_index = PolicyGet(unit, policy_mem, policy_entry,
                                        NEXT_HOP_INDEXf);

                        /* Read Next Hop information into entry */
                        rv = soc_mem_read(unit, EGR_L3_NEXT_HOPm,
                                MEM_BLOCK_ANY, hw_index,
                                egr_l3_next_hop_entry.entry_data);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }

                        /* Get the VLAN ID infomation */
                        if (SOC_IS_SC_CQ(unit)) {
                            vlan_id = soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                        egr_l3_next_hop_entry.entry_data,
                                        INTF_NUMf);
                        } else {
                            vlan_id = soc_mem_field32_get(unit, EGR_L3_NEXT_HOPm,
                                        egr_l3_next_hop_entry.entry_data,
                                        OVIDf);
                        }

                        /* Re-Create bcmFieldActionOuterVlanNew action for the
                         * FP entry */
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionOuterVlanNew, vlan_id, 0,
                                0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                    }
                    break;
                case 2:
                    action = bcmFieldActionL3ChangeVlanCancel;
                    append = 1;
                    break;
                case 3:
                    action = bcmFieldActionAddClassTag;
                    nh_ecmp = PolicyGet(unit, policy_mem, policy_entry,
                                NEXT_HOP_INDEXf);
                    param0 = _FP_L3_ACTION_PACK_NEXT_HOP(nh_ecmp);
                    append = 1;
                    break;
                case 4:
                    action = bcmFieldActionL3ChangeMacDa;
                    if (PolicyGet(unit, policy_mem, policy_entry, ECMPf)) {
                        ecmp_paths = PolicyGet(unit, policy_mem,
                                               policy_entry, ECMP_COUNTf) + 1;
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                            policy_entry, ECMP_PTRf);
                        param0 = _FP_L3_ACTION_PACK_ECMP(nh_ecmp, ecmp_paths);
                    } else {
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                            policy_entry, NEXT_HOP_INDEXf);
                        param0 = _FP_L3_ACTION_PACK_NEXT_HOP(nh_ecmp);
                    }
                    append = 1;

                    if (PolicyGet(unit, policy_mem, policy_entry, ECMPf) == 0) {

                        /* Get the Next Hop Index value */
                        hw_index = PolicyGet(unit, policy_mem, policy_entry,
                                        NEXT_HOP_INDEXf);

                        /* Read Next Hop information into entry */
                        rv = soc_mem_read(unit, EGR_L3_NEXT_HOPm,
                                MEM_BLOCK_ANY, hw_index,
                                egr_l3_next_hop_entry.entry_data);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }

                        /* Get the DA/DMAC infomation */
                        soc_mem_mac_addr_get(unit, EGR_L3_NEXT_HOPm,
                            egr_l3_next_hop_entry.entry_data,
                            MAC_ADDRESSf, mac_addr);
                        SAL_MAC_ADDR_TO_UINT32(mac_addr, mac_addr_words);

                        /* Re-Create bcmFieldActionDstMacNew action for the
                         * FP entry */
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionDstMacNew,
                                mac_addr_words[0], mac_addr_words[1], 0, 0,
                                0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                    }
                    break;
                case 5:
                    action = bcmFieldActionL3ChangeMacDaCancel;
                    append = 1;
                    break;
                case 6:
                    action = bcmFieldActionL3Switch;
#if defined INCLUDE_L3
                    if (PolicyGet(unit, policy_mem, policy_entry, ECMPf)) {
                        ecmp_paths = PolicyGet(unit, policy_mem,
                                policy_entry, ECMPf) + 1;
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                policy_entry, ECMP_NH_INFOf);
                        param0 = (nh_ecmp) +
                            (BCM_XGS3_MPATH_EGRESS_IDX_MIN);
                    } else {
                        nh_ecmp = PolicyGet(unit, policy_mem,
                                policy_entry, NEXT_HOP_INDEXf);
                        param0 = (nh_ecmp) +
                            (BCM_XGS3_EGRESS_IDX_MIN);
                    }
                    append = 1;
#endif
                    break;
                case 7:
                    action = bcmFieldActionL3SwitchCancel;
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;

        case G_L3SW_CHANGE_L2_FIELDSf:
            switch (fldval) {
            int class_tag;
            case 1:
#if defined INCLUDE_L3
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, ECMPf) &&
                    PolicyGet(unit, policy_mem, policy_entry, ECMPf)) {
                    ecmp_paths = PolicyGet(unit, policy_mem,
                            policy_entry, ECMPf) + 1;
                    nh_ecmp = PolicyGet(unit, policy_mem,
                            policy_entry, ECMP_PTRf);
                    param0 = (nh_ecmp) + (BCM_XGS3_MPATH_EGRESS_IDX_MIN);
                    action = bcmFieldActionChangeL2Fields;
                    append = 1;
                    break;
                }
                /*
                 *  Skip recovery for actions under this field as it has
                 *  dependency with L3 module. As L3 module recovery happends
                 *  after Field module, the recovery for these actions has to
                 *  be performed after getting callback from L3.
                 */
                _FP_XGS3_ALLOC(l3_cb, sizeof(_bcm_field_l3_callback_recover_t),
                                 "Field L3 Callback Recover Alloc.");
                if (l3_cb == NULL) {
                   return BCM_E_MEMORY;
                }

                l3_cb->f_ent = f_ent;
                l3_cb->action = bcmFieldActionChangeL2Fields;
                l3_cb->next = NULL;

                nh_ecmp = PolicyGet(unit, policy_mem, policy_entry,
                                    NEXT_HOP_INDEXf);
                l3_cb->param0 = (nh_ecmp) + (BCM_XGS3_EGRESS_IDX_MIN);
                l3_cb->hw_index = nh_ecmp;

                if (_field_l3_cb == NULL) {
                   _field_l3_cb = l3_cb;
                } else {
                   _bcm_field_l3_callback_recover_t *_cb;

                   for (_cb = _field_l3_cb; _cb != NULL; _cb = _cb->next) {
                       if (_cb->next == NULL) {
                          _cb->next = l3_cb;
                          break;
                       }
                   }
                }
#endif /* INCLUDE_L3 */
                break;
            case 3:
                /*recover fabricQueue action*/
                if ((action_sync == 1) &&
                     SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamFabricQueue)) {
                    action = bcmFieldActionFabricQueue;
                    append = 1;
                    param0 = f_ent_wb_info->action_fabricQueue_wb.cosq_gport;
#if defined(BCM_KATANA_SUPPORT)
                    tag_type = PolicyGet(unit, policy_mem, policy_entry,
                                            EH_TAG_TYPEf);
                    if (SOC_IS_KATANAX(unit) && tag_type == 2) {
                        param1 =  f_ent_wb_info->action_fabricQueue_wb.profile_idx;
                        cosq_idx = PolicyGet(unit, policy_mem, policy_entry,
                                             EH_QUEUE_TAGf);
                        rv = _bcm_field_fabricQueue_action_node_increment_ref_Count(
                                   unit, cosq_idx, param1);
                        if (rv == BCM_E_NOT_FOUND) {
                            rv = _bcm_field_fabricQueue_action_node_add (
                                     unit, cosq_idx, param1);
                            if (BCM_FAILURE(rv)) {
                                return (rv);
                            }
                        }
                    }
#endif /*BCM_KATANA_SUPPORT */
                }
                break;
            case 4:
                action = bcmFieldActionAddClassTag;
                class_tag = PolicyGet(unit, policy_mem, policy_entry,
                                      NEXT_HOP_INDEXf);
                param0 = _FP_L3_ACTION_PACK_NEXT_HOP(class_tag);
                append = 1;
                break;
            case 6:
                action = bcmFieldActionL3Switch;
#if defined INCLUDE_L3
                if (PolicyGet(unit, policy_mem, policy_entry, ECMPf)) {
                    ecmp_paths = PolicyGet(unit, policy_mem,
                            policy_entry, ECMPf) + 1;
                    nh_ecmp = PolicyGet(unit, policy_mem,
                            policy_entry, ECMP_PTRf);
                    param0 = (nh_ecmp) +
                        (BCM_XGS3_MPATH_EGRESS_IDX_MIN);
                } else {
                    nh_ecmp = PolicyGet(unit, policy_mem,
                            policy_entry, NEXT_HOP_INDEXf);
                    param0 = (nh_ecmp) +
                        (BCM_XGS3_EGRESS_IDX_MIN);
                }
                append = 1;
#endif /* INCLUDE_L3 */
                break;
            case 7:
                action = bcmFieldActionL3SwitchCancel;
                append = 1;
                break;
#if defined (BCM_TRIUMPH3_SUPPORT)
            case 9:
                if (SOC_IS_TRIUMPH3(unit)) {
                    index = PolicyGet(unit, policy_mem,
                                        policy_entry, L2MOD_TBL_INDEXf);
                    rv = _field_tr3_actions_recover_replaceL2Fields(unit,
                                              index,
                                              f_ent);
                    if (BCM_FAILURE(rv)) {
                        return (rv);
                    }
                }
                break;
#endif
            default:
                ;
            }

            break;

        case DROP_PRECEDENCEf:
            if (fldval) {
                action = bcmFieldActionDropPrecedence;
                param0 = fldval;
                append = 1;
            }
            break;
        case RP_DROP_PRECEDENCEf:
            if (fldval) {
                action = bcmFieldActionRpDropPrecedence;
                param0 = fldval;
                append = 1;
            }
            break;
        case YP_DROP_PRECEDENCEf:
            if (fldval) {
                action = bcmFieldActionYpDropPrecedence;
                param0 = fldval;
                append = 1;
            }
            break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT)
        case FLEX_CTR_BASE_COUNTER_IDXf:
#if defined BCM_TRIDENT2PLUS_SUPPORT
            if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit))
                    && (f_ent->group->stage_id
                        == _BCM_FIELD_STAGE_INGRESS)) {
                if (fldval) {
                    if(PolicyGet(unit, policy_mem, policy_entry,
                                G_L3SW_CHANGE_L2_FIELDSf) == 0x9) {
                        stat_action = PolicyGet(unit, policy_mem,
                                policy_entry, FLEX_COUNTER_ACTIONf);
                        if (f_ent_wb_info->f_ent_oam_wb != NULL) {
                            BCM_IF_ERROR_RETURN(
                                    _field_extended_flex_counter_recover(unit,
                                        f_ent, part, f_ent_wb_info->sid, f_ent_wb_info->f_ent_oam_wb,
                                        stat_action));
                        }
                    }
                }
            } else if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit))
                    && (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                if (fldval) {
                    stat_action = bcmFieldStatActionIncrement;
                    if(PolicyGet(unit, policy_mem, policy_entry,
                                FLEX_COUNTER_DSCP_SELf) == 0x1) {
                        if (SOC_IS_APACHE(unit)) {
                            stat_action = PolicyGet(unit, policy_mem,
                                    policy_entry, FLEX_COUNTER_ACTIONf);
                        }
                        if (f_ent_wb_info->f_ent_oam_wb != NULL) {
                            BCM_IF_ERROR_RETURN(
                                    _field_extended_flex_counter_recover(unit,
                                        f_ent, part, f_ent_wb_info->sid, f_ent_wb_info->f_ent_oam_wb,
                                        stat_action));
                        }
                    }
                }
            } else
#endif
            {
                if (fldval) {
                    BCM_IF_ERROR_RETURN(_field_flex_counter_recover(
                                unit, f_ent, part, f_ent_wb_info->sid));
                }
            }
             break;
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
        case VLAN_CTR_ENABLEf:
            if (fldval) {
                BCM_IF_ERROR_RETURN(_field_flowcnt_counter_recover(
                            unit, f_ent, part, f_ent_wb_info->sid));
            }
            break;
#endif
        case COUNTER_MODEf:
            if (fldval) {
                ctr_mode = fldval;
                ctr_idx = PolicyGet(unit, policy_mem, policy_entry,
                                    COUNTER_INDEXf);
                BCM_IF_ERROR_RETURN
                   (_field_tr2_counter_recover(unit,
                                               f_ent,
                                               ctr_mode,
                                               ctr_idx,
                                               part,
                                               f_ent_wb_info->sid
                                               )
                    );
            }
            break;

        case EXT_COUNTER_MODEf:
            if (fldval != 0) {
                BCM_IF_ERROR_RETURN
                   (_field_tr2_counter_recover(unit,
                                               f_ent,
                                               fldval,
                                               f_ent->slice_idx,
                                               part,
                                               f_ent_wb_info->sid
                                               )
                    );
            }

            break;

#ifdef BCM_TRIUMPH3_SUPPORT
        case COUNTER_SETf:
            if (fldval) {
                BCM_IF_ERROR_RETURN
                    (_bcm_field_tr3_counter_recover(unit,
                                                f_ent,
                                                policy_entry,
                                                part,
                                                f_ent_wb_info->sid));
            }
            break;
#endif

        case METER_PAIR_MODEf:
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                BCM_IF_ERROR_RETURN
                    (_bcm_field_tr3_meter_recover(unit,
                                              f_ent,
                                              part,
                                              f_ent_wb_info->pid,
                                              0,
                                              policy_mem,
                                              policy_entry,
                                              &already_recovered
                                              )
                    );
            } else
#endif
            {
                BCM_IF_ERROR_RETURN(
                    SOC_IS_SC_CQ(unit)
                    ? _field_sc_cq_meter_recover(unit,
                                                 f_ent,
                                                 part,
                                                 f_ent_wb_info->pid,
                                                 policy_entry,
                                                 &already_recovered
                        )
                    : _field_trx_meter_recover(unit,
                                               f_ent,
                                               part,
                                               f_ent_wb_info->pid,
                                               0,
                                               policy_mem,
                                               policy_entry,
                                               &already_recovered
                                               )
                    );
            }
            if (1 == already_recovered) {
                _field_trx_meter_recover_configured_rates(unit, 
                        f_ent, 0, 
                        f_ent_wb_info);
            }
            break;

        case METER_SHARING_MODEf:
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                BCM_IF_ERROR_RETURN
                    (_bcm_field_tr3_meter_recover(unit,
                                              f_ent,
                                              part,
                                              f_ent_wb_info->pid1,
                                              1,
                                              policy_mem,
                                              policy_entry,
                                              &already_recovered
                                              )
                    );
            } else
#endif
            {

                BCM_IF_ERROR_RETURN
                    (_field_trx_meter_recover(unit,
                                              f_ent,
                                              part,
                                              f_ent_wb_info->pid1,
                                              1,
                                              policy_mem,
                                              policy_entry,
                                              &already_recovered
                                              )
                    );
            }
            if (1 == already_recovered) {
                _field_trx_meter_recover_configured_rates(unit, 
                        f_ent, 1,
                        f_ent_wb_info);
            }
            break;

        case CHANGE_CPU_COSf:
            switch (fldval) {
            case 1:         /* Change CPU CoS */
                action = bcmFieldActionCosQCpuNew;
                param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   soc_mem_field_valid(unit, policy_mem, NEW_CPU_COSf)
                                   ? NEW_CPU_COSf : CPU_COSf
                                   );
                append = 1;

                break;

                case 2:
                    val = PolicyGet(unit, policy_mem, policy_entry,
                                         CPU_COSf);
                    if ((val & 0x10) && (val & 0x20)) {
                        action = bcmFieldActionServicePoolIdPrecedenceNew;
                        param1 = (val & 0x3);
                    /* SPAP is 2b'00 for BCM_FIELD_COLOR_GREEN
                               2b'01 for BCM_FIELD_COLOR_RED
                               2b'11 for BCM_FIELD_COLOR_YELLOW
                    */
                        param1 = ((0 == param1) ? BCM_FIELD_COLOR_GREEN : \
                                 ((3 == param1) ? BCM_FIELD_COLOR_YELLOW : BCM_FIELD_COLOR_RED));
                    }
                    else if (val & 0x20) {
                        action = bcmFieldActionServicePoolIdNew;
                    }
                    else {
                        break;
                    }
                    param0 = ((val >> 2) & 0x3);
                    append = 1;
                    break;


            default:
                ;
            }

            break;

        case PID_IPFIX_ACTIONSf:
            switch (fldval) {
#ifdef BCM_TRIDENT2_SUPPORT
                if (SOC_IS_TD2_TT2(unit)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif
                case 1:
                    action = bcmFieldActionIpFix;
                    append = 1;
                    break;
                case 2:
                    action = bcmFieldActionIpFixCancel;
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
        case PID_REPLACE_INNER_VIDf:
            if (fldval) {
#ifdef BCM_TRIDENT2_SUPPORT
                if (SOC_IS_TD2_TT2(unit)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif
                action = bcmFieldActionInnerVlanNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, PID_NEW_INNER_VIDf);
                append = 1;
            }
            break;
        case PID_REPLACE_INNER_PRIf:
            if (fldval) {
#ifdef BCM_TRIDENT2_SUPPORT
                if (SOC_IS_TD2_TT2(unit)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif
                action = bcmFieldActionInnerVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, PID_NEW_INNER_PRIf);
                append = 1;
            }
            break;
        case PID_REPLACE_OUTER_VIDf:
            if (fldval) {
#ifdef BCM_TRIDENT2_SUPPORT
                if (SOC_IS_TD2_TT2(unit)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif
                action = bcmFieldActionOuterVlanNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, PID_NEW_OUTER_VIDf);
                append = 1;
            }
            break;
        case PID_REPLACE_OUTER_TPIDf:
            if (fldval) {
                uint32 mode;
                uint16 tpid;

#ifdef BCM_TRIDENT2_SUPPORT
                if (SOC_IS_TD2_TT2(unit)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif
                action = bcmFieldActionOuterTpidNew;
                mode = PolicyGet(unit, policy_mem, policy_entry, PID_OUTER_TPID_INDEXf);
                BCM_IF_ERROR_RETURN
                    (_field_tpid_hw_decode(unit, mode, &tpid));
                param0 = tpid;
                append = 1;
            }
            break;

        case VXLAN_RESERVED_2f:
            if (fldval) {
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                    if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                        action = bcmFieldActionVxlanHeaderBits56_63_Set;
                        param0 = PolicyGet(unit, policy_mem, policy_entry, VXLAN_RESERVED_2f);
                        append = 1;
                    }
                }
            }
            break;
        case VXLAN_RESERVED_1f:
            if (fldval) {
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                    if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                        action = bcmFieldActionVxlanHeaderBits8_31_Set;
                        param0 = PolicyGet(unit, policy_mem, policy_entry, VXLAN_RESERVED_1f);
                        append = 1;
                    }
                }
            }
            break;
        case VXLAN_FLAGSf:
            if (fldval) {
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                    if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                        action = bcmFieldActionVxlanHeaderFlags;
                        param0 = PolicyGet(unit, policy_mem, policy_entry, VXLAN_FLAGSf);
                        append = 1;
                    }
                }
            }
            break;
        case R_CHANGE_DSCPf:
#if defined BCM_TRIDENT2PLUS_SUPPORT
            if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                if(PolicyGet(unit, policy_mem, policy_entry,
                            FLEX_COUNTER_DSCP_SELf) == 0x1) {
                    break;
                }
            }
#endif
            switch (fldval) {
               case 1:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                       break;
                  }
                  action = bcmFieldActionRpDscpNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_DSCPf);
                  append = 1;
                  break;

               case 2:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                       break;
                  }
                  action = bcmFieldActionRpDscpCancel;
                  append = 1;
                  break;

               default:
                  ;
            }
            break;

        case Y_CHANGE_DSCPf:
#if defined BCM_TRIDENT2PLUS_SUPPORT
            if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                if(PolicyGet(unit, policy_mem, policy_entry,
                            FLEX_COUNTER_DSCP_SELf) == 0x1) {
                    break;
                }
            }
#endif
            switch (fldval) {
               case 1:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                       break;
                  }
                  action = bcmFieldActionYpDscpNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_DSCPf);
                  append = 1;
                  break;

               case 2:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                       break;
                  }
                  action = bcmFieldActionYpDscpCancel;
                  append = 1;
                  break;

               default:
                  ;
            }

            break;

        case G_CHANGE_DSCPf:
#if defined BCM_TRIDENT2PLUS_SUPPORT
            if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                if(PolicyGet(unit, policy_mem, policy_entry,
                            FLEX_COUNTER_DSCP_SELf) == 0x1) {
                    break;
                }
            }
#endif
            switch (fldval) {
               case 1:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                     action = bcmFieldActionDscpNew;
                  } else {
                     action = bcmFieldActionGpDscpNew;
                  }
                  param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_DSCPf);
                  append = 1;
                  break;

               case 2:
                  if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                     action = bcmFieldActionDscpCancel;
                  } else {
                     action = bcmFieldActionGpDscpCancel;
                  }
                  append = 1;
                  break;

               default:
                  ;
            }

            break;

        case G_CHANGE_DSCP_TOSf:
            switch (fldval) {
            case 1:
                action = bcmFieldActionGpTosPrecedenceNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_DSCP_TOSf);

                append = 1;

                break;

            case 2:
                action = bcmFieldActionGpTosPrecedenceCopy;

                append = 1;

                break;

            case 3:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                     action = bcmFieldActionDscpNew;
                } else {
                     action = bcmFieldActionGpDscpNew;
                }
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_DSCP_TOSf);
                append = 1;
                break;

            case 4:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDscpNoColor)) {
                     action = bcmFieldActionDscpCancel;
                } else {
                     action = bcmFieldActionGpDscpCancel;
                }
                append = 1;
                break;

            default:
                ;
            }

            break;

        case R_REPLACE_INNER_PRIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamInnerVlanPriNewNoColor))) {
                   break;
                }
                action = bcmFieldActionRpInnerVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_INNER_PRIf);
                append = 1;
            }
            break;
        case Y_REPLACE_INNER_PRIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamInnerVlanPriNewNoColor))) {
                   break;
                }
                action = bcmFieldActionYpInnerVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_INNER_PRIf);
                append = 1;
            }
            break;
        case G_REPLACE_INNER_PRIf:
            if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                          _bcmFieldActionNoParamInnerVlanPriNewNoColor))) {
                action = bcmFieldActionInnerVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_INNER_PRIf);
                append = 1;
            } else if (fldval) {
                action = bcmFieldActionGpInnerVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_INNER_PRIf);
                append = 1;
            }
            break;
        case R_CHANGE_DOT1Pf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamOuterVlanPriNewNoColor))) {
                   break;
                }
                action = bcmFieldActionRpOuterVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_DOT1Pf);
                append = 1;
            }
            break;
        case Y_CHANGE_DOT1Pf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamOuterVlanPriNewNoColor))) {
                   break;
                }
                action = bcmFieldActionYpOuterVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_DOT1Pf);
                append = 1;
            }
            break;
        case G_CHANGE_DOT1Pf:
            if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                              _bcmFieldActionNoParamOuterVlanPriNewNoColor))) {
                action = bcmFieldActionOuterVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_DOT1Pf);
                append = 1;
            }
            if (fldval) {
                action = bcmFieldActionGpOuterVlanPrioNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_DOT1Pf);
                append = 1;
            }
            break;
        case R_CHANGE_INNER_CFIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamInnerVlanCfiNewNoColor))) {
                   break;
                }
                action = bcmFieldActionRpInnerVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_INNER_CFIf);
                append = 1;
            }
            break;
        case Y_CHANGE_INNER_CFIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamInnerVlanCfiNewNoColor))) {
                   break;
                }
                action = bcmFieldActionYpInnerVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_INNER_CFIf);
                append = 1;
            }
            break;
        case G_CHANGE_INNER_CFIf:
            if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                           _bcmFieldActionNoParamInnerVlanCfiNewNoColor))) {
                action = bcmFieldActionInnerVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_INNER_CFIf);
                append = 1;
            } else if (fldval) {
                action = bcmFieldActionGpInnerVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_INNER_CFIf);
                append = 1;
            }
            break;
        case R_CHANGE_OUTER_CFIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamOuterVlanCfiNewNoColor))) {
                   break;
                }
                action = bcmFieldActionRpOuterVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_OUTER_CFIf);
                append = 1;
            }
            break;
        case Y_CHANGE_OUTER_CFIf:
            if (fldval) {
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamOuterVlanCfiNewNoColor))) {
                   break;
                }
                action = bcmFieldActionYpOuterVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_OUTER_CFIf);
                append = 1;
            }
            break;
        case G_CHANGE_OUTER_CFIf:
            if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                            _bcmFieldActionNoParamOuterVlanCfiNewNoColor))) {
                action = bcmFieldActionOuterVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_OUTER_CFIf);
                append = 1;
            }
            if (fldval) {
                action = bcmFieldActionGpOuterVlanCfiNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_OUTER_CFIf);
                append = 1;
            }
            break;
        case PID_COUNTER_MODEf:
            if (fldval) {
#ifdef BCM_TRIDENT2_SUPPORT
                if ((SOC_IS_TD2_TT2(unit)) &&
                        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, VXLAN_ACTIONf)) {
                        if (PolicyGet(unit, policy_mem, policy_entry, VXLAN_ACTIONf) == 1) {
                            break;
                        }
                    }
                }
#endif

                ctr_mode = fldval;
                ctr_idx = PolicyGet(unit, policy_mem, policy_entry,
                                    PID_COUNTER_INDEXf);
                BCM_IF_ERROR_RETURN
                   (_field_tr2_counter_recover(unit,
                                               f_ent,
                                               ctr_mode,
                                               ctr_idx,
                                               part,
                                               f_ent_wb_info->sid
                                               )
                    );
            }
            break;
        case OAM_PBBTE_LOOKUP_ENABLEf:
            if (fldval) {
                action = bcmFieldActionOamPbbteLookupEnable;
                param0 = fldval;
                append = 1;
            }
            break;
#if defined(BCM_TRIUMPH2_SUPPORT)
        case USE_VINTF_CTR_IDXf:
            if (fldval && flex_info[unit].valid) {
                ctr_idx = PolicyGet(unit, policy_mem, policy_entry,
                                    VINTF_CTR_IDXf);
                if (ctr_idx) {
                    BCM_IF_ERROR_RETURN(_field_vfp_flex_counter_recover(
                                unit, f_ent, part, ctr_idx, f_ent_wb_info->sid));
                }
            }
            break;
#endif
        case CPU_COSf:
            if ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) && fldval) {
                 action = bcmFieldActionCosQCpuNew;
                 param0 = fldval;
                 append = 1;
            }
            break;
        case DO_NOT_LEARNf:
            if (fldval) {
                action = bcmFieldActionDoNotLearn;
                append = 1;
            }
            break;
        case CHANGE_INT_PRIORITYf:
            if (fldval) {
                if (SOC_IS_TD_TT(unit)
                    || SOC_IS_KATANAX(unit)
                    || SOC_IS_TRIUMPH3(unit)) {
                    pkt_int_new = PolicyGet(unit, policy_mem, policy_entry,
                                            CHANGE_OUTER_DOT1Pf);
                } else {
                    pkt_int_new = PolicyGet(unit, policy_mem, policy_entry,
                                            CHANGE_PKT_PRIORITYf);
                }

                if (1 == pkt_int_new) {
                    action = bcmFieldActionPrioPktAndIntNew;
                } else {
                    action = bcmFieldActionPrioIntNew;
                }
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_INT_PRIORITYf);
                append = 1;
            }
            break;
        case CHANGE_PKT_PRIORITYf:
            if (fldval) {
                if (PolicyGet(unit, policy_mem, policy_entry,
                              CHANGE_INT_PRIORITYf) == 1) {
                    action = bcmFieldActionPrioPktAndIntNew;
                } else {
                    action = bcmFieldActionPrioPktNew;
                }
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_PKT_PRIORITYf);
                append = 1;
            }
            break;
        case OUTER_VLAN_ACTIONSf:
            switch (fldval) {
            case 1:
                action = bcmFieldActionOuterVlanAdd;
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_OUTER_VLANf);
                append = 1;
                break;
            case 2:
                action = bcmFieldActionOuterVlanNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_OUTER_VLANf);
                append = 1;
                break;
            case 3:
                action = bcmFieldActionOuterVlanLookup;
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_OUTER_VLANf);
                append = 1;
                break;
            case 4:
                action = bcmFieldActionOuterVlanCopyInner;
                append = 1;
            default:
                break; /* Do nothing */
            }
            break;
        case INNER_VLAN_ACTIONSf:
            switch (fldval) {
            case 1:
                action = bcmFieldActionInnerVlanAdd;
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_INNER_VLANf);
                append = 1;
                break;
            case 2:
                action = bcmFieldActionInnerVlanNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_INNER_VLANf);
                append = 1;
                break;
            case 3:
                action = bcmFieldActionInnerVlanDelete;
                append = 1;
                break;
            case 4:
                action = bcmFieldActionInnerVlanCopyOuter;
                append = 1;
                break;
            default:
                break; /* Do nothing */
            }
            break;
        case CHANGE_CNGf:
            if (fldval) {
                param0 = PolicyGet(unit, policy_mem, policy_entry, NEW_CNGf);
                action = bcmFieldActionDropPrecedence;
                switch (param0) {
                    case 0:
                        param0 = BCM_FIELD_COLOR_GREEN;
                        append = 1;
                        break;
                    case 1:
                        param0 = BCM_FIELD_COLOR_RED;
                        append = 1;
                        break;
                    case 3:
                        param0 = BCM_FIELD_COLOR_YELLOW;
                        append = 1;
                        break;
                    default:
                        break; /* Do nothing */
                }
            }
            break;

        case R_CHANGE_PKT_PRIf:
            switch (fldval) {
            case 4:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   R_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 4
                    ? bcmFieldActionRpPrioPktAndIntCopy
                    : bcmFieldActionRpPrioPktCopy;
                append = 1;

                break;

            case 5:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   R_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 5
                    ? bcmFieldActionRpPrioPktAndIntNew
                    : bcmFieldActionRpPrioPktNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, R_NEW_PKT_PRIf);
                append = 1;

                break;

            case 6:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   R_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 6
                    ? bcmFieldActionRpPrioPktAndIntTos
                    : bcmFieldActionRpPrioPktTos;
                append = 1;

                break;

            case 7:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   R_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 7
                    ? bcmFieldActionRpPrioPktAndIntCancel
                    : bcmFieldActionRpPrioPktCancel;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case R_CHANGE_COS_OR_INT_PRIf:
            switch (fldval) {
            case 1:
                if (SOC_IS_TD_TT(unit)) {
                    /* Recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                    if ((1 == PolicyGet(unit, policy_mem, policy_entry,
                            G_CHANGE_COS_OR_INT_PRIf))
                        && (1 == PolicyGet(unit, policy_mem, policy_entry,
                            Y_CHANGE_COS_OR_INT_PRIf))) {
                        continue;
                    }
                    action = bcmFieldActionRpCosQNew;
                    param0 = PolicyGet(unit,
                                       policy_mem,
                                       policy_entry,
                                       R_COS_INT_PRIf
                                       )
                             & 0xf;
                    append = 1;
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);
                    uc_cosq = param0 & 0xf;
                    mc_cosq = (param0 >> 0x4) & 0xf;

                    if (uc_cosq != mc_cosq) {
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionRpUcastCosQNew, uc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionRpMcastCosQNew, mc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                    } else {
                        action = bcmFieldActionRpCosQNew;
                        param0 = uc_cosq;
                        append = 1;
                    }
                } else {
                    action = bcmFieldActionRpCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);

                    append = 1;
                }

                break;

            case 2:
                if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                    || SOC_IS_TRIUMPH3(unit)) {
                    action= bcmFieldActionRpUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_TD_TT(unit)) {
                     action = bcmFieldActionRpCosQNew;
                     param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x7f;
                     append = 1;
                } else {
                    action = bcmFieldActionRpVlanCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) - 8;
                    append = 1;
                }

                break;

           case 3:
              if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                  action= bcmFieldActionRpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0xfff;
                  param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 12;
                  append = 1;
              } else if (SOC_IS_TRIUMPH3(unit)) {
                  action= bcmFieldActionRpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x3ff;
                  append = 1;
              }
              break;


            case 4:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              R_CHANGE_PKT_PRIf
                              )
                    != 4
                    ) {
                    action = bcmFieldActionRpPrioIntCopy;

                    append = 1;
                }

                break;

            case 5:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              R_CHANGE_PKT_PRIf
                              )
                    != 5
                    ) {
                    action = bcmFieldActionRpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);

                    append = 1;
                }

                break;

            case 6:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              R_CHANGE_PKT_PRIf
                              )
                    != 6
                    ) {
                    action = bcmFieldActionRpPrioIntTos;

                    append = 1;
                }

                break;

            case 7:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              R_CHANGE_PKT_PRIf
                              )
                    != 7
                    ) {
                    action = bcmFieldActionRpPrioIntCancel;

                    append = 1;
                }

                break;
            case 8:
                if (SOC_IS_TD_TT(unit)) {
                    if ((8 == PolicyGet(unit, policy_mem, policy_entry,
                            G_CHANGE_COS_OR_INT_PRIf))
                        && (8 == PolicyGet(unit, policy_mem, policy_entry,
                            Y_CHANGE_COS_OR_INT_PRIf))) {
                        /* recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                        continue;
                    } else {
                        action = bcmFieldActionRpUcastCosQNew;
                        param0 = PolicyGet(unit,
                                        policy_mem,
                                        policy_entry,
                                        R_COS_INT_PRIf)
                                 & 0xf;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionRpUcastCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);
                    append = 1;
                } else if ( SOC_IS_KATANA2(unit)) {
                   action = bcmFieldActionRpUcastQueueNew;
                   param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf);
                   append = 1;
                 }

                break;
            case 9:
                if (SOC_IS_TD_TT(unit)) {
                    if ((9 == PolicyGet(unit, policy_mem, policy_entry,
                                    G_CHANGE_COS_OR_INT_PRIf))
                            && (9 == PolicyGet(unit, policy_mem, policy_entry,
                                    Y_CHANGE_COS_OR_INT_PRIf))) {
                        /* recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                        continue;
                    } else {
                        action = bcmFieldActionRpMcastCosQNew;
                        param0 = (PolicyGet(unit,
                                    policy_mem,
                                    policy_entry,
                                    R_COS_INT_PRIf) >> 0x4)
                            & 0xf;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionRpMcastCosQNew;
                    param0 = (PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 0x4) & 0xf;
                    append = 1;
                } else if (SOC_IS_SABER2(unit)) {
                    action = bcmFieldActionRpIntCosUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x3ff;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 10;
                    append = 1;
                } else if (SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionRpIntCosUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0xfff;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 12;
                    append = 1;
                }

                break;


           case 10 :
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                 if (SOC_IS_SABER2(unit)) {
                    if (PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x400) {
                        action = bcmFieldActionRpServicePrioIntCosQNew;
                    } else {
                        if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                            break;
                        } else {
                            action = bcmFieldActionRpPortPrioIntCosQNew;
                        }
                    }
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamRpPortPrioIntCosQNew)) {
                        param1 = f_ent_wb_info->rp_port_prio_int_gport;
                    } else {
                        param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x1ff;
                    }
                    param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 10;
                    _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                    append = 1;
                 } else if (SOC_IS_KATANA2(unit)
                         || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                     if (SOC_IS_KATANA2(unit)  && PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x800) {
                         action = bcmFieldActionRpServicePrioIntCosQNew;
                     } else {
                         if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                     _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                             break;
                         } else {
                             action = bcmFieldActionRpPortPrioIntCosQNew;
                         }
                     }
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamRpPortPrioIntCosQNew)) {
                         param1 = f_ent_wb_info->rp_port_prio_int_gport;
                     } else {
                         param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x3ff;
                     }
                     param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 12;
                     _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                     append = 1;
                 } else if (SOC_IS_TRIUMPH3(unit)) {
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                         break;
                     } else {
                         action = bcmFieldActionRpPortPrioIntCosQNew;
                     }
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamRpPortPrioIntCosQNew)) {
                         param1 = f_ent_wb_info->rp_port_prio_int_gport;
                     } else {
                         param1 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) & 0x1ff;
                     }
                     param0 = PolicyGet(unit, policy_mem, policy_entry, R_COS_INT_PRIf) >> 9;
                     _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                     append = 1;
                 }
#endif
            default:
                ;
            }

            break;

        case Y_CHANGE_PKT_PRIf:
            switch (fldval) {
            case 4:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   Y_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 4
                    ? bcmFieldActionYpPrioPktAndIntCopy
                    : bcmFieldActionYpPrioPktCopy;
                append = 1;

                break;

            case 5:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   Y_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 5
                    ? bcmFieldActionYpPrioPktAndIntNew
                    : bcmFieldActionYpPrioPktNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, Y_NEW_PKT_PRIf);
                append = 1;

                break;

            case 6:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   Y_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 6
                    ? bcmFieldActionYpPrioPktAndIntTos
                    : bcmFieldActionYpPrioPktTos;
                append = 1;

                break;

            case 7:
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   break;
                }
                action = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   Y_CHANGE_COS_OR_INT_PRIf
                                   )
                    == 7
                    ? bcmFieldActionYpPrioPktAndIntCancel
                    : bcmFieldActionYpPrioPktCancel;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case Y_CHANGE_COS_OR_INT_PRIf:
            switch (fldval) {
            case 1:
                if (SOC_IS_TD_TT(unit)) {
                    /* Recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                    if ((1 == PolicyGet(unit, policy_mem, policy_entry,
                            G_CHANGE_COS_OR_INT_PRIf))
                        && (1 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        continue;
                    }
                    action = bcmFieldActionYpCosQNew;
                    param0 = PolicyGet(unit,
                                       policy_mem,
                                       policy_entry,
                                       Y_COS_INT_PRIf
                                       )
                             & 0xf;

                    append = 1;
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);
                    uc_cosq = param0 & 0xf;
                    mc_cosq = (param0 >> 0x4) & 0xf;

                    if (uc_cosq != mc_cosq) {
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionYpUcastCosQNew, uc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionYpMcastCosQNew, mc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                    } else {
                        action = bcmFieldActionYpCosQNew;
                        param0 = uc_cosq;
                        append = 1;
                    }
                } else {
                    action = bcmFieldActionYpCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);

                    append = 1;
                }

                break;

            case 2:
                if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                    || SOC_IS_TRIUMPH3(unit)) {
                    action= bcmFieldActionYpUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_TD_TT(unit)) {
                    action = bcmFieldActionYpCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x7f;
                    append = 1;
                } else {
                    action = bcmFieldActionYpVlanCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) - 8;
                    append = 1;
                }
                break;

           case 3:
              if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                  action= bcmFieldActionYpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0xfff;
                  param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 12;
                  append = 1;
              } else if (SOC_IS_TRIUMPH3(unit)) {
                  action= bcmFieldActionYpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x3ff;
                  append = 1;
              }
              break;

            case 4:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              Y_CHANGE_PKT_PRIf
                              )
                    != 4
                    ) {
                    action = bcmFieldActionYpPrioIntCopy;

                    append = 1;
                }

                break;

            case 5:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              Y_CHANGE_PKT_PRIf
                              )
                    != 5
                    ) {
                    action = bcmFieldActionYpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);

                    append = 1;
                }

                break;

            case 6:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              Y_CHANGE_PKT_PRIf
                              )
                    != 6
                    ) {
                    action = bcmFieldActionYpPrioIntTos;

                    append = 1;
                }

                break;

            case 7:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              Y_CHANGE_PKT_PRIf
                              )
                    != 7
                    ) {
                    action = bcmFieldActionYpPrioIntCancel;

                    append = 1;
                }

                break;
            case 8:
                if (SOC_IS_TD_TT(unit)) {
                    if ((8 == PolicyGet(unit, policy_mem, policy_entry,
                            G_CHANGE_COS_OR_INT_PRIf))
                        && (8 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        /* recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                        continue;
                    } else {
                        action = bcmFieldActionYpUcastCosQNew;
                        param0 = PolicyGet(unit,
                                        policy_mem,
                                        policy_entry,
                                        Y_COS_INT_PRIf)
                                 & 0xf;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionYpUcastCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);
                    append = 1;
                } else if ( SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionYpUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf);
                    append = 1;
                }

                break;
            case 9:
                if (SOC_IS_TD_TT(unit)) {
                    if ((9 == PolicyGet(unit, policy_mem, policy_entry,
                            G_CHANGE_COS_OR_INT_PRIf))
                        && (9 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        /* recovered as part of G_CHANGE_COS_OR_INT_PRIf */
                        continue;
                    } else {
                        action = bcmFieldActionYpMcastCosQNew;
                        param0 = (PolicyGet(unit,
                                        policy_mem,
                                        policy_entry,
                                        Y_COS_INT_PRIf) >> 0x4)
                                  & 0xf;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionYpMcastCosQNew;
                    param0 = (PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 0x4) & 0xf;
                    append = 1;
               } else if (SOC_IS_SABER2(unit)) {
                   action = bcmFieldActionYpIntCosUcastQueueNew;
                   param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x3ff;
                   param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 10;
                   append = 1;
               } else if (SOC_IS_KATANA2(unit)) {
                   action = bcmFieldActionYpIntCosUcastQueueNew;
                   param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0xfff;
                   param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 12;
                   append = 1;
               }
                break;

            case 10 :
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                 if (SOC_IS_SABER2(unit)) {
                     if (PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x400) {
                         action = bcmFieldActionYpServicePrioIntCosQNew;
                     } else {
                         if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                     _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                             break;
                         } else {
                             action = bcmFieldActionYpPortPrioIntCosQNew;
                         }
                     }
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamYpPortPrioIntCosQNew)) {
                         param1 = f_ent_wb_info->yp_port_prio_int_gport;
                     } else {
                         param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x1ff;
                     }
                     param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 10;
                     _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                     append = 1;
                 } else if (SOC_IS_KATANA2(unit)
                         || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                     if (SOC_IS_KATANA2(unit) && PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x800) {
                         action = bcmFieldActionYpServicePrioIntCosQNew;
                     } else {
                         if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                     _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                             break;
                         } else {
                             action = bcmFieldActionYpPortPrioIntCosQNew;
                       }
                     }
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamYpPortPrioIntCosQNew)) {
                         param1 = f_ent_wb_info->yp_port_prio_int_gport;
                     } else {
                         param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x3ff;
                     }
                     param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 12;
                     _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                     append = 1;
                 } else if (SOC_IS_TRIUMPH3(unit)) {
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                         break;
                     } else {
                         action = bcmFieldActionYpPortPrioIntCosQNew;
                     }
                     if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamYpPortPrioIntCosQNew)) {
                         param1 = f_ent_wb_info->yp_port_prio_int_gport;
                     } else {
                         param1 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) & 0x1ff;
                     }
                     param0 = PolicyGet(unit, policy_mem, policy_entry, Y_COS_INT_PRIf) >> 9;
                     _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                   append = 1;
                 }
#endif
            default:
                ;
            }

            break;

        case G_CHANGE_PKT_PRIf:
            switch (fldval) {
            case 4:
                val = PolicyGet(unit,
                                policy_mem,
                                policy_entry,
                                G_CHANGE_COS_OR_INT_PRIf);
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                   action = (val == 4) ? bcmFieldActionPrioPktAndIntCopy
                                       : bcmFieldActionPrioPktCopy;
                } else {
                   action = (val == 4) ? bcmFieldActionGpPrioPktAndIntCopy
                                       : bcmFieldActionGpPrioPktCopy;
                }
                append = 1;
                break;

            case 5:
                val = PolicyGet(unit,
                                policy_mem,
                                policy_entry,
                                G_CHANGE_COS_OR_INT_PRIf);
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                    action = (val == 5) ? bcmFieldActionPrioPktAndIntNew
                                        : bcmFieldActionPrioPktNew;
                } else {
                    action = (val == 5) ? bcmFieldActionGpPrioPktAndIntNew
                                        : bcmFieldActionGpPrioPktNew;
                }
                param0 = PolicyGet(unit, policy_mem, policy_entry, G_NEW_PKT_PRIf);
                append = 1;
                break;

            case 6:
                val = PolicyGet(unit,
                                policy_mem,
                                policy_entry,
                                G_CHANGE_COS_OR_INT_PRIf);
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                    action = (val == 6) ? bcmFieldActionPrioPktAndIntTos
                                        : bcmFieldActionPrioPktTos;
                } else {
                    action = (val == 6) ? bcmFieldActionGpPrioPktAndIntTos
                                        : bcmFieldActionGpPrioPktTos;
                }
                append = 1;
                break;

            case 7:
                val = PolicyGet(unit,
                                policy_mem,
                                policy_entry,
                                G_CHANGE_COS_OR_INT_PRIf);
                if ((action_sync == 1) && (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamPrioPktNoColor))) {
                    action = (val == 7) ? bcmFieldActionPrioPktAndIntCancel
                                        : bcmFieldActionPrioPktCancel;
                } else {
                    action = (val == 7) ? bcmFieldActionGpPrioPktAndIntCancel
                                        : bcmFieldActionGpPrioPktCancel;
                }
                append = 1;
                break;

            default:
                ;
            }

            break;

        case G_CHANGE_COS_OR_INT_PRIf:
            switch (fldval) {
            case 1:
                if (SOC_IS_TD_TT(unit)) {
                    if ((1 == PolicyGet(unit, policy_mem, policy_entry,
                            Y_CHANGE_COS_OR_INT_PRIf))
                        && (1 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        uc_cosq = PolicyGet(unit,
                                            policy_mem,
                                            policy_entry,
                                            G_COS_INT_PRIf)
                                  & 0xf;
                        mc_cosq = ((PolicyGet(unit,
                                              policy_mem,
                                              policy_entry,
                                              G_COS_INT_PRIf) >> 0x4)
                                    & 0xf);
                        if (uc_cosq == mc_cosq) {
                            /*
                             * Since queue values are same, cold boot action
                             * was set using bcmFieldActionCosQNew
                             */
                            action = bcmFieldActionCosQNew;
                            param0 = uc_cosq;
                            append = 1;
                        } else {
                            /*
                             * UC and MC COS queues are different. So, cold
                             * boot config was done using two actions
                             * bcmFieldActionUcastCosQNew and
                             * bcmFieldActionMcastCosQNew
                             */
                            rv = _field_trx_actions_recover_action_add(unit,
                                    f_ent, bcmFieldActionUcastCosQNew, uc_cosq,
                                    0, 0, 0, 0, 0, hw_index);
                            if (BCM_FAILURE(rv)) {
                                return (rv);
                            }
                            rv = _field_trx_actions_recover_action_add(unit,
                                    f_ent, bcmFieldActionMcastCosQNew, mc_cosq,
                                    0, 0, 0, 0, 0, hw_index);
                            if (BCM_FAILURE(rv)) {
                                return (rv);
                            }
                        }
                    } else {
                        action = bcmFieldActionGpCosQNew;
                        param0 = PolicyGet(unit,
                                       policy_mem,
                                       policy_entry,
                                       G_COS_INT_PRIf)
                                 & 0xf;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                    uc_cosq = param0 & 0xf;
                    mc_cosq = (param0 >> 0x4) & 0xf;

                    if (uc_cosq != mc_cosq) {
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionGpUcastCosQNew, uc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                        rv = _field_trx_actions_recover_action_add(unit,
                                f_ent, bcmFieldActionGpMcastCosQNew, mc_cosq,
                                0, 0, 0, 0, 0, hw_index);
                        if (BCM_FAILURE(rv)) {
                            return (rv);
                        }
                    } else {
                        action = bcmFieldActionGpCosQNew;
                        param0 = uc_cosq;
                        append = 1;
                    }
                } else {
                    action = bcmFieldActionGpCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                    append = 1;
                }

                break;

            case 2:
                if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                    || SOC_IS_TRIUMPH3(unit)) {
                    action= bcmFieldActionGpUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_TD_TT(unit)) {
                     action = bcmFieldActionGpCosQNew;
                     param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x7f;
                     append = 1;
                } else {
                    action = bcmFieldActionGpVlanCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) - 8;
                    append = 1;
                }
                break;

           case 3:
              if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                  action= bcmFieldActionGpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0xfff;
                  param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 12;
                  append = 1;
              } else if (SOC_IS_TRIUMPH3(unit)) {
                  action= bcmFieldActionGpIntCosUcastQueueNew;
                  param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x3ff;
                  append = 1;
              }
              break;

            case 4:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   action = bcmFieldActionPrioIntCopy;
                   append = 1;
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              G_CHANGE_PKT_PRIf
                              )
                    != 4
                    ) {
                    action = bcmFieldActionGpPrioIntCopy;
                    append = 1;
                }

                break;

            case 5:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   action = bcmFieldActionPrioIntNew;
                   param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                   append = 1;
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              G_CHANGE_PKT_PRIf
                              )
                    != 5
                    ) {
                    action = bcmFieldActionGpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);

                    append = 1;
                }

                break;

            case 6:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   action = bcmFieldActionPrioIntTos;
                   append = 1;
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              G_CHANGE_PKT_PRIf
                              )
                    != 6
                    ) {
                    action = bcmFieldActionGpPrioIntTos;

                    append = 1;
                }

                break;

            case 7:
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamPrioIntNoColor)) {
                   action = bcmFieldActionPrioIntCancel;
                   append = 1;
                   break;
                }
                if (PolicyGet(unit,
                              policy_mem,
                              policy_entry,
                              G_CHANGE_PKT_PRIf
                              )
                    != 7
                    ) {
                    action = bcmFieldActionGpPrioIntCancel;

                    append = 1;
                }

                break;

            case 8:
                if (SOC_IS_TD_TT(unit)) {
                    uc_cosq = PolicyGet(unit,
                                        policy_mem,
                                        policy_entry,
                                        G_COS_INT_PRIf)
                              & 0xf;
                    if ((8 == PolicyGet(unit, policy_mem, policy_entry,
                            Y_CHANGE_COS_OR_INT_PRIf))
                        && (8 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        action = bcmFieldActionUcastCosQNew;
                        param0 = uc_cosq;
                        append = 1;
                    } else {
                        action = bcmFieldActionGpUcastCosQNew;
                        param0 = uc_cosq;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionGpUcastCosQNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                    append = 1;
                } else if ( SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionGpUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf);
                    append = 1;
                }

                break;

            case 9:
                if (SOC_IS_TD_TT(unit)) {
                    mc_cosq = (PolicyGet(unit,
                                        policy_mem,
                                        policy_entry,
                                        G_COS_INT_PRIf) >> 0x4)
                              & 0xf;
                    if ((9 == PolicyGet(unit, policy_mem, policy_entry,
                            Y_CHANGE_COS_OR_INT_PRIf))
                        && (9 == PolicyGet(unit, policy_mem, policy_entry,
                            R_CHANGE_COS_OR_INT_PRIf))) {
                        action = bcmFieldActionMcastCosQNew;
                        param0 = mc_cosq;
                        append = 1;
                    } else {
                        action = bcmFieldActionGpMcastCosQNew;
                        param0 = mc_cosq;
                        append = 1;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    action = bcmFieldActionGpMcastCosQNew;
                    param0 = (PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 0x4) & 0xf;
                    append = 1;
                } else if (SOC_IS_SABER2(unit)) {
                    action = bcmFieldActionGpIntCosUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x3ff;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 10;
                    append = 1;
                } else if (SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionGpIntCosUcastQueueNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0xfff;
                    param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 12;
                    append = 1;
                }
                break;

            case 10 :
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    if (PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x400) {
                        action = bcmFieldActionGpServicePrioIntCosQNew;
                    } else {
                        if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                            action = bcmFieldActionPortPrioIntCosQNew;
                        } else {
                            action = bcmFieldActionGpPortPrioIntCosQNew;
                        }
                    }
                    if ((action_sync == 1) && ((SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                        _bcmFieldActionNoParamGpPortPrioIntCosQNew)) ||
                                (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                            _bcmFieldActionNoParamPortPrioIntCosQNew)))) {
                        param1 = f_ent_wb_info->port_prio_int_gport;
                    } else {
                        param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x1ff;
                    }
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 10;
                    _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                    append = 1;
                } else if (SOC_IS_KATANA2(unit)
                    || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                    if (SOC_IS_KATANA2(unit) && PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x800) {
                        action = bcmFieldActionGpServicePrioIntCosQNew;
                    } else {
                        if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                            action = bcmFieldActionPortPrioIntCosQNew;
                        } else {
                            action = bcmFieldActionGpPortPrioIntCosQNew;
                        }
                    }
                    if ((action_sync == 1) && ((SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                        _bcmFieldActionNoParamGpPortPrioIntCosQNew)) ||
                                (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                            _bcmFieldActionNoParamPortPrioIntCosQNew)))) {
                        param1 = f_ent_wb_info->port_prio_int_gport;
                    } else {
                        param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x3ff;
                    }
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 12;
                    _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                    append = 1;
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamPortPrioIntCosQNew)) {
                        action = bcmFieldActionPortPrioIntCosQNew;
                    } else {
                        action = bcmFieldActionGpPortPrioIntCosQNew;
                    }
                    if ((action_sync == 1) && ((SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamGpPortPrioIntCosQNew)) ||
                            (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                        _bcmFieldActionNoParamPortPrioIntCosQNew)))) {
                        param1 = f_ent_wb_info->port_prio_int_gport;
                    } else {
                        param1 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) & 0x1ff;
                    }
                    param0 = PolicyGet(unit, policy_mem, policy_entry, G_COS_INT_PRIf) >> 9;
                    _BCM_COSQ_CLASSIFIER_FIELD_SET(param0, param0);
                    append = 1;
                }
#endif
                break;


            default:
                ;
            }

            break;

        case R_DROP_PRECEDENCEf:
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamDropPrecedenceNoColor)) {
                break;
            }
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamRpDropPrecedence))|| (fldval)) {
                action = bcmFieldActionRpDropPrecedence;
                param0 = fldval;
                append = 1;
            }

            break;

        case Y_DROP_PRECEDENCEf:
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamDropPrecedenceNoColor)) {
                break;
            }
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamYpDropPrecedence))|| (fldval)) {
                action = bcmFieldActionYpDropPrecedence;
                param0 = fldval;
                append = 1;
            }

            break;

        case G_DROP_PRECEDENCEf:
            if (((action_sync == 1) &&
                        (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamDropPrecedenceNoColor) ||
                         SHR_BITGET(f_ent_wb_info->action_bmp->w,
                             _bcmFieldActionNoParamGpDropPrecedence))) ||
                    (fldval)) {
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                     _bcmFieldActionNoParamDropPrecedenceNoColor)) {
                    action = bcmFieldActionDropPrecedence;
                } else {
                    action = bcmFieldActionGpDropPrecedence;
                }
                param0 = fldval;
                append = 1;
            }

            break;

        case USE_VFP_CLASS_ID_Lf:
            if (fldval) {
                action = bcmFieldActionClassDestSet;
                param0 = PolicyGet(unit, policy_mem, policy_entry, VFP_CLASS_ID_Lf);
                append = 1;
            }
            break;
        case USE_VFP_CLASS_ID_Hf:
            if (fldval) {
                action = bcmFieldActionClassSourceSet;
                param0 = PolicyGet(unit, policy_mem, policy_entry, VFP_CLASS_ID_Hf);
                append = 1;
            }
            break;
        case FIELDS_ACTIONf:
        case MPLS_ACTIONf:
            {
                uint32 data = 0;
                if ((fld == MPLS_ACTIONf)
                     && (soc_mem_field_valid(unit, policy_mem, FIELDS_ACTIONf))) {
                    /* Recovery to be done as a part of FIELDS_ACTIONf, if present.
                       If FIELDS_ACTIONf is not present, then recover from
                       MPLS_ACTIONSf.
                     */
                    continue;
                }
                switch (fldval) {
                    case 1:
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
                        /* Virtual Port Actions will be recovered as Gport,
                         * even if they were to be configured using respective
                         * actions (like bcmFieldActionIncomingMplsPortSet).
                         */
                        if ((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit))
                            && !SOC_IS_TOMAHAWKX(unit)) {
                            /* FIELDS_ACTION = 1 for SVP is not valid on Trident2X devices */
                            action = bcmFieldActionIngressGportSet;

                            data = PolicyGet(unit, policy_mem, policy_entry, SVPf);
                            /* Virtual port need to be converted back to Gport. */
                            if (action_sync == 1) {
                               int gport_type;
                               _field_control_t *fc;

                               action = -1;
                               if (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                         _bcmFieldActionNoParamIngressGportSet)) {
                                   action = bcmFieldActionIngressGportSet;
                               }
                               BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
                               if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_19) {
                                  if (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                       _bcmFieldActionNoParamIncomingMplsPortSet)) {
                                     action = bcmFieldActionIncomingMplsPortSet;
                                  }
                               }

                               if (action == -1) {
                                  param0 = data;
                                  append = 1;
                                  break;
                               }

                               append = 1;
                               gport_type = f_ent_wb_info->ing_gport_type;
                               if (gport_type == _bcmVpTypeMpls) {
                                  BCM_GPORT_MPLS_PORT_ID_SET(param0, data);
                               } else if (gport_type == _bcmVpTypeMim) {
                                  BCM_GPORT_MIM_PORT_ID_SET(param0, data);
                               } else if (gport_type == _bcmVpTypeWlan) {
                                  BCM_GPORT_WLAN_PORT_ID_SET(param0, data);
                               } else if (gport_type == _bcmVpTypeTrill) {
                                  BCM_GPORT_TRILL_PORT_ID_SET(param0, data);
                               } else if (gport_type == _bcmVpTypeNiv) {
                                  BCM_GPORT_NIV_PORT_ID_SET(param0, data);
                               } else if (gport_type == _bcmVpTypeVxlan) {
                                  BCM_GPORT_VXLAN_PORT_ID_SET(param0, data);
                               } else {
                                  append = 0;
                               }
                            } else {
                              param0 = data;
                              append = 1;
                            }
                        }
#endif /* INCLUDE_L3 */
                        break;
                    case 2:
                        action = bcmFieldActionL3IngressSet;
                        data = PolicyGet(unit, policy_mem, policy_entry, L3_IIFf);
                        /* L3_IIF needs to be converted back to Ingress L3 interface. */
                        param0 = data;
                        append = 1;
                        break;
                    case 3:
                        action = bcmFieldActionVrfSet;
                        param0 = PolicyGet(unit, policy_mem, policy_entry, VFP_VRF_IDf);
                        append = 1;
                        break;
                    default:
                        break; /* Do nothing */
                }
            }
            break;
        case DISABLE_VLAN_CHECKSf:
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                 _bcmFieldActionNoParamEnableVlanCheck)) {
                action = bcmFieldActionEnableVlanCheck;
                append = 1;
            } else if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                    || SOC_IS_TOMAHAWKX(unit)) {
                if ((PolicyGet(unit, policy_mem, policy_entry, SVPf) == 0)
                        || (PolicyGet(unit, policy_mem,
                                policy_entry, SVP_VALIDf) == 0)) {
                    if (fldval) {
                        action = bcmFieldActionDoNotCheckVlan;
                        append = 1;
                    }
                }
            } else {
                tmp_fld = (soc_mem_field_valid(unit, policy_mem, FIELDS_ACTIONf)
                        ? FIELDS_ACTIONf : MPLS_ACTIONf);
                if (!soc_mem_field_valid(unit, policy_mem, tmp_fld)
                     || PolicyGet(unit, policy_mem, policy_entry, tmp_fld) != 1
                   ) {
                    if (fldval) {
                        action = bcmFieldActionDoNotCheckVlan;
                        append = 1;
                    }
                }
            }
            break;
#if defined(BCM_TRIUMPH3_SUPPORT)
         case ESM_SEARCH_PRIORITYf :
            if (soc_feature(unit, soc_feature_esm_support) && fldval) {
                action = bcmFieldActionEsmSearchKeySrcMac;
                append = 1;
            }
            break;

#endif
         case SVPf:
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
            /* Only in trident2 device SVPf needs to be read directly to get source
             * virtual ports. In Other devices FIELDS_ACTIONf and MPLS_ACTIONSf
             * call SVPf indirectly to obtain source virtual ports.
             */
            if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                || SOC_IS_TOMAHAWKX(unit)) {
                if ((PolicyGet(unit, policy_mem,
                           policy_entry, SVP_VALIDf) == 1) && (fldval != 0)) {
                    action = bcmFieldActionIngressGportSet;
                    /* Virtual port need to be converted back to Gport. */
                    if (action_sync == 1) {
                       int gport_type;
                       _field_control_t *fc;

                       action = -1;
                       if (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamIngressGportSet)) {
                           action = bcmFieldActionIngressGportSet;
                       }
                       BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
                       if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_19) {
                          if (SHR_BITGET(f_ent_wb_info->action_bmp->w,
                               _bcmFieldActionNoParamIncomingMplsPortSet)) {
                             action = bcmFieldActionIncomingMplsPortSet;
                          }
                       }

                       if (action == -1) {
                          param0 = fldval;
                          append = 1;
                          break;
                       }

                       append = 1;
                       gport_type = f_ent_wb_info->ing_gport_type;
                       if (gport_type == _bcmVpTypeMpls) {
                          BCM_GPORT_MPLS_PORT_ID_SET(param0, fldval);
                       } else if (gport_type == _bcmVpTypeMim) {
                          BCM_GPORT_MIM_PORT_ID_SET(param0, fldval);
                       } else if (gport_type == _bcmVpTypeWlan) {
                          BCM_GPORT_WLAN_PORT_ID_SET(param0, fldval);
                       } else if (gport_type == _bcmVpTypeTrill) {
                          BCM_GPORT_TRILL_PORT_ID_SET(param0, fldval);
                       } else if (gport_type == _bcmVpTypeNiv) {
                          BCM_GPORT_NIV_PORT_ID_SET(param0, fldval);
                       } else if (gport_type == _bcmVpTypeVxlan) {
                          BCM_GPORT_VXLAN_PORT_ID_SET(param0, fldval);
                       } else {
                          append = 0;
                       }
                    } else {
                      param0 = fldval;
                      append = 1;
                    }
                }
            }
#endif /* INCLUDE_L3 */
            break;
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
         case VFIf:
            if (fldval != 0) {
                if (soc_feature(unit, soc_feature_vfi_from_vlan_tables) ||
                    soc_feature(unit, soc_feature_vxlan_lite)) {
                    param0 = PolicyGet(unit, policy_mem,
                            policy_entry, VFIf);
                    action = bcmFieldActionVpnSet;
                    append = 1;
                }
            }
            break;
#endif
        case R_CHANGE_ECNf:
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamEcnNewNoColor)) {
                break;
            }
            if (fldval != 0) {
                action = bcmFieldActionRpEcnNew;
                param0 = fldval;
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, R_NEW_ECNf);
                }
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
                if ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                     SOC_IS_GREYHOUND2(unit)) &&
                    (policy_mem == EFP_POLICY_TABLEm)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, R_NEW_ECNf);
                }
#endif
                append = 1;
            }

            break;

        case Y_CHANGE_ECNf:
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamEcnNewNoColor)) {
                break;
            }
            if (fldval != 0) {
                action = bcmFieldActionYpEcnNew;
                param0 = fldval;
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, Y_NEW_ECNf);
                }
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
                if ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                     SOC_IS_GREYHOUND2(unit)) &&
                    (policy_mem == EFP_POLICY_TABLEm)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, Y_NEW_ECNf);
                }
#endif
                append = 1;
            }

            break;

        case G_CHANGE_ECNf:
            if (fldval != 0) {
                if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamEcnNewNoColor)) {
                   action = bcmFieldActionEcnNew;
                } else {
                   action = bcmFieldActionGpEcnNew;
                }
                param0 = fldval;
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, G_NEW_ECNf);
                }
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
                if ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                     SOC_IS_GREYHOUND2(unit)) &&
                    (policy_mem == EFP_POLICY_TABLEm)) {
                    param0 = PolicyGet(unit, policy_mem,
                                       policy_entry, G_NEW_ECNf);
                }
#endif
                append = 1;
            }

            break;

        case DO_NOT_CHANGE_TTLf:
            if (fldval) {
                action = bcmFieldActionDoNotChangeTtl;

                append = 1;
            }

            break;

        case DO_NOT_URPFf:
            if (fldval) {
                action = bcmFieldActionDoNotCheckUrpf;

                append = 1;
            }

            break;

           /***** Mirroring recovery, for Triumph / Valkyrie / Enduro *****/

        case INGRESS_MIRRORf:
            /*This field is not required on KATANA and ENDURO devices,
             *but only retained for C-code compilation*/
            if (!SOC_IS_KATANA(unit) && !SOC_IS_ENDURO(unit)) {
                if (fldval & (1U << 0)) {
                    bcm_module_t modid;
                    bcm_gport_t  port;

                    hw_index = PolicyGet(unit,
                                         policy_mem,
                                         policy_entry,
                                         soc_mem_field_valid(unit, policy_mem, MTP_INDEX0f)
                                         ? MTP_INDEX0f
                                         : IM0_MTP_INDEXf
                                         );

                    /* Translate hw index into (module_num, port_num) */

                    _bcm_esw_mirror_mtp_to_modport(unit,
                                                   hw_index,
                                                   FALSE,
                                                   BCM_MIRROR_PORT_INGRESS,
                                                   &modid,
                                                   &port
                                                   );

                    rv = _field_trx_actions_recover_action_add(
                             unit,
                             f_ent,
                             bcmFieldActionMirrorIngress,
                             modid,
                             port,
                             0,
                             0,
                             0,
                             0,
                             hw_index
                                                               );

                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }

                if (fldval & (1U << 1)) {
                    bcm_module_t modid;
                    bcm_gport_t  port;

                    hw_index = PolicyGet(unit,
                                         policy_mem,
                                         policy_entry,
                                         soc_mem_field_valid(unit, policy_mem, MTP_INDEX1f)
                                         ? MTP_INDEX1f
                                         : IM1_MTP_INDEXf
                                         );

                    /* Translate hw index into (module_num, port_num) */

                    _bcm_esw_mirror_mtp_to_modport(unit,
                                                   hw_index,
                                                   FALSE,
                                                   BCM_MIRROR_PORT_INGRESS,
                                                   &modid,
                                                   &port
                                                   );

                    rv = _field_trx_actions_recover_action_add(
                             unit,
                             f_ent,
                             bcmFieldActionMirrorIngress,
                             modid,
                             port,
                             0,
                             0,
                             0,
                             0,
                             hw_index
                                                               );
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }

            }

            break;

        case EGRESS_MIRRORf:
            /*This field is not required on KATANA and ENDURO devices,
             *but only retained for C-code compilation*/
            if (!SOC_IS_KATANA(unit) && !SOC_IS_ENDURO(unit)) {
                if (fldval & (1U << 0)) {
                    bcm_module_t modid;
                    bcm_gport_t  port;

                    hw_index = PolicyGet(unit,
                                         policy_mem,
                                         policy_entry,
                                         soc_mem_field_valid(unit, policy_mem, MTP_INDEX2f)
                                         ? MTP_INDEX2f
                                         : EM0_MTP_INDEXf
                                         );

                    /* Translate hw index into (module_num, port_num) */

                    _bcm_esw_mirror_mtp_to_modport(unit,
                                                   hw_index,
                                                   FALSE,
                                                   BCM_MIRROR_PORT_EGRESS,
                                                   &modid,
                                                   &port
                                                   );

                    rv = _field_trx_actions_recover_action_add(
                             unit,
                             f_ent,
                             bcmFieldActionMirrorEgress,
                             modid,
                             port,
                             0,
                             0,
                             0,
                             0,
                             hw_index
                                                               );
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }

                if (fldval & (1U << 1)) {
                    bcm_module_t modid;
                    bcm_gport_t  port;

                    hw_index = PolicyGet(unit,
                                         policy_mem,
                                         policy_entry,
                                         soc_mem_field_valid(unit, policy_mem, MTP_INDEX3f)
                                         ? MTP_INDEX3f
                                         : EM1_MTP_INDEXf
                                         );

                    /* Translate hw index into (module_num, port_num) */

                    _bcm_esw_mirror_mtp_to_modport(unit,
                                                   hw_index,
                                                   FALSE,
                                                   BCM_MIRROR_PORT_EGRESS,
                                                   &modid,
                                                   &port
                                                   );

                    rv = _field_trx_actions_recover_action_add(
                             unit,
                             f_ent,
                             bcmFieldActionMirrorEgress,
                             modid,
                             port,
                             0,
                             0,
                             0,
                             0,
                             hw_index
                                                               );
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }
            }

            break;

            /***** Mirroring recovery, for Triumph2/Apollo *****/

        case MIRRORf:
            {
                static const unsigned mtp_index_field[] = {
                    MTP_INDEX0f, MTP_INDEX1f, MTP_INDEX2f, MTP_INDEX3f
                };

                uint32   ms_reg, mtp_type;
                unsigned b, i;
                bcm_module_t modid;
                bcm_gport_t  port;
                bcm_field_action_t action;
                _bcmFieldActionNoParam_t _action;
                _bcmFieldActionNoParam_t ingress_mirror_actions[] = {
                                             _bcmFieldActionNoParamMirrorIngress,
                                             _bcmFieldActionNoParamMirrorIngress1,
                                             _bcmFieldActionNoParamMirrorIngress2,
                                             _bcmFieldActionNoParamMirrorIngress3};
                _bcmFieldActionNoParam_t egress_mirror_actions[] = {
                                             _bcmFieldActionNoParamMirrorEgress,
                                             _bcmFieldActionNoParamMirrorEgress1,
                                             _bcmFieldActionNoParamMirrorEgress2,
                                             _bcmFieldActionNoParamMirrorEgress3};

                if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
                    SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
                    /* Enduro/Katana has this field, but as an overlay --
                       mirroring for Enduro/Katana is handled above.
                    */

                    break;
                }

                /* Get the mirroring direction control setting */
                BCM_IF_ERROR_RETURN(READ_MIRROR_SELECTr(unit, &ms_reg));
                mtp_type = soc_reg_field_get(unit, MIRROR_SELECTr, ms_reg, MTP_TYPEf);

                /* For each mirroring slot in the policy entry, ... */
                for (b = 1, i = 0; i < COUNTOF(mtp_index_field); ++i, b <<= 1) {
                    if (!(fldval & b)) {
                        /* Slot not in use => Skip */

                        continue;
                    }

                    /* Slot in use => Recover mirror action */
                    hw_index = PolicyGet(unit,
                                         policy_mem,
                                         policy_entry,
                                         mtp_index_field[i]
                                         );

                    action = (mtp_type & b) ? bcmFieldActionMirrorEgress : bcmFieldActionMirrorIngress;
                    if (mtp_type & b) {
                        if (fc->l2warm && fc->wb_recovered_version >= BCM_FIELD_WB_VERSION_1_21) {
                            _action = egress_mirror_actions[i];
                        } else {
                            _action = _bcmFieldActionNoParamMirrorEgress;
                        }
                    } else {
                        if (fc->l2warm && fc->wb_recovered_version >= BCM_FIELD_WB_VERSION_1_21) {
                            _action = ingress_mirror_actions[i];
                        } else {
                            _action = _bcmFieldActionNoParamMirrorIngress;
                        }
                    }

                    if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w, _action)) {
                       /*
                        *  It indicates the parameter present in the action is
                        *  Mirror destination ID instead of ModPort.
                        */
                       param0 = 0;
                       if (action == bcmFieldActionMirrorIngress) {
                           if (_action == _bcmFieldActionNoParamMirrorIngress) {
                               param1 = f_ent_wb_info->ingress_mirror[0];
                           } else {
                               param1 = f_ent_wb_info->ingress_mirror[i];
                           }
                       } else {
                           if (_action == _bcmFieldActionNoParamMirrorEgress) {
                               param1 = f_ent_wb_info->egress_mirror[0];
                           } else {
                               param1 = f_ent_wb_info->egress_mirror[i];
                           }
                       }
                    } else {
                       /* Translate hw index into (module_num, port_num) */
                       _bcm_esw_mirror_mtp_to_modport(unit,
                                                   hw_index,
                                                   FALSE,
                                                   mtp_type & b
                                                       ? BCM_MIRROR_PORT_EGRESS
                                                       : BCM_MIRROR_PORT_INGRESS,
                                                   &modid,
                                                   &port
                                                   );
                       param0 = modid;
                       param1 = port;
                    }

                    rv = _field_trx_actions_recover_action_add(unit, f_ent,
                                action, param0, param1, 0, 0, 0, 0, hw_index);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }
            }
            break;

        case G_PACKET_REDIRECTIONf:
            {
                soc_field_t redir_fld = REDIRECTIONf;
                uint32 redir = 0, nhi_sh = 0;
#if (defined BCM_TRIDENT_SUPPORT)
                uint32 redir_offset = 0;
#endif
                unsigned sh = (SOC_IS_TR_VL(unit) && (!SOC_IS_HURRICANE3(unit)))
                    ? ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                        SOC_IS_GREYHOUND2(unit)) ? 9 : 7)
                    : 8,
                    m = (1 << sh) - 1;

                if ((action_sync == 1) &&
                     SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                 _bcmFieldActionNoParamFabricQueue)) {
                    break;
                }

                if (SOC_IS_HURRICANE3(unit)) {
                    nhi_sh = 15;
                } else if (SOC_IS_GREYHOUND2(unit)) {
                    nhi_sh = 16;
                } else {
                    nhi_sh = 14;
                }

                if ((SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) &&
                    (policy_mem == EFP_POLICY_TABLEm) &&
                    (soc_mem_field_valid(unit, policy_mem, REDIRECTION_DESTINATIONf))) {
                    redir_fld = REDIRECTION_DESTINATIONf;
                }
                redir = PolicyGet(unit,
                                  policy_mem,
                                  policy_entry,
                                  redir_fld
                                  );

#if (defined BCM_TRIDENT_SUPPORT)
                if (SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
                    redir_offset = 3;
                }
#endif

                switch (fldval) {
                case 1:
                    if (SOC_IS_KATANAX(unit)) {
                        /* 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 */
                        /* RED[17:16] == 0 REDIRECT TO DGLP       */
                           /* DST_T : RED[15]: Trunk Group Bit    */
                           /* DST_MODID  : RED[14:7]              */
                           /* DST_PORTID : RED[ 6:0]              */
                        /* RED[17:16] == 1 REDIRECT TO NHI        */
                           /* NHI : RED[13:0]                     */
                        /* RED[17:16] == 2 REDIRECT TO ECMP GROUP */
                           /* ECMP Group Point : RED[ 9:0]        */
                        /* RED[17:16] == 3 INVALID                */
                        /* Should get constants from regfile!     */
                        switch((redir >> 16) & 0x3) {
                        case 0: /* REDIRECT TO DGLP */
                                if ((redir  & 0x8000) == 0x8000) {
                                     action = bcmFieldActionRedirectTrunk;
                                     param0 = redir & 0x7ff;
                                } else {
                                     action = bcmFieldActionRedirect;
                                     param0 = (redir >> 7) & 0xff;
                                     param1 = (redir & 0x7f);
                                }
                                break;
                        case 1: /* REDIRECT TO NHI */
#ifdef INCLUDE_L3
                                action = bcmFieldActionRedirectEgrNextHop;
                                param0 = (redir & 0x3fff) +
                                         (BCM_XGS3_EGRESS_IDX_MIN);
#endif
                                break;
                        case 2: /* REDIRECT TO ECMP GROUP */
#ifdef INCLUDE_L3
                                action = bcmFieldActionRedirectEgrNextHop;
                                param0 = (redir & 0x3ff) +
                                         (BCM_XGS3_MPATH_EGRESS_IDX_MIN);
#endif
                                break;
                        case 3:
                        default: /* Wrong */
                                return BCM_E_CONFIG;
                        }
                    } else
#ifdef BCM_TRIDENT_SUPPORT
                    if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) {

                        redir_offset = (SOC_IS_TD2_TT2(unit) ||
                                        SOC_IS_TRIUMPH3(unit)) ? 2 : 0;

                        switch ((redir >> (16 + redir_offset)) & 0x7) {
                            case 0x1:
                                action =
                                    bcmFieldActionUnmodifiedPacketRedirectPort;
                                if (redir & (0x1 << 15)) {
                                    BCM_GPORT_TRUNK_SET(param0,
                                        (redir & 0x3ff));
                                } else {
                                    BCM_GPORT_MODPORT_SET(param0,
                                        ((redir >> 7) & 0xff), (redir & 0x7f));
                                }
                                break;
#ifdef INCLUDE_L3
                            case 0x2: /* Regular Next Hop */
                                action = bcmFieldActionRedirectEgrNextHop;
                                param0 = (redir & ((1 << 16) - 1))
                                                + (BCM_XGS3_EGRESS_IDX_MIN);
                                break;
                            case 0x3: /* ECMP Next Hop Group */
                                action = bcmFieldActionRedirectEgrNextHop;
                                param0 = (redir & ((1 << 16) - 1))
                                              + (BCM_XGS3_MPATH_EGRESS_IDX_MIN);
                                break;
                            case 0x6:
#if defined(BCM_TRIDENT2_SUPPORT)
                                /* Recovering Redirect to VPLAG. */
                                if (soc_feature(unit, soc_feature_vp_lag)) {
                                    int tid_is_vp_lag = 0;
                                    int vp_id_min = -1;

                                    param0 = redir & ((1 << 13) - 1);

                                    rv = _bcm_esw_trunk_chip_info_vp_resource_get(
                                                  unit, &vp_id_min, NULL, NULL);

                                    BCM_IF_ERROR_RETURN(rv);

                                    param0 += vp_id_min;

                                    rv = _bcm_esw_trunk_id_is_vp_lag(unit, param0,
                                                                     &tid_is_vp_lag);
                                    BCM_IF_ERROR_RETURN(rv);

                                    if (tid_is_vp_lag) {
                                        action = bcmFieldActionRedirectTrunk;
                                        param1 = 0;
                                    } else {

                                        action = bcmFieldActionRedirect;
                                        /* Virtual port need to be converted
                                         * back to Gport. */
                                        param1 = redir & ((1 << 13) - 1);
                                        param0 = 0;
                                    }
                                } else
#endif
                                {
                                     action = bcmFieldActionRedirect;
                                     /* Virtual port need to be converted
                                      * back to Gport. */
                                     param1 = redir & ((1 << 13) - 1);
                                }
#endif  /* INCLUDE_L3 */
                                break;
                            default: /* 0x0 */
                                if (redir & (0x1 << 15)) {
                                     action = bcmFieldActionRedirectTrunk;
                                     param0 = redir & 0x3ff;
                                } else {
                                    action = bcmFieldActionRedirect;
                                    if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                                                HI_PRI_ACTION_CONTROLf)) {
                                        soc_field_t suppress_vxlt = INVALIDf;

                                        if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                                                    SUPPRESS_VXLTf)) {
                                            suppress_vxlt = SUPPRESS_VXLTf;
                                        } else {
                                            suppress_vxlt = HI_PRI_SUPPRESS_VXLTf;
                                        }

                                        action = PolicyGet(unit,
                                                policy_mem,
                                                policy_entry,
                                                HI_PRI_ACTION_CONTROLf
                                                )
                                            == 1
                                            && PolicyGet(unit,
                                                    policy_mem,
                                                    policy_entry,
                                                    HI_PRI_RESOLVEf
                                                    )
                                            == 1
                                            && PolicyGet(unit,
                                                    policy_mem,
                                                    policy_entry,
                                                    SUPPRESS_COLOR_SENSITIVE_ACTIONSf
                                                    )
                                            == 1
                                            && PolicyGet(unit,
                                                    policy_mem,
                                                    policy_entry,
                                                    DEFER_QOS_MARKINGSf
                                                    )
                                            == 1
                                            && PolicyGet(unit,
                                                    policy_mem,
                                                    policy_entry,
                                                    SUPPRESS_SW_ACTIONSf
                                                    )
                                            == 1
                                            && PolicyGet(unit,
                                                    policy_mem,
                                                    policy_entry,
                                                    suppress_vxlt
                                                    )
                                            == 1
                                            ? bcmFieldActionOffloadRedirect :
                                            bcmFieldActionRedirect;

                                    }
                                    param0 = (redir >> 7) & 0xff;
                                    param1 = (redir & 0x7f);
                                }
                                break;
                        }
                    } else
#endif  /* BCM_TRIDENT_SUPPORT */
                    if (((redir >> nhi_sh) == 0x1)
                               && soc_feature(unit, soc_feature_field_action_redirect_nexthop)) {
#if defined(BCM_HURRICANE3_SUPPORT)
                        if (soc_feature(unit, soc_feature_miml) && (PolicyGet(unit,
                            policy_mem, policy_entry, ASSIGN_HEADER_ENCAP_FIELDSf))) {
                            /* MiML Switch Encap */
                            action = bcmFieldActionSwitchEncap;
                            hw_index = PolicyGet(unit, policy_mem, policy_entry,
                                                 HEADER_ENCAP_INDEXf);
                            param0 = redir & ((1 << nhi_sh) - 1);
                            param0 |= (hw_index <<
                                               _BCM_SWITCH_ENCAP_MIML_EGR_HEADER_ENCAP_SHIFT);
                            param0 |= (_BCM_SWITCH_ENCAP_TYPE_MIML <<
                                               _BCM_SWITCH_ENCAP_SHIFT);
                        } else
#endif  /* BCM_HURRICANE3_SUPPORT */
                        {
#ifdef INCLUDE_L3
                            /* Regular Next Hop */
                            action = bcmFieldActionRedirectEgrNextHop;
                            param0 = (redir & ((1 << nhi_sh) - 1))
                                            + (BCM_XGS3_EGRESS_IDX_MIN);
#endif  /* INCLUDE_L3 */
                        }
                    } else if (redir & (0x40 << sh)) {
                        action = bcmFieldActionRedirectTrunk;
                        param0 = redir & m;
                    } else {
                        if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                                                HI_PRI_ACTION_CONTROLf)) {
                            soc_field_t suppress_vxlt = INVALIDf;

                            if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                                                    SUPPRESS_VXLTf)) {
                               suppress_vxlt = SUPPRESS_VXLTf;
                            } else {
                               suppress_vxlt = HI_PRI_SUPPRESS_VXLTf;
                            }

                            action = PolicyGet(unit,
                                               policy_mem,
                                               policy_entry,
                                               HI_PRI_ACTION_CONTROLf
                                               )
                                == 1
                                && PolicyGet(unit,
                                             policy_mem,
                                             policy_entry,
                                             HI_PRI_RESOLVEf
                                             )
                                == 1
                                && PolicyGet(unit,
                                             policy_mem,
                                             policy_entry,
                                             SUPPRESS_COLOR_SENSITIVE_ACTIONSf
                                             )
                                == 1
                                && PolicyGet(unit,
                                             policy_mem,
                                             policy_entry,
                                             DEFER_QOS_MARKINGSf
                                             )
                                == 1
                                && PolicyGet(unit,
                                             policy_mem,
                                             policy_entry,
                                             SUPPRESS_SW_ACTIONSf
                                             )
                                == 1
                                && PolicyGet(unit,
                                             policy_mem,
                                             policy_entry,
                                             suppress_vxlt
                                             )
                                == 1
                                ? bcmFieldActionOffloadRedirect :
                                bcmFieldActionRedirect;
                            param0 = redir >> 6;
                            param1 = redir & 0x3f;
                            if (action == bcmFieldActionOffloadRedirect) {
                                param0 = param0 & 0x7f;
                            }
                        } else {
                            action = bcmFieldActionRedirect;
                            param0 = redir >> 6;
                            param1 = redir & 0x3f;
                        }
                    }

                    append = 1;

                    break;

                case 2:
                    action = bcmFieldActionRedirectCancel;

                    break;

                case 3:
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
                    if (SOC_IS_KATANAX(unit)) {
                        /* 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0       */
                        /* RED[13:12] == 1 Broadcast Replace PortBitMap      */
                        /*            PortBitMapIndex = RED[11:0]            */
                        /* RED[13:12] == 2 L2MC Replace Port BitMap          */
                        /*            L2MC_Index=PortBitMapIndex = RED[11:0] */
                        /* RED[13:12] == 3 L3MC Replace Port BitMap          */
                        /*            L3MC_Index=PortBitMapIndex = RED[11:0] */
                        /* Should get constants from regfile!     */
                        switch((redir >> 12) & 0x3) {
                        case 1 :  /* Broadcast */
                                  if ((redir >> 11) & 0x01) {
                                      /* RedirectBcastPbmp */
                                      hw_index = (redir & 0x3ff);
                                      action = bcmFieldActionRedirectBcastPbmp;
                                      rv = soc_mem_read(unit, profile_mem,
                                               MEM_BLOCK_ANY, hw_index,
                                               entry_ptr[0]);
                                      BCM_IF_ERROR_RETURN(rv);
                                      soc_mem_pbmp_field_get(unit, profile_mem,
                                          entry_ptr[0], BITMAPf, &pbmp);
                                      param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                                      param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                                      param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                                      if (SOC_IS_KATANA2(unit)) {
                                            param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                                            param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                                            param5 = SOC_PBMP_WORD_GET(pbmp, 5);
                                      }
                                      SOC_PROFILE_MEM_REFERENCE(unit,
                                          redirect_profile, hw_index, 1);
                                      SOC_PROFILE_MEM_ENTRIES_PER_SET(unit,
                                          redirect_profile, hw_index, 1);
                                 } else {
                                     /* RedirectVlan */
                                     action = bcmFieldActionRedirectVlan;
                                 }
                                 break;
                        case 2 :  /* L2MC */
                                  /* RedirectMcast */
                                  action = bcmFieldActionRedirectMcast;
                                  if (soc_feature(unit,
                                      soc_feature_field_action_redirect_ipmc)) {
                                      param0 = (redir & 0xfff);
                                  } else {
                                      hw_index = (redir & 0xfff);
                                  }
                                  break;
                        case 3 :  /* L3MC */
                                  /* RedirectIpmc */
                                  action = bcmFieldActionRedirectIpmc;
                                  if (soc_feature(unit,
                                      soc_feature_field_action_redirect_ipmc)) {
                                      param0 = (redir & 0xfff);
                                      if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                                _bcmFieldActionNoParamRedirectIpmcWlan)) {
                                           _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_WLAN,
                                                                    param0);
                                      } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                                _bcmFieldActionNoParamRedirectIpmcVpls)) {
                                           _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_VPLS,
                                                                    param0);
                                      } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                                _bcmFieldActionNoParamRedirectIpmcL3)){
                                           _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_L3,
                                                                    param0);
                                      }
                                  } else {
                                      hw_index = (redir & 0xfff);
                                  }
                                  break;
                        default  :
                            /* RedirectPbmp */
                            hw_index = redir;
                            action = bcmFieldActionRedirectPbmp;
                            rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                              hw_index, entry_ptr[0]);
                            BCM_IF_ERROR_RETURN(rv);
                            soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                                                   BITMAPf, &pbmp);
                            param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                            param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                            param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                            if (SOC_IS_KATANA2(unit)) {
                                param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                                param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                                param5 = SOC_PBMP_WORD_GET(pbmp, 5);
                            }
                            SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                                  hw_index, 1);
                            SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                                        hw_index, 1);
                        }
                    } else if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) {
                switch ((redir >> (13 + redir_offset)) & 0x03) {
                    case 0x01:
                        if ((redir >> 11) & 0x01) {
                            /* RedirectBcastPbmp */
                            hw_index = (redir & 0x3ff);
                            action = bcmFieldActionRedirectBcastPbmp;
                            rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                    hw_index, entry_ptr[0]);
                            BCM_IF_ERROR_RETURN(rv);
                            soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                                BITMAPf, &pbmp);
                            param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                            param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                            param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                            if (SOC_IS_KATANA2(unit)) {
                                param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                                param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                                param5 = SOC_PBMP_WORD_GET(pbmp, 5);
                            }

                            if (SOC_IS_TD2_TT2(unit)) {
                                param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                            }
                            SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                                      hw_index, 1);
                            SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                                            hw_index, 1);
                            break;
                        } else {
                            /* RedirectVlan */
                            action = bcmFieldActionRedirectVlan;
                            break;
                        }
                        break;
                    case 0x02:
                        /* RedirectMcast */
                        action = bcmFieldActionRedirectMcast;
                        if (soc_feature(unit,
                                        soc_feature_field_action_redirect_ipmc)) {
                            param0 = (redir & 0x1fff);
                        } else {
                            hw_index = (redir & 0x1fff);
                        }
                        break;
                    case 0x03:
                        /* RedirectIpmc */
                        action = bcmFieldActionRedirectIpmc;
                        if (soc_feature(unit,
                                        soc_feature_field_action_redirect_ipmc)) {
                            param0 = (redir & 0xfff);
                            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                      _bcmFieldActionNoParamRedirectIpmcWlan)) {
                                 _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_WLAN,
                                                          param0);
                            } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                      _bcmFieldActionNoParamRedirectIpmcVpls)) {
                                 _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_VPLS,
                                                          param0);
                            } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                                _bcmFieldActionNoParamRedirectIpmcL3)){
                                           _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_L3,
                                                                    param0);
                            }
                        } else {
                            hw_index = (redir & 0xfff);
                        }
                        break;
                    default:
                        /* RedirectPbmp */
                        hw_index = redir;
                        action = bcmFieldActionRedirectPbmp;
                        rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                hw_index, entry_ptr[0]);
                        BCM_IF_ERROR_RETURN(rv);
                        soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                            BITMAPf, &pbmp);
                        param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                        param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                        param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                        if (SOC_IS_KATANA2(unit)) {
                            param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                            param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                            param5 = SOC_PBMP_WORD_GET(pbmp, 5);
                        }

                        if (SOC_IS_TD2_TT2(unit)) {
                            param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                        }
                        SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                                  hw_index, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                                        hw_index, 1);
                }
            } else
#endif /* !BCM_TRIDENT_SUPPORT */
            {
                        switch ((redir >> 11) & 0x07) {
                    case 0x02:
                        action = bcmFieldActionRedirectVlan;
                        break;
                    case 0x03:
                        hw_index = (redir & 0x3ff);
                        action = bcmFieldActionRedirectBcastPbmp;
                        rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                hw_index, entry_ptr[0]);
                        BCM_IF_ERROR_RETURN(rv);
                        soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                                BITMAPf, &pbmp);
                        param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                        param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                        SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                                  hw_index, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                                        hw_index, 1);
                        break;
                    case 0x04:
                        action = bcmFieldActionRedirectMcast;

                        if (soc_feature(unit,
                                        soc_feature_field_action_redirect_ipmc)) {
                            param0 = redir;
                        } else {
                            hw_index = redir;
                        }
                        break;
                    case 0x06:
                        action = bcmFieldActionRedirectIpmc;
                        if (soc_feature(unit,
                                        soc_feature_field_action_redirect_ipmc)) {
                            param0 = redir;
                            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                      _bcmFieldActionNoParamRedirectIpmcWlan)) {
                                 _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_WLAN,
                                                          param0);
                            } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                             _bcmFieldActionNoParamRedirectIpmcVpls)) {
                                 _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_VPLS,
                                                          param0);
                            } else if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                                                _bcmFieldActionNoParamRedirectIpmcL3)){
                                           _BCM_MULTICAST_GROUP_SET(param0, _BCM_MULTICAST_TYPE_L3,
                                                                    param0);
                            }
                        } else {
                            hw_index = redir;
                        }
                        break;
                    default:
                        hw_index = redir;
                        action = bcmFieldActionRedirectPbmp;
                        rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                hw_index, entry_ptr[0]);
                        BCM_IF_ERROR_RETURN(rv);
                        soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                            BITMAPf, &pbmp);
                        param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                        param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                        SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                                  hw_index, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                                        hw_index, 1);
                }
            }
            append = 1;
                    break;
                case 4:
                    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
                        mirror_pbm = PolicyGet(unit, policy_mem,
                                           policy_entry, redir_fld);
                        for (bit_pos = 1, mtp_index = 0;
                                mtp_index < BCM_MIRROR_MTP_COUNT;
                                ++mtp_index, bit_pos <<= 1) {
                            if (!(mirror_pbm & bit_pos)) {
                                /* Slot not in use => Skip */
                                continue;
                            }
                            /* Translate hw index into (module_num, port_num) */
                            _bcm_esw_mirror_mtp_to_modport(unit, mtp_index,
                                TRUE, BCM_MIRROR_PORT_EGRESS_TRUE, &modid,
                                &gport);
                            rv = _field_trx_actions_recover_action_add(unit,
                                    f_ent, bcmFieldActionMirrorEgress, -1,
                                    gport, 0, 0, 0, 0, mtp_index);
                            if (BCM_FAILURE(rv)) {
                                return rv;
                            }
                        }
                    } else {
                        action   = bcmFieldActionEgressMask;
                        hw_index = redir;
                        rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                          hw_index, entry_ptr[0]);
                        BCM_IF_ERROR_RETURN(rv);
                        soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                                               BITMAPf, &pbmp);
                        param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                        param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                        param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                        param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                        param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                        param5 = SOC_PBMP_WORD_GET(pbmp, 5);

                        SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                            hw_index, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                            hw_index, 1);
                        append = 1;
                    }
                    break;

                case 5:
                    if (SOC_IS_KATANA2(unit)
                            && (policy_mem == EFP_POLICY_TABLEm)) {
                        action = bcmFieldActionRedirect;
                        param0 = redir >> 7;
                        param1 = redir & 0x7f;
                    } else if (SOC_IS_TRIUMPH3(unit) &&
                            (policy_mem == EFP_POLICY_TABLEm)) {
                        action = bcmFieldActionRedirect;
                        param0 = redir >> 6;
                        param1 = redir & 0x3f;
                    } else {
                        action   = bcmFieldActionEgressPortsAdd;
                        hw_index = redir;
                        rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY,
                                hw_index, entry_ptr[0]);
                        BCM_IF_ERROR_RETURN(rv);
                        soc_mem_pbmp_field_get(unit, profile_mem, entry_ptr[0],
                                BITMAPf, &pbmp);
                        param0 = SOC_PBMP_WORD_GET(pbmp, 0);
                        param1 = SOC_PBMP_WORD_GET(pbmp, 1);
                        param2 = SOC_PBMP_WORD_GET(pbmp, 2);
                        param3 = SOC_PBMP_WORD_GET(pbmp, 3);
                        param4 = SOC_PBMP_WORD_GET(pbmp, 4);
                        param5 = SOC_PBMP_WORD_GET(pbmp, 5);
                        SOC_PROFILE_MEM_REFERENCE(unit, redirect_profile,
                                hw_index, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit, redirect_profile,
                                hw_index, 1);
                    }
                    append = 1;
                    break;

                    case 6 :
                        if ((SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit))
                             && (policy_mem == EFP_POLICY_TABLEm)) {
                          action = bcmFieldActionRedirectTrunk;
                          param0 = redir & m;
                          append = 1;
                        }
                        break;

                    case 7 :
                        if ((SOC_IS_KATANA2(unit) || SOC_IS_TRIUMPH3(unit))
                             && (policy_mem == EFP_POLICY_TABLEm)) {
                          action = bcmFieldActionRedirectMcast;
                          param0 = redir;
                          append =1;
                       }
                       break;

                default:
                    ;
                }
            }

            break;

        case PPD3_CLASS_TAGf:
            if (fldval != 0) {
                if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                            G_L3SW_CHANGE_L2_FIELDSf)) {
                    if(PolicyGet(unit, policy_mem, policy_entry,
                                G_L3SW_CHANGE_L2_FIELDSf) == 0x4) {
                        action = bcmFieldActionOffloadClassSet;
                        param0 = fldval;
                        append = 1;
                    }
                }
            }

            break;

            /* Additions for Enduro */

        case OAM_LMEP_ENf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamLmepEnable)) ||
                (fldval)) {
                action = bcmFieldActionOamLmepEnable;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_LM_ENf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamLmEnable)) ||
                (fldval)) {
                action = bcmFieldActionOamLmEnable;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_DM_ENf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamDmEnable)) ||
                (fldval)) {
                action = bcmFieldActionOamDmEnable;
                param0 = fldval;
                append = 1;
            }

            break;
        case OAM_ENABLE_LM_DM_SAMPLEf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                  _bcmFieldActionNoParamOamLmDmSampleEnable)) ||
                (fldval)) {
                action = bcmFieldActionOamLmDmSampleEnable;
                param0 = fldval;
                append = 1;
            }
            break;
        case OAM_LM_BASE_PTRf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamLmBasePtr)) ||
                (fldval)) {
                action = bcmFieldActionOamLmBasePtr;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_SERVICE_PRI_MAPPING_PTRf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                              _bcmFieldActionNoParamOamServicePriMappingPtr)) ||
                (fldval)) {
                action = bcmFieldActionOamServicePriMappingPtr;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_LMEP_MDLf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamLmepMdl)) ||
                (fldval)) {
                action = bcmFieldActionOamLmepMdl;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_TXf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamTx)) ||
                (fldval)) {
                action = bcmFieldActionOamTx;
                param0 = fldval;
                append = 1;
            }

            break;

        case OAM_UP_MEPf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                    _bcmFieldActionNoParamOamUpMep)) ||
                (fldval)) {
                action = bcmFieldActionOamUpMep;
                param0 = fldval;
                append = 1;
            }
            break;

        case DO_NOT_GENERATE_CNMf:
            if (fldval) {
                action = bcmFieldActionCnmCancel;
                append = 1;
            }

            break;

        case DISABLE_DYNAMIC_LOAD_BALANCINGf:
        case HGT_DLB_DISABLEf:
            if (fldval) {
                action = bcmFieldActionDynamicHgTrunkCancel;
                append = 1;
#if (defined(BCM_TRIDENT_SUPPORT) && defined(BCM_TRIUMPH3_SUPPORT)) || \
    (defined(BCM_TRIDENT_SUPPORT) && defined(BCM_TRIDENT2_SUPPORT))
                if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                    if (PolicyGet(unit, policy_mem, policy_entry,
                        LAG_RH_DISABLEf) && PolicyGet(unit, policy_mem,
                        policy_entry, HGT_RH_DISABLEf)) {
                        action = bcmFieldActionTrunkLoadBalanceCancel;
                    }
                } else if (SOC_IS_TRIUMPH3(unit)) {
                    if (PolicyGet(unit, policy_mem, policy_entry,
                                                LAG_DLB_DISABLEf)) {
                        action = bcmFieldActionTrunkLoadBalanceCancel;
                    }
                }
#endif
            }

            break;

        case CHANGE_OUTER_DOT1Pf:
            switch (fldval) {
            case 1:
                action
                    = PolicyGet(unit, policy_mem, policy_entry,
                        CHANGE_INT_PRIORITYf)
                        ? bcmFieldActionPrioPktAndIntNew
                        : bcmFieldActionPrioPktNew;
                if (bcmFieldActionPrioPktAndIntNew == action) {
                    /*
                     * PrioPktAndIntNew action is recovered by
                     * CHANGE_INT_PRIORITYf
                     */
                    continue;
                }
                param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   NEW_OUTER_DOT1Pf
                                   );

                append = 1;

                break;
            case 2:
#ifdef BCM_TRIDENT_SUPPORT
                if ((SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                     SOC_IS_TRIUMPH3(unit))
                     && _BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {

                    action = bcmFieldActionOuterVlanPrioNew;
                    param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   NEW_OUTER_DOT1Pf
                                   );
                    append = 1;
                }
#endif
                break;
            case 3:
                action = bcmFieldActionOuterVlanPrioCopyInner;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case CHANGE_OUTER_CFIf:
            switch (fldval) {
            case 2:
                action = bcmFieldActionOuterVlanCfiNew;
                param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   NEW_OUTER_CFIf
                                   );

                append = 1;

                break;
            case 3:
                action = bcmFieldActionOuterVlanCfiCopyInner;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case CHANGE_INNER_DOT1Pf:
            switch (fldval) {
            case 2:
                /* No corresponding cold config (?) */
                action = bcmFieldActionInnerVlanPrioNew;
                param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   NEW_INNER_DOT1Pf
                                   );
                append = 1;

                break;

            case 3:
                action = bcmFieldActionInnerVlanPrioCopyOuter;
                append = 1;

                break;

            default:
                ;
            }

            break;

        case CHANGE_INNER_CFIf:
            switch (fldval) {
            case 2:
                action = bcmFieldActionInnerVlanCfiNew;
                param0 = PolicyGet(unit,
                                   policy_mem,
                                   policy_entry,
                                   NEW_INNER_CFIf
                                   );
                append = 1;
                break;

            case 3:
                action = bcmFieldActionInnerVlanCfiCopyOuter;
                append = 1;

                break;

            default:
                ;
            }

            break;

    case IPV6_TO_IPV4_MAP_SIP_VALIDf:
        if (fldval != 0) {
            action = bcmFieldActionCompressSrcIp6;
            param0 = PolicyGet(unit,
                               policy_mem,
                               policy_entry,
                               IPV6_TO_IPV4_MAP_OFFSET_SETf);
            append = 1;
        }
        break;

    case IPV6_TO_IPV4_MAP_DIP_VALIDf:
        if (fldval != 0) {
            action = bcmFieldActionCompressDstIp6;
            param0 = PolicyGet(unit,
                               policy_mem,
                               policy_entry,
                               IPV6_TO_IPV4_MAP_OFFSET_SETf);
            append = 1;
        }
        break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined (BCM_GREYHOUND2_SUPPORT)
    case USE_SVC_METER_COLORf:
        if (fldval != 0) {
            action = bcmFieldActionUseGlobalMeterColor;
            append = 1;
        }
        break;
#endif
        case USE_VFP_VRF_IDf:
            if (fldval) {
                action = bcmFieldActionVrfSet;
                param0 = PolicyGet(unit, policy_mem, policy_entry, VFP_VRF_IDf);
                append = 1;
            }
            break;

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)\
            || defined (BCM_TRIDENT2PLUS_SUPPORT)
    case OAM_KEY1f:
        if (fldval != 0) {
            action = bcmFieldActionOamDomain;
            param0 = PolicyGet(unit, policy_mem, policy_entry, OAM_KEY1f) - 1;
            param1 = PolicyGet(unit, policy_mem, policy_entry, OAM_KEY2f) - 1;
            append = 1;
        }
        break;

    case OLP_HDR_ADDf:
        if (fldval != 0) {
            action = bcmFieldActionOamOlpHeaderAdd;
            if (soc_feature(unit, soc_feature_oam)) {
                hw_index = PolicyGet(unit, policy_mem, policy_entry,
                        OLP_HDR_TYPE_COMPRESSEDf);
                param0 = 0;
                rv = _bcm_oam_olp_hw_index_olp_type_get (unit,
                        hw_index, &param0);
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                append = 1;
            }
        }
        break;

    case ADD_OLP_HEADERf:
        if (fldval != 0) {
            if (soc_feature(unit, soc_feature_fp_based_oam)) {
                /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidOam
                 * for Trident2Plus */
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
                    if(PolicyGet(unit, policy_mem, policy_entry,
                                NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidOam) {
                        break;
                    }
                }

                hw_index = PolicyGet(unit, policy_mem, policy_entry,
                        OLP_HDR_TYPE_COMPRESSEDf);
                param0 = 0;
                rv = _bcm_oam_olp_hw_index_olp_type_get (unit,
                        hw_index, &param0);
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                action = bcmFieldActionOamOlpHeaderAdd;
                append = 1;
            }
        }
        break;

    case SAMPLE_TIMESTAMPf:
        if (fldval != 0) {
            action = bcmFieldActionOamDmTimeFormat;
            if (soc_feature(unit, soc_feature_fp_based_oam)) {
                /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidOam
                 * for Trident2Plus */
                if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
                    if(PolicyGet(unit, policy_mem, policy_entry,
                                NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidOam) {
                        break;
                    }
                }

                if (fldval == 1) {
                    param0 = BCM_FIELD_OAM_DM_TIME_FORMAT_IEEE1588;
                } else if(fldval == 2) {
                    param0 = BCM_FIELD_OAM_DM_TIME_FORMAT_NTP;
                } else {
                    return BCM_E_INTERNAL;
                }
                append = 1;
            }
        }
        break;

    case OAM_SESSION_IDf:
        if (fldval != 0) {
            /* OAM_SESSION_ID is overlayed with DSCP acion */
            if (!(PolicyGet(unit, policy_mem, policy_entry, G_CHANGE_DSCP_TOSf) ||
                        PolicyGet(unit, policy_mem, policy_entry, Y_CHANGE_DSCPf) ||
                        PolicyGet(unit, policy_mem, policy_entry, R_CHANGE_DSCPf))) {
                action = bcmFieldActionOamSessionId;
                param0 = PolicyGet(unit, policy_mem, policy_entry,
                        OAM_SESSION_IDf);
                append = 1;
            }
        }
        break;
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    case FCOE_SRC_BIND_CHECK_ENABLEf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanSrcBindEnable;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_SRC_BIND_CHECK_ENABLEf);
            append = 1;
        }
        break;
    case FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanFpmaPrefixCheckEnable;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf);
            append = 1;
        }
        break;
    case FCOE_ZONE_CHECK_ENABLEf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanZoneCheckEnable;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_ZONE_CHECK_ENABLEf);
            append = 1;
        }
        break;
    case FCOE_VSAN_IDf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanVsanId;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_VSAN_IDf);
            append = 1;
        }
        break;
    case FCOE_ZONE_CHECK_ACTIONf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanZoneCheckActionCancel;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_ZONE_CHECK_ACTIONf);
            append = 1;
        }
        break;
    case FCOE_VSAN_PRI_VALIDf:
        if (fldval != 0) {
            action = bcmFieldActionFibreChanIntVsanPri;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               FCOE_VSAN_PRIf);
            append = 1;
        }
        break;
   case DO_NOT_NATf:
        /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidNat
         * for Trident2Plus */
        if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
            if(PolicyGet(unit, policy_mem, policy_entry,
                        NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidNat) {
                break;
            }
        }
        if (fldval != 0) {
            action = bcmFieldActionNatCancel;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                    DO_NOT_NATf);
            append = 1;
        }
        break;
   case NAT_ENABLEf:
        /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidNat
         * for Trident2Plus */
        if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
            if(PolicyGet(unit, policy_mem, policy_entry,
                        NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidNat) {
                break;
            }
        }
        if (fldval != 0) {
            action = bcmFieldActionNat;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               NAT_ENABLEf);
            append = 1;
        }
        break;
#ifdef INCLUDE_L3
   case NAT_PACKET_EDIT_IDXf:
        /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidNat
         * for Trident2Plus */
        if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
            if(PolicyGet(unit, policy_mem, policy_entry,
                        NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidNat) {
                break;
            }
        }
        if (fldval != 0) {
            action = bcmFieldActionNatEgressOverride;
            param0 = BCM_L3_NAT_EGRESS_SW_IDX_GET(PolicyGet(unit, policy_mem,
                                         policy_entry, NAT_PACKET_EDIT_IDXf),
                                    PolicyGet(unit, policy_mem, policy_entry,
                                                NAT_PACKET_EDIT_ENTRY_SELf));
            append = 1;
        }
        break;
   case NAT_PACKET_EDIT_ENTRY_SELf:
        /* The param value is updated in NAT_PACKET_EDIT_IDXf */
        break;
#endif /* INCLUDE_L3 */
   case SFLOW_ING_SAMPLEf:
        if (fldval != 0) {
            action = bcmFieldActionIngSampleEnable;
            append = 1;
        }
        break;
   case SFLOW_EGR_SAMPLEf:
        if (fldval != 0) {
            action = bcmFieldActionEgrSampleEnable;
            append = 1;
        }
        break;
    case HASH_FIELD_BITMAP_PTR_Af:
        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            hw_index = PolicyGet(unit, policy_mem, policy_entry,
                                 HASH_FIELD_BITMAP_PTR_Af);
            action = bcmFieldActionHashSelect0;
            rv = soc_mem_read(unit, hash_select_profile_mem[0],
                              MEM_BLOCK_ANY, hw_index,
                              entry_ptr[0]);
            BCM_IF_ERROR_RETURN(rv);
            param0 = PolicyGet(unit, hash_select_profile_mem[0],
                               entry_ptr[0], BITMAPf);
            if (param0) {
                append = 1;
            }
        }
        break;
    case HASH_FIELD_BITMAP_PTR_Bf:
        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            hw_index = PolicyGet(unit, policy_mem, policy_entry,
                                 HASH_FIELD_BITMAP_PTR_Bf);
            action = bcmFieldActionHashSelect1;
            rv = soc_mem_read(unit, hash_select_profile_mem[1],
                              MEM_BLOCK_ANY, hw_index,
                              entry_ptr[0]);
            BCM_IF_ERROR_RETURN(rv);
            param0 = PolicyGet(unit, hash_select_profile_mem[1],
                               entry_ptr[0], BITMAPf);
            if (param0) {
                append = 1;
            }
        }
        break;
    case LAG_RH_DISABLEf:
        if (fldval != 0) {
            action = bcmFieldActionTrunkResilientHashCancel;
            if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                if (PolicyGet(unit, policy_mem, policy_entry,
                       HGT_DLB_DISABLEf) && PolicyGet(unit, policy_mem,
                        policy_entry, HGT_RH_DISABLEf)) {
                    action = bcmFieldActionTrunkLoadBalanceCancel;
                }
            }
            append = 1;
        }
        break;
    case HGT_RH_DISABLEf:
        if (fldval != 0) {
            action = bcmFieldActionHgTrunkResilientHashCancel;
            if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
                if (PolicyGet(unit, policy_mem, policy_entry,
                       HGT_DLB_DISABLEf) && PolicyGet(unit, policy_mem,
                        policy_entry, LAG_RH_DISABLEf)) {
                    action = bcmFieldActionTrunkLoadBalanceCancel;
                }
            }
            append = 1;
        }
        break;
    case ECMP_RH_DISABLEf:
        if (fldval != 0) {
            action = bcmFieldActionEcmpResilientHashCancel;
            append = 1;
        }
        break;
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
    case G_HG_CONGESTION_CLASS_CHANGEf:
        append = 0;
        if (soc_feature(unit, soc_feature_ecn_wred) && fldval) {
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               G_HG_CONGESTION_CLASS_NEWf);
            action = bcmFieldActionGpHGCongestionClassNew;
            append = 1;
        }
        break;
    case Y_HG_CONGESTION_CLASS_CHANGEf:
        append = 0;
        if (soc_feature(unit, soc_feature_ecn_wred) && fldval) {
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               Y_HG_CONGESTION_CLASS_NEWf);
            action = bcmFieldActionYpHGCongestionClassNew;
            append = 1;
        }
        break;
    case R_HG_CONGESTION_CLASS_CHANGEf:
        append = 0;
        if (soc_feature(unit, soc_feature_ecn_wred) && fldval) {
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                               R_HG_CONGESTION_CLASS_NEWf);
            action = bcmFieldActionRpHGCongestionClassNew;
            append = 1;
        }
        break;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
    case HG_DST_MODID_CHANGEf:
        if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf)) {
            /* HiGiG header modification actions */
            change_modid = fldval;
            change_portid = PolicyGet(unit, policy_mem, policy_entry,
                                                HG_DST_PORT_CHANGEf);
            modid_new = PolicyGet(unit, policy_mem, policy_entry,
                                              HG_DST_MODID_NEWf);
            portid_new = PolicyGet(unit, policy_mem, policy_entry,
                                                HG_DST_PORT_NEWf);

            if (change_modid && change_portid) {

                /*
                 * Though new HiGiG "Destination module" and
                 * "Destination Port" actions in Cold Boot are assigned
                 * using bcmFieldActionHiGigDstModuleGportNew and
                 * bcmFieldActionHiGigDstPortGportNew respectively,
                 * in Warm Boot it is recover as single field qualifier
                 * bcmFieldActionHiGigDstGportNew.
                 */

                BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                action = bcmFieldActionHiGigDstGportNew;
                param0 = gport;
                append = 1;
            } else if (change_modid && !change_portid) {
                portid_new = 0;
                BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                action = bcmFieldActionHiGigDstModuleGportNew;
                param0 = gport;
                append = 1;
            } else if (!change_modid && change_portid) {
                modid_new = 0;
                BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                action = bcmFieldActionHiGigDstPortGportNew;
                param0 = gport;
                append = 1;
            } else {
                append = 0;
            }
        }
        break;
    case G_HG_DP_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigDropPrecedenceNew)) {
		break;
	}
        else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionGpHiGigDropPrecedenceNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry, G_HG_DP_NEWf);
            append = 1;
        }
        break;
    case Y_HG_DP_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigDropPrecedenceNew)) {
		break;
	} else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
		action = bcmFieldActionYpHiGigDropPrecedenceNew;
		param0 = PolicyGet(unit, policy_mem, policy_entry, Y_HG_DP_NEWf);
		append = 1;
	}
        break;
    case R_HG_DP_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigDropPrecedenceNew)) {
		action = bcmFieldActionHiGigDropPrecedenceNew;
		append = 1;
	} else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionRpHiGigDropPrecedenceNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry, R_HG_DP_NEWf);
            append = 1;
        }
        break;
    case G_HG_INT_PRI_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigIntPriNew)) {
		break;
	} else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
		action = bcmFieldActionGpHiGigIntPriNew;
		param0 = PolicyGet(unit, policy_mem, policy_entry,
				G_HG_INT_PRI_NEWf);
		append = 1;
	}
        break;
    case Y_HG_INT_PRI_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigIntPriNew)) {
		break;
	} else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionYpHiGigIntPriNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                            Y_HG_INT_PRI_NEWf);
            append = 1;
        }
        break;
    case R_HG_INT_PRI_CHANGEf:
        append = 0;
	if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
				_bcmFieldActionNoParamHiGigIntPriNew)) {
		action = bcmFieldActionHiGigIntPriNew;
		append = 1;
	} else if (PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionRpHiGigIntPriNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                            R_HG_INT_PRI_NEWf);
            append = 1;
        }
        break;
    case LB_SRC_MODID_CHANGEf:
        if (!PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) &&
             PolicyGet(unit, policy_mem, policy_entry, LB_SRC_TYPE_CHANGEf)) {
            /* HiGiG header modification actions */
            change_modid = fldval;
            change_portid = PolicyGet(unit, policy_mem, policy_entry,
                                                LB_SRC_PORT_CHANGEf);
            modid_new = PolicyGet(unit, policy_mem, policy_entry,
                                               LB_SRC_MODID_NEWf);
            portid_new = PolicyGet(unit, policy_mem, policy_entry,
                                                 LB_SRC_PORT_NEWf);
            is_not_svp = PolicyGet(unit, policy_mem, policy_entry,
                                            LB_SRC_TYPE_NEWf);

            if (change_modid && change_portid) {
                /*
                 * Though new LoopBack "Source module" and
                 * "Source Port" actions in Cold Boot are assigned
                 * using bcmFieldActionLoopbackSrcModuleGportNew and
                 * bcmFieldActionLoopbackSrcPortGportNew respectively,
                 * in Warm Boot it is recover as single field qualifier
                 * bcmFieldActionLoopbackSrcGportNew.
                 */
                 if (is_not_svp) {
                     BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                 } else {
                     /* Any SVP(MiM, TRILL, L2GRE or VXLAN) is recovered as
                      * VXLAN SVP, as h/w doent have svp type information.
                      */
                     svp = ((uint32)modid_new << 0x8) |  (portid_new & 0xff);
                     BCM_GPORT_VXLAN_PORT_ID_SET(gport, svp);
                 }
                 action = bcmFieldActionLoopbackSrcGportNew;
                 param0 = gport;
                 append = 1;
            } else if (change_modid && !change_portid) {
                portid_new = 0;
                BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                action = bcmFieldActionLoopbackSrcModuleGportNew;
                param0 = gport;
                append = 1;
            } else if (!change_modid && change_portid) {
                modid_new = 0;
                BCM_GPORT_MODPORT_SET(gport, modid_new, portid_new);
                action = bcmFieldActionLoopbackSrcPortGportNew;
                param0 = gport;
                append = 1;
            } else {
                append = 0;
            }
        }
        break;
    case LB_PACKET_PROFILE_CHANGEf:
        append = 0;
        if (!PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionLoopbackCpuMasqueradePktProfileNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                      LB_PACKET_PROFILE_NEWf);
            append = 1;
        }
        break;
    case LB_PP_PORT_CHANGEf:
        append = 0;
        if (!PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionLoopbackPacketProcessingPortNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                             LB_PP_PORT_NEWf);
            append = 1;
        }
        break;
    case LB_TYPE_CHANGEf:
        append = 0;
        if (!PolicyGet(unit, policy_mem, policy_entry,HG_ACTIONf) && fldval) {
            action = bcmFieldActionLoopBackTypeNew;
            param0 = PolicyGet(unit, policy_mem, policy_entry,
                                             LB_TYPE_NEWf);
            append = 1;
        }
        break;
#endif
#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_TOMAHAWK_SUPPORT)
     case PROTECTION_SWITCHING_DROP_OVERIDEf:
#if defined(BCM_TOMAHAWK2_SUPPORT)
     case PROTECTION_SWITCHING_DROP_OVERRIDEf:
#endif
        if (fldval != 0) {
            action = bcmFieldActionRecoverableDropCancel;
            append = 1;
        }
        break;
#endif
#endif /* INCLUDE_L3 */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
     case DROP_DATA_ENABLEf:
        if ((fldval != 0) &&
             (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
            action = bcmFieldActionProtectionSwitchingDrop;
            append = 1;
        }
        break;
#endif
#if defined (BCM_TRX_SUPPORT)
    case R_REDIR_DROP_PRECEDENCEf:
        if (fldval != 0) {
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamRedirDropPrecedenceNoColor)) {
                break;
            }
            action = bcmFieldActionRpRedirDropPrecedence;
            param0 = fldval;
            append = 1;
            switch (param0) {
                case 0:
                    param0 = BCM_FIELD_COLOR_PRESERVE;
                    break;
                case 1:
                    param0 = BCM_FIELD_COLOR_GREEN;
                    break;
                case 2:
                    param0 = BCM_FIELD_COLOR_YELLOW;
                    break;
                case 3:
                    param0 = BCM_FIELD_COLOR_RED;
                    break;
                default:
                    break; /* Do nothing */
            }
        }
        break;
    case Y_REDIR_DROP_PRECEDENCEf:
            if (fldval != 0) {
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamRedirDropPrecedenceNoColor)) {
                break;
            }
            action = bcmFieldActionYpRedirDropPrecedence;
            param0 = fldval;
            append = 1;
            switch (param0) {
                case 0:
                    param0 = BCM_FIELD_COLOR_PRESERVE;
                    break;
                case 1:
                    param0 = BCM_FIELD_COLOR_GREEN;
                    break;
                case 2:
                    param0 = BCM_FIELD_COLOR_YELLOW;
                    break;
                case 3:
                    param0 = BCM_FIELD_COLOR_RED;
                    break;
                default:
                    break; /* Do nothing */
            }
        }
        break;
    case G_REDIR_DROP_PRECEDENCEf:
            if (fldval != 0) {
            if ((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                        _bcmFieldActionNoParamRedirDropPrecedenceNoColor)) {
                action = bcmFieldActionRedirDropPrecedence;
            } else {
                action = bcmFieldActionGpRedirDropPrecedence;
            }
            param0 = fldval;
            append = 1;
            switch (param0) {
                case 0:
                    param0 = BCM_FIELD_COLOR_PRESERVE;
                    break;
                case 1:
                    param0 = BCM_FIELD_COLOR_GREEN;
                    break;
                case 2:
                    param0 = BCM_FIELD_COLOR_YELLOW;
                    break;
                case 3:
                    param0 = BCM_FIELD_COLOR_RED;
                    break;
                default:
                    break; /* Do nothing */
            }
        }
        break;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT) || defined (BCM_KATANA2_SUPPORT) || \
    defined(BCM_TRIUMPH3_SUPPORT)
        case I2E_CLASSID_SELf:
        if((SOC_IS_KATANA2(unit)
            || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
            SOC_IS_SABER2(unit) || SOC_IS_TRIUMPH3(unit) ) &&
             (fldval != 0) ) {
            if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                        G_L3SW_CHANGE_L2_FIELDSf)) {
                int val;

                val = PolicyGet(unit, policy_mem, policy_entry,
                            G_L3SW_CHANGE_L2_FIELDSf);
                if ((SOC_IS_KATANA2(unit) && val == 0x5) ||
                    (SOC_IS_SABER2(unit) && val == 0x5) ||
                    (SOC_IS_TRIUMPH3(unit) && val == 0x8) ||
                    ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                    && val == 0x8)) {
                    param0 = fldval;
                    action = bcmFieldActionEgressClassSelect;
                    append = 1;
                    switch (param0) {
                        case 0x1:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_PORT;
                            break;
                        case 0x2:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_SVP;
                            break;
                        case 0x3:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_L3_IIF;
                            break;
                        case 0x4:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_SRC;
                            break;
                        case 0x5:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_DST;
                            break;
                        case 0x6:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_L2_SRC;
                            break;
                        case 0x7:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_L2_DST;
                            break;
                        case 0x8:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_L3_SRC;
                            break;
                        case 0x9:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_L3_DST;
                            break;
                        case 0xa:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_VLAN;
                            break;
                        case 0xb:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_VRF;
                            break;
                        case 0xf:
                            param0 = BCM_FIELD_EGRESS_CLASS_SELECT_NEW;
                            break;
                        default:
                            break;/* Do nothing */
                    }
                }
            }
        }
        break;
        case HG_CLASSID_SELf:
            /* HiGigClassSelect is overlayed with many other actions which set
               G_L3SW_CHANGE_L2_FIELDSf */
            if((fldval != 0) &&
                    (PolicyGet(unit, policy_mem,
                               policy_entry,G_L3SW_CHANGE_L2_FIELDSf) == 0)) {
                    param0 = fldval;
                    action = bcmFieldActionHiGigClassSelect;
                    append = 1;
                    switch (param0) {
                        case 0x1:
                            param0 = BCM_FIELD_HIGIG_CLASS_SELECT_EGRESS;
                            break;
                        case 0x2:
                            param0 = BCM_FIELD_HIGIG_CLASS_SELECT_EGR_NEXT_HOP;
                            break;
                        case 0x3:
                            param0 = BCM_FIELD_HIGIG_CLASS_SELECT_EGR_L3_INTERFACE;
                            break;
                        case 0x4:
                            param0 = BCM_FIELD_HIGIG_CLASS_SELECT_EGR_DVP;
                            break;
                        case 0x7:
                            param0 = BCM_FIELD_HIGIG_CLASS_SELECT_PORT;
                            break;
                        default:
                            break;/* Do nothing */
                    }
            }
            break;
        case I2E_CLASSIDf:
            if (((action_sync == 1) && SHR_BITGET(f_ent_wb_info->action_bmp->w,
                                _bcmFieldActionNoParamNewClassId)) ||
                 (fldval != 0)) {
                if(SOC_IS_KATANA2(unit)
                    || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
                   SOC_IS_SABER2(unit) || SOC_IS_TRIUMPH3(unit) ) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem,
                        G_L3SW_CHANGE_L2_FIELDSf)) {
                        int val;
                        val = PolicyGet(unit, policy_mem, policy_entry,
                                G_L3SW_CHANGE_L2_FIELDSf);
                        if ((SOC_IS_KATANA2(unit) && val == 0x5) ||
                            (SOC_IS_SABER2(unit) && val == 0x5) ||
                            (SOC_IS_TRIUMPH3(unit) && val == 0x8) ||
                            ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))
                                && val == 0x8)) {
                            action = bcmFieldActionNewClassId;
                            param0 = fldval;
                            append = 1;
                        }
                    }
                } else {
                    action = bcmFieldActionNewClassId;
                    param0 = fldval;
                    append = 1;
                }
            }
            break;
#endif /* BCM_KATANA2_SUPPORT */
    case ACTION_PRI_MODIFIERf:
        if (fldval != 0) {
 #if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)  || defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)
                   || SOC_IS_APACHE(unit)) {
                if(0 == PolicyGet(unit, policy_mem,
                                  policy_entry, SVC_METER_INDEX_PRIORITYf)) {
                    action = bcmFieldActionDoNotOverride;
                    append = 1;
                }
            } else if((SOC_IS_TD2_TT2(unit))) {
               action = bcmFieldActionDoNotOverride;
               append = 1;
            }
#endif
        }
        break;
    case CHANGE_INPUT_PRIORITYf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionPfcClassNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        NEW_INPUT_PRIORITYf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
    case G_CHANGE_INT_CNf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionGpIntCongestionNotificationNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        G_NEW_INT_CNf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
    case Y_CHANGE_INT_CNf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionYpIntCongestionNotificationNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        Y_NEW_INT_CNf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
    case R_CHANGE_INT_CNf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionRpIntCongestionNotificationNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        R_NEW_INT_CNf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_APACHE_SUPPORT)
    case R_CHANGE_REDIR_INT_PRIf:
            if  (fldval) {
                if (SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionRpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            R_NEW_REDIR_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_APACHE(unit)) {
                    action = bcmFieldActionRpRedirectPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            R_NEW_REDIR_INT_PRIf);
                    append = 1;
                }
            }
            break;
    case G_CHANGE_REDIR_INT_PRIf:
            if  (fldval) {
                if (SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionGpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            G_NEW_REDIR_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_APACHE(unit)) {
                    action = bcmFieldActionGpRedirectPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            G_NEW_REDIR_INT_PRIf);
                    append = 1;
                }
            }
            break;
    case Y_CHANGE_REDIR_INT_PRIf:
            if  (fldval) {
                if (SOC_IS_KATANA2(unit)) {
                    action = bcmFieldActionYpPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            Y_NEW_REDIR_INT_PRIf);
                    append = 1;
                } else if (SOC_IS_APACHE(unit)) {
                    action = bcmFieldActionYpRedirectPrioIntNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                            Y_NEW_REDIR_INT_PRIf);
                    append = 1;
                }
            }
            break;
#endif /* BCM_KATANA2_SUPPORT || BCM_APACHE_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
    case NEW_CPU_COSf:
            if  (fldval) {
                if (SOC_IS_APACHE(unit) &&
                        (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
                    action = bcmFieldActionCosQCpuNew;
                    param0 = fldval;
                    append = 1;
                }
            }
            break;
    case REDIR_STRENGTHf:
            if  (fldval) {
                if (SOC_IS_APACHE(unit)) {
                    action = bcmFieldActionStrength;
                    param0 = fldval;
                    append = 1;
                }
            }
            break;
    case REDIR_RDB_PRIORITYf:
            if  (fldval) {
                if (SOC_IS_APACHE(unit)) {
                    action = bcmFieldActionRedirectBufferPriority;
                    param0 = fldval;
                    append = 1;
                }
            }
            break;
    case LOOPBACKf:
            if  (fldval) {
                if (SOC_IS_APACHE(unit)) {
                    append = 1;
                    if (fldval == 0x1) {
                        action = bcmFieldActionLoopbackOamResponse;
                    } else if (fldval == 0x2) {
                        action = bcmFieldActionLoopbackSatResponse;
                    } else {
                        append = 0;
                    }
                }
            }
            break;
       case SESSION_ID_POOL_SELECTORf:
            if (SOC_IS_APACHE(unit) &&
                    f_ent_wb_info->action_StatObjSId_wb.valid) {
                f_ent_wb_info->action_StatObjSId_wb.valid = 0;
                append = 1;
                action = bcmFieldActionOamStatObjectSessionId;
                param0 = f_ent_wb_info->action_StatObjSId_wb.stat_object;
            }
            break;
       case COPY_TO_CPU_FIRST_CELL_ONLYf:
            if (fldval && f_ent_wb_info->action_copytocpu_wb.valid) {
                f_ent_wb_info->action_copytocpu_wb.params.flags |=
                    BCM_FIELD_COPYTOCPU_TRUNCATE;
            }
            break;
       case REDIR_FIRST_CELL_ONLYf:
            if (fldval && f_ent_wb_info->action_redir_wb.valid) {
                f_ent_wb_info->action_redir_wb.params.flags |=
                    BCM_FIELD_REDIRECT_TRUNCATE;
            }
            break;
       case REDIR_SOURCEf:
            if (fldval && f_ent_wb_info->action_redir_wb.valid) {
                uint32 redir = 0;
                if (fldval == 0x1) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_SOURCE_USE_ORIGINAL_DESTINATION;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_SOURCE_USE_ORIGINAL_SOURCE;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_SOURCE_USE_CONFIGURED;
                    redir = PolicyGet(unit, policy_mem, policy_entry,REDIR_SOURCE_VALUEf);
                    switch(f_ent_wb_info->action_redir_wb.params.source_port) {
                        case 1:
                            BCM_GPORT_MPLS_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        case 2:
                            BCM_GPORT_NIV_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        case 3:
                            BCM_GPORT_MIM_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        case 4:
                            BCM_GPORT_TRILL_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        case 5:
                            BCM_GPORT_L2GRE_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        case 6:
                            BCM_GPORT_VXLAN_PORT_ID_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    redir);
                            break;
                        default:
                            BCM_GPORT_MODPORT_SET(f_ent_wb_info->action_redir_wb.params.source_port,
                                    ((redir >> 8) & 0xff), (redir & 0xff));
                            break;
                    }
                }
            }
            break;
       case G_REDIRECTf:
            if (fldval && f_ent_wb_info->action_redir_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_GREEN_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_GREEN_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_GREEN_PACKET;
                }
            }
            break;
       case Y_REDIRECTf:
            if (fldval && f_ent_wb_info->action_redir_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_YELLOW_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_YELLOW_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_YELLOW_PACKET;
                }
            }
            break;
       case R_REDIRECTf:
            if (fldval && f_ent_wb_info->action_redir_wb.valid) {
                if (fldval == 0x1) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_RED_NOT_DROPPED_PACKET;
                } else if (fldval == 0x2) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_RED_DROPPED_PACKET;
                } else if (fldval == 0x3) {
                    f_ent_wb_info->action_redir_wb.params.flags |=
                        BCM_FIELD_REDIRECT_RED_PACKET;
                }
            }
            break;
       case REDIRECTION_DEST_TYPEf:
            if (fldval) {
                uint32 redir = 0;
                redir = PolicyGet(unit,
                                  policy_mem,
                                  policy_entry,
                                  REDIRECTION_DESTINATIONf
                                  );
                switch(fldval) {
                    case 0x4:
                        mirror_pbm = redir;
                        for (bit_pos = 1, mtp_index = 0;
                                mtp_index < BCM_MIRROR_MTP_COUNT;
                                ++mtp_index, bit_pos <<= 1) {
                            if (!(mirror_pbm & bit_pos)) {
                                /* Slot not in use => Skip */
                                continue;
                            }
                            /* Translate hw index into (module_num, port_num) */
                            _bcm_esw_mirror_mtp_to_modport(unit, mtp_index,
                                    TRUE, BCM_MIRROR_PORT_EGRESS_TRUE, &modid,
                                    &gport);
                            rv = _field_trx_actions_recover_action_add(unit,
                                    f_ent, bcmFieldActionMirrorEgress, -1,
                                    gport, 0, 0, 0, 0, mtp_index);
                            if (BCM_FAILURE(rv)) {
                                return rv;
                            }
                        }
                        break;
                    case 0x5:
                        param0 = (redir >> 8) & 0xff;
                        param1 = redir  & 0xff;
                        if (f_ent_wb_info->action_redir_wb.valid) {
                            f_ent_wb_info->action_redir_wb.params.destination_type =
                                bcmFieldRedirectDestinationPort;
                            BCM_GPORT_MODPORT_SET(
                                    f_ent_wb_info->action_redir_wb.params.destination,
                                    param0, param1);
                        } else {
                            action = bcmFieldActionRedirect;
                            append = 1;
                        }
                        break;
                    case 0x6:
                        param0 = redir & 0x1ff;
                        if (f_ent_wb_info->action_redir_wb.valid) {
                            f_ent_wb_info->action_redir_wb.params.destination_type =
                                bcmFieldRedirectDestinationTrunk;
                            if (f_ent_wb_info->action_redir_wb.valid == 0x1) {
                                BCM_GPORT_TRUNK_SET(
                                        f_ent_wb_info->action_redir_wb.params.destination,
                                        param0);
                            } else {
                                f_ent_wb_info->action_redir_wb.params.destination =  param0;
                            }
                        } else {
                            action = bcmFieldActionRedirectTrunk;
                            append = 1;
                        }
                        break;
                    case 0x7:
                        if (f_ent_wb_info->action_redir_wb.valid) {
                            f_ent_wb_info->action_redir_wb.params.destination_type =
                                bcmFieldRedirectDestinationMCast;
                            _BCM_MULTICAST_GROUP_SET(
                                    f_ent_wb_info->action_redir_wb.params.destination,
                                    _BCM_MULTICAST_TYPE_L2,
                                    redir & 0xfff);
                        } else {
                            action = bcmFieldActionRedirectMcast;
                            if (soc_feature(unit,
                                soc_feature_field_action_redirect_ipmc)) {
                                 param0 = redir & 0xfff;
                            } else {
                                hw_index = redir & 0xfff;
                            }
                            append = 1;
                        }
                        break;
                    default :
                        break;
                }
            }
            break;
#endif /* BCM_APACHE_SUPPORT */
#if !defined(BCM_GREYHOUND_SUPPORT) && !defined(BCM_TOMAHAWK_SUPPORT)
    case G_HG_CONGESTION_CLASS_CHANGEf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionGpHGCongestionClassNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        G_HG_CONGESTION_CLASS_NEWf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
    case Y_HG_CONGESTION_CLASS_CHANGEf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionYpHGCongestionClassNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        Y_HG_CONGESTION_CLASS_NEWf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
    case R_HG_CONGESTION_CLASS_CHANGEf:
            switch (fldval) {
                case 1:
                    action = bcmFieldActionRpHGCongestionClassNew;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                        R_HG_CONGESTION_CLASS_NEWf);
                    append = 1;
                    break;
                default:
                    break; /* Do nothing */
            }
            break;
#endif
#if defined BCM_TRIDENT2PLUS_SUPPORT
    case LM_COUNTER_POOL_ACTION_Af:
            /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidOam
             * for Trident2Plus */
            if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
                /* When NAT_OAM_ACTION_SELECTf is valid, automatically
                 * LM_COUNTER fields are also valid*/
                if(PolicyGet(unit, policy_mem, policy_entry,
                            NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidOam) {
                    break;
                }
            }
            if ((fldval == 0) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                break;
            }

            oam_action[0].flex_pool_id = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ID_Af);
            oam_action[0].action = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ACTION_Af);
            break;
    case LM_COUNTER_POOL_ACTION_Bf:
            /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidOam
             * for Trident2Plus */
            if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
                /* When NAT_OAM_ACTION_SELECTf is valid, automatically
                 * LM_COUNTER fields are also valid*/
                if(PolicyGet(unit, policy_mem, policy_entry,
                        NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidOam) {
                    break;
                }
            }
            if ((fldval == 0) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                break;
            }

            oam_action[1].flex_pool_id = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ID_Bf);
            oam_action[1].action = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ACTION_Bf);
            break;
    case LM_COUNTER_POOL_ACTION_Cf:
            /* NAT_OAM_ACTION_SELECTf = _bcmFieldNatOamValidOam
             * for Trident2Plus */
            if (SOC_MEM_FIELD_VALID(unit, policy_mem, NAT_OAM_ACTION_SELECTf)) {
                /* When NAT_OAM_ACTION_SELECTf is valid, automatically
                 * LM_COUNTER fields are also valid*/
                if(PolicyGet(unit, policy_mem, policy_entry,
                        NAT_OAM_ACTION_SELECTf) != _bcmFieldNatOamValidOam) {
                    break;
                }
            }
            if ((fldval == 0) &&
                    (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
                break;
            }

            oam_action[2].flex_pool_id = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ID_Cf);
            oam_action[2].action = PolicyGet(unit, policy_mem,
                    policy_entry, LM_COUNTER_POOL_ACTION_Cf);
            break;
#endif
    case INSTRUMENTATION_TRIGGERS_ENABLEf:
            if (fldval) {
                action = bcmFieldActionEgressPbmpNullCopyToCpu;
                param0 = PolicyGet(unit, policy_mem, policy_entry,
                        INSTRUMENTATION_TRIGGERS_ENABLEf);
                append = 1;
            }
            break;
        case PIM_BIDIR_FORWARDf:
            if (fldval) {
                action = bcmFieldActionPimBidirFwd;
                append = 1;
            }
            break;
        case TRUST_DSCPf:
#if defined BCM_TRIUMPH2_SUPPORT
            if (fldval) {
                if ((SOC_IS_KATANA2(unit))
                    || ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)))) {
                    if (SOC_MEM_FIELD_VALID(unit, policy_mem, TRUST_DSCP_PTRf)) {
                        action = bcmFieldActionDscpMapNew;
                        hw_index = PolicyGet(unit, policy_mem,
                                policy_entry, TRUST_DSCP_PTRf);
                        param0 = hw_index;
                        append = 1;

                        /* Allocate memory for dscp_map_new_eid_list */
                        _FP_XGS3_ALLOC (dscp_map_new_eid_node,
                                sizeof (_field_dscp_map_new_eid_list_t),
                                "dscp_map_new_eid_node");
                        if (NULL == dscp_map_new_eid_node) {
                            return BCM_E_MEMORY;
                        }

                        /* fill the node and add to the eid_list.
                         * list will be free in _bcm_notify_qos_reinit_to_fp
                         * function*/
                        dscp_map_new_eid_node->eid = f_ent->eid;
                        dscp_map_new_eid_node->next = NULL;

                        if ( dscp_map_new_eid_list[unit] != NULL) {
                            dscp_map_new_eid_node->next = dscp_map_new_eid_list[unit];
                        }
                        dscp_map_new_eid_list[unit] = dscp_map_new_eid_node;
                    }
                }
            }
#endif
            break;
#if defined (BCM_HURRICANE3_SUPPORT)
        case PFC_TRIGGERf:
            if (fldval) {
                    action = bcmFieldActionPfcTx;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                                       PFC_STREAM_IDf);
                    param1 = PolicyGet(unit, policy_mem, policy_entry,
                                       PFC_TCf);
                    append = 1;
                    break;
            }
            break;
        case ASSIGN_HEADER_ENCAP_FIELDSf:
            if (fldval) {
                if (!PolicyGet(unit, policy_mem, policy_entry, G_PACKET_REDIRECTIONf)) {
                    /* Custom Header Switch Encap */
                    action = bcmFieldActionSwitchEncap;
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                                       HEADER_ENCAP_INDEXf);
                    param0 |= (_BCM_SWITCH_ENCAP_TYPE_CUSTOM_HEADER <<
                                       _BCM_SWITCH_ENCAP_SHIFT);
                    append = 1;
                    break;
                }
            }
            break;
#endif /* BCM_HURRICANE3_SUPPORT */

#if defined (BCM_METROLITE_SUPPORT)
        case DA_SA_SWAPf:
            if (fldval) {
                action = bcmFieldActionSwapMacDaSa;
                append = 1;
            }
            break;
        case SIP_DIP_SWAPf:
            if (fldval) {
                action = bcmFieldActionSwapSourceIPDestIP;
                append = 1;
            }
            break;
        case REPLACE_TTLf:
            if (fldval) {
                action = bcmFieldActionReplaceTtl;
                append = 1;
            }
            break;
        case L3SATf:
            if (fldval) {
                action = bcmFieldActionPacketIsL3SAT;
                append = 1;
            }
            break;
#endif /* (BCM_METROLITE_SUPPORT) */

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
        case DO_NOT_CUT_THROUGHf:
            if (fldval) {
               action = bcmFieldActionDoNotCutThrough;
               append = 1;
            }
            break;
#endif /* BCM_TRIDENT2_SUPPORT || BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_GREYHOUND2_SUPPORT)
        case VXLAN_DECAPf:
            if (fldval) {
                if (soc_feature(unit, soc_feature_vxlan_lite)) {
                    action = bcmFieldActionVxlanTerminate;
                    append = 1;
                }
            }
            break;
        case IP_TUNNEL_TERMINATIONf:
            if (fldval) {
                if (soc_feature(unit, soc_feature_vxlan_lite)) {
                    param0 = PolicyGet(unit, policy_mem, policy_entry,
                                       IP_TUNNEL_TERMINATIONf);
                    action = bcmFieldActionUseTunnelPayload;
                    append = 1;
                }
            }
            break;
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined BCM_TOMAHAWK2_SUPPORT
        case CHANGE_EXPf:
            append = 0;
            if (fldval) {
                action = bcmFieldActionMplsLabel1ExpNew;
                param0 = PolicyGet(unit, policy_mem, policy_entry, EXPf);
                append = 1;
            }
            break;
#endif /* BCM_TOMAHAWK2_SUPPORT */

        default:
            break; /* Do nothing */
        }


        if (append) {
            rv = _field_trx_actions_recover_action_add(unit,
                                                       f_ent,
                                                       action,
                                                       param0,
                                                       param1,
                                                       param2,
                                                       param3,
                                                       param4,
                                                       param5,
                                                       hw_index
                                                       );
            if (BCM_FAILURE(rv)) {
                return rv;
            }
        }
    }
#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam) &&
            ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
             (SOC_IS_APACHE(unit) &&
              (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)))) {
        rv = _field_oam_stat_action_wb_add (unit, f_ent, oam_action);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
#if defined BCM_APACHE_SUPPORT
    rv = _field_apache_actions_recovery(unit, policy_mem, policy_entry,
            f_ent, f_ent_wb_info);
    if (BCM_FAILURE(rv)) {
        return rv;
    }
#endif /* BCM_APACHE_SUPPORT */

    return BCM_E_NONE;
}

STATIC int
_field_src_dst_entity_compare(_bcm_field_fwd_entity_sel_t entity1,
                              _bcm_field_fwd_entity_sel_t entity2)
{
    switch (entity1) {
    case _bcmFieldFwdEntityMplsGport:
    case _bcmFieldFwdEntityNivGport:
    case _bcmFieldFwdEntityCommonGport: /* For DstGport */
    case _bcmFieldFwdEntityMimGport:
    case _bcmFieldFwdEntityWlanGport:
    case _bcmFieldFwdEntityVxlanGport:
    case _bcmFieldFwdEntityVlanGport:
        if ((entity2 == _bcmFieldFwdEntityMplsGport) ||
            (entity2 == _bcmFieldFwdEntityNivGport) ||
            (entity2 == _bcmFieldFwdEntityCommonGport) ||
            (entity2 == _bcmFieldFwdEntityMimGport) ||
            (entity2 == _bcmFieldFwdEntityWlanGport) ||
            (entity2 == _bcmFieldFwdEntityVlanGport) ||
            (entity2 == _bcmFieldFwdEntityVxlanGport)) {
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    default:
        if (entity1 != entity2) {
            return FALSE;
        }
        break;
    }
    return TRUE;
}


int
_field_tr2_slice_key_control_entry_recover(int      unit,
                                           unsigned slice_num,
                                           _field_sel_t *sel
                                           )
{
    int                          rv;
    fp_slice_key_control_entry_t buf;

    sel->src_class_sel
        = sel->dst_class_sel
        = sel->intf_class_sel
        = sel->aux_tag_1_sel
        = sel->aux_tag_2_sel
        = _FP_SELCODE_DONT_CARE;

    if (!SOC_MEM_IS_VALID(unit, FP_SLICE_KEY_CONTROLm)) {
        return (BCM_E_NONE);
    }

    rv = soc_mem_read(unit,
                      FP_SLICE_KEY_CONTROLm,
                      MEM_BLOCK_ALL,
                      0,
                      buf.entry_data
                      );
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Get source class select field. */
    sel->src_class_sel = soc_mem_field32_get(unit,
                                             FP_SLICE_KEY_CONTROLm,
                                             buf.entry_data,
                                             _trx_src_class_id_sel[slice_num]
                                             );

    /* Get destination class select field. */
    sel->dst_class_sel = soc_mem_field32_get(unit,
                                             FP_SLICE_KEY_CONTROLm,
                                             buf.entry_data,
                                             _trx_dst_class_id_sel[slice_num]
                                             );
    sel->ttl_class_sel = soc_mem_field32_get(unit,
                                             FP_SLICE_KEY_CONTROLm,
                                             buf.entry_data,
                                             _trx_ttl_slice_control_enable_field[slice_num]
                                             );
    sel->tcp_class_sel = soc_mem_field32_get(unit,
                                             FP_SLICE_KEY_CONTROLm,
                                             buf.entry_data,
                                             _trx_tcp_slice_control_enable_field[slice_num]
                                             );
    sel->tos_class_sel = soc_mem_field32_get(unit,
                                             FP_SLICE_KEY_CONTROLm,
                                             buf.entry_data,
                                             _trx_tos_slice_control_enable_field[slice_num]
                                             );

    /* Get interface class select field. */
    sel->intf_class_sel = soc_mem_field32_get(
                              unit,
                              FP_SLICE_KEY_CONTROLm,
                              buf.entry_data,
                              _trx_interface_class_id_sel[slice_num]
                                              );

    sel->aux_tag_1_sel = soc_mem_field32_get_def(
                             unit,
                             FP_SLICE_KEY_CONTROLm,
                             buf.entry_data,
                             _bcm_trx2_aux_tag_1_field[slice_num],
                             _FP_SELCODE_DONT_CARE
                                                 );

    sel->aux_tag_2_sel = soc_mem_field32_get_def(
                             unit,
                             FP_SLICE_KEY_CONTROLm,
                             buf.entry_data,
                             _bcm_trx2_aux_tag_2_field[slice_num],
                             _FP_SELCODE_DONT_CARE
                                                 );

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        sel->oam_overlay_sel= soc_mem_field32_get_def(
                            unit,
                            FP_SLICE_KEY_CONTROLm,
                            buf.entry_data,
                            _bcm_td2plus_oam_overlay_field[slice_num],
                            _FP_SELCODE_DONT_CARE
                                                 );
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    return (BCM_E_NONE);
}

/* Allocate and initialize a group structure */

int
_field_tr2_group_construct_alloc(int unit, _field_group_t **pfg)
{
    _field_group_t *fg = 0;
    unsigned       i;

    _FP_XGS3_ALLOC(fg, sizeof(*fg), "field group");
    if (fg == 0) {
        return BCM_E_MEMORY;
    }

    for (i = 0; i < COUNTOF(fg->sel_codes); ++i) {
        _FIELD_SELCODE_CLEAR(fg->sel_codes[i]);
        fg->sel_codes[i].intraslice = _FP_SELCODE_DONT_USE;
    }
    _bcm_field_group_status_init(unit, &fg->group_status);
    fg->action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    for (i = 0; i < _FP_PAIR_MAX; i++) {
        fg->vmap_group[i] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    }

    *pfg = fg;

    return (BCM_E_NONE);
}

/* Add the given qualifier to the given group */

int
_field_trx_group_qual_add(_bcm_field_group_qual_t *grp_qual,
                          unsigned                 qid,
                          _bcm_field_qual_offset_t *qual_offset
                          )
{
    uint16                   *new_qid_arr;
    _bcm_field_qual_offset_t *new_qoffset_arr;
    unsigned                 new_size;

    new_size = grp_qual->size + 1;

    new_qid_arr = (uint16 *) sal_alloc(new_size * sizeof(grp_qual->qid_arr[0]),
                                       "Group qual id"
                                       );
    if (new_qid_arr == 0) {
        return (BCM_E_MEMORY);
    }

    new_qoffset_arr = (_bcm_field_qual_offset_t *)
        sal_alloc(new_size * sizeof(grp_qual->offset_arr[0]),
                  "Group qual offset");
    if (new_qoffset_arr == 0) {
        sal_free(new_qid_arr);

        return (BCM_E_MEMORY);
    }

    if (grp_qual->size != 0) {
        sal_memcpy(new_qid_arr,
                   grp_qual->qid_arr,
                   grp_qual->size * sizeof(grp_qual->qid_arr[0])
                   );
        sal_memcpy(new_qoffset_arr,
                   grp_qual->offset_arr,
                   grp_qual->size * sizeof(grp_qual->offset_arr[0])
                   );

        sal_free(grp_qual->qid_arr);
        sal_free(grp_qual->offset_arr);
    }

    new_qid_arr[new_size - 1]     = qid;
    new_qoffset_arr[new_size - 1] = *qual_offset;

    grp_qual->qid_arr    = new_qid_arr;
    grp_qual->offset_arr = new_qoffset_arr;
    grp_qual->size       = new_size;

    return (BCM_E_NONE);
}

STATIC int
_field_trx_wb_group_selcode_compare(int              unit,
                                    _field_group_t   *fg,
                                    _field_group_t   *new_fg
                                   )
{
    int           idx;
    int           parts_cnt;

    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
            fg->flags, &parts_cnt));

    for (idx = 0; idx < parts_cnt; idx++) {
        if ((new_fg->sel_codes[idx].fpf0 != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fpf0 != fg->sel_codes[idx].fpf0)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].fpf1 != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fpf1 != fg->sel_codes[idx].fpf1)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].fpf2 != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fpf2 != fg->sel_codes[idx].fpf2)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].fpf3 != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fpf3 != fg->sel_codes[idx].fpf3)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].fpf4 != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fpf4 != fg->sel_codes[idx].fpf4)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].extn != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].extn != fg->sel_codes[idx].extn)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].src_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].src_class_sel != fg->sel_codes[idx].src_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].dst_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].dst_class_sel != fg->sel_codes[idx].dst_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].intf_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].intf_class_sel != fg->sel_codes[idx].intf_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].ttl_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].ttl_class_sel != fg->sel_codes[idx].ttl_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].tcp_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].tcp_class_sel != fg->sel_codes[idx].tcp_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].tos_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].tos_class_sel != fg->sel_codes[idx].tos_class_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].ingress_entity_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].ingress_entity_sel != fg->sel_codes[idx].ingress_entity_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].src_entity_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].src_entity_sel != fg->sel_codes[idx].src_entity_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].dst_fwd_entity_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].dst_fwd_entity_sel != fg->sel_codes[idx].dst_fwd_entity_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].fwd_field_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].fwd_field_sel != fg->sel_codes[idx].fwd_field_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].loopback_type_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].loopback_type_sel != fg->sel_codes[idx].loopback_type_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].ip_header_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].ip_header_sel != fg->sel_codes[idx].ip_header_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].ip6_addr_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].ip6_addr_sel != fg->sel_codes[idx].ip6_addr_sel)) {
            return BCM_E_INTERNAL;
        }

#if 0  /* Not required, since group is created with appropriate mode */
        if ((new_fg->sel_codes[idx].intraslice != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].intraslice != fg->sel_codes[idx].intraslice)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].secondary != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].secondary != fg->sel_codes[idx].secondary)) {
            return BCM_E_INTERNAL;
        }
#endif

        if ((new_fg->sel_codes[idx].inner_vlan_overlay != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].inner_vlan_overlay != fg->sel_codes[idx].inner_vlan_overlay)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].intraslice_vfp_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].intraslice_vfp_sel != fg->sel_codes[idx].intraslice_vfp_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].aux_tag_1_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].aux_tag_1_sel != fg->sel_codes[idx].aux_tag_1_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].aux_tag_2_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].aux_tag_2_sel != fg->sel_codes[idx].aux_tag_2_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].oam_overlay_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].oam_overlay_sel != fg->sel_codes[idx].oam_overlay_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].normalize_ip_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].normalize_ip_sel != fg->sel_codes[idx].normalize_ip_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].normalize_mac_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].normalize_mac_sel != fg->sel_codes[idx].normalize_mac_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f1_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f1_sel != fg->sel_codes[idx].egr_class_f1_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f2_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f2_sel != fg->sel_codes[idx].egr_class_f2_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f3_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f3_sel != fg->sel_codes[idx].egr_class_f3_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f4_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f4_sel != fg->sel_codes[idx].egr_class_f4_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f6_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f6_sel != fg->sel_codes[idx].egr_class_f6_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f7_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f7_sel != fg->sel_codes[idx].egr_class_f7_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_class_f8_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_class_f8_sel != fg->sel_codes[idx].egr_class_f8_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].src_dest_class_f1_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].src_dest_class_f1_sel != fg->sel_codes[idx].src_dest_class_f1_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].src_dest_class_f3_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].src_dest_class_f3_sel != fg->sel_codes[idx].src_dest_class_f3_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].src_type_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].src_type_sel != fg->sel_codes[idx].src_type_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_key4_dvp_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_key4_dvp_sel != fg->sel_codes[idx].egr_key4_dvp_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_key8_dvp_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_key8_dvp_sel != fg->sel_codes[idx].egr_key8_dvp_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_dest_port_f1_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_dest_port_f1_sel != fg->sel_codes[idx].egr_dest_port_f1_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_dest_port_f5_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_dest_port_f5_sel != fg->sel_codes[idx].egr_dest_port_f5_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_key4_mdl_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_key4_mdl_sel != fg->sel_codes[idx].egr_key4_mdl_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].egr_oam_overlay_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].egr_oam_overlay_sel != fg->sel_codes[idx].egr_oam_overlay_sel)) {
            return BCM_E_INTERNAL;
        }
        if ((new_fg->sel_codes[idx].oam_intf_class_sel != _FP_SELCODE_DONT_CARE) &&
                (new_fg->sel_codes[idx].oam_intf_class_sel != fg->sel_codes[idx].oam_intf_class_sel)) {
            return BCM_E_INTERNAL;
        }
    }
    return BCM_E_NONE;
}

/* Recover qualifiers offset for the given group
 * based the dummy group create using group qset and entry type
 * Dummy group selcodes are compared with HW recovered selcodes
 * before copying the qualifier offset
 */

int
_field_trx_group_construct_quals_add(int              unit,
                                     _field_control_t *fc,
                                     _field_group_t   *fg,
                                     uint8            fg_entry_type,
                                     bcm_field_qset_t *new_qset,
                                     int8             pri_key1,
                                     int8             pri_key2
                                     )
{
    _field_group_t      new_fg;
    bcm_field_qset_t    group_qset;
    int                 idx;        /* Generic iteration index.       */
    int                 rv = BCM_E_NONE;
    uint8               entry_type;

    if (!fc->l2warm) {
        return BCM_E_INTERNAL;
    }

    if ((fg_entry_type == _FP_ENTRY_TYPE_1) &&
            (new_qset == NULL)) {
        return BCM_E_INTERNAL;
    }

    /* Qualifier offset recovery based on group create
     * is restricted to IFP, VFP & EFP */
    if ((fg->stage_id != _BCM_FIELD_STAGE_INGRESS) &&
            (fg->stage_id != _BCM_FIELD_STAGE_LOOKUP) &&
            (fg->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_INTERNAL;
    }

    /* EFP stage group recovery based on dummy group create
     * for only new device which have
     * soc_feature_fp_qual_recovery_with_group_create enabled.
     * For older devices fallback to old approach for qual recovery.
     */
    if (!soc_feature(unit, soc_feature_fp_qual_recovery_with_group_create) &&
            (fg->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_INTERNAL;
    }

    sal_memset(&new_fg, 0, sizeof(_field_group_t));
    new_fg.flags = fg->flags & _FP_GROUP_SPAN_MASK;
    new_fg.stage_id = fg->stage_id;

    BCM_FIELD_QSET_INIT(group_qset);
    group_qset = fg->qset;

    /* Clear the group's slice Qsets.  */
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        _FIELD_SELCODE_CLEAR(new_fg.sel_codes[idx]);
    }

    /* For EFP Copy KEY's from recovered group */
    if (fg->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        if (fg_entry_type == _FP_ENTRY_TYPE_1) {
            /* Create dummy group with primary key and compare selcodes
             * if primary selcodes match, then proceed with secondary key's.
             * Dummy group create with primary key is required
             * since secondary key should have the same secondary
             * selectors as that of primary key.
             */
            new_fg.sel_codes[0].fpf3 = pri_key1;
            if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                new_fg.sel_codes[1].fpf3 = pri_key2;
            }

            rv = _field_selcode_assign(unit, group_qset, 0, &new_fg);
            if (BCM_SUCCESS(rv)) {
                new_fg.sel_codes[0].fpf3 = fg->sel_codes[0].fpf3;
                if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                    new_fg.sel_codes[1].fpf3 = fg->sel_codes[1].fpf3;
                }
                rv = _field_trx_wb_group_selcode_compare(unit, fg, &new_fg);
            }


            /* Free memory allocated for qualifier offset during group create */
            for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
                BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&new_fg, idx));
            }

            /* Update Qset as per the secondary key */
            group_qset = *new_qset;
        } else {
            new_fg.sel_codes[0].fpf3 = fg->sel_codes[0].fpf3;
            if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                new_fg.sel_codes[1].fpf3 = fg->sel_codes[1].fpf3;
            }
        }
    }

    if (BCM_SUCCESS(rv)) {
        /* Dummy group create to compare selcodes and copy qualifier offsets */
        rv = _field_selcode_assign(unit, group_qset, 0, &new_fg);

        if (BCM_SUCCESS(rv)) {
            rv = _field_trx_wb_group_selcode_compare(unit, fg, &new_fg);
        }
    }

    if (BCM_SUCCESS(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) Qualifier offset recovery based"
                            "on group create approach for stage id %d "
                            "group id %d type %d group flags %d\n"), unit,
                 fg->stage_id, fg->gid, fg_entry_type, new_fg.flags));
        /* Copy Qualifier offsets */
        for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
            for (entry_type = 0; entry_type < _FP_MAX_ENTRY_TYPES; entry_type++) {
                if (entry_type == 0) {
                    fg->qual_arr[fg_entry_type][idx] = new_fg.qual_arr[entry_type][idx];
                    new_fg.qual_arr[entry_type][idx].qid_arr = NULL;
                    new_fg.qual_arr[entry_type][idx].offset_arr = NULL;
                    new_fg.qual_arr[entry_type][idx].size = 0;
                }
            }
        }
    } else {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) Qualifier offset recovery based"
                            " on HW based selcodes approach for stage id %d "
                            "group id %d type %d group flags %d\n"), unit,
                    fg->stage_id, fg->gid, fg_entry_type, new_fg.flags));
    }

    /* Clear memory allocated for qual offset in dummy group */
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&new_fg, idx));
    }

    return rv;
}

 /* Recover all qualifiers for the given group, based on its selector codes */

STATIC int
_field_tr2_group_construct_quals_add(int              unit,
                                     _field_control_t *fc,
                                     _field_stage_t   *stage_fc,
                                     _field_group_t   *fg
                                     )
{
    int rv;
    int parts_cnt, part_idx, sel_idx;
    uint8 e_type = _FP_ENTRY_TYPE_DEFAULT;
    _field_sel_t           temp_sel_codes[_FP_MAX_ENTRY_WIDTH];
    uint8 intraslice = 0;

    if (fc->l2warm) {
        rv = _field_trx_group_construct_quals_add(unit, fc, fg, e_type,
                                                  NULL, -1, -1);
        if (BCM_SUCCESS(rv)) {
            return rv;
        }
    }

    rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                           fg->flags, &parts_cnt);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
        intraslice = 1;
    }

    for (part_idx = 0; part_idx < parts_cnt; ++part_idx) {
        _bcm_field_group_qual_t *grp_qual = &fg->qual_arr[e_type][part_idx];
        unsigned qid;

        for (qid = 0; qid < _bcmFieldQualifyCount; ++qid) {
            _bcm_field_qual_info_t *f_qual_arr = stage_fc->f_qual_arr[qid];
            unsigned               j;
            uint8                  diff_cnt;

            if (f_qual_arr == NULL) {
                continue; /* Qualifier does not exist in this stage */
            }

            if (fc->l2warm && !BCM_FIELD_QSET_TEST(fg->qset, qid)) {
                continue; /* Qualifier not present in the group */
            }

            /* Add all of the stage's qualifiers that match the recovered
               selector codes.  Qualifiers that appear more than once
               (because more than one configuration of a qualifier matches
               the recovered selector codes) will be cleaned up later.
            */

            for (j = 0; j < f_qual_arr->conf_sz; j++) {
                if (_field_selector_diff(unit,
                                         fg->sel_codes,
                                         part_idx,
                                         &f_qual_arr->conf_arr[j].selector,
                                         &diff_cnt
                                         )
                    != BCM_E_NONE
                    || diff_cnt != 0
                   ) {
                    if (fc->l2warm && (qid == _bcmFieldQualifyRangeCheckBits24_31) &&
                            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyRangeCheck) &&
                            (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {

                        for (sel_idx = 0 ; sel_idx < _FP_MAX_ENTRY_WIDTH ; sel_idx++) {
                            temp_sel_codes[sel_idx] = fg->sel_codes[sel_idx];
                        }

                        /* Update secondary selector in sel codes */
                        /* Primary slice */
                        if ((part_idx == 0)  && (temp_sel_codes[0].fpf3 == 7)) {
                            if (temp_sel_codes[0].intf_class_sel != 3) {
                                temp_sel_codes[0].intf_class_sel = 3;
                            }
                        } else if (part_idx == 1) {
                            /* Intraslice */
                            if (intraslice && (temp_sel_codes[1].fpf2 == 0)) {
                                if (temp_sel_codes[0].intf_class_sel != 3) {
                                    temp_sel_codes[0].intf_class_sel = 3;
                                }
                            } else if ((!intraslice) && (temp_sel_codes[1].fpf3 == 7)) {
                                /* Secondary slice */
                                if (temp_sel_codes[1].intf_class_sel != 3) {
                                    temp_sel_codes[1].intf_class_sel = 3;
                                }
                            }
                        } else if ((part_idx == 2)  && (temp_sel_codes[2].fpf3 == 7)) {
                            if (temp_sel_codes[2].intf_class_sel != 3) {
                                temp_sel_codes[2].intf_class_sel = 3;
                            }
                        } else if ((part_idx == 3)  && (temp_sel_codes[3].fpf2 == 0)) {
                            if (temp_sel_codes[2].intf_class_sel != 3) {
                                temp_sel_codes[2].intf_class_sel = 3;
                            }
                        }

                        if (_field_selector_diff(unit,
                                    temp_sel_codes,
                                    part_idx,
                                    &f_qual_arr->conf_arr[j].selector,
                                    &diff_cnt
                                    )
                                != BCM_E_NONE
                                || diff_cnt != 0
                           ) {
                            continue;
                        }
                    } else {
                        continue;
                    }
                }

                if (!fc->l2warm) {
                    BCM_FIELD_QSET_ADD(fg->qset, qid);
                }

                _field_trx_group_qual_add(grp_qual,
                                          qid,
                                          &f_qual_arr->conf_arr[j].offset
                                          );

                _field_qset_udf_bmap_reinit(unit,
                                            stage_fc,
                                            &fg->qset,
                                            qid
                                            );
            }
        }
    }

    return (BCM_E_NONE);
}


int
_field_tr2_group_construct(int                   unit,
                           int                   inst,
                           _field_hw_qual_info_t *hw_sel,
                           int                   intraslice,
                           int                   paired,
                           _field_control_t      *fc,
                           bcm_port_t            port,
                           _field_stage_id_t     stage_id,
                           int                   slice_idx
                           )
{
    int rv = BCM_E_NONE;
    _field_group_t *fg_ptr = fc->groups;
    bcm_field_group_t gid;
    int               priority;
    int               group_flags = 0;
    _field_stage_t *stage_fc;
    bcm_field_qset_t qset;
    bcm_pbmp_t all_pbmp;
    bcm_pbmp_t group_pbmp;
    int action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

    bcm_field_qset_t_init(&qset);

    /* Get the stage control structure */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, stage_id, &stage_fc));
    SOC_PBMP_CLEAR(group_pbmp);

    /* Iterate over groups and compare all selectors */
    fg_ptr = fc->groups;
    while (fg_ptr != NULL) {
        if (intraslice && !(fg_ptr->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            fg_ptr = fg_ptr->next;
            continue;
        }
        if (!intraslice && (fg_ptr->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            fg_ptr = fg_ptr->next;
            continue;
        }
        if (paired && (fg_ptr->flags & _FP_GROUP_SPAN_SINGLE_SLICE)) {
            fg_ptr = fg_ptr->next;
            continue;
        }
        if (!paired && (fg_ptr->flags & _FP_GROUP_SPAN_DOUBLE_SLICE)) {
            fg_ptr = fg_ptr->next;
            continue;
        }

        /*
         * Check for the given instance and primary slice numbers, there may be
         * groups with the same QSET but residing in different slices.
         */
        if ((inst != fg_ptr->instance) ||
            (slice_idx != fg_ptr->slices[0].slice_number)) {
            fg_ptr = fg_ptr->next;
            continue;
        }

        /* Compare primary slice selectors */
        if ((fg_ptr->sel_codes[0].fpf1 != hw_sel->pri_slice[0].fpf1) ||
            (fg_ptr->sel_codes[0].fpf2 != hw_sel->pri_slice[0].fpf2) ||
            (fg_ptr->sel_codes[0].fpf3 != hw_sel->pri_slice[0].fpf3) ||
            (fg_ptr->sel_codes[0].fpf4 != hw_sel->pri_slice[0].fpf4) ||
            (!_field_src_dst_entity_compare(fg_ptr->sel_codes[0].src_entity_sel,
                                        hw_sel->pri_slice[0].src_entity_sel)) ||
            (!_field_src_dst_entity_compare
                                   (fg_ptr->sel_codes[0].ingress_entity_sel,
                                    hw_sel->pri_slice[0].ingress_entity_sel)) ||
            (!_field_src_dst_entity_compare
                                    (fg_ptr->sel_codes[0].dst_fwd_entity_sel,
                                    hw_sel->pri_slice[0].dst_fwd_entity_sel
                                     )
             ) ||
            (fg_ptr->sel_codes[0].aux_tag_1_sel != hw_sel->pri_slice[0].aux_tag_1_sel) ||
            (fg_ptr->sel_codes[0].aux_tag_2_sel != hw_sel->pri_slice[0].aux_tag_2_sel)
            || ((SOC_IS_TRIUMPH2(unit)
                || SOC_IS_APOLLO(unit)
                || SOC_IS_VALKYRIE2(unit)
                || SOC_IS_TRIUMPH3(unit)
                || SOC_IS_ENDURO(unit)
                || SOC_IS_KATANAX(unit))
                && (fg_ptr->sel_codes[0].loopback_type_sel
                != hw_sel->pri_slice[0].loopback_type_sel))) {
            fg_ptr = fg_ptr->next;
            continue;
        }
        if (intraslice
            && (fg_ptr->sel_codes[1].fpf2 != hw_sel->pri_slice[1].fpf2
                || fg_ptr->sel_codes[1].fpf4 != hw_sel->pri_slice[1].fpf4
                || !_field_src_dst_entity_compare
                       (fg_ptr->sel_codes[1].dst_fwd_entity_sel,
                        hw_sel->pri_slice[1].dst_fwd_entity_sel)
                )
            ) {
            fg_ptr = fg_ptr->next;
            continue;
        }
        /* Compare second and third slice config if mode is paired and intraslice**/
        if (paired && intraslice) {
            if ((fg_ptr->sel_codes[2].fpf1 != hw_sel->sec_slice[0].fpf1) ||
                (fg_ptr->sel_codes[2].fpf2 != hw_sel->sec_slice[0].fpf2) ||
                (fg_ptr->sel_codes[2].fpf3 != hw_sel->sec_slice[0].fpf3) ||
                (fg_ptr->sel_codes[2].fpf4 != hw_sel->sec_slice[0].fpf4) ||
                (!_field_src_dst_entity_compare
                                   (fg_ptr->sel_codes[2].src_entity_sel,
                                    hw_sel->sec_slice[0].src_entity_sel)) ||
                (!_field_src_dst_entity_compare
                                   (fg_ptr->sel_codes[2].ingress_entity_sel,
                                    hw_sel->sec_slice[0].ingress_entity_sel)) ||
                (!_field_src_dst_entity_compare
                                   (fg_ptr->sel_codes[2].dst_fwd_entity_sel,
                                hw_sel->sec_slice[0].dst_fwd_entity_sel
                                    )
                 ) ||
                (fg_ptr->sel_codes[2].aux_tag_1_sel != hw_sel->sec_slice[0].aux_tag_1_sel) ||
                (fg_ptr->sel_codes[2].aux_tag_2_sel != hw_sel->sec_slice[0].aux_tag_2_sel)
                ) {
                fg_ptr = fg_ptr->next;
                continue;
            }
            if (fg_ptr->sel_codes[3].fpf2 != hw_sel->sec_slice[1].fpf2
                    || fg_ptr->sel_codes[3].fpf4 != hw_sel->sec_slice[1].fpf4
                    || !_field_src_dst_entity_compare
                                     (fg_ptr->sel_codes[3].dst_fwd_entity_sel,
                                      hw_sel->sec_slice[1].dst_fwd_entity_sel)
                ) {
                fg_ptr = fg_ptr->next;
                continue;
            }
        }

        /* Compare secondary slice if paired */
        if (paired && !intraslice) {
            if ((fg_ptr->sel_codes[1].fpf1 != hw_sel->sec_slice[0].fpf1) ||
                (fg_ptr->sel_codes[1].fpf2 != hw_sel->sec_slice[0].fpf2) ||
                (fg_ptr->sel_codes[1].fpf3 != hw_sel->sec_slice[0].fpf3) ||
                (fg_ptr->sel_codes[1].fpf4 != hw_sel->sec_slice[0].fpf4) ||
                (!_field_src_dst_entity_compare
                                    (fg_ptr->sel_codes[1].src_entity_sel,
                                    hw_sel->sec_slice[0].src_entity_sel)) ||
                (!_field_src_dst_entity_compare
                                    (fg_ptr->sel_codes[1].ingress_entity_sel,
                                    hw_sel->sec_slice[0].ingress_entity_sel)) ||
                (!_field_src_dst_entity_compare
                                   (fg_ptr->sel_codes[1].dst_fwd_entity_sel,
                                hw_sel->sec_slice[0].dst_fwd_entity_sel)) ||
                (fg_ptr->sel_codes[1].aux_tag_1_sel != hw_sel->sec_slice[0].aux_tag_1_sel) ||
                (fg_ptr->sel_codes[1].aux_tag_2_sel != hw_sel->sec_slice[0].aux_tag_2_sel)
                ) {
                fg_ptr = fg_ptr->next;
                continue;
            }
        }

        if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_21) {
            /* Found a match - add port to group pbmp */
            BCM_PBMP_PORT_ADD(fg_ptr->pbmp, port);
            BCM_PBMP_OR(fg_ptr->slices[0].pbmp, fg_ptr->pbmp);
            if (1 == paired) {
                BCM_PBMP_OR(fg_ptr->slices[1].pbmp, fg_ptr->pbmp);
            }
        }

        if (fc->l2warm) {
            /* Get stored group ID and QSET for Level 2 */
            BCM_IF_ERROR_RETURN
                (_field_group_info_retrieve(unit, port, inst,
                                            &gid, &priority,
                                            &action_res_id,
                                            &group_pbmp,
                                            NULL,
                                            &group_flags,
                                            &qset,
                                            fc
                                            )
                 );
            if (gid != -1) {
                sal_memcpy(&fg_ptr->qset, &qset, sizeof(bcm_field_qset_t));
                fg_ptr->gid      = gid;
                fg_ptr->priority = priority;
                fg_ptr->action_res_id = action_res_id;
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_21) {
                    SOC_PBMP_ASSIGN(fg_ptr->pbmp, group_pbmp);
                }
                fg_ptr->instance = inst;
                if (group_flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
                    fg_ptr->flags = fg_ptr->flags |
                                        _FP_GROUP_SELECT_AUTO_EXPANSION;
                }

                /* Recover group qualifiers based on selector codes */
                _field_tr2_group_construct_quals_add(unit,
                                             fc,
                                             stage_fc,
                                             fg_ptr
                                             );
            }
        }
        break;
    }
    if (fg_ptr == NULL) {
        /* No match - create a new group and populate the group structure */

        rv = _field_tr2_group_construct_alloc(unit, &fg_ptr);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }

        /* Initialize action res id and VMAP group to default */
        action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

        if (fc->l2warm) {
            /* Get stored group ID and QSET for Level 2 */
            rv = _field_group_info_retrieve(unit, port, inst,
                                            &gid, &priority,
                                            &action_res_id,
                                            &group_pbmp,
                                            NULL,
                                            &group_flags,
                                            &qset,
                                            fc);
            if (gid != -1) {
                sal_memcpy(&fg_ptr->qset, &qset, sizeof(bcm_field_qset_t));
            } else {
                sal_free(fg_ptr);
                return rv;
            }
        } else {
            /* Generate group ID (a ++ operation) for Level 1 */

            unsigned vmap, vslice;

            rv = _bcm_field_group_id_generate(unit, &gid);

            if (BCM_SUCCESS(rv)) {
                for (priority = -1, vmap = 0; priority == -1 && vmap < _FP_VMAP_CNT; ++vmap) {
                    for (vslice = 0; vslice < COUNTOF(stage_fc->vmap[inst][0]); ++vslice) {
                        if (stage_fc->vmap[inst][vmap][vslice].vmap_key == slice_idx) {
                            priority = stage_fc->vmap[inst][vmap][vslice].priority;

                            break;
                        }
                    }
                }

                if (priority == -1) {
                    rv = BCM_E_INTERNAL;
                }
            }
        }
        if (BCM_FAILURE(rv)) {
            sal_free(fg_ptr);
            return rv;
        }

        fg_ptr->gid      = gid;
        fg_ptr->priority = priority;
        fg_ptr->action_res_id = action_res_id;
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_21) {
            SOC_PBMP_ASSIGN(fg_ptr->pbmp, group_pbmp);
        }
        fg_ptr->stage_id = stage_id;
        fg_ptr->instance = inst;
        if (group_flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
            fg_ptr->flags = fg_ptr->flags | _FP_GROUP_SELECT_AUTO_EXPANSION;
        }

        /* Set group's selector codes to those recovered from hardware */
        fg_ptr->sel_codes[0] = hw_sel->pri_slice[0];
        if (paired && intraslice) {
            /* 4 parts */
            fg_ptr->sel_codes[1] = hw_sel->pri_slice[1];
            fg_ptr->sel_codes[2] = hw_sel->sec_slice[0];
            fg_ptr->sel_codes[3] = hw_sel->sec_slice[1];
        } else if (paired && !intraslice) {
            /* 2 parts */
            fg_ptr->sel_codes[1] = hw_sel->sec_slice[0];
        } else if (!paired && intraslice) {
            /* 2 parts */
            fg_ptr->sel_codes[1] = hw_sel->pri_slice[1];
        }

        /* Refine selector codes, if possible */
        if (fc->l2warm) {
            /* Refine VP selectors only if it's used in hardware. */
            if (hw_sel->pri_slice[0].dst_fwd_entity_sel
                == _bcmFieldFwdEntityMimGport) {
                if ((BCM_FIELD_QSET_TEST (fg_ptr->qset,
                             bcmFieldQualifyDstMplsGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstMplsGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityMplsGport;
                } else if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstNivGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstNivGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityNivGport;
                } else if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstGport)) ||
                         (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityCommonGport;
                } else if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstMimGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstMimGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityMimGport;
                } else if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstWlanGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstWlanGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityWlanGport;
                } else if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstVlanGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                            bcmFieldQualifyDstVlanGports))) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel
                        = _bcmFieldFwdEntityVlanGport;
                }
            }

            if (_BCM_FIELD_STAGE_LOOKUP == stage_id) {

                /* primary part */
                switch(hw_sel->pri_slice[0].src_entity_sel)
                {
                    case 4:
                        fg_ptr->sel_codes[0].src_entity_sel =
                                             _bcmFieldFwdEntityPortGroupNum;
                        break;
                    case 3:
                        fg_ptr->sel_codes[0].src_entity_sel =
                                             _bcmFieldFwdEntityMplsGport;
                        break;
                    case 2:
                        fg_ptr->sel_codes[0].src_entity_sel =
                                             _bcmFieldFwdEntityModPortGport;
                        break;
                    case 1:
                        fg_ptr->sel_codes[0].src_entity_sel =
                                             _bcmFieldFwdEntityGlp;
                        break;
                    default:
                        fg_ptr->sel_codes[0].src_entity_sel =
                                             _FP_SELCODE_DONT_CARE;
                        break;
                }

               if (intraslice) {

                   switch(hw_sel->pri_slice[1].src_entity_sel)
                   {
                        case 4:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityPortGroupNum;
                            break;
                        case 3:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityMplsGport;
                            break;
                        case 2:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityModPortGport;
                            break;
                        case 1:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityGlp;
                            break;
                        default:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _FP_SELCODE_DONT_CARE;
                            break;
                   }
               }

               if (paired && (!intraslice)) {
                   switch(hw_sel->sec_slice[0].src_entity_sel)
                   {
                        case 4:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityPortGroupNum;
                            break;
                        case 3:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityMplsGport;
                            break;
                        case 2:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityModPortGport;
                            break;
                        case 1:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _bcmFieldFwdEntityGlp;
                            break;
                        default:
                            fg_ptr->sel_codes[1].src_entity_sel =
                                                 _FP_SELCODE_DONT_CARE;
                            break;
                  }
              }

              if (paired && intraslice) {
                   switch(hw_sel->sec_slice[0].src_entity_sel)
                   {
                        case 4:
                            fg_ptr->sel_codes[2].src_entity_sel =
                                                 _bcmFieldFwdEntityPortGroupNum;
                            break;
                        case 3:
                            fg_ptr->sel_codes[2].src_entity_sel =
                                                 _bcmFieldFwdEntityMplsGport;
                            break;
                        case 2:
                            fg_ptr->sel_codes[2].src_entity_sel =
                                                 _bcmFieldFwdEntityModPortGport;
                            break;
                        case 1:
                            fg_ptr->sel_codes[2].src_entity_sel =
                                                 _bcmFieldFwdEntityGlp;
                            break;
                        default:
                            fg_ptr->sel_codes[2].src_entity_sel =
                                                 _FP_SELCODE_DONT_CARE;
                            break;
                  }

                  switch(hw_sel->sec_slice[1].src_entity_sel)
                   {
                        case 4:
                            fg_ptr->sel_codes[3].src_entity_sel =
                                                 _bcmFieldFwdEntityPortGroupNum;
                            break;
                        case 3:
                            fg_ptr->sel_codes[3].src_entity_sel =
                                                 _bcmFieldFwdEntityMplsGport;
                            break;
                        case 2:
                            fg_ptr->sel_codes[3].src_entity_sel =
                                                 _bcmFieldFwdEntityModPortGport;
                            break;
                        case 1:
                            fg_ptr->sel_codes[3].src_entity_sel =
                                                 _bcmFieldFwdEntityGlp;
                            break;
                        default:
                            fg_ptr->sel_codes[3].src_entity_sel =
                                                 _FP_SELCODE_DONT_CARE;
                            break;
                  }

              }

            }

            if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                    bcmFieldQualifySrcMplsGport)) ||
                (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                      bcmFieldQualifySrcMplsGports))) {
                if (_FP_SELCODE_DONT_CARE
                    != fg_ptr->sel_codes[0].ingress_entity_sel) {
                    fg_ptr->sel_codes[0].ingress_entity_sel =
                                           _bcmFieldFwdEntityMplsGport;
                } else if (_bcmFieldFwdEntityAny
                    != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                                           _bcmFieldFwdEntityMplsGport;
                }
            } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifySrcNivGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifySrcNivGports))) {
                if (_FP_SELCODE_DONT_CARE
                    != fg_ptr->sel_codes[0].ingress_entity_sel) {
                    fg_ptr->sel_codes[0].ingress_entity_sel =
                                           _bcmFieldFwdEntityNivGport;
                } else if (_bcmFieldFwdEntityAny
                    != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                                           _bcmFieldFwdEntityNivGport;
                }
            } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifySrcMimGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifySrcMimGports))) {
                if (_FP_SELCODE_DONT_CARE
                    != fg_ptr->sel_codes[0].ingress_entity_sel) {
                    fg_ptr->sel_codes[0].ingress_entity_sel =
                                           _bcmFieldFwdEntityMimGport;
                } else if (_bcmFieldFwdEntityAny
                    != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                                           _bcmFieldFwdEntityMimGport;
                }
            } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifySrcWlanGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifySrcWlanGports))) {
                if (_bcmFieldFwdEntityAny
                    != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                                           _bcmFieldFwdEntityWlanGport;
                }
            } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifySrcVlanGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifySrcVlanGports))) {
                if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[0].ingress_entity_sel) {
                    fg_ptr->sel_codes[0].ingress_entity_sel =
                        _bcmFieldFwdEntityVlanGport;
                } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                        _bcmFieldFwdEntityVlanGport;
                }
            } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                            bcmFieldQualifyInPort) ||
                        BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                            bcmFieldQualifyInterfaceClassPort))
                       && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {
                /* Only for VFP. IFP uses IPBM for InPort */
                if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[0].src_entity_sel) {
                    fg_ptr->sel_codes[0].src_entity_sel =
                                           _bcmFieldFwdEntityPortGroupNum;
                }
            }

            if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                     bcmFieldQualifySrcVxlanGport)) ||
                (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                     bcmFieldQualifySrcVxlanGports))) {
                if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[0].ingress_entity_sel) {
                    fg_ptr->sel_codes[0].ingress_entity_sel =
                                     _bcmFieldFwdEntityVxlanGport;
                }
            }

            if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                     bcmFieldQualifyDstVxlanGport)) ||
                (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                     bcmFieldQualifyDstVxlanGports))) {
                if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[0].dst_fwd_entity_sel) {
                    fg_ptr->sel_codes[0].dst_fwd_entity_sel =
                                     _bcmFieldFwdEntityVxlanGport;
                }
            }

            /* If vpn qualifier is part of the qset, update the field group
               selector */
            if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVpn)) {
                if (_bcmFieldFwdFieldAny
                        != fg_ptr->sel_codes[0].fwd_field_sel) {
                    fg_ptr->sel_codes[0].fwd_field_sel = _bcmFieldFwdFieldVpn;
                }
            }

            /* If vrf qualifier is part of the qset, update the field group
               selector */
            if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVrf)) {
                if (_bcmFieldFwdFieldAny
                        != fg_ptr->sel_codes[0].fwd_field_sel) {
                    fg_ptr->sel_codes[0].fwd_field_sel = _bcmFieldFwdFieldVrf;
                }
            }

            /* If vlanid qualifier is part of the qset, update the field group
               selector */
            if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyForwardingVlanId)) {
                if (_bcmFieldFwdFieldAny
                        != fg_ptr->sel_codes[0].fwd_field_sel) {
                    fg_ptr->sel_codes[0].fwd_field_sel = _bcmFieldFwdFieldVlan;
                }
            }

            /* If QSET has srcGport, the ingress entity select must to common gport */
             if (hw_sel->pri_slice[0].ingress_entity_sel
                                == _bcmFieldFwdEntityMimGport) {
                 if (BCM_FIELD_QSET_TEST
                         (fg_ptr->qset, bcmFieldQualifySrcGport) ||
                     BCM_FIELD_QSET_TEST
                         (fg_ptr->qset, bcmFieldQualifySrcGports)) {
                     fg_ptr->sel_codes[0].ingress_entity_sel = _bcmFieldFwdEntityCommonGport;
                 }
             }
        }

        if (port != -1) {
            BCM_PBMP_PORT_ADD(fg_ptr->pbmp, port);
        } else {
            if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                    (stage_fc->oper_mode != bcmFieldGroupOperModeGlobal)) {
                SOC_PBMP_ASSIGN(fg_ptr->pbmp, PBMP_PIPE(unit, inst));
                BCM_PBMP_REMOVE(fg_ptr->pbmp, PBMP_LB(unit));
            } else {
                SOC_PBMP_CLEAR(all_pbmp);
                SOC_PBMP_ASSIGN(all_pbmp, PBMP_PORT_ALL(unit));
                SOC_PBMP_OR(all_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
                if (soc_feature(unit, soc_feature_linkphy_coe) ||
                        soc_feature(unit, soc_feature_subtag_coe)) {
                    _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
                }
#endif
                SOC_PBMP_ASSIGN(fg_ptr->pbmp, all_pbmp);
            }
        }

        /* double-wide but not paired */
        if (intraslice) {
            fg_ptr->flags |= _FP_GROUP_INTRASLICE_DOUBLEWIDE;

            if (fc->l2warm
                && (hw_sel->pri_slice[1].dst_fwd_entity_sel
                    == _bcmFieldFwdEntityMimGport)) {
                /* Refine VP selectors only if it's used in hardware. */
                if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifyDstMplsGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifyDstMplsGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                           _bcmFieldFwdEntityMplsGport;
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifyDstNivGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifyDstNivGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                            _bcmFieldFwdEntityNivGport;
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                           bcmFieldQualifyDstGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifyDstGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                            _bcmFieldFwdEntityCommonGport;
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                           bcmFieldQualifyDstMimGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifyDstMimGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                            _bcmFieldFwdEntityMimGport;
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifyDstVlanGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifyDstVlanGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                            _bcmFieldFwdEntityVlanGport;
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifyDstWlanGport)) ||
                    (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifyDstWlanGports))) {
                    fg_ptr->sel_codes[1].dst_fwd_entity_sel =
                                           _bcmFieldFwdEntityWlanGport;
                }
            }

            if (fc->l2warm) {
               /* If QSET has srcGport, the ingress entity select must to common gport */
                if (hw_sel->pri_slice[1].ingress_entity_sel
                                == _bcmFieldFwdEntityMimGport) {
                    if (BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGport) ||
                        BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGports)) {
                        fg_ptr->sel_codes[1].ingress_entity_sel = _bcmFieldFwdEntityCommonGport;
                    }
                }
            }
        }

        if ((1 == paired) && (1 == intraslice)) {
            fg_ptr->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
            fg_ptr->flags |= _FP_GROUP_INTRASLICE_DOUBLEWIDE;

            if (fc->l2warm) {
                /* Refine VP selectors only if it's used in hardware. */
                if (hw_sel->sec_slice[0].dst_fwd_entity_sel
                    == _bcmFieldFwdEntityMimGport) {
                    if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstMplsGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstMplsGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMplsGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstNivGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstNivGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityNivGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityCommonGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstMimGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstMimGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMimGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstVlanGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstVlanGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityVlanGport;
                    } else if ((BCM_FIELD_QSET_TEST
                               (fg_ptr->qset, bcmFieldQualifyDstWlanGport))  ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstWlanGports))) {
                        fg_ptr->sel_codes[2].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityWlanGport;
                    }
                }

                if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifySrcMplsGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifySrcMplsGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[2].ingress_entity_sel) {
                        fg_ptr->sel_codes[2].ingress_entity_sel =
                                               _bcmFieldFwdEntityMplsGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                                               _bcmFieldFwdEntityMplsGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcNivGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcNivGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[2].ingress_entity_sel) {
                        fg_ptr->sel_codes[2].ingress_entity_sel =
                                               _bcmFieldFwdEntityNivGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                                               _bcmFieldFwdEntityNivGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcMimGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcMimGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[2].ingress_entity_sel) {
                        fg_ptr->sel_codes[2].ingress_entity_sel =
                                               _bcmFieldFwdEntityMimGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                                               _bcmFieldFwdEntityMimGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                           bcmFieldQualifySrcVlanGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                          bcmFieldQualifySrcVlanGports))) {
                    if (_FP_SELCODE_DONT_CARE
                            != fg_ptr->sel_codes[2].ingress_entity_sel) {
                        fg_ptr->sel_codes[2].ingress_entity_sel =
                            _bcmFieldFwdEntityVlanGport;
                    } else if (_bcmFieldFwdEntityAny
                            != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                            _bcmFieldFwdEntityVlanGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcWlanGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcWlanGports))) {
                    if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                                               _bcmFieldFwdEntityWlanGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                                bcmFieldQualifyInPort) ||
                            BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                                bcmFieldQualifyInterfaceClassPort))
                           && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {
                    /* Only for VFP. IFP uses IPBM for InPort */
                    if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[2].src_entity_sel) {
                        fg_ptr->sel_codes[2].src_entity_sel =
                                               _bcmFieldFwdEntityPortGroupNum;
                    }
                }

                /* part-4 */
                if (hw_sel->sec_slice[1].dst_fwd_entity_sel
                    == _bcmFieldFwdEntityMimGport) {
                    if ((BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifyDstMplsGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstMplsGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMplsGport;
                    } else if ((BCM_FIELD_QSET_TEST
                             (fg_ptr->qset, bcmFieldQualifyDstNivGport)) ||
                                 (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstNivGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityNivGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstGport)) ||
                              (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityCommonGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstMimGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstMimGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMimGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstVlanGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstVlanGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityVlanGport;
                    } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                              bcmFieldQualifyDstWlanGport)) ||
                            (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifyDstWlanGports))) {
                        fg_ptr->sel_codes[3].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityWlanGport;
                    }
                }
                /* If vpn qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVpn)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[2].fwd_field_sel) {
                        fg_ptr->sel_codes[2].fwd_field_sel = _bcmFieldFwdFieldVpn;
                    }
                }

                /* If vrf qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVrf)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[2].fwd_field_sel) {
                        fg_ptr->sel_codes[2].fwd_field_sel = _bcmFieldFwdFieldVrf;
                    }
                }

                /* If vlanid qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyForwardingVlanId)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[2].fwd_field_sel) {
                        fg_ptr->sel_codes[2].fwd_field_sel = _bcmFieldFwdFieldVlan;
                    }
                }

                /* If QSET has srcGport, the ingress entity select must to common gport */
                if (hw_sel->sec_slice[0].dst_fwd_entity_sel
                                == _bcmFieldFwdEntityMimGport) {
                    if (BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGport) ||
                        BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGports)) {
                        fg_ptr->sel_codes[2].ingress_entity_sel = _bcmFieldFwdEntityCommonGport;
                    }
                }
            }
        } else if ((1 == paired) && (0 == intraslice)) {
            /* paired but not intraslice */
            fg_ptr->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;

            if (fc->l2warm) {
                /* part-2 */
                /* Refine VP selectors only if it's used in hardware. */
                if (hw_sel->sec_slice[0].dst_fwd_entity_sel
                    == _bcmFieldFwdEntityMimGport) {
                    if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                            bcmFieldQualifyDstMplsGport)) ||
                       (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                            bcmFieldQualifyDstMplsGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMplsGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstNivGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstNivGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityNivGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                                  bcmFieldQualifyDstGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityCommonGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstMimGport)) ||
                        (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                              bcmFieldQualifyDstMimGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityMimGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstVlanGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstVlanGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityVlanGport;
                    } else if ((BCM_FIELD_QSET_TEST
                                (fg_ptr->qset, bcmFieldQualifyDstWlanGport)) ||
                            (BCM_FIELD_QSET_TEST (fg_ptr->qset,
                                             bcmFieldQualifyDstWlanGports))) {
                        fg_ptr->sel_codes[1].dst_fwd_entity_sel
                            = _bcmFieldFwdEntityWlanGport;
                    }
                }

                if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                        bcmFieldQualifySrcMplsGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                         bcmFieldQualifySrcMplsGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[1].ingress_entity_sel) {
                        fg_ptr->sel_codes[1].ingress_entity_sel =
                                               _bcmFieldFwdEntityMplsGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                                               _bcmFieldFwdEntityMplsGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcNivGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcNivGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[1].ingress_entity_sel) {
                        fg_ptr->sel_codes[1].ingress_entity_sel =
                                               _bcmFieldFwdEntityNivGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                                               _bcmFieldFwdEntityNivGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcMimGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcMimGports))) {
                    if (_FP_SELCODE_DONT_CARE
                        != fg_ptr->sel_codes[1].ingress_entity_sel) {
                        fg_ptr->sel_codes[1].ingress_entity_sel =
                                               _bcmFieldFwdEntityMimGport;
                    } else if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                                               _bcmFieldFwdEntityMimGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                            bcmFieldQualifySrcVlanGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                           bcmFieldQualifySrcVlanGports))) {
                    if (_FP_SELCODE_DONT_CARE
                            != fg_ptr->sel_codes[1].ingress_entity_sel) {
                        fg_ptr->sel_codes[1].ingress_entity_sel =
                            _bcmFieldFwdEntityVlanGport;
                    } else if (_bcmFieldFwdEntityAny
                            != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                            _bcmFieldFwdEntityVlanGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                               bcmFieldQualifySrcWlanGport)) ||
                        (BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                             bcmFieldQualifySrcWlanGports))) {
                    if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                                               _bcmFieldFwdEntityWlanGport;
                    }
                } else if ((BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                                bcmFieldQualifyInPort) ||
                            BCM_FIELD_QSET_TEST(fg_ptr->qset,
                                                bcmFieldQualifyInterfaceClassPort))
                           && (_BCM_FIELD_STAGE_LOOKUP == stage_id)) {
                    /* Only for VFP. IFP uses IPBM for InPort */
                    if (_bcmFieldFwdEntityAny
                        != fg_ptr->sel_codes[1].src_entity_sel) {
                        fg_ptr->sel_codes[1].src_entity_sel =
                                               _bcmFieldFwdEntityPortGroupNum;
                    }
                }
                /* If vpn qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVpn)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[1].fwd_field_sel) {
                        fg_ptr->sel_codes[1].fwd_field_sel = _bcmFieldFwdFieldVpn;
                    }
                }

                /* If vrf qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyVrf)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[1].fwd_field_sel) {
                        fg_ptr->sel_codes[1].fwd_field_sel = _bcmFieldFwdFieldVrf;
                    }
                }

                /* If vlanid qualifier is part of the qset, update the field group
                   selector */
                if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyForwardingVlanId)) {
                    if (_bcmFieldFwdFieldAny
                            != fg_ptr->sel_codes[1].fwd_field_sel) {
                        fg_ptr->sel_codes[1].fwd_field_sel = _bcmFieldFwdFieldVlan;
                    }
                }

                /* If QSET has srcGport, the ingress entity select must to common gport */
                if (hw_sel->sec_slice[0].ingress_entity_sel
                                  == _bcmFieldFwdEntityMimGport) {
                    if (BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGport) ||
                        BCM_FIELD_QSET_TEST
                            (fg_ptr->qset, bcmFieldQualifySrcGports)) {
                        fg_ptr->sel_codes[1].ingress_entity_sel = _bcmFieldFwdEntityCommonGport;
                    }
                }

            }
        } else {
            fg_ptr->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
        }

#if defined(BCM_TRX_SUPPORT)
        /* Add Range check internal qualifier */
        if (fc->l2warm && SOC_IS_TRX(unit) && (_BCM_FIELD_STAGE_INGRESS == stage_id)) {
            if (BCM_FIELD_QSET_TEST (fg_ptr->qset, bcmFieldQualifyRangeCheck) &&
                    !(BCM_FIELD_QSET_TEST(fg_ptr->qset, bcmFieldQualifyInterfaceClassPort) ||
                        BCM_FIELD_QSET_TEST(fg_ptr->qset, bcmFieldQualifyInterfaceClassL3) ||
                        BCM_FIELD_QSET_TEST(fg_ptr->qset, bcmFieldQualifyInterfaceClassVPort) ||
                        BCM_FIELD_QSET_TEST(fg_ptr->qset, bcmFieldQualifyInterfaceClassL2)) &&
                    BCM_FIELD_QSET_TEST(stage_fc->_field_supported_qset,
                        _bcmFieldQualifyRangeCheckBits24_31)) {
                BCM_FIELD_QSET_ADD(fg_ptr->qset, _bcmFieldQualifyRangeCheckBits24_31);
            }
        }
#endif

        /* Skip qual offset construct for IFP and VFP stage
         * for the devices using sync function
         * _field_tr2_group_entry_write, quals add will be done as part of
         * _field_tr2_group_construct_quals_with_sel_update
         */
        if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit) ||
                SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
                (!(fc->l2warm && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) &&
                    ((_BCM_FIELD_STAGE_INGRESS == stage_id) ||
                    (_BCM_FIELD_STAGE_LOOKUP == stage_id))))) {

            _field_tr2_group_construct_quals_add(unit,
                                                 fc,
                                                 stage_fc,
                                                 fg_ptr
                                                 );
        }

        /* Associate slice(s) to group */
        if (fg_ptr->slices == NULL) {
            fg_ptr->slices = stage_fc->slices[inst] + slice_idx;
            if (1 == intraslice) {
                fg_ptr->slices->group_flags |= _FP_GROUP_INTRASLICE_DOUBLEWIDE;
                if (1 == paired) {
                    fg_ptr->slices[1].group_flags |=
                                               _FP_GROUP_INTRASLICE_DOUBLEWIDE;
                }
            }
        }

        BCM_PBMP_OR(fg_ptr->slices[0].pbmp, fg_ptr->pbmp);
        if (1 == paired) {
            BCM_PBMP_OR(fg_ptr->slices[1].pbmp, fg_ptr->pbmp);
        }

        /* Initialize group default ASET list. */
        rv = _field_group_default_aset_set(unit, fg_ptr);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }

        if (fc->l2warm
                && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15)) {
            if (group_flags & _FP_GROUP_LOOKUP_ENABLED) {
                fg_ptr->flags = fg_ptr->flags | _FP_GROUP_LOOKUP_ENABLED;
            }
            if (group_flags & _FP_GROUP_WLAN) {
                fg_ptr->flags = fg_ptr->flags | _FP_GROUP_WLAN;
            }
        } else {
            fg_ptr->flags |= _FP_GROUP_LOOKUP_ENABLED;
        }

        fg_ptr->next = fc->groups;
        fc->groups = fg_ptr;
    }

    return rv;
}


/* Delete the qualifier at the given index from the given group's qualifier array */

STATIC void
_field_tr2_group_qual_del(_bcm_field_group_qual_t *grp_qual, unsigned idx)
{
    uint16                   *qidp    = &grp_qual->qid_arr[idx];
    _bcm_field_qual_offset_t *offsetp = &grp_qual->offset_arr[idx];
    unsigned                 n;

    /* Shuffle all qualifier entries down by one slot, overwriting the one to be deleted */

    for (n = grp_qual->size - 1 - idx; n; --n, ++qidp, ++offsetp) {
        qidp[0]    = qidp[1];
        offsetp[0] = offsetp[1];
    }

    /* Reduce qualifier count */

    --grp_qual->size;
}

/* Eliminate duplicate (i.e. unused) qualifiers from a group's qualifier array */

STATIC void
_field_tr2_group_part_cleanup(_bcm_field_group_qual_t *grp_qual, uint8 *cnt_arr,
                            uint32 *tcam_mask, int part_idx)
{
    unsigned i;

    for (i = 0; i < grp_qual->size; ) {
        _bcm_field_qual_offset_t *q = &grp_qual->offset_arr[i];
        unsigned                 b = 0, b_set = 0, ct;
        uint8                    *cntp = &cnt_arr[grp_qual->qid_arr[i]];

        if ((*cntp == 1)
            || ((0 == part_idx)
            && (bcmFieldQualifyInPort == grp_qual->qid_arr[i]
            || bcmFieldQualifyInPorts == grp_qual->qid_arr[i]
            || bcmFieldQualifyStage == grp_qual->qid_arr[i]
            || bcmFieldQualifyStageIngress == grp_qual->qid_arr[i]
            || bcmFieldQualifyStageLookup == grp_qual->qid_arr[i]
            || bcmFieldQualifyStageExternal == grp_qual->qid_arr[i]
            || bcmFieldQualifyStageEgress == grp_qual->qid_arr[i]))) {
            /* Qualifier appears only once OR dup qualifier should not
             * be removed from primary part_idx.
             *  => Don't delete it from the group.
             */
            ++i;

            continue;
        }

        /* Check the qualifier against the given TCAM mask */
        for (ct = 0; ct < q->num_offsets; ct++) {
            SHR_BITTEST_RANGE(tcam_mask, q->offset[ct], q->width[ct], b);
            b_set |= b;
        }

        if (b_set) {
            /* Qualifier is in use (i.e. has a non-empty mask)
               => Don't delete it from the group.
            */

            ++i;

            continue;
        }

        /* Qualifier appears more than once, and this instance does not
           appear in the given TCAM mask
           => Delete qualifier from group.
        */

        _field_tr2_group_qual_del(grp_qual, i);
        --*cntp;
    }
}

int
_field_tr2_pbmp_status_get_from_fp_gm(int unit, int phys_tcam_idx,
                                    uint8 *clearInPorts,
                                    _field_table_pointers_t *fp_table_pointers)
{
    fp_global_mask_tcam_entry_t *global_mask_tcam_entry;
    fp_tcam_entry_t             *tcam_entry;
    bcm_pbmp_t                  entry_pbmp, entry_mask_pbmp;
#if (defined (BCM_TRIDENT_SUPPORT) || defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT))
    bcm_pbmp_t                  temp_pbmp, temp_pbm_mask;
#endif
    uint32                      *fp_tcam_buf = NULL;
    char                        *fp_gm_tcam_buf = NULL; /* Buffer to read the
                                                         * FP_GLOBAL_MASK_TCAM
                                                         * table */

#if defined(BCM_TRIDENT_SUPPORT)
    char *fp_gm_tcam_x_buf = NULL;                     /* Buffer to read
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * table. */
    fp_global_mask_tcam_x_entry_t *fp_gm_tcam_x_entry; /* Pointer to
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * entry */
    char *fp_gm_tcam_y_buf = NULL;                     /* Buffer to read
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * table. */
    fp_global_mask_tcam_y_entry_t *fp_gm_tcam_y_entry; /* Pointer to
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * entry */
#endif
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT)
    uint32  tcam_dual_pipe_entry[SOC_MAX_MEM_FIELD_WORDS]; /* Y-Pipe FP_TCAM
                                                            * entry. */
#endif


    if ((NULL == clearInPorts) || (NULL == fp_table_pointers)) {
          return (BCM_E_INTERNAL);
    }

    BCM_PBMP_CLEAR(entry_pbmp);
    BCM_PBMP_CLEAR(entry_mask_pbmp);
#if (defined (BCM_TRIDENT_SUPPORT) || defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT))
    BCM_PBMP_CLEAR(temp_pbmp);
    BCM_PBMP_CLEAR(temp_pbm_mask);
#endif

    if (soc_mem_is_valid(unit, FP_GLOBAL_MASK_TCAMm)) {
#if defined (BCM_TRIDENT_SUPPORT)
        if (SOC_IS_TD_TT(unit) &&
                SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Xm) &&
                SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Ym)) {

            fp_gm_tcam_x_buf = fp_table_pointers->fp_gm_tcam_x_buf;
            fp_gm_tcam_y_buf = fp_table_pointers->fp_gm_tcam_y_buf;

            if ((NULL == fp_gm_tcam_x_buf) || (NULL == fp_gm_tcam_y_buf )) {
                 return (BCM_E_INTERNAL);
            }

            /* Get X-Pipe IPBM KEY and MASK value. */
            fp_gm_tcam_x_entry = soc_mem_table_idx_to_pointer(unit,
                                            FP_GLOBAL_MASK_TCAM_Xm,
                                            fp_global_mask_tcam_x_entry_t *,
                                            fp_gm_tcam_x_buf,
                                            phys_tcam_idx);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAM_Xm,
                                   fp_gm_tcam_x_entry,
                                   IPBMf,
                                   &entry_pbmp);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAM_Xm,
                                   fp_gm_tcam_x_entry,
                                   IPBM_MASKf,
                                   &entry_mask_pbmp);

            /* Get Y-Pipe IPBM KEY and MASK value. */
            fp_gm_tcam_y_entry = soc_mem_table_idx_to_pointer(unit,
                                            FP_GLOBAL_MASK_TCAM_Ym,
                                            fp_global_mask_tcam_y_entry_t *,
                                            fp_gm_tcam_y_buf,
                                            phys_tcam_idx);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAM_Ym,
                                   fp_gm_tcam_y_entry,
                                   IPBMf,
                                   &temp_pbmp);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAM_Ym,
                                   fp_gm_tcam_y_entry,
                                   IPBM_MASKf,
                                   &temp_pbm_mask);
            SOC_PBMP_OR(entry_pbmp, temp_pbmp);
            SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
        } else
#endif
        {
            fp_gm_tcam_buf = fp_table_pointers->fp_global_mask_tcam_buf;

            if (NULL == fp_gm_tcam_buf) {
                return BCM_E_INTERNAL;
            }
            global_mask_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                                                FP_GLOBAL_MASK_TCAMm,
                                                fp_global_mask_tcam_entry_t *,
                                                fp_gm_tcam_buf,
                                                phys_tcam_idx);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAMm,
                                   global_mask_tcam_entry,
                                   IPBMf,
                                   &entry_pbmp);
            soc_mem_pbmp_field_get(unit,
                                   FP_GLOBAL_MASK_TCAMm,
                                   global_mask_tcam_entry,
                                   IPBM_MASKf,
                                   &entry_mask_pbmp);
        }

    } else {

        fp_tcam_buf = fp_table_pointers->fp_tcam_buf;
        if (NULL == fp_tcam_buf) {
            return BCM_E_INTERNAL;
        }
        tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                  fp_tcam_entry_t *,
                                                  fp_tcam_buf,
                                                  phys_tcam_idx);

        if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) == 0) {
            return BCM_E_INTERNAL;
        }


        soc_mem_pbmp_field_get(unit,
                               FP_TCAMm,
                               tcam_entry,
                               IPBMf,
                               &entry_pbmp);
        soc_mem_pbmp_field_get(unit,
                               FP_TCAMm,
                               tcam_entry,
                               IPBM_MASKf,
                               &entry_mask_pbmp);
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT)
        /*
         * Scorpion and Conqurer are dual pipe line devices.
         * Retrieve IPBMf and IPBM_MASKf field values from Y Pipleline
         * FP_TCAM table.
         */
        if (SOC_IS_SC_CQ(unit)) {
            sal_memset(&tcam_dual_pipe_entry, 0,sizeof(tcam_dual_pipe_entry));

            BCM_IF_ERROR_RETURN(soc_mem_read(unit, FP_TCAM_Ym, MEM_BLOCK_ANY,
                                phys_tcam_idx, tcam_dual_pipe_entry));

            soc_mem_pbmp_field_get(unit,
                                   FP_TCAM_Ym,
                                   tcam_dual_pipe_entry,
                                   IPBMf,
                                   &temp_pbmp);
            soc_mem_pbmp_field_get(unit,
                                   FP_TCAM_Ym,
                                   tcam_dual_pipe_entry,
                                   IPBM_MASKf,
                                   &temp_pbm_mask);
            SOC_PBMP_OR(entry_pbmp, temp_pbmp);
            SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
        }
#endif

    }

    if(BCM_PBMP_IS_NULL(entry_pbmp) && BCM_PBMP_IS_NULL(entry_mask_pbmp)) {
        *clearInPorts = 1;
    } else {
        *clearInPorts = 0;
    }

    return BCM_E_NONE;
}

/* Eliminate duplicate qualifiers from all groups in the given stage */

int
_field_tr2_stage_reinit_all_groups_cleanup(int unit,
                                     _field_control_t *fc,
                                     unsigned stage_id,
                                     _field_table_pointers_t *fp_table_pointers)
{
    int            idx, rv = BCM_E_NONE;
    uint8          clear_inports = 0, installed_entry_found = 0;
    unsigned       cnt_arr_sz;
    uint8          *cnt_arr;
    uint8          e_type = _FP_ENTRY_TYPE_DEFAULT; /* Entry type */
    _field_group_t *fg;
    _field_entry_t *f_ent = NULL;


    cnt_arr_sz = _bcmFieldQualifyCount * sizeof(cnt_arr[0]);
    if ((cnt_arr = (uint8 *) sal_alloc(cnt_arr_sz, "qual cnt array")) == 0) {
        return (BCM_E_MEMORY);
    }

    /* For all groups, ... */

    for (fg = fc->groups; fg; fg = fg->next) {
        int      parts_cnt, part_idx;
        unsigned duplf;

        /* In the given stage, ... */

        if (fg->stage_id != stage_id) {
            continue;
        }

        rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                               fg->flags, &parts_cnt);
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }

        /* Construct an array of counts, 1 per qualifier, and set each count
           to the number times the qualifier occurs in the given group
        */

        for (e_type = 0; e_type < _FP_MAX_ENTRY_TYPES; e_type++) {

            /* No Default entry exists only for EFP. */
            if (_FP_ENTRY_TYPE_DEFAULT != e_type) {

                if (_BCM_FIELD_STAGE_EGRESS != stage_id) {
                    break;
                }

                /* Prior to TD2 SDK maintains only _FP_ENTRY_TYPE_DEFAULT */
                if (!SOC_IS_TD2_TT2(unit)) {
                    break;
                }
            }

            sal_memset(cnt_arr, 0, cnt_arr_sz);
            duplf = FALSE;
            for (part_idx = 0; part_idx < parts_cnt; ++part_idx) {
                _bcm_field_group_qual_t *grp_qual =
                                                &fg->qual_arr[e_type][part_idx];
                unsigned                i;

                /* Construct an array of counts, 1 per qualifier, and set each
                 * count to the number times the qualifier occurs in the given
                 * group
                 */

                for (i = 0; i < grp_qual->size; ++i) {
                    if (++cnt_arr[grp_qual->qid_arr[i]] > 1) {
                        /* Count for a qualifier just exceeded 1 */
                        /* Indicate there are duplicate qualifiers */
                        duplf = TRUE;
                    }
                }
            }

            if (!duplf) {
                /* No duplicate qualifiers => Skip to next group */
                continue;
            }

            /* There are some duplicate qualifiers
             *  => Compute the union of all TCAM masks, over all entries in
             * group, and use that to determine which qualifiers are in use.
             */

            for (part_idx = 0; part_idx < parts_cnt; ++part_idx) {
                _bcm_field_group_qual_t *grp_qual =
                                                &fg->qual_arr[e_type][part_idx];
                unsigned                i;
                uint32                  tcam_mask[SOC_MAX_MEM_FIELD_WORDS];

                sal_memset(tcam_mask, 0, sizeof(tcam_mask));

                for (i = 0; i < fg->group_status.entry_count; ++i) {
                    _field_entry_t *f_ent = &fg->entry_arr[i][part_idx];
                    unsigned free_entry_tcam_buff = (f_ent->tcam.key == 0);
                    unsigned j;

                    rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent);
                    if (BCM_FAILURE(rv)) {
                        goto cleanup;
                    }

                    for (j = 0;
                         j < (f_ent->tcam.key_size / sizeof(uint32)); ++j) {
                        tcam_mask[j] |= f_ent->tcam.mask[j];
                    }

                    if (free_entry_tcam_buff) {
                        if (f_ent->tcam.key != 0) {
                            sal_free(f_ent->tcam.key);
                            sal_free(f_ent->tcam.mask);
                        }

                        if (f_ent->flags & _FP_ENTRY_USES_IPBM_OVERLAY) {
                            if (f_ent->extra_tcam.key != 0) {
                                sal_free(f_ent->extra_tcam.key);
                                sal_free(f_ent->extra_tcam.mask);
                            }
                        }

                        f_ent->tcam.key
                             = f_ent->tcam.mask
                             = f_ent->extra_tcam.key
                             = f_ent->extra_tcam.mask
                             = 0;
                    }
                }

                /* Use the union of all TCAM masks for all entries in the group to
                   eliminate duplicate qualifiers from group
                */

                _field_tr2_group_part_cleanup(grp_qual, cnt_arr,
                                              tcam_mask, part_idx);
            }

            if (_BCM_FIELD_STAGE_INGRESS == stage_id) {

                if (BCM_FIELD_QSET_TEST(fg->qset,bcmFieldQualifyLoopback) ||
                    BCM_FIELD_QSET_TEST(fg->qset,bcmFieldQualifyLoopbackType)) {

                    clear_inports        = 0;
                    installed_entry_found = 0;

                    for(idx = 0; idx < fg->group_status.entry_count; idx++) {
                        f_ent = fg->entry_arr[idx];
                        if (_FP_ENTRY_INSTALLED & f_ent->flags) {
                            installed_entry_found =1;
                            break;
                        }
                    }

                    if (installed_entry_found) {

                        rv = _field_tr2_pbmp_status_get_from_fp_gm(unit,
                                                       f_ent->slice_idx,
                                                       &clear_inports,
                                                       fp_table_pointers);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        if (clear_inports) {
                            BCM_FIELD_QSET_REMOVE(fg->qset,
                                                  bcmFieldQualifyInPort);
                            BCM_FIELD_QSET_REMOVE(fg->qset,
                                                  bcmFieldQualifyInPorts);
                        }
                    }
                }
            }
        }
    }

 cleanup:
    sal_free(cnt_arr);

    return (rv);
}


int
_field_tr2_ifp_slice_expanded_status_get(int            unit,
                                         _field_control_t *fc,
                                         _field_stage_t *stage_fc,
                                         int            *expanded,
                                         int            *slice_master_idx
                                         )
{
    static const soc_field_t ifp_virtual_to_physical_map_tr[][16] = {
        { VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_8_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_9_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_10_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_11_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_12_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_13_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_14_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
          VIRTUAL_SLICE_15_PHYSICAL_SLICE_NUMBER_ENTRY_0f

        },
        { VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_8_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_9_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_10_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_11_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_12_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_13_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_14_PHYSICAL_SLICE_NUMBER_ENTRY_1f,
          VIRTUAL_SLICE_15_PHYSICAL_SLICE_NUMBER_ENTRY_1f

        },
        { VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_8_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_9_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_10_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_11_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_12_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_13_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_14_PHYSICAL_SLICE_NUMBER_ENTRY_2f,
          VIRTUAL_SLICE_15_PHYSICAL_SLICE_NUMBER_ENTRY_2f
        }
    };
    static const soc_field_t ifp_virtual_to_group_map_tr[][16] = {
        { VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_8_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_9_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_10_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_11_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_12_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_13_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_14_VIRTUAL_SLICE_GROUP_ENTRY_0f,
          VIRTUAL_SLICE_15_VIRTUAL_SLICE_GROUP_ENTRY_0f

        },
        { VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_8_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_9_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_10_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_11_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_12_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_13_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_14_VIRTUAL_SLICE_GROUP_ENTRY_1f,
          VIRTUAL_SLICE_15_VIRTUAL_SLICE_GROUP_ENTRY_1f
        },
        { VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_8_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_9_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_10_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_11_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_12_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_13_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_14_VIRTUAL_SLICE_GROUP_ENTRY_2f,
          VIRTUAL_SLICE_15_VIRTUAL_SLICE_GROUP_ENTRY_2f
        }
    };

    int                  i, vmap, vmap_cnt, vslice, slice_idx, vgroup = -1, max = -1;
    int                  nslices;
    fp_slice_map_entry_t map_entry;
    soc_field_t          fld;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];

    if (!soc_mem_field_valid(unit,
                             FP_SLICE_MAPm,
                             ifp_virtual_to_physical_map_tr[0][0]
                             )
        ) {
        /* Fall back to Firebolt */

        return (_field_slice_expanded_status_get(unit, fc, stage_fc, expanded, slice_master_idx));
    }

    BCM_IF_ERROR_RETURN(READ_FP_SLICE_MAPm(unit, MEM_BLOCK_ANY, 0, &map_entry));
    nslices = stage_fc->tcam_slices;
    /* Iterate over virtual slices to get physical slices and virtual groups */



    vmap_cnt =
        /* Trident uses the field nomenclature from TR2, but has only 1 vmap */
        (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) ? 1 : _FP_VMAP_CNT;

    for (vmap = 0; vmap < vmap_cnt; ++vmap) {
        for (vslice = 0; vslice < nslices; vslice++) {
            fld = ifp_virtual_to_physical_map_tr[vmap][vslice];
            if (!soc_mem_field_valid(unit,FP_SLICE_MAPm,fld)) {
                continue;
            }
            slice_idx = soc_FP_SLICE_MAPm_field32_get(unit, &map_entry, fld);
            /* Now get virtual group for this virtual slice */
            fld = ifp_virtual_to_group_map_tr[vmap][vslice];
            if (!soc_mem_field_valid(unit,FP_SLICE_MAPm,fld)) {
                continue;
            }
            vgroup = soc_FP_SLICE_MAPm_field32_get(unit, &map_entry, fld);
            /* Phys slice_idx <=> virtual vslice <=> vgroup */
            stage_fc->vmap[_FP_DEF_INST][vmap][vslice].vmap_key = slice_idx;
            stage_fc->vmap[_FP_DEF_INST][vmap][vslice].virtual_group = vgroup;
            stage_fc->vmap[_FP_DEF_INST][vmap][vslice].priority = vgroup;
            
           }

        /* See if virtual slice is the highest number in the virtual group */
        for (vslice = 0; (vslice < nslices) && (vmap == 0); vslice++) {
            max = -1;
            for (i = 0; i < nslices; i++) {
                if ((stage_fc->vmap[_FP_DEF_INST][vmap][vslice].virtual_group ==
                    stage_fc->vmap[_FP_DEF_INST][vmap][i].virtual_group)) {
                    if (i > max) {
                        max = i;
                    }
                }
            }

            if (!((fc->l2warm)
                        && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8))) {
                if ((max != vslice) && (max != -1)) {
                    expanded[stage_fc->vmap[_FP_DEF_INST][vmap][vslice].vmap_key] = 1;
                }
            }
        }
    }

    /* Software mantains 3 MAPS, make them identical if only 1 map is present */
    if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS)
            && (vmap_cnt == 1)) {
        for (vmap = 1; vmap < _FP_VMAP_CNT; ++vmap) {
            for (vslice = 0; vslice < nslices; vslice++) {
                stage_fc->vmap[_FP_DEF_INST][vmap][vslice] =
                              stage_fc->vmap[_FP_DEF_INST][0][vslice];
            }
        }
    }

    if ((fc->l2warm)
            && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
        for (i = 0; i < nslices; i++) {
            expanded[i] = buf[fc->scache_pos] & 0x1;
            slice_master_idx[i] = buf[fc->scache_pos] >> 1;

            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                     "_field_tr2_ifp_slice_expanded_status_get:   Read slice %d"
                     " map expanded %d master slice %d @ byte %d...\n"),
                     i, expanded[i], slice_master_idx[i], fc->scache_pos));

            fc->scache_pos++;
        }
    }

    return BCM_E_NONE;
}

int  _field_entry_oam_wb_scache_sync (int unit, _field_control_t *fc,
                              _field_stage_t *stage_fc, uint8 *scache_ptr,
                             _field_entry_oam_wb_t *f_ent_oam_wb)
{
    uint8 *curr_scache_ptr = scache_ptr; /* Scache Pointer */
    int oam_stat_size = 0;
    _field_extended_stat_wb_t *extended_stat_wb = NULL;

    if ((fc == NULL) || (stage_fc == NULL)
            || (scache_ptr == NULL) || (f_ent_oam_wb == NULL)) {
        return BCM_E_PARAM;
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS)
            && (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_NONE;
    }

        sal_memcpy (curr_scache_ptr,
                &(f_ent_oam_wb->is_present_bmp), sizeof (uint32));
        fc->scache_pos  += sizeof (uint32);
        curr_scache_ptr += sizeof (uint32);

        if (soc_feature(unit, soc_feature_fp_based_oam)) {
            if (f_ent_oam_wb->is_present_bmp & _FP_OAM_STAT_ACTION_WB_SYNC) {
                sal_memcpy (curr_scache_ptr,
                        &(f_ent_oam_wb->oam_stat_action_count), sizeof (uint8));
                fc->scache_pos  += sizeof (uint8);
                curr_scache_ptr += sizeof (uint8);

                oam_stat_size = sizeof (_field_oam_stat_action_wb_t)
                    * f_ent_oam_wb->oam_stat_action_count;
                sal_memcpy (curr_scache_ptr,
                        (f_ent_oam_wb->oam_stat_action_wb), oam_stat_size);
                fc->scache_pos  += oam_stat_size;
                curr_scache_ptr += oam_stat_size;
            }
        }

        if (f_ent_oam_wb->is_present_bmp & _FP_EXTENDED_STATS_WB_SYNC) {
            extended_stat_wb = f_ent_oam_wb->extended_stat_wb;
            if (extended_stat_wb != NULL) {
                sal_memcpy (curr_scache_ptr, &(extended_stat_wb->stat_id),
                        sizeof (extended_stat_wb->stat_id));
                fc->scache_pos  += sizeof (extended_stat_wb->stat_id);
                curr_scache_ptr += sizeof (extended_stat_wb->stat_id);

                sal_memcpy (curr_scache_ptr, &(extended_stat_wb->flex_mode),
                        sizeof (extended_stat_wb->flex_mode));
                fc->scache_pos  += sizeof (extended_stat_wb->flex_mode);
                curr_scache_ptr += sizeof (extended_stat_wb->flex_mode);

                sal_memcpy (curr_scache_ptr, &(extended_stat_wb->hw_flags),
                        sizeof (extended_stat_wb->hw_flags));
                fc->scache_pos  += sizeof (extended_stat_wb->hw_flags);
                curr_scache_ptr += sizeof (extended_stat_wb->hw_flags);

                sal_memcpy (curr_scache_ptr, &(extended_stat_wb->flex_stat_map),
                        sizeof (extended_stat_wb->flex_stat_map));
                fc->scache_pos  += sizeof (extended_stat_wb->flex_stat_map);
                curr_scache_ptr += sizeof (extended_stat_wb->flex_stat_map);
            }
        }

    return BCM_E_NONE;
}


int  _field_entry_oam_wb_scache_recover (int unit, _field_control_t *fc,
        _field_stage_t *stage_fc, uint8 *scache_ptr,
        _field_entry_oam_wb_t *f_ent_oam_wb)
{
    uint8 *curr_scache_ptr = scache_ptr; /* Scache Pointer */
    int oam_stat_size = 0;
    _field_extended_stat_wb_t *extended_stat_wb = NULL;

    if ((fc == NULL) || (stage_fc == NULL)
            || (scache_ptr == NULL) || (f_ent_oam_wb == NULL)) {
        return BCM_E_PARAM;
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) &&
            (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_NONE;
    }

    sal_memcpy (&(f_ent_oam_wb->is_present_bmp),
            curr_scache_ptr,sizeof (uint32));
    fc->scache_pos  += sizeof (uint32);
    curr_scache_ptr += sizeof (uint32);

    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        if (f_ent_oam_wb->is_present_bmp & _FP_OAM_STAT_ACTION_WB_SYNC) {
            sal_memcpy (&(f_ent_oam_wb->oam_stat_action_count),
                    curr_scache_ptr, sizeof (uint8));
            fc->scache_pos  += sizeof (uint8);
            curr_scache_ptr += sizeof (uint8);

            oam_stat_size = sizeof (_field_oam_stat_action_wb_t)
                * f_ent_oam_wb->oam_stat_action_count;
            _FP_XGS3_ALLOC(f_ent_oam_wb->oam_stat_action_wb,
                    oam_stat_size, "Oam Stat Warmboot");
            if (f_ent_oam_wb->oam_stat_action_wb == NULL) {
                return BCM_E_MEMORY;
            }

            sal_memcpy ((f_ent_oam_wb->oam_stat_action_wb),
                    curr_scache_ptr,oam_stat_size);
            fc->scache_pos  += oam_stat_size;
            curr_scache_ptr += oam_stat_size;
        }
    }

    if (f_ent_oam_wb->is_present_bmp & _FP_EXTENDED_STATS_WB_SYNC) {
        _FP_XGS3_ALLOC(f_ent_oam_wb->extended_stat_wb,
                (sizeof (_field_extended_stat_wb_t)),
                "Extended Stat WB");
        if (f_ent_oam_wb->extended_stat_wb == NULL) {
            return BCM_E_MEMORY;
        }
        extended_stat_wb = f_ent_oam_wb->extended_stat_wb;
        if (extended_stat_wb != NULL) {
            sal_memcpy (&(extended_stat_wb->stat_id), curr_scache_ptr,
                    sizeof (extended_stat_wb->stat_id));
            fc->scache_pos  += sizeof(extended_stat_wb->stat_id);
            curr_scache_ptr += sizeof(extended_stat_wb->stat_id);

            sal_memcpy (&(extended_stat_wb->flex_mode), curr_scache_ptr,
                    sizeof (extended_stat_wb->flex_mode));
            fc->scache_pos  += sizeof (extended_stat_wb->flex_mode);
            curr_scache_ptr += sizeof (extended_stat_wb->flex_mode);

            sal_memcpy (&(extended_stat_wb->hw_flags), curr_scache_ptr,
                    sizeof (extended_stat_wb->hw_flags));
            fc->scache_pos  += sizeof (extended_stat_wb->hw_flags);
            curr_scache_ptr += sizeof (extended_stat_wb->hw_flags);

            sal_memcpy (&(extended_stat_wb->flex_stat_map), curr_scache_ptr,
                    sizeof (extended_stat_wb->flex_stat_map));
            fc->scache_pos  += sizeof (extended_stat_wb->flex_stat_map);
            curr_scache_ptr += sizeof (extended_stat_wb->flex_stat_map);
        }
    }

    return BCM_E_NONE;
}

int _field_entry_oam_wb_free (int unit, _field_entry_oam_wb_t **f_ent_oam_wb)
{
    if (f_ent_oam_wb == NULL) {
        return BCM_E_PARAM;
    }

    if (*f_ent_oam_wb == NULL) {
        return BCM_E_NONE;
    }

    if ((*f_ent_oam_wb)->oam_stat_action_wb != NULL) {
        sal_free ((*f_ent_oam_wb)->oam_stat_action_wb);
        (*f_ent_oam_wb)->oam_stat_action_wb = NULL;
    }

    if ((*f_ent_oam_wb)->extended_stat_wb != NULL) {
        sal_free ((*f_ent_oam_wb)->extended_stat_wb);
        (*f_ent_oam_wb)->extended_stat_wb = NULL;
    }

    sal_free (*f_ent_oam_wb);
    *f_ent_oam_wb = NULL;

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_trx_meter_recover_configured_rates
 *
 * Purpose:
 *      Recover configured packet committed rate and burst size and
 *      peak rate and peak burst size.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     f_ent    - (IN) Field entry structure
 *     level - (IN) Policer level
 *     f_ent_wb_info - (IN) Warmboot Field entry structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_field_trx_meter_recover_configured_rates(int unit, _field_entry_t   *f_ent,
        uint32 level,
        _field_entry_wb_info_t *f_ent_wb_info)
{
    _field_policer_t    *f_pl;   /* Internal policer descriptor. */
    _field_entry_policer_t *f_ent_pl; /* Field entry policer structure.  */
    int rv;

    if ((f_ent == NULL) || (f_ent_wb_info == NULL)) {
        return BCM_E_PARAM;
    }

    if (f_ent_wb_info->f_ent_policer_wb == NULL) {
        return BCM_E_NONE;
    }

    f_ent_pl = f_ent->policer + level;

    rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
    if (BCM_SUCCESS(rv)) {
        if (f_pl->sw_ref_count == 2) {
            /* A policer can be attached to more than one field entry.
             * Calculate configured rates only when its a new policer
             * object after Warmboot. */
            f_pl->cfg.actual_ckbits_sec = f_pl->cfg.ckbits_sec;
            f_pl->cfg.ckbits_sec = f_pl->cfg.actual_ckbits_sec -
                f_ent_wb_info->f_ent_policer_wb->policer_delta_rates[level][0];

            f_pl->cfg.actual_ckbits_burst = f_pl->cfg.ckbits_burst;
            f_pl->cfg.ckbits_burst = f_pl->cfg.actual_ckbits_burst -
                f_ent_wb_info->f_ent_policer_wb->policer_delta_rates[level][1];

            f_pl->cfg.actual_pkbits_sec = f_pl->cfg.pkbits_sec;
            f_pl->cfg.pkbits_sec = f_pl->cfg.actual_pkbits_sec -
                f_ent_wb_info->f_ent_policer_wb->policer_delta_rates[level][2];

            f_pl->cfg.actual_pkbits_burst = f_pl->cfg.pkbits_burst;
            f_pl->cfg.pkbits_burst = f_pl->cfg.actual_pkbits_burst -
                f_ent_wb_info->f_ent_policer_wb->policer_delta_rates[level][3];
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *  _field_entry_policer_delta_rates_sync
 *
 * Purpose:
 *  Sync the delta between the actual hardware rate and burst
 *  and the configured rate and burst
 *
 * Parameters:
 *  unit  - (IN) BCM device number.
 *  stage_fc - (IN) Field stage control structure.
 *  scache_ptr - (IN) Scache Pointer
 *  f_ent    - (IN) Field entry structure
 *
 * Returns:
 *  BCM_E_XXX
 *
 */
int _field_entry_policer_delta_rates_sync(int unit, _field_control_t *fc,
        _field_stage_t *stage_fc, uint8 *scache_ptr,
        _field_entry_t *f_ent)
{
    uint8 *curr_scache_ptr = scache_ptr;    /* Scache Pointer */
    _field_policer_t    *f_pl;   /* Internal policer descriptor. */
    _field_entry_policer_t *f_ent_pl; /* Field entry policer structure.  */
    int idx;                     /* Policers levels iterator.       */
    int rv;
    uint16 kbits_diff = 0;

    if ((fc == NULL) || (stage_fc == NULL)
            || (scache_ptr == NULL) || (f_ent == NULL)) {
        return BCM_E_PARAM;
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS)
            && (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_NONE;
    }

    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;

        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        if (BCM_SUCCESS(rv)) {

            if(!(f_ent->policer[idx].flags & _FP_POLICER_INSTALLED))  {
                continue;
            }

            kbits_diff = f_pl->cfg.actual_ckbits_sec - f_pl->cfg.ckbits_sec;
            sal_memcpy (curr_scache_ptr, &kbits_diff, sizeof (uint16));
            fc->scache_pos  += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);

            kbits_diff = f_pl->cfg.actual_ckbits_burst - f_pl->cfg.ckbits_burst;
            sal_memcpy (curr_scache_ptr, &kbits_diff, sizeof (uint16));
            fc->scache_pos  += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);

            kbits_diff = f_pl->cfg.actual_pkbits_sec - f_pl->cfg.pkbits_sec;
            sal_memcpy (curr_scache_ptr, &kbits_diff, sizeof (uint16));
            fc->scache_pos  += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);

            kbits_diff = f_pl->cfg.actual_pkbits_burst - f_pl->cfg.pkbits_burst;
            sal_memcpy (curr_scache_ptr, &kbits_diff, sizeof (uint16));
            fc->scache_pos  += sizeof (uint16);
            curr_scache_ptr += sizeof (uint16);
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *  _field_entry_policer_delta_rates_recover
 *
 * Purpose:
 *  Recover the synced delta rates of the policer hardware and
 *  configured values.
 *
 * Parameters:
 *  unit  - (IN) BCM device number.
 *  fc - (IN) Field control structure.
 *  stage_fc - (IN) Field stage control structure.
 *  scache_ptr - (IN) Scache Pointer
 *  f_ent_policer_wb - (IN) Warmboot field entry policer structure.
 *  pol_present - (IN) Level 0 policer is present
 *  pol_present1 - (IN) Level 1 policer is present
 */

int _field_entry_policer_delta_rates_recover (int unit, _field_control_t *fc,
        _field_stage_t *stage_fc, uint8 *scache_ptr,
        _field_entry_policer_wb_t *f_ent_policer_wb,
        uint8 pol_present, uint8 pol_present1)
{
    uint8 *curr_scache_ptr = scache_ptr; /* Scache Pointer */

    if ((fc == NULL) || (stage_fc == NULL)
            || (scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS)
            && (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_NONE;
    }

    if (f_ent_policer_wb == NULL) {
        return BCM_E_PARAM;
    }

    if (pol_present) {
        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[0][0]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[0][1]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[0][2]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[0][3]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);
    }

    if (pol_present1) {
        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[1][0]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[1][1]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[1][2]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);

        sal_memcpy (&(f_ent_policer_wb->policer_delta_rates[1][3]),
                    curr_scache_ptr, sizeof(uint16));
        fc->scache_pos  += sizeof (uint16);
        curr_scache_ptr += sizeof (uint16);
    }
    return BCM_E_NONE;
}

int
_field_tr2_group_entry_write(int unit, int instance, int slice_idx,
                             _field_slice_t *fs, _field_control_t *fc,
                             _field_stage_t *stage_fc)
{
    int qset_count, ratio, idx, prev_prio, multigroup, master_slice;
    uint8 stat_present, pol_present, prio_ctrl, pol_present1;
    uint8 group_auto_expansion = 0, next_group_valid = 0;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    _field_group_t *fg;
    _field_entry_t *f_ent;
    bcm_port_t port;
    bcm_field_qualify_t q;
    bcm_pbmp_t port_cmic_pbmp;
    _field_slice_t *temp_fs = fs;
    _field_entry_oam_wb_t *f_ent_oam_wb = NULL;
    int rv = BCM_E_NONE;
    uint8 color_independent = 0;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT) \
    || defined(BCM_HURRICANE3_SUPPORT)
    _field_stat_t  *f_st;
    int flex_mode=0;
    int hw_flags=0;
    uint8 flex_stat_map=0;
#endif
    uint8 *count = NULL;
    _field_stage_t *ingress_stage_fc = NULL;
    uint8 max_udf_count = 0;
    uint8 udf_idx;
    int part_idx;
    int parts_cnt;
    uint8 group_flags = 0;

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                _BCM_FIELD_STAGE_INGRESS, &ingress_stage_fc));

    if (ingress_stage_fc->data_ctrl) {
        max_udf_count = ingress_stage_fc->data_ctrl->num_elems * 2;
    }

    SOC_PBMP_ASSIGN(port_cmic_pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_OR(port_cmic_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &port_cmic_pbmp);
    }
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &port_cmic_pbmp));
    }
#endif

    /* Check for multiple groups in a slice */
    if (SOC_PBMP_EQ(fs->pbmp, port_cmic_pbmp)) {
        multigroup = 0;
    } else {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync:   Multigroup.\n")));
        multigroup = 1;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWKX(unit) &&
        stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
       multigroup = 0;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                          "_field_scache_sync: Writing slice %d @ byte %d...\n"),
               slice_idx, fc->scache_pos));

    buf[fc->scache_pos] = (slice_idx << 1) | multigroup;
    fc->scache_pos++;

    /* Get the master slice if expanded */
    master_slice = slice_idx;
    while (temp_fs->prev != NULL) {
        temp_fs = temp_fs->prev;
        master_slice = temp_fs->slice_number;
    }

    /* Traverse all groups and dump group data for this slice */
    fg = fc->groups;
    while (fg != NULL) {
        if ((fg->instance != instance) ||
            (fg->stage_id != stage_fc->stage_id) ||
            (fg->slices[0].slice_number != master_slice)) {
            fg = fg->next;
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                      "_field_scache_sync:   No match on group %d.\n"),
                       fg->gid));
            continue; /* Not in this stage */
        }

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "_field_scache_sync:   Match on group %d...\n"),
                   fg->gid));

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "_field_scache_sync:   Writing group %d @ byte %d...\n"),
                   fg->gid, fc->scache_pos));

        if (BCM_PBMP_IS_NULL(fg->pbmp)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP WB Group Sync failed: At least one port has to be"
                                " part of group's pbmp with GID :[%d] for successful warmboot \n"),
                     fg->gid));
            return BCM_E_CONFIG;
        }

        SOC_PBMP_ITER(fg->pbmp, port) {
            break; /* Pick first port found as representative */
        }

        if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
            /* Save long GID */

            buf[fc->scache_pos] = fg->gid;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 8;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 16;
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 24;
            fc->scache_pos++;
        } else {
            /* Save compact GID */

            buf[fc->scache_pos] = fg->gid; /* GID_lo */
            fc->scache_pos++;
            buf[fc->scache_pos] = fg->gid >> 8; /* GID_hi */
            fc->scache_pos++;
        }
        buf[fc->scache_pos] = port;        /* Rep_port */
        fc->scache_pos++;

        if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_21) {
            int i = 0;
            for (i = 0; i < _SHR_PBMP_WORD_MAX; i++) {
                buf[fc->scache_pos] = fg->pbmp.pbits[i];
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = fg->pbmp.pbits[i] >> 24;
                fc->scache_pos++;
            }
        }
        /* Write group priority */
        buf[fc->scache_pos] = fg->priority;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->priority >> 24;
        fc->scache_pos++;

        /* Write group action res id */
        buf[fc->scache_pos] = fg->action_res_id;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 8;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 16;
        fc->scache_pos++;
        buf[fc->scache_pos] = fg->action_res_id >> 24;
        fc->scache_pos++;

        /* Obtain list of qualifiers in fg->qset */
        qset_count = 0;
        _FIELD_QSET_ITER(fg->qset, q) {
            qset_count++;
        }

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "Before Writing qset count (%d) @ byte s_pos=%d s_pos1=%d...\n\r"),
                qset_count, fc->scache_pos, fc->scache_pos1));

        buf[fc->scache_pos] = qset_count; /* qset_count */
        fc->scache_pos++;
        _FIELD_QSET_ITER(fg->qset, q) {
            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "_field_scache_sync:  Writing qid %d @ byte %d...\n"),
                  q, fc->scache_pos));

            buf[fc->scache_pos] = q; /* QID */
            fc->scache_pos++;
            if(NULL != buf1) {
                buf1[fc->scache_pos1] = q >> 8;
                fc->scache_pos1++;
            }
        }

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "After Writing qset count (%d) @ byte s_pos=%d s_pos1=%d...\n\r"),
                qset_count, fc->scache_pos, fc->scache_pos1));

        count = &buf[fc->scache_pos];
        fc->scache_pos++;
        *count = 0;

        for (q = bcmFieldQualifyCount; q < ((int)_bcmFieldQualifyCount); q++) {
            if (BCM_FIELD_QSET_TEST(fg->qset, q)) {
                buf[fc->scache_pos] = q - bcmFieldQualifyCount;
                fc->scache_pos++;
                if(NULL != buf1) {
                    buf1[fc->scache_pos1] = (q - bcmFieldQualifyCount) >> 8;
                    fc->scache_pos1++;
                }
                *count = *count + 1;
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "_field_scache_sync:     Writing internal qid idx %d @ byte %d...\n"),
                            q, fc->scache_pos - 1));
            }
        }
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "_field_scache_sync:   Writing internal qset count (%d) @ byte %d...\n"),
                    *count, fc->scache_pos - 1 - *count));

        count = &buf[fc->scache_pos];
        fc->scache_pos++;
        *count = 0;

        for (udf_idx = 0; udf_idx < max_udf_count ; udf_idx++) {
            if (SHR_BITGET(fg->qset.udf_map, udf_idx)) {
                buf[fc->scache_pos] = udf_idx;
                fc->scache_pos++;
                *count = *count + 1;
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "_field_scache_sync:     Writing UDF idx %d @ byte %d...\n"),
                            udf_idx, fc->scache_pos - 1));
            }
        }
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "Writing udf count (%d) @ byte s_pos=%d...\n\r"),
                *count, fc->scache_pos - 1 - *count));

        /* Sync EFP KEY info */
        if (((SOC_IS_TRIDENT2X(unit) &&
             ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15)) ||
             ((SOC_IS_TITAN2PLUS(unit) ||
              soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
              ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_16)))
               && (fg->stage_id == _BCM_FIELD_STAGE_EGRESS)) {

            buf[fc->scache_pos] = fg->sel_codes[0].fpf3 & 0xf;
            if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                buf[fc->scache_pos] |= (fg->sel_codes[1].fpf3 & 0xf) << 4;
            }
            fc->scache_pos++;
            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                   "Writing EFP KEY Info @ byte s_pos=%d...\n\r"),
                    fc->scache_pos - 1));
        }

        if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
            if ((fg->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                   (fg->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
                parts_cnt = 0;
                BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                        fg->flags, &parts_cnt));
                /* Sync Group part count  for ingress and src entity sel sync */
                buf[fc->scache_pos] = parts_cnt;
                fc->scache_pos++;
                for (part_idx = 0; part_idx < parts_cnt; part_idx++) {
                    if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                        buf[fc->scache_pos] = fg->sel_codes[part_idx].ingress_entity_sel;
                        fc->scache_pos++;
                        buf[fc->scache_pos] = fg->sel_codes[part_idx].dst_fwd_entity_sel;
                        fc->scache_pos++;
                    }
                    buf[fc->scache_pos] = fg->sel_codes[part_idx].src_entity_sel;
                    fc->scache_pos++;
                }
            }
        }

        if (fg->flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
            group_auto_expansion = _FIELD_GROUP_AUTO_EXPANSION;
        } else {
            group_auto_expansion = 0;
        }

        group_flags = 0;

        if (fg->flags & _FP_GROUP_LOOKUP_ENABLED) {
            group_flags |= _FIELD_GROUP_LOOKUP_ENABLED;
        }

        if (fg->flags & _FP_GROUP_WLAN) {
            group_flags |= _FIELD_GROUP_WLAN;
        }

        /* Next group not valid */
        next_group_valid = 0x0;
        fg = fg->next;
        while (fg != NULL) {
            if (multigroup
                    && (fg->stage_id == stage_fc->stage_id)
                    && (fg->slices[0].slice_number == master_slice)) {
                /* Next group valid */
                next_group_valid = _FIELD_GROUP_NEXT_GROUP_VALID;
                break;
            }
            fg = fg->next;
        }

        /*
         * In this byte, 6 bits are used as below
         * bit 0 --  to indicate wheather next group
         *           in this slice is valid or not
         * bit 1,2 -- contains group's instance.
         * bit 5 --  to indicate group lookup enable status.
         * bit 6 --  to indicate group is WLAN.
         * bit 7 --  to indicate group auto expansion status.
         */

        buf[fc->scache_pos] = (group_auto_expansion | next_group_valid | group_flags);

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(): Writing group_auto_exp:%d and"
                 " next_group_valid:%d @ byte %d...\n\r"),
             __func__, group_auto_expansion, next_group_valid, fc->scache_pos));
        /*
         * Write instance at 1st bit position of the same byte
         */
        buf[fc->scache_pos] |= ((instance << 1) & 0x6);

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(): Writing instance:%d @ byte %d...\n\r"),
                 __func__, instance, fc->scache_pos));
        fc->scache_pos++;
    }

    /* Traverse all entries and dump entry data for this slice */
    if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
        ratio = 2;
    } else {
        ratio = 1;
    }
    prev_prio = -1;

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(%d): Before Entry write instance:%d @ byte %d...\n\r"),
                 __func__, __LINE__,instance, fc->scache_pos));

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(%d): Slice Info: id %d entry count %d ratio %d...\n\r"),
                 __func__, __LINE__, fs->slice_number, fs->entry_count, ratio));

    for (idx = 0; idx < fs->entry_count / ratio; idx++) {
        /* Find EID that matches this HW index */
        f_ent = fs->entries[idx];
        if (f_ent == NULL) {
            continue;
        }
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "%s(%d): Before Entry write idx %d @ byte %d...\n\r"),
                    __func__, __LINE__, f_ent->eid, fc->scache_pos));
        if (f_ent->flags & _FP_ENTRY_INSTALLED) {
            prio_ctrl = (f_ent->prio != prev_prio) ? 1 : 0;
            stat_present = (f_ent->statistic.flags &
                            _FP_ENTRY_STAT_INSTALLED) ? 1 : 0;
            pol_present = (f_ent->policer[0].flags &
                           _FP_POLICER_INSTALLED) ? 1 : 0;
            pol_present1 = (f_ent->policer[1].flags &
                           _FP_POLICER_INSTALLED) ? 1 : 0;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT) \
    || defined(BCM_HURRICANE3_SUPPORT)
            if ((stat_present)  &&
                (((soc_feature(unit, soc_feature_advanced_flex_counter) ||
                 soc_feature(unit, soc_feature_field_vfp_flex_counter) ||
                 soc_feature(unit, soc_feature_flowcnt)) &&
                (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
                (soc_feature(unit, soc_feature_advanced_flex_counter) &&
                (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id)))) {
                BCM_IF_ERROR_RETURN(_bcm_field_stat_get(
                                    unit, f_ent->statistic.sid, &f_st));
                flex_mode  = f_st->flex_mode;
                hw_flags  = f_st->hw_flags;
                switch(f_st->nstat) {
                case 1:if(f_st->stat_arr[0] == bcmFieldStatBytes) {
                          flex_stat_map = 1;
                       } else {
                          flex_stat_map = 2;
                       }
                       break;
                case 2:
                default: /* Although 0-and-default cases are invalid */
                       flex_stat_map=3;
                       break;
                }
            }
#endif
            if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                /* Save long EID */

                buf[fc->scache_pos] = f_ent->eid;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->eid >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->eid >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->eid >> 24;
                fc->scache_pos++;

                buf[fc->scache_pos] = prio_ctrl
                    | (stat_present << 1)
                    | (pol_present << 2);
                fc->scache_pos++;

            } else {
                /* Save compact EID */

                buf[fc->scache_pos] = f_ent->eid & 0xFF; /* EID_lo */
                fc->scache_pos++;
                buf[fc->scache_pos] = ((f_ent->eid >> 8) & 0x1F) | (prio_ctrl << 5) |
                    (stat_present << 6) | (pol_present << 7);
                /* EID_hi + control bits */
                fc->scache_pos++;
            }

            if (multigroup) {
                /* Multiple groups in slice => Save id of group entry belongs to */

                if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                    /* Save complete GID */

                    buf[fc->scache_pos] = f_ent->group->gid;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->group->gid >> 8;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->group->gid >> 16;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->group->gid >> 24;
                    fc->scache_pos++;
                } else {
                    /* Save compact GID */

                    buf[fc->scache_pos] = f_ent->group->gid; /* GID_lo */
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->group->gid >> 8; /* GID_hi */
                    fc->scache_pos++;
                }
            }
            if (prio_ctrl) {
                /* 32-bit priority is written */
                buf[fc->scache_pos] = f_ent->prio & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (f_ent->prio >> 8) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (f_ent->prio >> 16) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (f_ent->prio >> 24) & 0xFF;
                fc->scache_pos++;
                prev_prio = f_ent->prio;
            }

            /* Write policer and stat object IDs if present */

            if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
                /* Save complete policer and stat ids */

                if (pol_present) {
                    buf[fc->scache_pos] = f_ent->policer[0].pid;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->policer[0].pid >> 8;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->policer[0].pid >> 16;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->policer[0].pid >> 24;
                    fc->scache_pos++;
                }

                if (stat_present) {
                    buf[fc->scache_pos] = f_ent->statistic.sid;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->statistic.sid >> 8;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->statistic.sid >> 16;
                    fc->scache_pos++;
                    buf[fc->scache_pos] = f_ent->statistic.sid >> 24;
                    fc->scache_pos++;
                }
            } else {
                /* Save compact policer and stat ids */

                if (pol_present) {
                    buf[fc->scache_pos] = (f_ent->policer[0].pid) & 0xFF;
                    fc->scache_pos++;
                }
                if (stat_present) {
                    if (pol_present) {
                        buf[fc->scache_pos] =
                            (((f_ent->policer[0].pid >> 8) & 0xF) << 4) |
                            (f_ent->statistic.sid & 0xF);
                        fc->scache_pos++;
                    } else {
                        buf[fc->scache_pos] = f_ent->statistic.sid & 0xF;
                        fc->scache_pos++;
                    }
                    buf[fc->scache_pos] = (f_ent->statistic.sid >> 4) & 0xFF;
                    fc->scache_pos++;
                } else if (pol_present) {
                    buf[fc->scache_pos] =
                        ((f_ent->policer[0].pid >> 8) & 0xF) << 4;
                    fc->scache_pos++;
                }
            }

            parts_cnt = 0;
            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
                if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) ||
                        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
                    /* Sync entry part count for SVP & DVP type */
                    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                                f_ent->group->stage_id, f_ent->group->flags,
                                &parts_cnt));

                    buf[fc->scache_pos] = parts_cnt;
                    fc->scache_pos++;
                }
            }

            /* Save Dvp Type */
            buf[fc->scache_pos] = f_ent->dvp_type;
            fc->scache_pos++;
            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
                for (part_idx = 1; part_idx < parts_cnt; part_idx++) {
                    buf[fc->scache_pos] = f_ent[part_idx].dvp_type;
                    fc->scache_pos++;
                }
            }

            /* Save SVP Type */
            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_16) {
                buf[fc->scache_pos] = f_ent->svp_type;
                fc->scache_pos++;
            }
            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_18) {
                for (part_idx = 1; part_idx < parts_cnt; part_idx++) {
                    buf[fc->scache_pos] = f_ent[part_idx].svp_type;
                    fc->scache_pos++;
                }
            }

#if defined(BCM_APACHE_SUPPORT)
            if (SOC_IS_APACHE(unit))  {
                BCM_IF_ERROR_RETURN(_field_apache_entry_info_sync(unit,
                            fc, stage_fc, f_ent));
            }
#endif


#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT) \
    || defined(BCM_HURRICANE3_SUPPORT)
            if ((stat_present)  &&
                (((soc_feature(unit, soc_feature_advanced_flex_counter) ||
                 (((fc->wb_current_version)
                   >= BCM_FIELD_WB_VERSION_1_12) &&
                 soc_feature(unit, soc_feature_field_vfp_flex_counter)) ||
                 soc_feature(unit, soc_feature_flowcnt)) &&
                (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
                (soc_feature(unit, soc_feature_advanced_flex_counter) &&
                (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) &&
                ((fc->wb_current_version)
                 >= BCM_FIELD_WB_VERSION_1_14)))) {
                buf[fc->scache_pos] = flex_mode;
                fc->scache_pos++;
                buf[fc->scache_pos] = flex_mode >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = flex_mode >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = flex_mode >> 24;
                fc->scache_pos++;
                buf[fc->scache_pos] = hw_flags;
                fc->scache_pos++;
                buf[fc->scache_pos] = hw_flags >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = hw_flags >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = hw_flags >> 24;
                fc->scache_pos++;
                buf[fc->scache_pos] = flex_stat_map;
                fc->scache_pos++;
           }
#endif

            if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS)
                   || (((fc->wb_current_version)
                   >= BCM_FIELD_WB_VERSION_1_11) &&
                   (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
                _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                        "Field Entry Warmboot");
                if (f_ent_oam_wb == NULL) {
                    return BCM_E_MEMORY;
                }
#if defined BCM_TRIDENT2PLUS_SUPPORT
                if (soc_feature(unit, soc_feature_fp_based_oam)) {
                    rv = _field_oam_stat_action_scache_sync
                                          (unit, stage_fc, f_ent, f_ent_oam_wb);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        return rv;
                    }
                }

                if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) {
                    rv = _field_extended_stat_scache_sync (unit, stage_fc,
                            f_ent, f_ent_oam_wb);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        return rv;
                    }
                }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
                /* Writing f_ent_oam_wb in Scache */
                rv = _field_entry_oam_wb_scache_sync (unit, fc,
                        stage_fc, &buf[fc->scache_pos], f_ent_oam_wb);
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    return rv;
                }
            }
            {
                if ((fc->wb_current_version)
                    >= BCM_FIELD_WB_VERSION_1_13) {
                   /* Save Entry Color independent flag */
                   color_independent = (f_ent->flags &
                           _FP_ENTRY_COLOR_INDEPENDENT) ? 1 : 0;
                }
                if ((fc->wb_current_version)
                    < BCM_FIELD_WB_VERSION_1_15) {
                    pol_present1 = 0;
                }

                if ((fc->wb_current_version)
                    >= BCM_FIELD_WB_VERSION_1_13) {
                buf[fc->scache_pos] = ((color_independent << 7)
                                      | (pol_present1 << 6));
                fc->scache_pos++;
                }
            }

            if (pol_present1) {
                buf[fc->scache_pos] = f_ent->policer[1].pid;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->policer[1].pid >> 8;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->policer[1].pid >> 16;
                fc->scache_pos++;
                buf[fc->scache_pos] = f_ent->policer[1].pid >> 24;
                fc->scache_pos++;
            }

            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
                rv = _field_entry_no_param_actions_scache_sync(unit, stage_fc,
                                                               fc, f_ent, buf);
            }
            if (BCM_FAILURE(rv)) {
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                return rv;
            }

            if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_17) {
                if (pol_present || pol_present1) {
                    rv = _field_entry_policer_delta_rates_sync (unit, fc,
                            stage_fc, &buf[fc->scache_pos], f_ent);
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                }
            }

            /* Free the f_ent_oam_wb structure since it has been
             * written in scache */
            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
        }

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "%s(%d): After Entry write idx %d @ byte %d...\n\r"),
                    __func__, __LINE__,f_ent->eid, fc->scache_pos));
    }
    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(%d): After Entry write instance:%d @ byte %d...\n\r"),
                 __func__, __LINE__,instance, fc->scache_pos));
    /* Mark next slice valid */
    return BCM_E_NONE;
}

/*
 * This function manages the Level 2 warm boot cache. The data will be stored
 * in the following format:
 * Start indicator (32 bits): Value = IFP/EFP/VFP
 *
 * Range check IDs (IFP)
 * 8-bit ID count (1 uint8)
 * ID0 (4 x uint8)
 * .
 * IDN (4 x uint8)
 *
 * Data qualifier data, as follows:
 * If the device has a FP_UDF_TCAM, the following is present, for each TCAM entry:
 * 8-bit TCAM entry reference count (1 uint 8)
 * Followed by:
 * 8-bit data qualifier count (1 uint 8)
 * 32-bit data qualifier id (1 int)
 * 2-bit "length remainder" | 3-bit flags | 3-bit offset base (1 uint 8)
 * 16-bit data qualifier match-data offset (1 uint 16)
 * 16-bit hw_bmap field of data qualifier
 *   (Note that this field is linked to the hardware; namely, the width of this
 *   bitmap is the number of UDF n-byte chunks supported, i.e. the number of
 *   "columns" in the UDF_OFFSET table.)
 *
 * Group/entry data
 * Slice num (5 bits) | Multigroup slice indicator (1 bit): (1 uint8)
 * GID_lo (8 bits): (1 uint 8)
 * GID_hi (8 bits): (1 uint 8)
 * Representative_port (8 bits): (1 uint 8)
 * Group priority (32 bits): (4 uint 8)
 * Qualifier count (8 bits): (1 uint 8)
 * QID 1 (8 bits): (1 uint 8)
 * .
 * QID N (8 bits): (1 uint 8)
 * Next_group_valid (1 bit) | Reserved (7 bits): (1 uint 8)
 *
 * Groups are immediately followed by entries, which can have one of the
 * following two formats depending on the multigroup slice indicator:
 * Long format:
 * 8 bit EID_lo: (1 uint 8)
 * 5 bit EID_hi | priority_ctrl (1 bit) | Policer (1 bit) | Stat (1 bit):
  (1 uint 8)
 * 8 bit GID_lo: (1 uint 8)
 * 8 bit GID_hi: (1 uint 8)
 * priority_0: (1 uint 8)
 * priority_1: (1 uint 8) <---- The 32-bit priority is stored only if it is
 * priority_2: (1 uint 8)       different from the entry before it.
 * priority_3: (1 uint 8)
 * PID_lo (8 bits): (1 uint8)
 * PID_hi (4 bits) | SID_lo (4 bits): (1 uint8)
 * SID_hi (4 bits): (1 uint 8)
 * Short format:
 * 8 bit EID_lo: (1 uint 8)
 * 5 bit EID_hi | priority_ctrl (1 bit) | Policer (1 bit) | Stat (1 bit):
  (1 uint 8)
 * priority_0: (1 uint 8)
 * priority_1: (1 uint 8) <---- The 32-bit priority is stored only if it is
 * priority_2: (1 uint 8)       different from the entry before it.
 * priority_3: (1 uint 8)
 * PID_lo (8 bits): (1 uint8)
 * PID_hi (4 bits) | SID_lo (4 bits): (1 uint8)
 * SID_hi (8 bits): (1 uint 8)
 * End indicator (32 bits): Value = IFP/EFP/VFP
 */

STATIC int
_field_tr2_ext_scache_sync_chk(int              unit,
                               _field_control_t *fc,
                               _field_stage_t   *stage_fc
                               );
STATIC int
_field_tr2_ext_scache_sync(int              unit,
                           _field_control_t *fc,
                           _field_stage_t   *stage_fc
                           );

/* Function: _field_egr_ports_recovery_scache_recover
 *
 * Purpose:
 *     Recover EgressPortBitmap Database from scache
 * Parameters:
 *          unit - BCM device number
 *            fc - Field Control
 *      stage_fc - Stage Control
 *    scache_ptr - Scache Pointer.

 * Returns:
       BCM_E_NONE - Success
 */
int _field_egr_ports_recovery_scache_recover (int              unit,
                                          _field_control_t *fc,
                                          _field_stage_t   *stage_fc,
                                          uint8 *scache_ptr)
{
    int entryCnt = 0;
    int entryId = 0;
    int idx = 0;
    bcm_pbmp_t egrPortsPbmp;
    uint8 *currScachePtr = scache_ptr;

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        /* Recover Entry Count */
        sal_memcpy (&entryCnt, currScachePtr, sizeof (int));
        entryCnt = entryCnt - (stage_fc->tcam_slices * 2);
        fc->scache_pos += sizeof (int);
        currScachePtr += sizeof (int);

        /* Recover Entry Id, egrPortPbmp and add it to
           egr_ports_pbm_recovery database */
        for (idx = 0 ; idx < entryCnt; idx++) {
            /* Recover Entry Id*/
            sal_memcpy (&entryId, currScachePtr, sizeof (bcm_field_entry_t));
            fc->scache_pos += sizeof (int);
            currScachePtr += sizeof (int);

            /* Recover EgressPortsAdd*/
            sal_memset (&egrPortsPbmp, 0, sizeof(bcm_pbmp_t));
            sal_memcpy (&egrPortsPbmp, currScachePtr, sizeof(bcm_pbmp_t));
            fc->scache_pos += sizeof (bcm_pbmp_t);
            currScachePtr += sizeof (bcm_pbmp_t);

            /* Add to redirect_pbm_recovery database*/
           _bcm_trx_field_egr_ports_recovery_add (unit, entryId, egrPortsPbmp);
        }
    }
    return BCM_E_NONE;
}

/* Function: _field_egr_ports_recovery_scache_sync
 *
 * Purpose:
 *     Sync Recover EgressPortBitmap Database from scache
 * Parameters:
 *          unit - BCM device number
 *            fc - Field Control
 *      stage_fc - Stage Control
 *    scache_ptr - Scache Pointer.

 * Returns:
       BCM_E_NONE - Success
 */
int _field_egr_ports_recovery_scache_sync(int unit,
                                           _field_control_t *fc,
                                           _field_stage_t   *stage_fc,
                                           uint8 *scache_ptr)
{
    _field_egr_ports_entry_ids_list_t *entryIds = NULL;
    _field_egr_ports_entry_ids_list_t *eId = NULL;
    int entryCnt = 0;
    int entryCntSync = 0;
    uint8 *curr_scache_ptr = scache_ptr;
    int idx = 0;

    /* Get entry count and list of entries where
       EgressPortsAdd action is configured*/
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {

        _bcm_trx_field_egr_ports_recovery_entry_ids_list_get (unit,
                                                        &entryIds, &entryCnt);
        eId = entryIds;

        /* Bumping up the entryCnt by
         * (stage_fc->tcam_slices * 2) during sync and must be
         * subracted during recovery.
         * This is done for the following reason :-
         * When no groups are installed,the last scache buf[fc->scache_pos]
         * value is 0xEF.
         * The _field_trx_scache_slice_group_recover function (last recovery
         * function) expects the buf[fc->scache_pos] value as
         * (slice_number * 2) or 0xEF as valid group number
         * and tries to recover  entries based on those values.
         * This leads to undefined behaviour.
         * Hence the values are bumped up by (2 * maximum tcam) slices
         */

        entryCntSync = (stage_fc->tcam_slices * 2) +  entryCnt;

        /* Sync Entry Count followed by Entry Id and corresponding
         * EgressPortsAdd */
        sal_memcpy (curr_scache_ptr, &entryCntSync, sizeof (int));
        fc->scache_pos += sizeof (int);
        curr_scache_ptr += sizeof (int);

        for (idx = 0 ; idx < entryCnt; idx++) {
            if (eId == NULL) {
                return BCM_E_INTERNAL;
            }
            /* Sync EntryId*/
            sal_memcpy (curr_scache_ptr, &(eId->eid),
                    sizeof (bcm_field_entry_t));
            fc->scache_pos += sizeof (int);
            curr_scache_ptr += sizeof (int);

            /* Sync EgressPortsAdd */
            sal_memcpy (curr_scache_ptr, &(eId->egr_ports_pbmp),
                         sizeof(bcm_pbmp_t));
            fc->scache_pos += sizeof (bcm_pbmp_t);
            curr_scache_ptr += sizeof (bcm_pbmp_t);

            eId = eId->next;
        }

        _bcm_trx_field_egr_ports_recovery_entry_list_destroy (unit, &entryIds);
    }
    return BCM_E_NONE;
}

int
_field_tr2_scache_sync(int              unit,
                       _field_control_t *fc,
                       _field_stage_t   *stage_fc
                       )
{
    int slice_idx, range_count = 0;
    int rv = BCM_E_NONE;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    _field_slice_t *fs;
    _field_group_t *fg;
    uint32 start_char, end_char;
    soc_field_t fld;
    int efp_slice_mode, paired = 0;
    uint32 val;
    fp_port_field_sel_entry_t pfs;
    _field_data_control_t *data_ctrl;
    _field_range_t *fr;
    int ratio = 0;
    int idx;
    _field_entry_t *f_ent;
    uint64 val64;

    soc_field_t _fb2_slice_pairing_field[8] = {
        SLICE1_0_PAIRINGf,   SLICE3_2_PAIRINGf,
        SLICE5_4_PAIRINGf,   SLICE7_6_PAIRINGf,
        SLICE9_8_PAIRINGf,   SLICE11_10_PAIRINGf,
        SLICE13_12_PAIRINGf, SLICE15_14_PAIRINGf};
    soc_field_t _efp_slice_mode[] = {SLICE_0_MODEf, SLICE_1_MODEf,
                                     SLICE_2_MODEf, SLICE_3_MODEf};

    switch (stage_fc->stage_id) {
    case _BCM_FIELD_STAGE_INGRESS:
        start_char = _FIELD_IFP_DATA_START;
        end_char = _FIELD_IFP_DATA_END;
        break;
    case _BCM_FIELD_STAGE_EGRESS:
        start_char = _FIELD_EFP_DATA_START;
        end_char = _FIELD_EFP_DATA_END;
        break;
    case _BCM_FIELD_STAGE_LOOKUP:
        start_char = _FIELD_VFP_DATA_START;
        end_char = _FIELD_VFP_DATA_END;
        break;
    case _BCM_FIELD_STAGE_EXTERNAL:
        if (_field_tr2_ext_scache_sync_chk(unit, fc, stage_fc)) {
            return (_field_tr2_ext_scache_sync(unit, fc, stage_fc));
        }
        start_char = _FIELD_EXTFP_DATA_START;
        end_char   = _FIELD_EXTFP_DATA_END;
        break;
    default:
        return BCM_E_PARAM;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "_field_scache_sync: Synching scache for FP stage %d...\n"),
               stage_fc->stage_id));

    _field_scache_stage_hdr_save(fc, start_char);

    /* Save the range check IDs */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {

        fr = stage_fc->ranges;
        while (fr) {
            fr = fr->next;
            range_count++;
        }
        buf[fc->scache_pos] = (uint8)range_count;
        fc->scache_pos++;
        if (range_count) {
            fr = stage_fc->ranges;
            while (fr) {
                buf[fc->scache_pos] = fr->rid & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 8) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 16) & 0xFF;
                fc->scache_pos++;
                buf[fc->scache_pos] = (fr->rid >> 24) & 0xFF;
                fc->scache_pos++;
                fr = fr->next;
            }
        }

        /* Sync Hints information */
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"Syncing hints @pos= %d\r\n"),
                                                    fc->scache_pos));
            BCM_IF_ERROR_RETURN (_bcm_field_hints_scache_sync(unit,
                        fc, stage_fc, &buf[fc->scache_pos]));
        }

       /* Write data qual count */
        buf[fc->scache_pos] = (uint8)(bcmFieldQualifyCount >> 8);
        fc->scache_pos++;
        buf[fc->scache_pos] = (uint8)bcmFieldQualifyCount;
        fc->scache_pos++;

    }

    /* Save data qualifiers */

    if ((data_ctrl = stage_fc->data_ctrl) != 0) {
        if (soc_mem_is_valid(unit, FP_UDF_TCAMm)) {
            /* Device has UDF TCAM =>
               Save internal information regarding TCAM entry usage
            */

            _field_data_tcam_entry_t *p;
            unsigned                 n;

            for (p = data_ctrl->tcam_entry_arr,
                     n = soc_mem_index_count(unit, FP_UDF_TCAMm);
                 n;
                 --n, ++p
                 ) {
                buf[fc->scache_pos] = p->ref_count;
                fc->scache_pos++;
            }
        }

        _field_scache_sync_data_quals_write(fc, data_ctrl);
    }

    _field_slice_map_write(unit, fc, stage_fc);

    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "_field_scache_sync: Checking slice %d...\n"),
                   slice_idx));
        /* Skip slices without groups */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        fg = fc->groups;
        while (fg != NULL) {
            if (fg->stage_id != stage_fc->stage_id) {
                fg = fg->next;
                continue; /* Not in this stage */
            }
            if (fg->slices[0].slice_number == slice_idx) {
                break;
            }
            fg = fg->next;
        }
        if (fg == NULL) {
            continue; /* No group found */
        }
        /* Also skip expanded slices */
        if ((stage_fc->slices[_FP_DEF_INST] + slice_idx)->prev != NULL) {
            continue;
        }

        paired = 0;

        /* Ignore secondary slice in paired mode */
        switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            BCM_IF_ERROR_RETURN(soc_mem_read(unit, FP_PORT_FIELD_SELm,
                                             MEM_BLOCK_ANY, 0, &pfs));
            fld = _fb2_slice_pairing_field[slice_idx / 2];
            paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                        &pfs, fld);
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            BCM_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &val));
            efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr,
                                               val,_efp_slice_mode[slice_idx]);
            if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) {
                paired = 1;
            }
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
            if (SOC_IS_KATANA2(unit)) {
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROL_1r(unit, &val64));
                paired = soc_reg64_field32_get(unit, VFP_KEY_CONTROL_1r, val64, fld);
            } else {
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROLr(unit, &val));
                paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, val, fld);
            }
            break;
        case _BCM_FIELD_STAGE_EXTERNAL:
            paired = 0;
            break;
        default:
            return BCM_E_PARAM;
            break;
        }
        if (paired && (slice_idx % 2)) {
            continue;
        }
        BCM_IF_ERROR_RETURN
            (_field_tr2_group_entry_write(unit, _FP_DEF_INST, slice_idx,
                                          fs, fc, stage_fc));
    }

    /* Now sync the expanded slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        /* Skip empty slices */
        if (fs->entry_count == fs->free_count) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "_field_scache_sync:   Slice is empty.\n")));
            continue;
        }
        /* Skip master slices */
        if (stage_fc->slices[_FP_DEF_INST][slice_idx].prev == NULL) {
            continue;
        }

        /*
         * Skip expanded slices with no entries installed in Hw
         * to match recovery logic.
         */
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            ratio = 2;
        } else {
            ratio = 1;
        }

        for (idx = 0; idx < fs->entry_count / ratio; idx++) {
            /* Find EID that matches this HW index */
            f_ent = fs->entries[idx];
            if (f_ent == NULL) {
                continue;
            }
            if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
                continue;
            }
            break;
        }

        if (idx == (fs->entry_count / ratio)) {
            continue;
        }

        paired = 0;

        /* Ignore secondary slice in paired mode */
        switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            BCM_IF_ERROR_RETURN(soc_mem_read(unit, FP_PORT_FIELD_SELm,
                                             MEM_BLOCK_ANY, 0, &pfs));
            fld = _fb2_slice_pairing_field[slice_idx / 2];
            paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                        &pfs, fld);
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            BCM_IF_ERROR_RETURN(READ_EFP_SLICE_CONTROLr(unit, &val));
            efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr,
                                               val,_efp_slice_mode[slice_idx]);
            if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) {
                paired = 1;
            }
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
            if (SOC_IS_KATANA2(unit)) {
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROL_1r(unit, &val64));
                paired = soc_reg64_field32_get(unit, VFP_KEY_CONTROL_1r, val64, fld);
            } else {
                BCM_IF_ERROR_RETURN(READ_VFP_KEY_CONTROLr(unit, &val));
                paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, val, fld);
            }
            break;
        case _BCM_FIELD_STAGE_EXTERNAL:
            paired = 0;
            break;
        default:
            return BCM_E_PARAM;
            break;
        }
        if (paired && (slice_idx % 2)) {
            continue;
        }
        BCM_IF_ERROR_RETURN
            (_field_tr2_group_entry_write(unit, _FP_DEF_INST, slice_idx,
                                          fs, fc, stage_fc));
    }

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
       /* Mark end of Slice Info */
       buf[fc->scache_pos] = _FP_WB_END_OF_SLICES;
       fc->scache_pos++;
    }

    /* Sync EgressPortsAdd Workaround Information */
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        BCM_IF_ERROR_RETURN (_field_egr_ports_recovery_scache_sync
                (unit, fc, stage_fc, &buf[fc->scache_pos]));
    }

    if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
        if ( stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS ||
             stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS ||
             stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP
           ) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"FP(unit %d) vverb:"
                        "_bcm_field_td2_scache_sync() - section  Writing"
                        " HintIds information @ byte %d.\n"),
                        unit, fc->scache_pos));
            BCM_IF_ERROR_RETURN (_bcm_hints_scache_hintid_sync (unit, stage_fc,
                        &buf[fc->scache_pos]));
        }
    }

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
        /* Group Slice Selectors */
        BCM_IF_ERROR_RETURN(_field_group_slice_selectors_sync(unit,
                            &buf[fc->scache_pos], stage_fc->stage_id));
    }
    LOG_DEBUG(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                        "_field_scache_sync: Writing end of section @ byte %d.\n"),
             fc->scache_pos));

    /* Mark the end of the section */
    buf[fc->scache_pos] = end_char & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 8) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 16) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 24) & 0xFF;
    fc->scache_pos++;
    fc->scache_usage = fc->scache_pos; /* Usage in bytes */

    if(NULL != buf1) {
        /* Mark the end of the section */
        buf1[fc->scache_pos1] = end_char & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 8) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 16) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 24) & 0xFF;
        fc->scache_pos1++;
    }

    /* Check for overflow */
    if (fc->scache_pos > fc->scache_size[_FIELD_SCACHE_PART_0]) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: Current Scache Position[%u] exceeds Scache size[%u]\n"),
                 unit, fc->scache_pos, fc->scache_size[_FIELD_SCACHE_PART_0]));
        return BCM_E_INTERNAL;
    }

    if (buf1 != NULL) {
        if (fc->scache_pos1 > fc->scache_size[_FIELD_SCACHE_PART_1]) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Current Scache Position1[%u] exceeds Scache size[%u]\n"),
                     unit, fc->scache_pos1, fc->scache_size[_FIELD_SCACHE_PART_1]));
            return BCM_E_INTERNAL;
        }
    }

    return rv;
}


/* Retrieve all GIDs from a slice during Level 2 warm boot */
int
_field_trx_scache_slice_group_recover(int              unit,
                                      _field_control_t *fc,
                                      int              instance,
                                      int              slice_num,
                                      int              *multigroup,
                                      _field_stage_t   *stage_fc,
                                      int              recovered_count
                                      )
{
    int i, slice_idx;
    int next_group_valid;
    int rv = BCM_E_INTERNAL;
    int qset_count;
    int qset;
    bcm_field_group_t gid;
    int               priority;
    bcm_port_t port;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    _field_slice_group_info_t *new_grp;
    int vmap_size; /* Virtual map index count. */
    int action_res_id;
    int revert_scache_pos = 0;
    int revert_scache_pos1 = 0;
    soc_pbmp_t group_pbmp;
    uint8  udf_count = 0;
    uint8 udf_idx = 0;
    int8 part_idx;
    int8 parts_cnt;

    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit) ||
        SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit)) {
        return (_field_scache_slice_group_recover(unit,
                             fc, slice_num, multigroup));
    }

    revert_scache_pos = fc->scache_pos;
    revert_scache_pos1 = fc->scache_pos1;
    /* Parse the scache buffer to recover GIDs and QSETs */
    /* To be used in stage reinit */
    slice_idx = buf[fc->scache_pos] >> 1;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "Read slice index %d @ byte %d\n"),
               slice_idx, fc->scache_pos));
    if (multigroup) {
        *multigroup = buf[fc->scache_pos] & 0x1;
    }

    fc->scache_pos++;
    if (slice_idx != slice_num) {
        /* No groups stored for this slice */
        fc->scache_pos--;
        return BCM_E_NOT_FOUND;
    }
    fc->group_arr = NULL;

    /* Parse all the group data for this slice */
    do {
        SOC_PBMP_CLEAR(group_pbmp);
        if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
            /* Read long group id */

            gid = buf[fc->scache_pos];
            fc->scache_pos++;
            gid |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            gid |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            gid |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        } else {
            /* Read compact group id  */

            gid = buf[fc->scache_pos]; /* GID_lo */
            fc->scache_pos++;
            gid |= (buf[fc->scache_pos] << 8); /* GID_hi */
            fc->scache_pos++;
        }

        port = buf[fc->scache_pos]; /* Rep_port */
        fc->scache_pos++;

        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "Read group id %d @ %d.\n"),
                 gid, fc->scache_pos - 3));

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_21) {
            int i = 0;
            for (i = 0; i < _SHR_PBMP_WORD_MAX; i++) {
                group_pbmp.pbits[i] = buf[fc->scache_pos];
                fc->scache_pos++;
                group_pbmp.pbits[i] |= buf[fc->scache_pos] << 8;
                fc->scache_pos++;
                group_pbmp.pbits[i] |= buf[fc->scache_pos] << 16;
                fc->scache_pos++;
                group_pbmp.pbits[i] |= buf[fc->scache_pos] << 24;
                fc->scache_pos++;
            }
        }

        /* Read group priority */
        priority = 0;
        priority |= buf[fc->scache_pos];
        fc->scache_pos++;
        priority |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        priority |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        priority |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;

        /* Read group action res id */
        action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8) {
            action_res_id = 0;
            action_res_id |= buf[fc->scache_pos];
            fc->scache_pos++;
            action_res_id |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            action_res_id |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            action_res_id |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        }

        /* Add group info to temp linked list */
        new_grp = NULL;
        _FP_XGS3_ALLOC(new_grp, sizeof(_field_slice_group_info_t),
                       "Temp group info");
        if (NULL == new_grp) {
            return (BCM_E_MEMORY);
        }
        new_grp->gid = gid;
        new_grp->priority = priority;
        new_grp->action_res_id = action_res_id;
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_21) {
            SOC_PBMP_ASSIGN(new_grp->pbmp, group_pbmp);
        }
        BCM_PBMP_PORT_ADD(new_grp->pbmp, port);
        new_grp->next = fc->group_arr;
        fc->group_arr = new_grp;
        qset_count = buf[fc->scache_pos]; /* QSET_count */
        fc->scache_pos++;

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "Read qset count %d @ s_pos:%d s_pos1:%d.\n\r"),
                 qset_count, fc->scache_pos, fc->scache_pos1));

        for (i = 0; i < qset_count; i++) {
            qset = 0;
            qset = buf[fc->scache_pos];
            fc->scache_pos++;
            if(NULL != buf1) {
                qset |= buf1[fc->scache_pos1] << 8;
                fc->scache_pos1++;
            }
            if ((qset >= recovered_count) && (recovered_count!=0)) {
                qset = qset + (bcmFieldQualifyCount - recovered_count);
            }
            BCM_FIELD_QSET_ADD(new_grp->qset, qset);

            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "Read qualifier %d @ %d.\n"),
                       qset, fc->scache_pos - 1));
        }

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "After qset count %d @ s_pos:%d s_pos1:%d.\n\r"),
                 qset_count, fc->scache_pos, fc->scache_pos1));

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
            qset_count = buf[fc->scache_pos]; /* Internal QSET_count */
            fc->scache_pos++;

            LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "Read Internal Qset count %d @ s_pos=%d s_pos1=%d\n"),
                        qset_count, fc->scache_pos - 1 , fc->scache_pos1));

            for (i = 0; i < qset_count; i++) {
                qset = 0;
                qset |= buf[fc->scache_pos];
                fc->scache_pos++;
                if(NULL != buf1) {
                    qset |= buf1[fc->scache_pos1] << 8;
                    fc->scache_pos1++;
                }
                qset += bcmFieldQualifyCount;
                BCM_FIELD_QSET_ADD(new_grp->qset, qset);

                LOG_VERBOSE(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "Read internal qualifier %d @ %d.\n"),
                         qset, fc->scache_pos - 1));
            }

            LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "After Internal qset count %d @ s_pos=%d s_pos1=%d\n"),
                        qset_count, fc->scache_pos, fc->scache_pos1));

            udf_count = buf[fc->scache_pos];
            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "Read udf count %d @ s_pos:%d \n\r"),
                        udf_count, fc->scache_pos));
            fc->scache_pos++;
            for (i = 0; i < udf_count; i++) {
                udf_idx = buf[fc->scache_pos];
                fc->scache_pos++;
                SHR_BITSET(new_grp->qset.udf_map, udf_idx);
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "Read UDF idx %d  @ %d.\n"),
                            udf_idx, fc->scache_pos - 1));
            }
            LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "After UDF count %d @ s_pos=%d s_pos1=%d\n"),
                        udf_count, fc->scache_pos, fc->scache_pos1));
        }

        if (((SOC_IS_TRIDENT2X(unit) &&
                ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15)) ||
                ((SOC_IS_TITAN2PLUS(unit) ||
                 soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
                ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_16))) &&
                (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            new_grp->efp_pri_key = buf[fc->scache_pos] & 0xf;
            new_grp->efp_sec_key = (buf[fc->scache_pos] >> 4) & 0xf;
            LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "Reading EFP Key Info@ s_pos=%d s_pos1=%d\n"),
                        fc->scache_pos, fc->scache_pos1));
            fc->scache_pos++;
        }

        if (((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) &&
                ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                 (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP))) {
            /* Recover group parts count and src and ingress entity sel */
            parts_cnt = buf[fc->scache_pos];
            fc->scache_pos++;
            for (part_idx = 0; part_idx < parts_cnt; part_idx++) {
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                    new_grp->sel_ingress_entity[part_idx] = buf[fc->scache_pos];
                    fc->scache_pos++;
                    new_grp->sel_dst_fwd_entity[part_idx] = buf[fc->scache_pos];
                    fc->scache_pos++;
                }
                new_grp->sel_src_entity[part_idx] = buf[fc->scache_pos];
                fc->scache_pos++;
            }
        }

        /*
         * In this byte,
         * bit 0   --  to indicate wheather next group
         *             in this slice is valid or not
         * bit 1,2 -- represents group instance.
         * bit 5 --  to indicate group lookup enable status.
         * bit 6 --  to indicate group is WLAN.
         * bit 7   --  to indicate group auto expansion status.
         */
        next_group_valid =  buf[fc->scache_pos] & _FIELD_GROUP_NEXT_GROUP_VALID;

        if (buf[fc->scache_pos] & _FIELD_GROUP_AUTO_EXPANSION) {
            new_grp->flags = new_grp->flags | _FP_GROUP_SELECT_AUTO_EXPANSION;
        }

        if (buf[fc->scache_pos] & _FIELD_GROUP_LOOKUP_ENABLED) {
            new_grp->flags = new_grp->flags | _FP_GROUP_LOOKUP_ENABLED;
        }

        if (buf[fc->scache_pos] & _FIELD_GROUP_WLAN) {
            new_grp->flags = new_grp->flags | _FP_GROUP_WLAN;
        }

        new_grp->instance = ((buf[fc->scache_pos] >> 1) & 0x3);
        if (instance != new_grp->instance) {
           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
           "%s(): Inst[%d] retrieved is different from the input inst[%d]\n\r"),
           __func__, new_grp->instance, instance));
           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
           "%s(): revert_scache_pos:[%d] fc->scache_pos:[%d]\n\r"),
           __func__, revert_scache_pos, fc->scache_pos));
           fc->scache_pos = revert_scache_pos;
           fc->scache_pos1 = revert_scache_pos1;
           return BCM_E_NOT_FOUND;
        }

        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(): Recover instance:%d byte data:0x%x @ byte %d...\n"),
                 __func__, new_grp->instance, buf[fc->scache_pos],
                 fc->scache_pos));
        fc->scache_pos++;
    } while (next_group_valid);

    /* The pointer has now advanced to the "entries" section */

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
        "Done reading slice @ %d.\n"), fc->scache_pos));
    return rv;
}

int
_field_trx_entry_info_retrieve(int               unit,
                               _field_control_t  *fc,
                               _field_stage_t    *stage_fc,
                               int               multigroup,
                               int               *prev_prio,
                               _field_entry_wb_info_t *f_ent_wb_info
                               )
{
    uint8 stat_present, pol_present, prio_ctrl;
    uint8 pol_present1 = 0;   /* Level 1  policer present */
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8  part_index = 0;
    uint8  part_count = 0;
    _bcmFieldActionNoParam_t ingress_mirror_actions[] = {
                                    _bcmFieldActionNoParamMirrorIngress,
                                    _bcmFieldActionNoParamMirrorIngress1,
                                    _bcmFieldActionNoParamMirrorIngress2,
                                    _bcmFieldActionNoParamMirrorIngress3};
    _bcmFieldActionNoParam_t egress_mirror_actions[] = {
                                    _bcmFieldActionNoParamMirrorEgress,
                                    _bcmFieldActionNoParamMirrorEgress1,
                                    _bcmFieldActionNoParamMirrorEgress2,
                                    _bcmFieldActionNoParamMirrorEgress3};

    if (f_ent_wb_info == NULL) {
        return BCM_E_INTERNAL;
    }

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    for (part_index = 0; part_index < _FP_MAX_ENTRY_WIDTH; part_index++) {
        f_ent_wb_info->dvp_type[part_index] = _bcmVpTypeAny;
        f_ent_wb_info->svp_type[part_index] = _bcmVpTypeAny;
    }
#endif

    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit) ||
        SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit)) {
        return (_field_entry_info_retrieve(unit,
                                           fc, stage_fc,
                                           multigroup,
                                           prev_prio,
                                           f_ent_wb_info
                                           )
                );
    }

    f_ent_wb_info->eid = 0;
    f_ent_wb_info->sid = 0;
    f_ent_wb_info->pid = f_ent_wb_info->pid1 = 0;
    f_ent_wb_info->color_independent = (fc->flags & _FP_COLOR_INDEPENDENT) ? 1 : 0;

    if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
        /* Read long EID and flags */

        f_ent_wb_info->eid |=  buf[fc->scache_pos];
        fc->scache_pos++;
        f_ent_wb_info->eid |=  buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        f_ent_wb_info->eid |=  buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        f_ent_wb_info->eid |=  buf[fc->scache_pos] << 24;
        fc->scache_pos++;

        prio_ctrl = buf[fc->scache_pos] & 1;
        stat_present = (buf[fc->scache_pos] >> 1) & 1;
        pol_present = (buf[fc->scache_pos] >> 2) & 1;
        fc->scache_pos++;

    } else {
        /* Read compact EID and flags */

        f_ent_wb_info->eid |=  buf[fc->scache_pos]; /* EID_lo */
        fc->scache_pos++;
        f_ent_wb_info->eid |= (buf[fc->scache_pos] & 0x1F) << 8; /* EID_hi */
        prio_ctrl = (buf[fc->scache_pos] >> 5) & 0x1;
        stat_present = (buf[fc->scache_pos] >> 6) & 0x1;
        pol_present = (buf[fc->scache_pos] >> 7) & 0x1;
        fc->scache_pos++;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "Read entry id %d @ byte %d.\n"),
               f_ent_wb_info->eid, fc->scache_pos - 2));

    if (multigroup) {
        fc->scache_pos += (fc->flags & _FP_STABLE_SAVE_LONG_IDS) ? 4 : 2; /* Skip over GID */
    }

    if (prio_ctrl) {
        f_ent_wb_info->prio = 0;
        f_ent_wb_info->prio |= buf[fc->scache_pos];
        fc->scache_pos++;
        f_ent_wb_info->prio |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        f_ent_wb_info->prio |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        f_ent_wb_info->prio |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        *prev_prio = f_ent_wb_info->prio;
    } else {
        f_ent_wb_info->prio = *prev_prio;
    }

    if (fc->flags & _FP_STABLE_SAVE_LONG_IDS) {
        /* Read long policer and stat ids, if present */

        if (pol_present) {
            f_ent_wb_info->pid |= buf[fc->scache_pos];
            fc->scache_pos++;
            f_ent_wb_info->pid |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            f_ent_wb_info->pid |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            f_ent_wb_info->pid |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        }

        if (stat_present) {
            f_ent_wb_info->sid |= buf[fc->scache_pos];
            fc->scache_pos++;
            f_ent_wb_info->sid |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            f_ent_wb_info->sid |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            f_ent_wb_info->sid |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
        }
    } else {
        /* Read compact policer and stat ids, if present */

        if (pol_present) {
            f_ent_wb_info->pid |= buf[fc->scache_pos];
            fc->scache_pos++;
        }
        if (stat_present) {
            if (pol_present) {
                f_ent_wb_info->pid |= (buf[fc->scache_pos] & 0xf0) << 4;
            }
            f_ent_wb_info->sid |= buf[fc->scache_pos] & 0xf;
            fc->scache_pos++;
            f_ent_wb_info->sid |= buf[fc->scache_pos] << 4;
            fc->scache_pos++;
        } else if (pol_present) {
            f_ent_wb_info->pid |= (buf[fc->scache_pos] & 0xf0) << 4;
            fc->scache_pos++;
        }
    }

    /* Retrieve Entry part count */
    if (((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) &&
            ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
             (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) ||
             (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP))) {
        part_count = buf[fc->scache_pos];
        fc->scache_pos++;
    } else {
        part_count = 0;
    }

    /* Retrieve DVP_type */
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_6) {
        f_ent_wb_info->dvp_type[0] =  buf[fc->scache_pos];
        fc->scache_pos++;
        part_index = 1;
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) {
            for (; part_index < part_count; part_index++) {
                f_ent_wb_info->dvp_type[part_index] =  buf[fc->scache_pos];
                fc->scache_pos++;
            }
        }
        for (; part_index < _FP_MAX_ENTRY_WIDTH; part_index++) {
            f_ent_wb_info->dvp_type[part_index] = f_ent_wb_info->dvp_type[0];
        }
    }

    /* Retrieve SVP Type */
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_16) {
        f_ent_wb_info->svp_type[0] =  buf[fc->scache_pos];
        fc->scache_pos++;
        part_index = 1;
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) {
            for (; part_index < part_count; part_index++) {
                f_ent_wb_info->svp_type[part_index] =  buf[fc->scache_pos];
                fc->scache_pos++;
            }
        }
        for (; part_index < _FP_MAX_ENTRY_WIDTH; part_index++) {
            f_ent_wb_info->svp_type[part_index] = f_ent_wb_info->svp_type[0];
        }
    }

#if defined(BCM_APACHE_SUPPORT)
    if (SOC_IS_APACHE(unit)) {
        BCM_IF_ERROR_RETURN(_field_apache_entry_info_recovery(unit,
                    fc, stage_fc, f_ent_wb_info));
    }
#endif

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT) \
    || defined(BCM_HURRICANE3_SUPPORT)
    if ((stat_present) &&
        (((soc_feature(unit, soc_feature_advanced_flex_counter) ||
         (((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_12) &&
          soc_feature(unit, soc_feature_field_vfp_flex_counter)) ||
         soc_feature(unit, soc_feature_flowcnt)) &&
        (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)) ||
        (soc_feature(unit, soc_feature_advanced_flex_counter) &&
        (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL) &&
        ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_14))) &&
        (flex_info[unit].valid == 0)) {
         flex_info[unit].flex_mode = buf[fc->scache_pos];
         fc->scache_pos++;
         flex_info[unit].flex_mode |= buf[fc->scache_pos] << 8;
         fc->scache_pos++;
         flex_info[unit].flex_mode |= buf[fc->scache_pos] << 16;
         fc->scache_pos++;
         flex_info[unit].flex_mode |= buf[fc->scache_pos] << 24;
         fc->scache_pos++;
         flex_info[unit].hw_flags = buf[fc->scache_pos];
         fc->scache_pos++;
         flex_info[unit].hw_flags |= buf[fc->scache_pos] << 8;
         fc->scache_pos++;
         flex_info[unit].hw_flags |= buf[fc->scache_pos] << 16;
         fc->scache_pos++;
         flex_info[unit].hw_flags |= buf[fc->scache_pos] << 24;
         fc->scache_pos++;
         flex_info[unit].flex_stat_map |= buf[fc->scache_pos];
         fc->scache_pos++;

         flex_info[unit].valid = 1;
    }
#endif
    /* Recover f_ent_oam_wb structure
     * Note: f_ent_oam_wb should be allocated by the
     * parent function
     */
    if ((((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8) &&
                (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS)) ||
            (((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_11) &&
             (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        BCM_IF_ERROR_RETURN(_field_entry_oam_wb_scache_recover (unit, fc,
                    stage_fc, &buf[fc->scache_pos], f_ent_wb_info->f_ent_oam_wb));
    }

    /*Retrieve Color Indpendent info*/
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_13) {
        f_ent_wb_info->color_independent = (buf[fc->scache_pos] >> 7) & 0x1;
    }

    /*Retrieve level 1 policer */
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
        pol_present1 = (buf[fc->scache_pos] >> 6) & 0x1;
    }

    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_13) {
        fc->scache_pos++;
    }

    if (pol_present1) {
        f_ent_wb_info->pid1 |= buf[fc->scache_pos];
        fc->scache_pos++;
        f_ent_wb_info->pid1 |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        f_ent_wb_info->pid1 |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        f_ent_wb_info->pid1 |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
    }

    /* Retrieve Action bitmap */
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
        if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) ||
                (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
            if(f_ent_wb_info->action_bmp->w == NULL) {
                return BCM_E_PARAM;
            }

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "Read action bitmap[0x%x] @ byte %d.\n"),
                        buf[fc->scache_pos], fc->scache_pos));

            f_ent_wb_info->action_bmp->w[0] = buf[fc->scache_pos];
            fc->scache_pos++;
            f_ent_wb_info->action_bmp->w[0] |= buf[fc->scache_pos] << 8;
            fc->scache_pos++;
            f_ent_wb_info->action_bmp->w[0] |= buf[fc->scache_pos] << 16;
            fc->scache_pos++;
            f_ent_wb_info->action_bmp->w[0] |= buf[fc->scache_pos] << 24;
            fc->scache_pos++;
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_19) {
                f_ent_wb_info->action_bmp->w[1] = buf[fc->scache_pos];
                fc->scache_pos++;
                f_ent_wb_info->action_bmp->w[1] |= buf[fc->scache_pos] << 8;
                fc->scache_pos++;
                f_ent_wb_info->action_bmp->w[1] |= buf[fc->scache_pos] << 16;
                fc->scache_pos++;
                f_ent_wb_info->action_bmp->w[1] |= buf[fc->scache_pos] << 24;
                fc->scache_pos++;
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
                defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                /* Retrieve only if actions are present and synced */
                if ((SHR_BITGET(f_ent_wb_info->action_bmp->w, _bcmFieldActionNoParamPortPrioIntCosQNew)) ||
                        (SHR_BITGET(f_ent_wb_info->action_bmp->w, _bcmFieldActionNoParamGpPortPrioIntCosQNew))) {
                    f_ent_wb_info->port_prio_int_gport |= buf[fc->scache_pos];
                    fc->scache_pos++;
                    f_ent_wb_info->port_prio_int_gport |= buf[fc->scache_pos] << 8;
                    fc->scache_pos++;
                    f_ent_wb_info->port_prio_int_gport |= buf[fc->scache_pos] << 16;
                    fc->scache_pos++;
                    f_ent_wb_info->port_prio_int_gport |= buf[fc->scache_pos] << 24;
                    fc->scache_pos++;
                }
                if (SHR_BITGET(f_ent_wb_info->action_bmp->w, _bcmFieldActionNoParamYpPortPrioIntCosQNew)) {
                    f_ent_wb_info->yp_port_prio_int_gport |= buf[fc->scache_pos];
                    fc->scache_pos++;
                    f_ent_wb_info->yp_port_prio_int_gport |= buf[fc->scache_pos] << 8;
                    fc->scache_pos++;
                    f_ent_wb_info->yp_port_prio_int_gport |= buf[fc->scache_pos] << 16;
                    fc->scache_pos++;
                    f_ent_wb_info->yp_port_prio_int_gport |= buf[fc->scache_pos] << 24;
                    fc->scache_pos++;
                }
                if (SHR_BITGET(f_ent_wb_info->action_bmp->w, _bcmFieldActionNoParamRpPortPrioIntCosQNew)) {
                    f_ent_wb_info->rp_port_prio_int_gport |= buf[fc->scache_pos];
                    fc->scache_pos++;
                    f_ent_wb_info->rp_port_prio_int_gport |= buf[fc->scache_pos] << 8;
                    fc->scache_pos++;
                    f_ent_wb_info->rp_port_prio_int_gport |= buf[fc->scache_pos] << 16;
                    fc->scache_pos++;
                    f_ent_wb_info->rp_port_prio_int_gport |= buf[fc->scache_pos] << 24;
                    fc->scache_pos++;
                }
#endif
          }
          if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_16) {
             /* Recover IngressGportType Entry Action. */
             f_ent_wb_info->ing_gport_type = buf[fc->scache_pos];
             fc->scache_pos++;
          }

          if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_20) {
              uint8 index, max_index = 1;
              if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_21) {
                  max_index = 4;
              }
              for (index = 0 ; index < max_index ; index++) {
                  if (SHR_BITGET(f_ent_wb_info->action_bmp->w, ingress_mirror_actions[index])) {
                      f_ent_wb_info->ingress_mirror[index] = buf[fc->scache_pos];
                      fc->scache_pos++;
                      f_ent_wb_info->ingress_mirror[index] |= buf[fc->scache_pos] << 8;
                      fc->scache_pos++;
                      f_ent_wb_info->ingress_mirror[index] |= buf[fc->scache_pos] << 16;
                      fc->scache_pos++;
                      f_ent_wb_info->ingress_mirror[index] |= buf[fc->scache_pos] << 24;
                      fc->scache_pos++;
                  }
              }
              for (index = 0 ; index < max_index ; index++) {
                  if (SHR_BITGET(f_ent_wb_info->action_bmp->w, egress_mirror_actions[index])) {
                      f_ent_wb_info->egress_mirror[index] = buf[fc->scache_pos];
                      fc->scache_pos++;
                      f_ent_wb_info->egress_mirror[index] |= buf[fc->scache_pos] << 8;
                      fc->scache_pos++;
                      f_ent_wb_info->egress_mirror[index] |= buf[fc->scache_pos] << 16;
                      fc->scache_pos++;
                      f_ent_wb_info->egress_mirror[index] |= buf[fc->scache_pos] << 24;
                      fc->scache_pos++;
                  }
              }
              if ( SHR_BITGET(f_ent_wb_info->action_bmp->w,
                   _bcmFieldActionNoParamFabricQueue)){
                  (f_ent_wb_info->action_fabricQueue_wb.cosq_gport) =
                        buf[fc->scache_pos];
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.cosq_gport) |=
                        buf[fc->scache_pos] << 8;
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.cosq_gport) |=
                        buf[fc->scache_pos] << 16;
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.cosq_gport) |=
                        buf[fc->scache_pos] << 24;
                  fc->scache_pos++;
#if defined(BCM_KATANA_SUPPORT)
                  if (SOC_IS_KATANAX(unit)) {
                      (f_ent_wb_info->action_fabricQueue_wb.profile_idx) =
                        buf[fc->scache_pos];
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.profile_idx) |=
                        buf[fc->scache_pos] << 8;
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.profile_idx) |=
                        buf[fc->scache_pos] << 16;
                  fc->scache_pos++;
                  (f_ent_wb_info->action_fabricQueue_wb.profile_idx) |=
                        buf[fc->scache_pos] << 24;
                  fc->scache_pos++;
                  }
#endif /* BCM_KATANA_SUPPORT */
              }
          }
       }
    }
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
        LOG_DEBUG (BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "Read policer delta rates @ %d\n"), fc->scache_pos));
        BCM_IF_ERROR_RETURN (_field_entry_policer_delta_rates_recover (unit, fc,
                    stage_fc, &buf[fc->scache_pos], f_ent_wb_info->f_ent_policer_wb,
                    pol_present, pol_present1));
        LOG_DEBUG (BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "Done reading policer delta rates @ %d\n"), fc->scache_pos));
    }
    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
       "Done reading entry @ %d.\n"), fc->scache_pos));

    return BCM_E_NONE;
}

/* Loops through the WB groups info of the slice
 * gets the appropriate group in fc to update
 * ingress and src entity selcode and
 * add qual offset
 */
int
_field_tr2_group_construct_quals_with_sel_update(int unit,
                                _field_control_t *fc,
                                _field_stage_t   *stage_fc)
{
    _field_slice_group_info_t     *curr_ptr = NULL;
    _field_group_t                *grp_ptr = NULL;
    int                           i, parts_count;

    if ((fc == NULL) ||  (stage_fc == NULL)) {
        return BCM_E_INTERNAL;
    }

    if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit) ||
        SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit)) {
        return BCM_E_NONE;
    }

    for (curr_ptr = fc->group_arr; curr_ptr != NULL; curr_ptr = curr_ptr->next) {
        /* loop through the fc->groups to find the matching group id */
        for (grp_ptr = fc->groups; grp_ptr != NULL ; grp_ptr = grp_ptr->next) {
            if (curr_ptr->gid == grp_ptr->gid) {

                BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                            grp_ptr->stage_id, grp_ptr->flags, &parts_count));

                /* Updates ingress and src entity selcode and
                 * free qual offset arr if allocated previously
                 */
                for (i = 0; i < parts_count; i++) {
                    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                        grp_ptr->sel_codes[i].ingress_entity_sel = curr_ptr->sel_ingress_entity[i];
                        grp_ptr->sel_codes[i].dst_fwd_entity_sel = curr_ptr->sel_dst_fwd_entity[i];
                    }
                    grp_ptr->sel_codes[i].src_entity_sel = curr_ptr->sel_src_entity[i];
                    BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(grp_ptr, i));
                }

                /* Recover group qualifiers based on selector codes */
                _field_tr2_group_construct_quals_add(unit,
                        fc,
                        stage_fc,
                        grp_ptr
                        );
                break;
            }
        }
    }
    return BCM_E_NONE;
}

#if defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *     _field_stat_mode_entry_count_get
 *
 * Purpose:
 *     Sets number of counters for the stat group mode in field
 *     stat structure
 *
 * Parameters:
 *     unit              - (IN) BCM device number
 *     f_st              - (IN) Field stat structure pointer
 *
 * Returns:
 *     BCM_E_XXX
 */
int _field_stat_mode_entry_count_get(int unit, _field_stat_t *f_st)
{
    if (f_st == NULL) {
        return (BCM_E_INTERNAL);
    }

    switch(f_st->hw_mode) {
        case bcmStatGroupModeSingle:
            f_st->hw_entry_count = 1;
            break;
        case bcmStatGroupModeTrafficType:
            f_st->hw_entry_count = 3;
            break;
        case bcmStatGroupModeDlfAll:
            f_st->hw_entry_count = 2;
            break;
        case bcmStatGroupModeDlfIntPri:
            f_st->hw_entry_count = 17;
            break;
        case bcmStatGroupModeTyped:
            f_st->hw_entry_count = 4;
            break;
        case bcmStatGroupModeTypedAll:
            f_st->hw_entry_count = 5;
            break;
        case bcmStatGroupModeTypedIntPri:
            f_st->hw_entry_count = 20;
            break;
        case bcmStatGroupModeSingleWithControl:
            f_st->hw_entry_count = 2;
            break;
        case bcmStatGroupModeTrafficTypeWithControl:
            f_st->hw_entry_count = 4;
            break;
        case bcmStatGroupModeDlfAllWithControl:
            f_st->hw_entry_count = 3;
            break;
        case bcmStatGroupModeDlfIntPriWithControl:
            f_st->hw_entry_count = 18;
            break;
        case bcmStatGroupModeTypedWithControl:
            f_st->hw_entry_count = 5;
            break;
        case bcmStatGroupModeTypedAllWithControl:
            f_st->hw_entry_count = 6;
            break;
        case bcmStatGroupModeTypedIntPriWithControl:
            f_st->hw_entry_count = 21;
            break;
        case bcmStatGroupModeDot1P:
            f_st->hw_entry_count = 8;
            break;
        case bcmStatGroupModeIntPri:
            f_st->hw_entry_count = 16;
            break;
        case bcmStatGroupModeIntPriCng:
            f_st->hw_entry_count = 64;
            break;
        case bcmStatGroupModeSvpType:
            f_st->hw_entry_count = 2;
            break;
        case bcmStatGroupModeDscp:
            f_st->hw_entry_count = 64;
            break;
        case bcmStatGroupModeDvpType:
            f_st->hw_entry_count = 0;
            break;
        case bcmStatGroupModeCng:
            f_st->hw_entry_count = 4;
            break;
        default:
            f_st->hw_entry_count = 0;
            break;
    }
    return BCM_E_NONE;
}
#endif


#if defined(BCM_TRIUMPH2_SUPPORT)
int _field_vfp_flex_stat_info_retrieve(int unit, int stat_id)
{
    _field_stat_t *f_st = NULL;
    _bcm_flex_stat_type_t fs_type;

    if (!soc_feature(unit, soc_feature_field_vfp_flex_counter)) {
        return BCM_E_INTERNAL;
    }

    if (flex_info[unit].valid == 1) {
        BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));

        /* Update only for the first ref of stat */
        if (f_st->hw_ref_count == 1) {

            f_st->flex_mode = flex_info[unit].flex_mode;
            f_st->hw_flags = flex_info[unit].hw_flags;

            /* During WARM BOOT, the controlling module should check if the
             * flexible statistic index for a particular handle is non-zero.  If so,
             * the flexible stats must be notified so the SW data structures are
             * maintained.*/

            if (flex_info[unit].flex_mode) {
                fs_type = _BCM_FLEX_STAT_TYPE(f_st->flex_mode);
            } else {
                fs_type = _bcmFlexStatTypeFp;
            }

            if (f_st->hw_index != _FP_INVALID_INDEX) {
                _bcm_esw_flex_stat_reinit_add(unit, fs_type,
                        f_st->hw_index, f_st->sid);
                }
        }
    }
    flex_info[unit].valid=0;
    return BCM_E_NONE;
}
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
int _field_flowcnt_stat_info_retrieve(int unit, int stat_id)
{
    _field_stat_t *f_st = NULL;
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    uint32                  pool_num = 0;     /* Flowcnt Stat Hw Pool No.          */
    uint32                  base_index = 0;   /* Flowcnt Stat counter base index.  */
    uint32                  profile_group = 0; /* Flowcnt Stat profile num */

    if (flex_info[unit].valid == 1) {
        BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));

        /* Update only for the first ref of stat */
        if (f_st->hw_ref_count == 1) {

            f_st->flex_mode = flex_info[unit].flex_mode;
            f_st->hw_flags = flex_info[unit].hw_flags;

            _bcm_esw_flowcnt_counter_id_get(f_st->flex_mode,
                            &stat_mode, &stat_obj, &profile_group,
                            &pool_num, &base_index);
            f_st->hw_index = base_index;
            f_st->pool_index = pool_num;
            f_st->hw_mode = stat_mode;
            f_st->hw_entry_count = 1;
        }
    }
    flex_info[unit].valid=0;
    return BCM_E_NONE;
}
#endif


#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) \
    || defined(BCM_TRIDENT2_SUPPORT)
int _field_adv_flex_stat_info_retrieve(int unit, int stat_id)
{
    _field_stat_t *f_st = NULL;
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    uint32                  pool_num;     /* Flex Stat Hw Pool No.          */
    uint32                  base_index;   /* Flex Stat counter base index.  */
    int                     offset_mode = 0;

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return BCM_E_INTERNAL;
    }

    if ((flex_info[unit].valid == 1) && (flex_info[unit].flex_mode != 0)) {
        BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));

        f_st->flex_mode = flex_info[unit].flex_mode;
        f_st->hw_flags = flex_info[unit].hw_flags;
        _bcm_esw_stat_get_counter_id_info(unit, f_st->flex_mode,
                                          &stat_mode,
                                          &stat_obj,
                                          (uint32 *)&offset_mode,
                                          &pool_num,
                                          &base_index
                                          );
        f_st->hw_index = base_index;
        f_st->pool_index = pool_num;
        f_st->hw_mode = offset_mode; /* offset_mode from counter info */
        f_st->hw_entry_count = 1; /* PlsNote:For SingleMode=1 */
        /* Currently OnlySingleMode is supportes so above OK */
        /* else decision will be based on stat_mode          */

#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            /* For TR3, multiple stat group modes are supported. Based on the
               stat group mode, set hw_entry_count */
            BCM_IF_ERROR_RETURN(_field_stat_mode_entry_count_get(unit, f_st));
        }
#endif
    }
    flex_info[unit].valid=0;
    return BCM_E_NONE;
}
#endif

#if 0
STATIC int
mem_read(int unit, int mem, char *str, void **buf)
{
    if ((*buf = soc_cm_salloc(unit,
                              soc_mem_index_count(unit, mem)
                              * soc_mem_entry_bytes(unit, mem),
                              str
                              )
         )
        == NULL
        ) {
        return (BCM_E_MEMORY);
    }

    return (soc_mem_read_range(unit,
                               mem,
                               MEM_BLOCK_ANY,
                               soc_mem_index_min(unit, mem),
                               soc_mem_index_max(unit, mem),
                               *buf
                               )
            );
}
#endif

/*
 * Function:
 *     _field_tr2_loopback_type_sel_recover
 *
 * Purpose:
 *     Retrieve slice TunnelType/LoopbackType settings from installed
 *     field entry.
 *
 * Parameters:
 *     unit              - (IN) BCM device number
 *     slice_idx         - (IN) Slice number to enable
 *     fp_tcam_buf       - (IN) TCAM entry
 *     stage_fc          - (IN) FP stage control info.
 *     intraslice        - (IN) Slice in Intra-Slice Double Wide mode.
 *     loopback_type_sel - (OUT) Tunnel/Loopback Type selector value
 *
 * Returns:
 *     Nothing
 */
STATIC int
_field_tr2_loopback_type_sel_recover(int unit,
                                     int slice_idx,
                                     uint32 *fp_tcam_buf,
                                     _field_stage_t *stage_fc,
                                     int intraslice,
                                     int8 *loopback_type_sel)
{
    fp_tcam_entry_t *tcam_entry;                /* Installed TCAM entry.     */
    uint32 tunnel_loopback_type = 0;            /* Hw Tunnel/Loopback value. */
    fp_slice_map_entry_t fp_slice_map_buf;      /* Slice map table entry.    */
    _field_slice_t       *fs;                   /* Pointer to Slice info.    */
    _field_control_t     *fc;                   /* Pointer to field control  */
    int slice_ent_cnt;                          /* No. of entries in slice.  */
    int idx;                                    /* Slice index.              */
    int vmap_size, index;                       /* Virtual Map entry size.   */
    int virtual_group = -1;                     /* Virtual Group ID.         */
    int phy_slice;                              /* Physical slice value.     */

    static const soc_field_t physical_slice[] = {
        VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_8_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_9_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_10_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_11_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_12_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_13_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_14_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_15_PHYSICAL_SLICE_NUMBER_ENTRY_0f,
        VIRTUAL_SLICE_16_PHYSICAL_SLICE_NUMBER_ENTRY_0f
    }, slice_group[] = {
        VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_8_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_9_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_10_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_11_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_12_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_13_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_14_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_15_VIRTUAL_SLICE_GROUP_ENTRY_0f,
        VIRTUAL_SLICE_16_VIRTUAL_SLICE_GROUP_ENTRY_0f
    };

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    vmap_size = stage_fc->tcam_slices;
    if (fc->flags & _FP_EXTERNAL_PRESENT) {
        ++vmap_size;
    }

    BCM_IF_ERROR_RETURN(soc_mem_read(unit,
                                     FP_SLICE_MAPm,
                                     MEM_BLOCK_ANY,
                                     0,
                                     fp_slice_map_buf.entry_data
                                     )
                        );

    /* Get the virtual group id for given slice_idx. */
    for (index = 0; index < vmap_size; index++) {
        phy_slice = soc_mem_field32_get(unit,
                            FP_SLICE_MAPm,
                            fp_slice_map_buf.entry_data,
                            physical_slice[index]);
        if (slice_idx != phy_slice) {
            continue;
        }
        virtual_group = soc_mem_field32_get(unit,
                            FP_SLICE_MAPm,
                            fp_slice_map_buf.entry_data,
                            slice_group[index]);
        break;
    }

    /* Must be a valid virtual_group to proceed further. */
    if (-1 == virtual_group) {
        return (BCM_E_INTERNAL);
    }

    /*
     * For expanded group slices, check if any entry in
     * this slice has loopback_type_sel selector set.
     */
    for (index = 0; index < vmap_size; index++) {
        if (virtual_group
            != soc_mem_field32_get(unit,
                                   FP_SLICE_MAPm,
                                   fp_slice_map_buf.entry_data,
                                   slice_group[index])) {
            continue;
        }

        phy_slice = soc_mem_field32_get(unit,
                            FP_SLICE_MAPm,
                            fp_slice_map_buf.entry_data,
                            physical_slice[index]);
        fs = stage_fc->slices[_FP_DEF_INST] + phy_slice;
        slice_ent_cnt = fs->entry_count;

        if (intraslice) {
            slice_ent_cnt >>= 1;
        }

        for (idx = 0; idx < slice_ent_cnt; idx++) {
            tcam_entry = soc_mem_table_idx_to_pointer
                            (unit,
                             FP_TCAMm,
                             fp_tcam_entry_t *,
                             fp_tcam_buf,
                             idx + slice_ent_cnt * phy_slice
                             );
            if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) != 0) {
                /* Extract Tunnel Info from tcam_entry  */
                _field_extract((uint32 *)tcam_entry,
                               21,
                               4,
                               &tunnel_loopback_type
                               );
                switch (tunnel_loopback_type) {
                    case 0x1: /* IP_TUNNEL       */
                    case 0x2: /* MPLS_TUNNEL     */
                    case 0x3: /* MIM_TUNNEL      */
                    case 0x4: /* WLAN_WTP TUNNEL */
                    case 0x5: /* WLAN_AC TUNNEL  */
                    case 0x6: /* AMT_TUNNEL      */
                    case 0x7: /* TRILL_TUNNEL    */
                        *loopback_type_sel = 1;
                        break;
                    case 0x8: /* NONE                                    */
                    case 0x9: /* EP REDIRECTION LOOPBACK                 */
                    case 0xb: /* MiM LOOPBACK                            */
                    case 0xc: /* WLAN LOOPBACK || Trill Network Loopback */
                    case 0xd: /* Trill Access Loopback                   */
                    case 0xe: /* EGRESS MIRROR LOOPBACK */
                        *loopback_type_sel = 0;
                        break;
                    default:
                        ;
                }

                if (*loopback_type_sel != _FP_SELCODE_DONT_CARE) {
                    goto done;
                }
            }
        }
    }

done:
    return (BCM_E_NONE);
}

void
_field_tr2_ingress_entity_get(int unit, int slice_idx, uint32 *fp_tcam_buf,
                              int slice_ent_cnt, _field_stage_t *stage_fc,
                              int8 *ingress_entity_sel)
{
    fp_tcam_entry_t *tcam_entry;
    uint32 svp_valid = 0;
    int idx;
    uint32 offset = 0;

    if (SOC_IS_TD2_TT2(unit)) {
        offset = 138 + 5; /* FIXED Start = 138, SVP_VALID offset = 5 */
    } else {
        offset = 10 + 4; /* FIXED Start = 10, SVP_VALID offset = 4 */
    }
    for (idx = 0; idx < slice_ent_cnt; idx++) {
        tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                  fp_tcam_entry_t *,
                                                  fp_tcam_buf, idx +
                                                  slice_ent_cnt *
                                                  slice_idx);
        if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) != 0) {
            _field_extract((uint32 *)tcam_entry, offset, 1, &svp_valid);
            if (svp_valid) {
                break;
            }
        }
    }
    if (svp_valid) {
        *ingress_entity_sel = _bcmFieldFwdEntityMimGport;
    }
    return;
}

int _field_action_params_pbmp_get (int unit, uint32 param[],
                                   bcm_pbmp_t *pbmp)
{
    int i;
    BCM_PBMP_CLEAR(*pbmp);

    for (i = 0; (i < _FP_ACTION_PARAM_SZ) && (i < SOC_PBMP_WORD_MAX); i++) {
        SOC_PBMP_WORD_SET(*pbmp, i, param[i]);
    }
    return BCM_E_NONE;
}

/* Function: _field_egr_ports_recovery_wb_upgrade_add
 *
 * Purpose:
 *     Handle Warmboot Upgrade case for Egress Portbitmap
 *     Recovery Database.
 * Parameters:
 *     unit  - BCM device number
 *       fg  - Group Structure Pointer
 * Returns:
       BCM_E_NONE - Success
 */
int _field_egr_ports_recovery_wb_upgrade_add (int unit,
                                              _field_group_t *fg
                                              )
{
    int idx = -1;
    _field_entry_t      *f_ent;       /* Field entry info */
    _field_action_t     *fa;          /* Field action descriptor */
    bcm_pbmp_t           pbmp;        /* Egress Ports Pbmp */

    while (fg != NULL) {
        if (fg->stage_id != _BCM_FIELD_STAGE_INGRESS) {
            fg = fg->next;
        } else {
            for (idx = 0; idx < fg->group_status.entry_count; idx++) {
                f_ent = fg->entry_arr[idx];

                if (f_ent != NULL) {
                    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
                        if (fa->action == bcmFieldActionEgressPortsAdd) {
                            /* Add code to insert Database */
                            _field_action_params_pbmp_get (unit, fa->param,
                                                       &pbmp);
                            _bcm_trx_field_egr_ports_recovery_add (unit,
                                                       f_ent->eid, pbmp);
                            break;
                        }
                    }
                }
            }
            fg = fg->next;
        }
    }
    return BCM_E_NONE;
}

int
_field_tr2_stage_ingress_reinit(int              unit,
                                _field_control_t *fc,
                                _field_stage_t   *stage_fc
                                )
{
    static const soc_field_t ifp_en_flds[] = {
        FP_SLICE_ENABLE_SLICE_0f,
        FP_SLICE_ENABLE_SLICE_1f,
        FP_SLICE_ENABLE_SLICE_2f,
        FP_SLICE_ENABLE_SLICE_3f,
        FP_SLICE_ENABLE_SLICE_4f,
        FP_SLICE_ENABLE_SLICE_5f,
        FP_SLICE_ENABLE_SLICE_6f,
        FP_SLICE_ENABLE_SLICE_7f,
        FP_SLICE_ENABLE_SLICE_8f,
        FP_SLICE_ENABLE_SLICE_9f,
        FP_SLICE_ENABLE_SLICE_10f,
        FP_SLICE_ENABLE_SLICE_11f,
        FP_SLICE_ENABLE_SLICE_12f,
        FP_SLICE_ENABLE_SLICE_13f,
        FP_SLICE_ENABLE_SLICE_14f,
        FP_SLICE_ENABLE_SLICE_15f
    };
    static const soc_field_t ifp_lk_en_flds[] = {
        FP_LOOKUP_ENABLE_SLICE_0f,
        FP_LOOKUP_ENABLE_SLICE_1f,
        FP_LOOKUP_ENABLE_SLICE_2f,
        FP_LOOKUP_ENABLE_SLICE_3f,
        FP_LOOKUP_ENABLE_SLICE_4f,
        FP_LOOKUP_ENABLE_SLICE_5f,
        FP_LOOKUP_ENABLE_SLICE_6f,
        FP_LOOKUP_ENABLE_SLICE_7f,
        FP_LOOKUP_ENABLE_SLICE_8f,
        FP_LOOKUP_ENABLE_SLICE_9f,
        FP_LOOKUP_ENABLE_SLICE_10f,
        FP_LOOKUP_ENABLE_SLICE_11f,
        FP_LOOKUP_ENABLE_SLICE_12f,
        FP_LOOKUP_ENABLE_SLICE_13f,
        FP_LOOKUP_ENABLE_SLICE_14f,
        FP_LOOKUP_ENABLE_SLICE_15f
    };
    static const soc_field_t ifp_en_field_tbl[][3] = {
        {  SLICE0_F1f,  SLICE0_F2f,  SLICE0_F3f },
        {  SLICE1_F1f,  SLICE1_F2f,  SLICE1_F3f },
        {  SLICE2_F1f,  SLICE2_F2f,  SLICE2_F3f },
        {  SLICE3_F1f,  SLICE3_F2f,  SLICE3_F3f },
        {  SLICE4_F1f,  SLICE4_F2f,  SLICE4_F3f },
        {  SLICE5_F1f,  SLICE5_F2f,  SLICE5_F3f },
        {  SLICE6_F1f,  SLICE6_F2f,  SLICE6_F3f },
        {  SLICE7_F1f,  SLICE7_F2f,  SLICE7_F3f },
        {  SLICE8_F1f,  SLICE8_F2f,  SLICE8_F3f },
        {  SLICE9_F1f,  SLICE9_F2f,  SLICE9_F3f },
        { SLICE10_F1f, SLICE10_F2f, SLICE10_F3f },
        { SLICE11_F1f, SLICE11_F2f, SLICE11_F3f },
        { SLICE12_F1f, SLICE12_F2f, SLICE12_F3f },
        { SLICE13_F1f, SLICE13_F2f, SLICE13_F3f },
        { SLICE14_F1f, SLICE14_F2f, SLICE14_F3f },
        { SLICE15_F1f, SLICE15_F2f, SLICE15_F3f }
    };
    static const soc_field_t ifp_en_sd_type_field_tbl[][2] = {
        {  SLICE0_S_TYPE_SELf,  SLICE0_D_TYPE_SELf},
        {  SLICE1_S_TYPE_SELf,  SLICE1_D_TYPE_SELf},
        {  SLICE2_S_TYPE_SELf,  SLICE2_D_TYPE_SELf},
        {  SLICE3_S_TYPE_SELf,  SLICE3_D_TYPE_SELf},
        {  SLICE4_S_TYPE_SELf,  SLICE4_D_TYPE_SELf},
        {  SLICE5_S_TYPE_SELf,  SLICE5_D_TYPE_SELf},
        {  SLICE6_S_TYPE_SELf,  SLICE6_D_TYPE_SELf},
        {  SLICE7_S_TYPE_SELf,  SLICE7_D_TYPE_SELf},
        {  SLICE8_S_TYPE_SELf,  SLICE8_D_TYPE_SELf},
        {  SLICE9_S_TYPE_SELf,  SLICE9_D_TYPE_SELf},
        { SLICE10_S_TYPE_SELf, SLICE10_D_TYPE_SELf},
        { SLICE11_S_TYPE_SELf, SLICE11_D_TYPE_SELf},
        { SLICE12_S_TYPE_SELf, SLICE12_D_TYPE_SELf},
        { SLICE13_S_TYPE_SELf, SLICE13_D_TYPE_SELf},
        { SLICE14_S_TYPE_SELf, SLICE14_D_TYPE_SELf},
        { SLICE15_S_TYPE_SELf, SLICE15_D_TYPE_SELf}
    };
    static const soc_field_t ifp_en_slice_wide_mode_field[] = {
        SLICE0_DOUBLE_WIDE_MODEf,
        SLICE1_DOUBLE_WIDE_MODEf,
        SLICE2_DOUBLE_WIDE_MODEf,
        SLICE3_DOUBLE_WIDE_MODEf,
        SLICE4_DOUBLE_WIDE_MODEf,
        SLICE5_DOUBLE_WIDE_MODEf,
        SLICE6_DOUBLE_WIDE_MODEf,
        SLICE7_DOUBLE_WIDE_MODEf,
        SLICE8_DOUBLE_WIDE_MODEf,
        SLICE9_DOUBLE_WIDE_MODEf,
        SLICE10_DOUBLE_WIDE_MODEf,
        SLICE11_DOUBLE_WIDE_MODEf,
        SLICE12_DOUBLE_WIDE_MODEf,
        SLICE13_DOUBLE_WIDE_MODEf,
        SLICE14_DOUBLE_WIDE_MODEf,
        SLICE15_DOUBLE_WIDE_MODEf
    };
    static const soc_field_t ifp_en_double_wide_key[] = {
        SLICE0_DOUBLE_WIDE_KEY_SELECTf,
        SLICE1_DOUBLE_WIDE_KEY_SELECTf,
        SLICE2_DOUBLE_WIDE_KEY_SELECTf,
        SLICE3_DOUBLE_WIDE_KEY_SELECTf,
        SLICE4_DOUBLE_WIDE_KEY_SELECTf,
        SLICE5_DOUBLE_WIDE_KEY_SELECTf,
        SLICE6_DOUBLE_WIDE_KEY_SELECTf,
        SLICE7_DOUBLE_WIDE_KEY_SELECTf,
        SLICE8_DOUBLE_WIDE_KEY_SELECTf,
        SLICE9_DOUBLE_WIDE_KEY_SELECTf,
        SLICE10_DOUBLE_WIDE_KEY_SELECTf,
        SLICE11_DOUBLE_WIDE_KEY_SELECTf,
        SLICE12_DOUBLE_WIDE_KEY_SELECTf,
        SLICE13_DOUBLE_WIDE_KEY_SELECTf,
        SLICE14_DOUBLE_WIDE_KEY_SELECTf,
        SLICE15_DOUBLE_WIDE_KEY_SELECTf
    };
    static const soc_field_t ifp_en_slice_pairing_field[] = {
        SLICE1_0_PAIRINGf,
        SLICE3_2_PAIRINGf,
        SLICE5_4_PAIRINGf,
        SLICE7_6_PAIRINGf,
        SLICE9_8_PAIRINGf,
        SLICE11_10_PAIRINGf,
        SLICE13_12_PAIRINGf,
        SLICE15_14_PAIRINGf
    };
    static const soc_field_t ifp_en_ing_f4_reg[] = {
        SLICE_0_F4f,
        SLICE_1_F4f,
        SLICE_2_F4f,
        SLICE_3_F4f,
        SLICE_4_F4f,
        SLICE_5_F4f,
        SLICE_6_F4f,
        SLICE_7_F4f,
        SLICE_8_F4f,
        SLICE_9_F4f,
        SLICE_10_F4f,
        SLICE_11_F4f,
        SLICE_12_F4f,
        SLICE_13_F4f,
        SLICE_14_F4f,
        SLICE_15_F4f
    };
    static const soc_field_t ifp_en_ing_f1_reg[] = {
        SLICE_0_F1f,
        SLICE_1_F1f,
        SLICE_2_F1f,
        SLICE_3_F1f,
        SLICE_4_F1f,
        SLICE_5_F1f,
        SLICE_6_F1f,
        SLICE_7_F1f,
        SLICE_8_F1f,
        SLICE_9_F1f,
        SLICE_10_F1f,
        SLICE_11_F1f,
        SLICE_12_F1f,
        SLICE_13_F1f,
        SLICE_14_F1f,
        SLICE_15_F1f
    };

    int idx, idx1, slice_idx, vslice_idx,index_min, index_max, rv = BCM_E_NONE;
    int group_found, mem_sz, parts_count, slice_ent_cnt;
    int i, pri_tcam_idx, part_index, slice_number, expanded[16], slice_master_idx[16];
    int prev_prio, multigroup, max, master_slice;
    uint16 recovered_ver_part0 = 0;
    uint32 *fp_tcam_buf = NULL; /* Buffer to read the FP_TCAM table */
    char *fp_pfs_buf = NULL; /* Buffer to read the FP_PORT_FIELD_SEL table */
    char *fp_policy_buf = NULL; /* Buffer to read the FP_POLICY table */
    char *fp_global_mask_tcam_buf = NULL; /* Buffer to read the FP_GLOBAL_MASK_TCAM table */
    uint32 rval, paired, intraslice;
    uint32 temp;
    soc_field_t fld;
    bcm_port_t port;
    fp_port_field_sel_entry_t *pfs_entry;
    fp_tcam_entry_t *tcam_entry;
    fp_policy_table_entry_t *policy_entry;
    fp_global_mask_tcam_entry_t *global_mask_tcam_entry;
    _field_hw_qual_info_t hw_sels;
    _field_slice_t *fs;
    _field_group_t *fg = NULL, *group = NULL;
    _field_entry_t *f_ent = NULL;
    bcm_pbmp_t entry_pbmp, entry_mask_pbmp, temp_pbmp, valid_pbm;
    bcm_port_config_t  port_config;            /* Device port config.    */
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    bcm_pbmp_t port_cmic_pbmp;
    int8 s_field, d_field;
    int phys_tcam_idx;
    uint8 old_physical_slice, slice_num;
    uint32 entry_flags;
    _field_slice_t *fs_temp = NULL;
    uint16 recovered_count = 0;
    _field_table_pointers_t *fp_table_pointers = NULL;
    soc_reg_t  double_wide_reg = 0;
    _field_entry_oam_wb_t *f_ent_oam_wb = NULL;
    _field_entry_policer_wb_t *f_ent_policer_wb = NULL;
    uint32 fwd_field_sel;

#if defined(BCM_TRIDENT_SUPPORT) \
    || defined(BCM_SCORPION_SUPPORT) \
    || defined(BCM_CONQUEROR_SUPPORT)
    bcm_pbmp_t temp_pbm_mask; /* Y-Pipe IPBM MASK value. */
#endif
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT)
    uint32  tcam_dual_pipe_entry[SOC_MAX_MEM_FIELD_WORDS]; /* Y-Pipe FP_TCAM
                                                            * entry. */
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    char *fp_gm_tcam_x_buf = NULL;                     /* Buffer to read
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * table. */
    fp_global_mask_tcam_x_entry_t *fp_gm_tcam_x_entry; /* Pointer to
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * entry */
    char *fp_gm_tcam_y_buf = NULL;                     /* Buffer to read
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * table. */
    fp_global_mask_tcam_y_entry_t *fp_gm_tcam_y_entry; /* Pointer to
                                                        * FP_GLOBAL_MASK_TCAM_Y
                                                        * entry */
#endif
    _field_action_bmp_t action_bmp;
    _field_entry_wb_info_t f_ent_wb_info;

    BCM_PBMP_ASSIGN(port_cmic_pbmp, PBMP_PORT_ALL(unit));
    BCM_PBMP_OR(port_cmic_pbmp, PBMP_CMIC(unit));
    BCM_PBMP_CLEAR(entry_pbmp);
    BCM_PBMP_CLEAR(entry_mask_pbmp);

    fc->scache_pos = 0;
    fc->scache_pos1 = 0;

    /* Reset Action bitmap to NULL. */
    action_bmp.w = NULL;

    /* Valid PBMP Supported on the Device */
    rv = (bcm_esw_port_config_get(unit, &port_config));
    if (BCM_FAILURE(rv)) {
       goto cleanup;
    }
    BCM_PBMP_ASSIGN(valid_pbm, port_config.all);
#ifdef BCM_KATANA2_SUPPORT
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &valid_pbm);
    }
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
#if defined(BCM_SABER2_SUPPORT)
        if((SOC_IS_SABER2(unit)) &&
                (fc->wb_recovered_version < BCM_FIELD_WB_VERSION_1_19) &&
                (bcm_sb2_wb_v2_flexio_update == 0)) {
            rv = _bcm_sb2_wb_v1_flexio_pbmp_update(unit, &valid_pbm);
        } else
#endif
        {
            rv = (_bcm_kt2_flexio_pbmp_update(unit, &valid_pbm));
        }
        if (BCM_FAILURE(rv)) {
           goto cleanup;
        }
    }
#endif /* BCM_KATANA2_SUPPORT */

    if (fc->l2warm) {
        recovered_ver_part0 = (fc->wb_recovered_version);

        if ((fc->wb_recovered_version) > (fc->wb_current_version)) {
            /* Notify the application with an event */
            /* The application will then need to reconcile the
               version differences using the documented behavioral
               differences on per module (handle) basis */
            SOC_IF_ERROR_RETURN
                (soc_event_generate(unit, SOC_SWITCH_EVENT_WARM_BOOT_DOWNGRADE,
                                    BCM_MODULE_FIELD, (fc->wb_recovered_version),
                                    (fc->wb_current_version)));
        }

        fc->scache_pos += SOC_WB_SCACHE_CONTROL_SIZE;

        if(NULL != fc->scache_ptr[_FIELD_SCACHE_PART_1]) {
            if ((fc->wb_recovered_version) > (fc->wb_current_version)) {
                /* Notify the application with an event */
                /* The application will then need to reconcile the
                   version differences using the documented behavioral
                   differences on per module (handle) basis */
                SOC_IF_ERROR_RETURN
                    (soc_event_generate(unit,
                                        SOC_SWITCH_EVENT_WARM_BOOT_DOWNGRADE,
                                        BCM_MODULE_FIELD, (fc->wb_recovered_version),
                                        (fc->wb_current_version)));
            }

            fc->scache_pos1 += SOC_WB_SCACHE_CONTROL_SIZE;
        }
    }

    SOC_PBMP_CLEAR(entry_pbmp);
    sal_memset(expanded, 0, 16 * sizeof(int));
    sal_memset(slice_master_idx, 0, 16 * sizeof(int));

    if (fc->l2warm) {
        rv = _field_scache_stage_hdr_chk(fc, _FIELD_IFP_DATA_START);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }

    fp_table_pointers = soc_cm_salloc(unit, sizeof(_field_table_pointers_t),
                                                "FP Table buffer Pointers");

    if (NULL == fp_table_pointers) {
        return BCM_E_MEMORY;
    }
    rv = _field_table_pointers_init(unit, fp_table_pointers);
    BCM_IF_ERROR_RETURN(rv);

    /* DMA various tables */

    fp_tcam_buf = soc_cm_salloc(unit, sizeof(fp_tcam_entry_t) *
                                soc_mem_index_count(unit, FP_TCAMm),
                                "FP TCAM buffer");
    if (NULL == fp_tcam_buf) {
        return BCM_E_MEMORY;
    }
    sal_memset(fp_tcam_buf, 0, sizeof(fp_tcam_entry_t) *
               soc_mem_index_count(unit, FP_TCAMm));
    index_min = soc_mem_index_min(unit, FP_TCAMm);
    index_max = soc_mem_index_max(unit, FP_TCAMm);
    fs = stage_fc->slices[_FP_DEF_INST];
    if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
        slice_ent_cnt = fs->entry_count * 2;
        /* DMA in chunks */
        for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
            if ((rv = soc_mem_read_range(unit, FP_TCAMm, MEM_BLOCK_ALL,
                                         slice_idx * slice_ent_cnt,
                                         slice_idx * slice_ent_cnt +
                                             fs->entry_count / 2 - 1,
                                         fp_tcam_buf + slice_idx *
                                             slice_ent_cnt *
                                   soc_mem_entry_words(unit, FP_TCAMm))) < 0 ) {
                goto cleanup;
            }
            if ((rv = soc_mem_read_range(unit, FP_TCAMm, MEM_BLOCK_ALL,
                                         slice_idx * slice_ent_cnt +
                                         fs->entry_count,
                                         slice_idx * slice_ent_cnt +
                                         fs->entry_count +
                                             fs->entry_count / 2 - 1,
                                         fp_tcam_buf + (slice_idx *
                                         slice_ent_cnt + fs->entry_count) *
                                    soc_mem_entry_words(unit, FP_TCAMm))) < 0 ) {
                goto cleanup;
            }
        }
    } else {
        slice_ent_cnt = fs->entry_count;
        if ((rv = soc_mem_read_range(unit, FP_TCAMm, MEM_BLOCK_ALL,
                                     index_min, index_max, fp_tcam_buf)) < 0 ) {
            goto cleanup;
        }
    }

    fp_pfs_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES(unit,
                               FP_PORT_FIELD_SELm),
                               "FP PORT_FIELD_SEL buffer");
    if (NULL == fp_pfs_buf) {
        rv = BCM_E_MEMORY;
        goto cleanup;
    }
    index_min = soc_mem_index_min(unit, FP_PORT_FIELD_SELm);
    index_max = soc_mem_index_max(unit, FP_PORT_FIELD_SELm);
    if ((rv = soc_mem_read_range(unit, FP_PORT_FIELD_SELm, MEM_BLOCK_ALL,
                                 index_min, index_max, fp_pfs_buf)) < 0 ) {
        goto cleanup;
    }

    fp_policy_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES
                                  (unit, FP_POLICY_TABLEm),
                                  "FP POLICY TABLE buffer");
    if (NULL == fp_policy_buf) {
        rv = BCM_E_MEMORY;
        goto cleanup;
    }
    index_min = soc_mem_index_min(unit, FP_POLICY_TABLEm);
    index_max = soc_mem_index_max(unit, FP_POLICY_TABLEm);
    if ((rv = soc_mem_read_range(unit, FP_POLICY_TABLEm, MEM_BLOCK_ALL,
                               index_min, index_max, fp_policy_buf)) < 0 ) {
        goto cleanup;
    }

    if (soc_mem_is_valid(unit, FP_GLOBAL_MASK_TCAMm)) {
#if defined(BCM_TRIDENT_SUPPORT)
        /* Allocate buffer to DMA X/Y-Pipe GM TCAM table entries. */
        if (SOC_IS_TD_TT(unit) &&
                SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Xm) &&
                SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Ym)) {
            fp_gm_tcam_x_buf = soc_cm_salloc(unit,
                                             SOC_MEM_TABLE_BYTES
                                             (unit,
                                             FP_GLOBAL_MASK_TCAM_Xm),
                                             "FP_GLOBAL_MASK_TCAM X-buffer"
                                             );
            if (fp_gm_tcam_x_buf == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }

            index_min = soc_mem_index_min(unit, FP_GLOBAL_MASK_TCAM_Xm);
            index_max = soc_mem_index_max(unit, FP_GLOBAL_MASK_TCAM_Xm);
            if ((rv = soc_mem_read_range(unit,
                                         FP_GLOBAL_MASK_TCAM_Xm,
                                         MEM_BLOCK_ALL,
                                         index_min,
                                         index_max,
                                         fp_gm_tcam_x_buf
                                         )) < 0) {
                goto cleanup;
            }

            fp_gm_tcam_y_buf = soc_cm_salloc(unit,
                                             SOC_MEM_TABLE_BYTES
                                             (unit,
                                             FP_GLOBAL_MASK_TCAM_Ym),
                                             "FP_GLOBAL_MASK_TCAM Y-buffer"
                                             );
            if (fp_gm_tcam_y_buf == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }

            index_min = soc_mem_index_min(unit, FP_GLOBAL_MASK_TCAM_Ym);
            index_max = soc_mem_index_max(unit, FP_GLOBAL_MASK_TCAM_Ym);
            if ((rv = soc_mem_read_range(unit,
                                         FP_GLOBAL_MASK_TCAM_Ym,
                                         MEM_BLOCK_ALL,
                                         index_min,
                                         index_max,
                                         fp_gm_tcam_y_buf
                                         )) < 0) {
                goto cleanup;
            }
        } else
#endif
        {
            fp_global_mask_tcam_buf = soc_cm_salloc(unit,
                                        SOC_MEM_TABLE_BYTES(
                                        unit,
                                        FP_GLOBAL_MASK_TCAMm),
                                        "FP_GLOBAL_MASK_TCAM buffer");
            if (fp_global_mask_tcam_buf == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
            index_min = soc_mem_index_min(unit, FP_GLOBAL_MASK_TCAMm);
            index_max = soc_mem_index_max(unit, FP_GLOBAL_MASK_TCAMm);
            if ((rv = soc_mem_read_range(unit,
                        FP_GLOBAL_MASK_TCAMm,
                        MEM_BLOCK_ALL,
                        index_min,
                        index_max,
                        fp_global_mask_tcam_buf)) < 0) {
                goto cleanup;
            }
        }
    } else {
        /* No global mask TCAM
           => Entries apply to all ports
        */

        BCM_PBMP_ASSIGN(entry_pbmp, PBMP_ALL(unit));
        BCM_PBMP_ASSIGN(entry_mask_pbmp, PBMP_ALL(unit));
#if defined(BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &entry_pbmp);
            _bcm_kt2_subport_pbmp_update(unit, &entry_mask_pbmp);
        }
#endif

    }

#if defined(BCM_TRIDENT_SUPPORT)
    fp_table_pointers->fp_gm_tcam_x_buf        = fp_gm_tcam_x_buf;
    fp_table_pointers->fp_gm_tcam_y_buf        = fp_gm_tcam_y_buf;
#endif
    fp_table_pointers->fp_global_mask_tcam_buf = fp_global_mask_tcam_buf;

    /* Recover range checkers */
    rv = _field_range_check_reinit(unit, stage_fc, fc);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    if (fc->l2warm) {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_7) {
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Recovering hints from "
                                        "pos = %d\r\n"), fc->scache_pos));
                    BCM_IF_ERROR_RETURN (_bcm_field_hints_scache_recover (unit,
                                fc, stage_fc, &buf[fc->scache_pos]));
                }
            }
        }
    }

    if (fc->l2warm) {
        if (!(SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit)
             || SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit))) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_5) {
                /* Read field qualifier count */
                recovered_count |= (buf[fc->scache_pos] << 8);
                fc->scache_pos++;
                recovered_count |= buf[fc->scache_pos];
                fc->scache_pos++;
            }
        }
    }

    /* Recover data qualifiers */
    rv = _field_data_qual_recover(unit, fc, stage_fc);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }

    /* Get slice expansion status and virtual map */
    if ((rv = _field_tr2_ifp_slice_expanded_status_get(unit,
                                                       fc,
                                                       stage_fc,
                                                       expanded,
                                                       slice_master_idx
                                                       )
         ) < 0
        ) {
        goto cleanup;
    }

    /* Iterate over the slices */
    if ((rv = READ_FP_SLICE_ENABLEr(unit, &rval)) < 0) {
        goto cleanup;
    }
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        /* Ignore disabled slice */
        if ((soc_reg_field_get(unit,
                               FP_SLICE_ENABLEr,
                               rval,
                               ifp_en_flds[slice_idx]
                               )
             == 0
             ) || soc_reg_field_get(unit,
                                    FP_SLICE_ENABLEr,
                                    rval,
                                    ifp_lk_en_flds[slice_idx]
                                    )
            == 0
            ) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
        pfs_entry = soc_mem_table_idx_to_pointer(unit, FP_PORT_FIELD_SELm,
                                                fp_port_field_sel_entry_t *,
                                                fp_pfs_buf, 0);
        fld = ifp_en_slice_pairing_field[slice_idx / 2];
        paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                    pfs_entry, fld);

        intraslice =
            soc_mem_field32_get_def(unit,
                                    FP_PORT_FIELD_SELm,
                                    pfs_entry,
                                    ifp_en_slice_wide_mode_field[slice_idx],
                                    FALSE
                                    );

        if (paired && (slice_idx % 2)) {
            continue;
        }

        /* Don't need to read selectors for expanded slice */
        if (expanded[slice_idx]) {
            continue;
        }

        /* Skip if slice has no valid groups and entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        slice_ent_cnt = fs->entry_count;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            if (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                    stage_fc,
                                                    _FP_DEF_INST,
                                                    slice_idx,
                                                    idx,
                                                    &phys_tcam_idx
                                                    )
                != BCM_E_NONE
                ) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                      fp_tcam_entry_t *,
                                                      fp_tcam_buf,
                                                      phys_tcam_idx
                                                      );
            if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) != 0) {
                break;
            }
        }
        if ((idx == slice_ent_cnt) && !fc->l2warm) {
            continue;
        }

        /* If Level 2, retrieve the GIDs in this slice */
        if (fc->l2warm) {
            rv = _field_trx_scache_slice_group_recover(unit,
                                                       fc, _FP_DEF_INST,
                                                       slice_idx,
                                                       &multigroup,
                                                       stage_fc,
                                                       recovered_count
                                                       );
            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                fc->l2warm = 0;
                goto cleanup;
            }
            if (rv == BCM_E_NOT_FOUND) {
                rv = BCM_E_NONE;
                continue;
            }
        }

        /* Iterate over FP_PORT_FIELD_SEL for all ports and this slice
         * to identify bins for selectors (also groups for level 1) */
        BCM_PBMP_ITER(valid_pbm, port) {
            if (IS_LB_PORT(unit, port)) {
                continue;
            }

            _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[0]);
            hw_sels.pri_slice[0].intraslice
                = hw_sels.pri_slice[0].secondary = _FP_SELCODE_DONT_USE;
            _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[1]);
            hw_sels.pri_slice[1].intraslice
                = hw_sels.pri_slice[1].secondary = _FP_SELCODE_DONT_USE;
            _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[0]);
            hw_sels.sec_slice[0].intraslice
                = hw_sels.sec_slice[0].secondary = _FP_SELCODE_DONT_USE;
            _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[1]);
            hw_sels.sec_slice[1].intraslice
                = hw_sels.sec_slice[1].secondary = _FP_SELCODE_DONT_USE;

            pfs_entry = soc_mem_table_idx_to_pointer
                            (unit, FP_PORT_FIELD_SELm,
                             fp_port_field_sel_entry_t *, fp_pfs_buf, port);
            /* Get primary slice's selectors */
            hw_sels.pri_slice[0].fpf1 = soc_FP_PORT_FIELD_SELm_field32_get(
                                            unit,
                                            pfs_entry,
                                            ifp_en_field_tbl[slice_idx][0]
                                                                           );
            hw_sels.pri_slice[0].fpf2 = soc_FP_PORT_FIELD_SELm_field32_get(
                                            unit,
                                            pfs_entry,
                                            ifp_en_field_tbl[slice_idx][1]
                                                                           );
            hw_sels.pri_slice[0].fpf3 = soc_FP_PORT_FIELD_SELm_field32_get(
                                            unit,
                                            pfs_entry,
                                            ifp_en_field_tbl[slice_idx][2]
                                                                           );
            /* Retrieve Tunnel Type information */
            if (SOC_IS_TRIUMPH2(unit)
                || SOC_IS_APOLLO(unit)
                || SOC_IS_VALKYRIE2(unit)
                || SOC_IS_ENDURO(unit)
                || SOC_IS_KATANA(unit)) {
                rv = _field_tr2_loopback_type_sel_recover
                        (unit,
                         slice_idx,
                         fp_tcam_buf,
                         stage_fc,
                         intraslice,
                         &(hw_sels.pri_slice[0].loopback_type_sel)
                         );
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
#if defined(BCM_KATANA2_SUPPORT)
             } else if (SOC_IS_KATANA2(unit)) {
                        rv = _bcm_field_kt2_loopback_type_sel_recover
                                 (unit,
                                 slice_idx,
                                 fp_global_mask_tcam_buf,
                                 stage_fc,
                                 intraslice,
                                 &(hw_sels.pri_slice[0].loopback_type_sel)
                                 );
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }
#endif
             }

            if (SOC_REG_FIELD_VALID(unit, FP_FORCE_FORWARDING_FIELDr,
                        _bcm_trx2_vrf_force_forwarding_enable_field[slice_idx])) {
                READ_FP_FORCE_FORWARDING_FIELDr(unit, &fwd_field_sel);

                if(soc_reg_field_get(unit,
                            FP_FORCE_FORWARDING_FIELDr,
                            fwd_field_sel,
                            _bcm_trx2_vrf_force_forwarding_enable_field[slice_idx]
                            )) {
                    hw_sels.pri_slice[0].fwd_field_sel = 1;
                }
            }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
            if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                        _bcm_ifp_normalize_fldtbl[slice_idx][0])) {
                hw_sels.pri_slice[0].normalize_ip_sel = 0;
                if(soc_FP_PORT_FIELD_SELm_field32_get(
                              unit,
                              pfs_entry,
                              _bcm_ifp_normalize_fldtbl[slice_idx][0]
                            )) {
                    hw_sels.pri_slice[0].normalize_ip_sel = 1;
                }
            }

            if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                        _bcm_ifp_normalize_fldtbl[slice_idx][1])) {
                hw_sels.pri_slice[0].normalize_mac_sel = 0;
                if(soc_FP_PORT_FIELD_SELm_field32_get(
                              unit,
                              pfs_entry,
                              _bcm_ifp_normalize_fldtbl[slice_idx][1]
                            )) {
                    hw_sels.pri_slice[0].normalize_mac_sel = 1;
                }
            }
#endif

            if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm, SLICE0_S_TYPE_SELf)) {
                s_field = soc_FP_PORT_FIELD_SELm_field32_get(
                              unit,
                              pfs_entry,
                              ifp_en_sd_type_field_tbl[slice_idx][0]
                                                             );
                d_field = soc_FP_PORT_FIELD_SELm_field32_get(
                              unit,
                              pfs_entry,
                              ifp_en_sd_type_field_tbl[slice_idx][1]
                                                             );
                /* Check for L3_IIF or SVP */
                _field_tr2_ingress_entity_get(unit, slice_idx, fp_tcam_buf,
                                  slice_ent_cnt, stage_fc,
                                  &(hw_sels.pri_slice[0].ingress_entity_sel));
            } else {
                /* Device (Triumph, for one) does not support source and destination qualification
                   => Use a default value
                */

                s_field = d_field = -1;
            }

            switch (s_field) {
            case 1:
                hw_sels.pri_slice[0].src_entity_sel = _bcmFieldFwdEntityGlp;
                break;
            case 2:
                hw_sels.pri_slice[0].src_entity_sel =
                    _bcmFieldFwdEntityModPortGport;
                break;
            case 3:
                /* Need to adjust later based on actual VP */
                hw_sels.pri_slice[0].src_entity_sel =
                    _bcmFieldFwdEntityMimGport;
                break;
            default:
                hw_sels.pri_slice[0].src_entity_sel = _bcmFieldFwdEntityAny;
                break;
            }

            switch (d_field) {
            case 0:
                hw_sels.pri_slice[0].dst_fwd_entity_sel =
                        _bcmFieldFwdEntityGlp;
                break;
            case 1:
                hw_sels.pri_slice[0].dst_fwd_entity_sel =
                    _bcmFieldFwdEntityL3Egress;
                break;
            case 2:
                hw_sels.pri_slice[0].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityMulticastGroup;
                break;
            case 3:
                /* Need to adjust later based on actual VP */
                hw_sels.pri_slice[0].dst_fwd_entity_sel =
                    _bcmFieldFwdEntityMimGport;
                break;
            case 7:
                hw_sels.pri_slice[0].dst_fwd_entity_sel =
                                     _bcmFieldFwdEntityMultipath;
                break;
            default:
                hw_sels.pri_slice[0].dst_fwd_entity_sel = _bcmFieldFwdEntityAny;
                break;
            }

            _field_tr2_slice_key_control_entry_recover(unit,
                                                       slice_idx,
                                                       &hw_sels.pri_slice[0]
                                                       );

            /* If intraslice, get double-wide key */
            if (intraslice) {
                uint32 dwf4sel, dwf1sel;

                hw_sels.pri_slice[1].intraslice = TRUE;
                hw_sels.pri_slice[1].fpf2
                    = soc_mem_field32_get(unit,
                                          FP_PORT_FIELD_SELm,
                                          pfs_entry,
                                          ifp_en_double_wide_key[slice_idx]
                                          );

                if (SOC_IS_KATANA2(unit)) {
                    double_wide_reg = FP_DOUBLE_WIDE_SELECTr;
                    soc_reg32_get(unit, double_wide_reg,
                        REG_PORT_ANY, 0, &dwf1sel);
                    hw_sels.pri_slice[1].fpf1
                        = soc_reg_field_get(unit,
                                            double_wide_reg,
                                            dwf1sel,
                                            ifp_en_ing_f1_reg[slice_idx]
                                            );
                } else {
                    double_wide_reg = FP_DOUBLE_WIDE_F4_SELECTr;
                }
                soc_reg32_get(unit, double_wide_reg, REG_PORT_ANY, 0, &dwf4sel);
                hw_sels.pri_slice[1].fpf4
                    = soc_reg_field_get(unit,
                                        double_wide_reg,
                                        dwf4sel,
                                        ifp_en_ing_f4_reg[slice_idx]
                                        );

                if (SOC_REG_FIELD_VALID(unit, FP_DOUBLE_WIDE_F1_SELECTr,
                                ifp_en_ing_f1_reg[slice_idx])) {
                    soc_reg32_get(unit, FP_DOUBLE_WIDE_F1_SELECTr,
                        REG_PORT_ANY, 0, &dwf1sel);
                    hw_sels.pri_slice[1].fpf1
                        = soc_reg_field_get(unit,
                                            FP_DOUBLE_WIDE_F1_SELECTr,
                                            dwf1sel,
                                            ifp_en_ing_f1_reg[slice_idx]
                                            );
                }

                if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                                        SLICE0_S_TYPE_SELf)) {
                    d_field = soc_mem_field32_get(unit,
                                          FP_PORT_FIELD_SELm,
                                          pfs_entry,
                                          ifp_en_sd_type_field_tbl[slice_idx][1]
                                          );
                    switch (d_field) {
                        case 0:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityGlp;
                            break;
                        case 1:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityL3Egress;
                            break;
                        case 2:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityMulticastGroup;
                            break;
                        case 3:
                            /* Need to adjust later based on actual VP */
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityMimGport;
                            break;
                        case 7:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                     _bcmFieldFwdEntityMultipath;
                            break;
                        default:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                _bcmFieldFwdEntityGlp;
                        break;
                    }
                }
            }
            /* If paired, get secondary slice's selectors */
            if (paired) {
                hw_sels.sec_slice[0].secondary = _FP_SELCODE_DONT_CARE;

                hw_sels.sec_slice[0].fpf1 = soc_FP_PORT_FIELD_SELm_field32_get
                                         (unit, pfs_entry,
                                          ifp_en_field_tbl[slice_idx + 1][0]);
                hw_sels.sec_slice[0].fpf2 = soc_FP_PORT_FIELD_SELm_field32_get
                                         (unit, pfs_entry,
                                          ifp_en_field_tbl[slice_idx + 1][1]);
                hw_sels.sec_slice[0].fpf3 = soc_FP_PORT_FIELD_SELm_field32_get
                                         (unit, pfs_entry,
                                          ifp_en_field_tbl[slice_idx + 1][2]);

                if (SOC_REG_FIELD_VALID(unit, FP_FORCE_FORWARDING_FIELDr,
                            _bcm_trx2_vrf_force_forwarding_enable_field[slice_idx + 1])) {
                    READ_FP_FORCE_FORWARDING_FIELDr(unit, &fwd_field_sel);

                    if (soc_reg_field_get(unit,
                                FP_FORCE_FORWARDING_FIELDr,
                                fwd_field_sel,
                                _bcm_trx2_vrf_force_forwarding_enable_field[slice_idx + 1]
                                )) {
                        hw_sels.sec_slice[0].fwd_field_sel = 1;
                    }
                }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
                if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                            _bcm_ifp_normalize_fldtbl[slice_idx + 1][0])) {
                    hw_sels.sec_slice[0].normalize_ip_sel = 0;
                    if(soc_FP_PORT_FIELD_SELm_field32_get(
                                unit,
                                pfs_entry,
                                _bcm_ifp_normalize_fldtbl[slice_idx + 1][0]
                                )) {
                        hw_sels.sec_slice[0].normalize_ip_sel = 1;
                    }
                }

                if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                            _bcm_ifp_normalize_fldtbl[slice_idx + 1][1])) {
                    hw_sels.sec_slice[0].normalize_mac_sel = 0;
                    if(soc_FP_PORT_FIELD_SELm_field32_get(
                                unit,
                                pfs_entry,
                                _bcm_ifp_normalize_fldtbl[slice_idx + 1][1]
                                )) {
                        hw_sels.sec_slice[0].normalize_mac_sel = 1;
                    }
                }
#endif

                if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                                        SLICE0_S_TYPE_SELf)) {
                    s_field = soc_FP_PORT_FIELD_SELm_field32_get(
                                  unit,
                                  pfs_entry,
                                  ifp_en_sd_type_field_tbl[slice_idx + 1][0]
                                                             );
                    d_field = soc_FP_PORT_FIELD_SELm_field32_get(
                                  unit,
                                  pfs_entry,
                                  ifp_en_sd_type_field_tbl[slice_idx + 1][1]
                                                             );
                    /* Check for L3_IIF or SVP */
                    _field_tr2_ingress_entity_get(unit, slice_idx,
                                                  fp_tcam_buf,
                                                  slice_ent_cnt, stage_fc,
                              &(hw_sels.sec_slice[0].ingress_entity_sel));
                }
                switch (s_field) {
                case 1:
                    hw_sels.sec_slice[0].src_entity_sel = _bcmFieldFwdEntityGlp;
                    break;
                case 2:
                    hw_sels.sec_slice[0].src_entity_sel =
                                                 _bcmFieldFwdEntityModPortGport;
                    break;
                case 3:
                    /* Need to adjust later based on actual VP */
                    hw_sels.sec_slice[0].src_entity_sel =
                                                     _bcmFieldFwdEntityMimGport;
                    break;
                 default:
                    hw_sels.sec_slice[0].src_entity_sel = _bcmFieldFwdEntityAny;
                    break;
                }

                switch (d_field) {
                case 0:
                    hw_sels.sec_slice[0].dst_fwd_entity_sel =
                                                 _bcmFieldFwdEntityGlp;
                    break;
                case 1:
                    hw_sels.sec_slice[0].dst_fwd_entity_sel =
                                                 _bcmFieldFwdEntityL3Egress;
                    break;
                case 2:
                    hw_sels.pri_slice[0].dst_fwd_entity_sel =
                                            _bcmFieldFwdEntityMulticastGroup;
                    break;
                case 3:
                    /* Need to adjust later based on actual VP */
                    hw_sels.sec_slice[0].dst_fwd_entity_sel =
                                                     _bcmFieldFwdEntityMimGport;
                    break;
                case 7:
                    hw_sels.pri_slice[0].dst_fwd_entity_sel =
                                     _bcmFieldFwdEntityMultipath;
                            break;
                 default:
                    hw_sels.sec_slice[0].dst_fwd_entity_sel =
                                                          _bcmFieldFwdEntityAny;
                    break;
                }

                _field_tr2_slice_key_control_entry_recover(unit,
                                                           slice_idx + 1,
                                                           &hw_sels.sec_slice[0]
                                                           );

                if (intraslice) {
                    uint32 dwf4sel;

                    hw_sels.sec_slice[1].intraslice = TRUE;
                    hw_sels.sec_slice[1].fpf2
                        = soc_mem_field32_get(unit,
                                           FP_PORT_FIELD_SELm,
                                           pfs_entry,
                                           ifp_en_double_wide_key[slice_idx + 1]
                                           );
                    if (SOC_IS_KATANA2(unit)) {
                        double_wide_reg = FP_DOUBLE_WIDE_SELECTr;
                    } else {
                        double_wide_reg = FP_DOUBLE_WIDE_F4_SELECTr;
                    }
                    soc_reg32_get(unit, double_wide_reg, REG_PORT_ANY, 0, &dwf4sel);
                    hw_sels.sec_slice[1].fpf4
                        = soc_reg_field_get(unit,
                                            double_wide_reg,
                                            dwf4sel,
                                            ifp_en_ing_f4_reg[slice_idx + 1]
                                            );

                    if (soc_mem_field_valid(unit, FP_PORT_FIELD_SELm,
                                            SLICE0_S_TYPE_SELf)) {
                        d_field = soc_mem_field32_get(unit,
                                          FP_PORT_FIELD_SELm,
                                          pfs_entry,
                                          ifp_en_sd_type_field_tbl[slice_idx][1]
                                          );
                        switch (d_field) {
                        case 0:
                            hw_sels.sec_slice[1].dst_fwd_entity_sel =
                                                     _bcmFieldFwdEntityGlp;
                            break;
                        case 1:
                            hw_sels.sec_slice[1].dst_fwd_entity_sel =
                                                     _bcmFieldFwdEntityL3Egress;
                            break;
                        case 2:
                            hw_sels.sec_slice[1].dst_fwd_entity_sel =
                                               _bcmFieldFwdEntityMulticastGroup;
                            break;
                        case 3:
                            /* Need to adjust later based on actual VP */
                            hw_sels.sec_slice[1].dst_fwd_entity_sel =
                                                     _bcmFieldFwdEntityMimGport;
                            break;
                        case 7:
                            hw_sels.pri_slice[1].dst_fwd_entity_sel =
                                     _bcmFieldFwdEntityMultipath;
                            break;
                        default:
                            hw_sels.sec_slice[1].dst_fwd_entity_sel =
                                                          _bcmFieldFwdEntityGlp;
                            break;
                        }
                    }
                }
            }
            /* Create a group based on HW qualifiers (or find existing) */
            rv = _field_tr2_group_construct(unit,
                                            _FP_DEF_INST,
                                            &hw_sels,
                                            intraslice,
                                            paired,
                                            fc,
                                            port,
                                            _BCM_FIELD_STAGE_INGRESS,
                                            slice_idx
                                            );
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        /* Now go over the entries in this slice */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        slice_ent_cnt = fs->entry_count;
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            slice_ent_cnt >>= 1;
            fs->free_count >>= 1;
        }
        prev_prio = -1;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            group_found = 0;

            if (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                    stage_fc,
                                                    _FP_DEF_INST,
                                                    slice_idx,
                                                    idx,
                                                    &phys_tcam_idx
                                                    )
                != BCM_E_NONE
                ) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                      fp_tcam_entry_t *,
                                                      fp_tcam_buf,
                                                      phys_tcam_idx
                                                      );
            if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) == 0) {
                continue;
            }

            /* Check which ports are applicable to this entry */

            if (soc_mem_is_valid(unit, FP_GLOBAL_MASK_TCAMm)) {
#if defined (BCM_TRIDENT_SUPPORT)
                if (SOC_IS_TD_TT(unit) &&
                        SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Xm) &&
                        SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Ym)) {
                    /* Get X-Pipe IPBM KEY and MASK value. */
                    fp_gm_tcam_x_entry = soc_mem_table_idx_to_pointer(
                                            unit,
                                            FP_GLOBAL_MASK_TCAM_Xm,
                                            fp_global_mask_tcam_x_entry_t *,
                                            fp_gm_tcam_x_buf,
                                            phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Xm,
                                           fp_gm_tcam_x_entry,
                                           IPBMf,
                                           &entry_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Xm,
                                           fp_gm_tcam_x_entry,
                                           IPBM_MASKf,
                                           &entry_mask_pbmp);

                    /* Get Y-Pipe IPBM KEY and MASK value. */
                    fp_gm_tcam_y_entry = soc_mem_table_idx_to_pointer(
                                            unit,
                                            FP_GLOBAL_MASK_TCAM_Ym,
                                            fp_global_mask_tcam_y_entry_t *,
                                            fp_gm_tcam_y_buf,
                                            phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Ym,
                                           fp_gm_tcam_y_entry,
                                           IPBMf,
                                           &temp_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Ym,
                                           fp_gm_tcam_y_entry,
                                           IPBM_MASKf,
                                           &temp_pbm_mask);
                    SOC_PBMP_OR(entry_pbmp, temp_pbmp);
                    SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
                } else
#endif
                {
                    global_mask_tcam_entry = soc_mem_table_idx_to_pointer(
                                                unit,
                                                FP_GLOBAL_MASK_TCAMm,
                                                fp_global_mask_tcam_entry_t *,
                                                fp_global_mask_tcam_buf,
                                                phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAMm,
                                           global_mask_tcam_entry,
                                           IPBMf,
                                           &entry_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAMm,
                                           global_mask_tcam_entry,
                                           IPBM_MASKf,
                                           &entry_mask_pbmp);
                }
            } else {
                soc_mem_pbmp_field_get(unit,
                                       FP_TCAMm,
                                       tcam_entry,
                                       IPBMf,
                                       &entry_pbmp
                                       );
                soc_mem_pbmp_field_get(unit,
                                       FP_TCAMm,
                                       tcam_entry,
                                       IPBM_MASKf,
                                       &entry_mask_pbmp
                                       );
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT)
                /*
                 * Scorpion and Conqurer are dual pipe line devices.
                 * Retrieve IPBMf and IPBM_MASKf field values from Y Pipleline
                 * FP_TCAM table.
                 */
                if (SOC_IS_SC_CQ(unit)) {
                    sal_memset(&tcam_dual_pipe_entry, 0,
                        sizeof(tcam_dual_pipe_entry));
                    rv = soc_mem_read(unit, FP_TCAM_Ym, MEM_BLOCK_ANY,
                            phys_tcam_idx, tcam_dual_pipe_entry);
                    if (BCM_FAILURE(rv)) {
                        goto cleanup;
                    }
                    soc_mem_pbmp_field_get(unit,
                                           FP_TCAM_Ym,
                                           tcam_dual_pipe_entry,
                                           IPBMf,
                                           &temp_pbmp
                                           );
                    soc_mem_pbmp_field_get(unit,
                                           FP_TCAM_Ym,
                                           tcam_dual_pipe_entry,
                                           IPBM_MASKf,
                                           &temp_pbm_mask
                                           );
                    SOC_PBMP_OR(entry_pbmp, temp_pbmp);
                    SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
                }
#endif
            }

            /* Search groups to find match */
            fg = fc->groups;
            while (fg != NULL) {
                /* Check if group is in this slice */
                fs = &fg->slices[0];
                if ((fg->stage_id != stage_fc->stage_id)
                        || (fs->slice_number != slice_idx)) {
                    fg = fg->next;
                    continue;
                }

                /* Check if entry_pbmp is a subset of group pbmp */

                SOC_PBMP_CLEAR(temp_pbmp);
                SOC_PBMP_ASSIGN(temp_pbmp, fg->pbmp);
                SOC_PBMP_OR(temp_pbmp, PBMP_LB(unit));
                SOC_PBMP_AND(temp_pbmp, entry_pbmp);
                if (SOC_PBMP_EQ(temp_pbmp, entry_pbmp)) {
                    group_found = 1;
                    break;
                }

                fg = fg->next;
            }
            if (!group_found) {
                return BCM_E_INTERNAL; /* Should never happen */
            }

            /* Allocate memory for the entry */
            rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                   fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            mem_sz = parts_count * sizeof (_field_entry_t);
            _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                /* Recover f_ent_oam_wb structure from here */
                /* Allocate f_ent_oam_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8) {
                    _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_oam_wb == NULL) {
                        sal_free (f_ent);
                        return BCM_E_MEMORY;
                    }
                }
                f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                   action_bmp.w = NULL;
                   _FP_XGS3_ALLOC(action_bmp.w,
                             SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                             "Action No Param Bitmap");
                   if (action_bmp.w == NULL) {
                      rv = BCM_E_MEMORY;
                      sal_free(f_ent);
                      goto cleanup;
                   }
                }
                f_ent_wb_info.action_bmp = &action_bmp;

                /* Recover f_ent_policer_wb structure from here */
                /* Allocate f_ent_policer_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                    _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_policer_wb == NULL) {
                        rv = BCM_E_MEMORY;
                        sal_free (f_ent);
                        goto cleanup;
                    }
                }
                f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;

                rv = _field_trx_entry_info_retrieve(unit,
                                                    fc,
                                                    stage_fc,
                                                    multigroup,
                                                    &prev_prio,
                                                    &f_ent_wb_info
                                                    );
                
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    sal_free(f_ent);
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }
            pri_tcam_idx = phys_tcam_idx;

            vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                    slice_idx, stage_fc);
            if (vslice_idx == -1) {
                rv = BCM_E_INTERNAL;
                sal_free(f_ent);
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                goto cleanup;
            }

            for (i = 0; i < parts_count; i++) {
                if (fc->l2warm) {
                    /* Use retrieved EID and priority */
                    f_ent[i].eid = f_ent_wb_info.eid;
                    /*
                     * In warm boot level 2, during sync, entry priority is
                     * written only for the first part of the entry and during
                     * recovery, the priority value from the first part is
                     * assigned to all parts of entry
                     */
                    f_ent[i].prio = f_ent_wb_info.prio;

                    /* Set retrieved dvp_type and svp_type */
                    f_ent[i].dvp_type  = f_ent_wb_info.dvp_type[i];
                    f_ent[i].svp_type  = f_ent_wb_info.svp_type[i];
#if defined(BCM_APACHE_SUPPORT)
                    /* Set retrieved OAM MEP type */
                    if (SOC_IS_APACHE(unit) && (i == 0)) {
                        f_ent[i].eth_oam_ctrl_mep_type = f_ent_wb_info.ingress_oam_mep_type[0];
                        f_ent[i].eth_oam_data_mep_type = f_ent_wb_info.ingress_oam_mep_type[1];
                        f_ent[i].mpls_oam_ctrl_mep_type = f_ent_wb_info.ingress_oam_mep_type[2];
                        f_ent[i].mpls_oam_data_mep_type = f_ent_wb_info.ingress_oam_mep_type[3];
                    }
#endif

                } else {
                    f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    /*
                     * For warm boot level 1, priority derived from vslice_idx
                     * is assigned to all parts of the entry
                     */
                    f_ent[i].prio = (vslice_idx << 10) | (slice_ent_cnt - idx);
                }
                f_ent[i].group = fg;
                if (i == 0) {
                    BCM_PBMP_ASSIGN(f_ent[i].pbmp.data, entry_pbmp);
                    BCM_PBMP_ASSIGN(f_ent[i].pbmp.mask, entry_mask_pbmp);
                }

                rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                         &f_ent[i].flags);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                if (f_ent_wb_info.color_independent) {
                    f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                }
                rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                        pri_tcam_idx,
                                                        i, &part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                         _FP_DEF_INST,
                                                         part_index,
                                                         &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                f_ent[i].fs = stage_fc->slices[_FP_DEF_INST] + slice_number;
                BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Decrement slice free entry count for primary
                       entries. */
                    f_ent[i].fs->free_count--;
                }
                /* Assign entry to a slice */
                f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) == 3) {
                    f_ent[i].flags |= _FP_ENTRY_ENABLED;
                }
                if (((!SOC_IS_TRIDENT2X(unit) && !SOC_IS_TITAN2PLUS(unit)))
                    && (SOC_IS_TD_TT(unit))) {
                    if (paired && i == 1) {
                        f_ent[i].flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
                    }
                } else if (SOC_IS_KATANAX(unit) && intraslice &&
                           ((i == 1) || (i == 3))) {
                    f_ent[i].flags |= _FP_ENTRY_USES_IPBM_OVERLAY;
                }

#if defined BCM_TRIDENT2PLUS_SUPPORT
                if (soc_feature(unit, soc_feature_fp_based_oam)) {
                    rv = _field_oam_stat_action_scache_recover
                        (unit, stage_fc, f_ent, f_ent_oam_wb);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
                /* Get the actions associated with this part of the entry */

                policy_entry = soc_mem_table_idx_to_pointer(
                                   unit,
                                   FP_POLICY_TABLEm,
                                   fp_policy_table_entry_t *,
                                   fp_policy_buf,
                                   part_index);

                rv = _field_tr2_actions_recover(unit,
                                                FP_POLICY_TABLEm,
                                                (uint32 *) policy_entry,
                                                f_ent,
                                                i,
                                                &f_ent_wb_info);
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (action_bmp.w != NULL) {
                   _FP_ACTION_BMP_FREE(action_bmp);
                   action_bmp.w = NULL;
                }
            }

            /* Add to the group */
            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                goto cleanup;
            }
            f_ent = NULL;

            /* Entry has been added to group,
             * so free f_ent_oam_wb structure */
            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
            if (f_ent_policer_wb != NULL) {
                sal_free(f_ent_policer_wb);
                f_ent_policer_wb = NULL;
            }
        }

        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) {
                /* update selcode and construct group qual offset */
                rv = _field_tr2_group_construct_quals_with_sel_update(unit, fc, stage_fc);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
            }
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }
    }

    /* Now go over the expanded slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        if (!expanded[slice_idx]) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
        pfs_entry = soc_mem_table_idx_to_pointer(unit, FP_PORT_FIELD_SELm,
                                                fp_port_field_sel_entry_t *,
                                                fp_pfs_buf, 0);
        fld = ifp_en_slice_pairing_field[slice_idx / 2];
        paired = soc_FP_PORT_FIELD_SELm_field32_get(unit,
                                                    pfs_entry, fld);
        if (paired && (slice_idx % 2)) {
            continue;
        }
        /* Skip if slice has no valid entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        slice_ent_cnt = fs->entry_count;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            if (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                    stage_fc,
                                                    _FP_DEF_INST,
                                                    slice_idx,
                                                    idx,
                                                    &phys_tcam_idx
                                                    )
                != BCM_E_NONE
                ) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                      fp_tcam_entry_t *,
                                                      fp_tcam_buf,
                                                      phys_tcam_idx
                                                      );
            if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) != 0) {
                break;
            }
        }
        if (idx == slice_ent_cnt) {
            continue;
        }
        /* If Level 2, retrieve the GIDs in this slice */
        if (fc->l2warm) {
            rv = _field_trx_scache_slice_group_recover(unit,
                                                       fc, _FP_DEF_INST,
                                                       slice_idx,
                                                       &multigroup,
                                                       stage_fc,
                                                       recovered_count
                                                       );
            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                fc->l2warm = 0;
                goto cleanup;
            }
            if (rv == BCM_E_NOT_FOUND) {
                rv = BCM_E_NONE;
                continue;
            }
        }
        /* Now find the master slice for this virtual group */
        vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                slice_idx, stage_fc);
        if (vslice_idx < 0) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        if (fc->l2warm
                && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
            master_slice = slice_master_idx[slice_idx];
        } else {
        max = -1;
        for (i = 0; i < stage_fc->tcam_slices; i++) {
            if ((stage_fc->vmap[_FP_DEF_INST][0][vslice_idx].virtual_group ==
                stage_fc->vmap[_FP_DEF_INST][0][i].virtual_group) && (i != vslice_idx)) {
                if (i > max) {
                    max = i;
                }
            }
        }
        if (max < 0) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        master_slice = stage_fc->vmap[_FP_DEF_INST][0][max].vmap_key;
        }
        /* See which group is in this slice - can be only one */
        fg = fc->groups;
        while (fg != NULL) {
            /* Check if group is in this slice */
            fs = &fg->slices[0];
            if ((fg->stage_id == stage_fc->stage_id)
                    && (fs->slice_number == master_slice)) {
                break;
            }
            fg = fg->next;
        }
        if (fg == NULL) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        /* Get number of entry parts for the group. */
        rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                                fg->flags, &parts_count);
        BCM_IF_ERROR_RETURN(rv);

        old_physical_slice = fs->slice_number;

        /* Set up the new physical slice parameters in Software */
        for(part_index = parts_count - 1; part_index >= 0; part_index--) {
            /* Get entry flags. */
            rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg, &entry_flags);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice id for entry part */
            rv = _bcm_field_tcam_part_to_slice_number(unit, part_index,
                                                      fg, &slice_num);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice pointer. */
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx
                    + slice_num;

            if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
                /* Set per slice configuration &  number of free entries in the slice.*/
                fs->free_count = fs->entry_count;
                if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                    fs->free_count >>= 1;
                }
                /* Set group flags in in slice.*/
                fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

                /* Add slice to slices linked list . */
                fs_temp = stage_fc->slices[_FP_DEF_INST] + old_physical_slice + slice_num;
                /* To handle more than one auto expanded slice in a group */
                while (fs_temp->next != NULL) {
                    fs_temp = fs_temp->next;
                }
                fs_temp->next = fs;
                fs->prev = fs_temp;
            }
        }

        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;
        slice_ent_cnt = fs->entry_count;
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            slice_ent_cnt >>= 1;
        }

        prev_prio = -1;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            group_found = 0;
            if (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                    stage_fc,
                                                    _FP_DEF_INST,
                                                    slice_idx,
                                                    idx,
                                                    &phys_tcam_idx
                                                    )
                != BCM_E_NONE
                ) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            tcam_entry = soc_mem_table_idx_to_pointer(unit, FP_TCAMm,
                                                      fp_tcam_entry_t *,
                                                      fp_tcam_buf,
                                                      phys_tcam_idx
                                                      );
            if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) == 0) {
                continue;
            }
            /* Check which ports are applicable to this entry */

            if (soc_mem_is_valid(unit, FP_GLOBAL_MASK_TCAMm)) {
#if defined (BCM_TRIDENT_SUPPORT)
                if (SOC_IS_TD_TT(unit) &&
                        SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Xm) &&
                        SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Ym)) {
                    /* Get X-Pipe IPBM KEY and MASK value. */
                    fp_gm_tcam_x_entry = soc_mem_table_idx_to_pointer(
                                            unit,
                                            FP_GLOBAL_MASK_TCAM_Xm,
                                            fp_global_mask_tcam_x_entry_t *,
                                            fp_gm_tcam_x_buf,
                                            phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Xm,
                                           fp_gm_tcam_x_entry,
                                           IPBMf,
                                           &entry_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Xm,
                                           fp_gm_tcam_x_entry,
                                           IPBM_MASKf,
                                           &entry_mask_pbmp);

                    /* Get Y-Pipe IPBM KEY and MASK value. */
                    fp_gm_tcam_y_entry = soc_mem_table_idx_to_pointer(
                                            unit,
                                            FP_GLOBAL_MASK_TCAM_Ym,
                                            fp_global_mask_tcam_y_entry_t *,
                                            fp_gm_tcam_y_buf,
                                            phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Ym,
                                           fp_gm_tcam_y_entry,
                                           IPBMf,
                                           &temp_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAM_Ym,
                                           fp_gm_tcam_y_entry,
                                           IPBM_MASKf,
                                           &temp_pbm_mask);
                    SOC_PBMP_OR(entry_pbmp, temp_pbmp);
                    SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
                } else
#endif
                {
                    global_mask_tcam_entry = soc_mem_table_idx_to_pointer(
                                                unit,
                                                FP_GLOBAL_MASK_TCAMm,
                                                fp_global_mask_tcam_entry_t *,
                                                fp_global_mask_tcam_buf,
                                                phys_tcam_idx);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAMm,
                                           global_mask_tcam_entry,
                                           IPBMf,
                                           &entry_pbmp);
                    soc_mem_pbmp_field_get(unit,
                                           FP_GLOBAL_MASK_TCAMm,
                                           global_mask_tcam_entry,
                                           IPBM_MASKf,
                                           &entry_mask_pbmp);
                }
            } else {
                soc_mem_pbmp_field_get(unit,
                                       FP_TCAMm,
                                       tcam_entry,
                                       IPBMf,
                                       &entry_pbmp
                                       );
                soc_mem_pbmp_field_get(unit,
                                       FP_TCAMm,
                                       tcam_entry,
                                       IPBM_MASKf,
                                       &entry_mask_pbmp
                                       );
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_CONQUEROR_SUPPORT)
                /*
                 * Scorpion and Conqurer are dual pipe line devices.
                 * Retrieve IPBMf and IPBM_MASKf field values from Y Pipleline
                 * FP_TCAM table.
                 */
                if (SOC_IS_SC_CQ(unit)) {
                    sal_memset(&tcam_dual_pipe_entry, 0,
                        sizeof(tcam_dual_pipe_entry));
                    rv = soc_mem_read(unit, FP_TCAM_Ym, MEM_BLOCK_ANY,
                            phys_tcam_idx, tcam_dual_pipe_entry);
                    if (BCM_FAILURE(rv)) {
                        goto cleanup;
                    }
                    soc_mem_pbmp_field_get(unit,
                                           FP_TCAM_Ym,
                                           tcam_dual_pipe_entry,
                                           IPBMf,
                                           &temp_pbmp
                                           );
                    soc_mem_pbmp_field_get(unit,
                                           FP_TCAM_Ym,
                                           tcam_dual_pipe_entry,
                                           IPBM_MASKf,
                                           &temp_pbm_mask
                                           );
                    SOC_PBMP_OR(entry_pbmp, temp_pbmp);
                    SOC_PBMP_OR(entry_mask_pbmp, temp_pbm_mask);
                }
#endif
            }

            /* Search groups to find match */
            fg = fc->groups;
            while (fg != NULL) {
                /* Check if group is in this slice */
                fs = &fg->slices[0];
                if ((fg->stage_id != stage_fc->stage_id)
                        || (fs->slice_number != master_slice)) {
                    fg = fg->next;
                    continue;
                }

                /* Check if entry_pbmp is a subset of group pbmp */

                SOC_PBMP_CLEAR(temp_pbmp);
                SOC_PBMP_ASSIGN(temp_pbmp, fg->pbmp);
                SOC_PBMP_OR(temp_pbmp, PBMP_LB(unit));
                SOC_PBMP_AND(temp_pbmp, entry_pbmp);
                if (SOC_PBMP_EQ(temp_pbmp, entry_pbmp)) {
                    group_found = 1;
                    break;
                }

                fg = fg->next;
            }
            if (!group_found) {
                return BCM_E_INTERNAL; /* Should never happen */
            }

            /* Allocate memory for the entry */
            rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                   fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            mem_sz = parts_count * sizeof (_field_entry_t);
            _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }

            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                /* Recover f_ent_oam_wb structure from here */
                /* Allocate f_ent_oam_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8) {
                    _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_oam_wb == NULL) {
                        sal_free (f_ent);
                        return BCM_E_MEMORY;
                    }
                }
                f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                   action_bmp.w = NULL;
                   _FP_XGS3_ALLOC(action_bmp.w,
                             SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                             "Action No Param Bitmap");
                   if (action_bmp.w == NULL) {
                      rv = BCM_E_MEMORY;
                      sal_free(f_ent);
                      goto cleanup;
                   }
                }
                f_ent_wb_info.action_bmp = &action_bmp;

                /* Recover f_ent_policer_wb structure from here */
                /* Allocate f_ent_policer_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                    _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_policer_wb == NULL) {
                        rv = BCM_E_MEMORY;
                        sal_free (f_ent);
                        goto cleanup;
                    }
                }
                f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;

                rv = _field_trx_entry_info_retrieve(unit,
                                                    fc,
                                                    stage_fc,
                                                    multigroup,
                                                    &prev_prio,
                                                    &f_ent_wb_info
                                                    );
                
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }
            pri_tcam_idx = phys_tcam_idx;
            for (i = 0; i < parts_count; i++) {
                if (fc->l2warm) {
                    /* Use retrieved EID and priority */
                    f_ent[i].eid = f_ent_wb_info.eid;
                    /*
                     * In warm boot level 2, during sync, entry priority is
                     * written only for the first part of the entry and during
                     * recovery, the priority value from the first part is
                     * assigned to all parts of entry
                     */
                    f_ent[i].prio = f_ent_wb_info.prio;

                    /* Set retrieved dvp_type and svp_type */
                    f_ent[i].dvp_type  = f_ent_wb_info.dvp_type[i];
                    f_ent[i].svp_type  = f_ent_wb_info.svp_type[i];
#if defined(BCM_APACHE_SUPPORT)
                    /* Set retrieved OAM MEP type */
                    if (SOC_IS_APACHE(unit) && (i == 0)) {
                        f_ent[i].eth_oam_ctrl_mep_type = f_ent_wb_info.ingress_oam_mep_type[0];
                        f_ent[i].eth_oam_data_mep_type = f_ent_wb_info.ingress_oam_mep_type[1];
                        f_ent[i].mpls_oam_ctrl_mep_type = f_ent_wb_info.ingress_oam_mep_type[2];
                        f_ent[i].mpls_oam_data_mep_type = f_ent_wb_info.ingress_oam_mep_type[3];
                    }
#endif
                } else {
                    f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    /*
                     * For warm boot level 1, priority derived from vslice_idx
                     * is assigned to all parts of the entry
                     */
                    f_ent[i].prio = (vslice_idx << 10) | (slice_ent_cnt - idx);
                }
                f_ent[i].group = fg;
                if (i == 0) {
                    BCM_PBMP_ASSIGN(f_ent[i].pbmp.data, entry_pbmp);
                    BCM_PBMP_ASSIGN(f_ent[i].pbmp.mask, entry_mask_pbmp);
                }

                rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                         &f_ent[i].flags);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                if (f_ent_wb_info.color_independent) {
                    f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                }
                rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                        pri_tcam_idx,
                                                        i, &part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                         _FP_DEF_INST,
                                                         part_index,
                                                         &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                f_ent[i].fs = stage_fc->slices[_FP_DEF_INST] + slice_number;
                BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Decrement slice free entry count for primary
                       entries. */
                    f_ent[i].fs->free_count--;
                }
                /* Assign entry to a slice */
                f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                if (soc_FP_TCAMm_field32_get(unit, tcam_entry, VALIDf) == 3) {
                    f_ent[i].flags |= _FP_ENTRY_ENABLED;
                }

                /* Get the actions associated with this part of the entry */

#if defined BCM_TRIDENT2PLUS_SUPPORT
                if (soc_feature(unit, soc_feature_fp_based_oam)) {
                    rv = _field_oam_stat_action_scache_recover
                        (unit, stage_fc, f_ent, f_ent_oam_wb);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        goto cleanup;
                    }
                }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

                policy_entry = soc_mem_table_idx_to_pointer(
                                   unit,
                                   FP_POLICY_TABLEm,
                                   fp_policy_table_entry_t *,
                                   fp_policy_buf,
                                   part_index
                                                            );
                rv = _field_tr2_actions_recover(unit,
                                                FP_POLICY_TABLEm,
                                                (uint32 *) policy_entry,
                                                f_ent,
                                                i,
                                                &f_ent_wb_info);
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (action_bmp.w != NULL) {
                   _FP_ACTION_BMP_FREE(action_bmp);
                   action_bmp.w = NULL;
                }
            }
            /* Add to the group */
            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                goto cleanup;
            }
            f_ent = NULL;
            /* Entry has been added to group,
             * so free f_ent_oam_wb structure */
            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
            if (f_ent_policer_wb != NULL) {
                sal_free(f_ent_policer_wb);
                f_ent_policer_wb = NULL;
            }
        }
        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }
    }

    /* Recover EgressPortsAdd Workaround Information */
    if (fc->l2warm) {

        /* Mark end of Slice Info */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            fc->scache_pos++;
        }

        if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
            if (recovered_ver_part0 >= BCM_FIELD_WB_VERSION_1_6) {
                BCM_IF_ERROR_RETURN (_field_egr_ports_recovery_scache_recover
                        (unit,fc, stage_fc, &buf[fc->scache_pos]));
            } else {
                BCM_IF_ERROR_RETURN (_field_egr_ports_recovery_wb_upgrade_add
                        (unit, fg));
            }
        }
    }

    /* To set per port flags */
    group = fc->groups;
    while (group != NULL) {
           if (group->stage_id == _BCM_FIELD_STAGE_INGRESS) {
               if (!BCM_PBMP_EQ(valid_pbm, group->pbmp)) {
                   /* Update Group Flags to denote Port based Group */
                   group->flags |= _FP_GROUP_PER_PORT_OR_PBMP;
               }
           }
           group = group->next;
    }

    if (fc->l2warm) {

        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_7) {
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Recovering hint Ids "
                                        "from pos = %d\r\n"), fc->scache_pos));
                    BCM_IF_ERROR_RETURN (_bcm_hints_scache_hintid_recover(unit, stage_fc,
                                fc, &buf[fc->scache_pos]));
                }
            }
        }

        /* Group Slice Selectors */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            rv = (_field_group_slice_selectors_recover(unit,
                        &buf[fc->scache_pos], stage_fc->stage_id));
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        temp = 0;
        temp |= buf[fc->scache_pos];
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        if (temp != _FIELD_IFP_DATA_END) {
            fc->l2warm = 0;
            rv = BCM_E_INTERNAL;
        }

        if (NULL != buf1) {
            temp = 0;
            temp |= buf1[fc->scache_pos1];
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 8;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 16;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 24;
            fc->scache_pos1++;
            if (temp != _FIELD_IFP_DATA_END) {
                fc->l2warm = 0;
                rv = BCM_E_INTERNAL;
            }
        }
   }

    if (BCM_SUCCESS(rv)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

      _field_tr2_stage_reinit_all_groups_cleanup(unit, fc,
                                                 _BCM_FIELD_STAGE_INGRESS,
                                                 fp_table_pointers);

cleanup:
#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) &&
            SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Xm) &&
            SOC_MEM_IS_VALID(unit, FP_GLOBAL_MASK_TCAM_Ym)) {
        if (fp_gm_tcam_x_buf) {
            soc_cm_sfree(unit, fp_gm_tcam_x_buf);
        }
        if (fp_gm_tcam_y_buf) {
            soc_cm_sfree(unit, fp_gm_tcam_y_buf);
        }
    } else
#endif
    {
        if (fp_global_mask_tcam_buf) {
            soc_cm_sfree(unit, fp_global_mask_tcam_buf);
        }
    }

    if (fp_tcam_buf) {
        soc_cm_sfree(unit, fp_tcam_buf);
    }
    if (fp_pfs_buf) {
        soc_cm_sfree(unit, fp_pfs_buf);
    }
    if (fp_policy_buf) {
        soc_cm_sfree(unit, fp_policy_buf);
    }
    if (fp_table_pointers) {
        soc_cm_sfree(unit, fp_table_pointers);
    }
    if (action_bmp.w != NULL) {
        _FP_ACTION_BMP_FREE(action_bmp);
        action_bmp.w = NULL;
    }
    if(f_ent_policer_wb != NULL) {
        sal_free(f_ent_policer_wb);
        f_ent_policer_wb = NULL;
    }
    return rv;
}

/*
 * Function:
 *     _bcm_field_trx_egress_secondary_selcode_set
 *
 * Purpose:
 *     Sets the secondary select codes based on field values in different
 *     registers EFP_CLASSID_SELECTORr, EFP_KEY4_DVP_SELECTORr and
 *     EFP_KEY4_MDL_SELECTORr.
 *
 * Parameters:
 *     unit             - (IN) BCM unit number.
 *     fg               - (IN/OUT) Select code information filled into the group
 *     slice_idx        - (IN) Slice id
 *     part_idx         - (IN) Part id of the given slice in the given group
 *
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     This function is required  for the devices Helix4, Katana2, Triumph3 ,
 *     Trident2, GreyHound and Enduro. Because these devices have atleast one
 *     of the three register mentioned below.
 *     1. EFP_CLASSID_SELECTORr  - (HX4, KT2, TR3, TD2, TH)
 *     2. EFP_KEY4_DVP_SELECTORr - (HX4, KT2, TR3, TD2, TH)
 *     3. EFP_KEY4_MDL_SELECTORr - (HX4, KT2, TR3, TD2, GreyHound, Enduro, TH)
 *     4. EFP_KEY8_DVP_SELECTORr - (TH)
 *     This function is called in _field_tr2_stage_egress_reinit as all the
 *     above mentioned devices use _field_tr2_stage_egress_reinit
 *     for efp reinitialization during warmboot.
 */
int
_bcm_field_trx_egress_secondary_selcodes_set(int unit, _field_group_t *fg,
                                             int slice_idx, uint8 part_idx)
{
    soc_field_t field;   /* H/W Register field.            */
    uint64 reg_val64;    /* 64 bit H/W Register value.     */
    uint32 reg_val32;    /* 32 bit H/W register value.     */
    uint32 fldval;       /* Field in a H/W register value. */
    uint8  num_fields;   /* Number of fields.              */
    soc_reg_t reg;       /* H/W register.                  */
    int rv = BCM_E_NONE; /* Operation status.              */
    int idx;             /* Index.                         */

    static const soc_field_t efp_classid_selector_flds[][7] = {
             {SLICE_0_F1f, SLICE_0_F2f, SLICE_0_F3f, SLICE_0_F4f,
                           SLICE_0_F6f, SLICE_0_F7f, SLICE_0_F8f},
             {SLICE_1_F1f, SLICE_1_F2f, SLICE_1_F3f, SLICE_1_F4f,
                           SLICE_1_F6f, SLICE_1_F7f, SLICE_1_F8f},
             {SLICE_2_F1f, SLICE_2_F2f, SLICE_2_F3f, SLICE_2_F4f,
                           SLICE_2_F6f, SLICE_2_F7f, SLICE_2_F8f},
             {SLICE_3_F1f, SLICE_3_F2f, SLICE_3_F3f, SLICE_3_F4f,
                           SLICE_3_F6f, SLICE_3_F7f, SLICE_3_F8f},
        };

    static const soc_field_t efp_dvp_selector_flds[][1] = {
             {SLICE_0f}, {SLICE_1f}, {SLICE_2f}, {SLICE_3f}
        };

    static const soc_field_t efp_mdl_selector_flds[][1] = {
             {SLICE_0f}, {SLICE_1f}, {SLICE_2f}, {SLICE_3f}
        };

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    static const soc_field_t oamoverlaytbl[4] = {
        SLICE_0_OAM_OVERLAY_ENABLEf,SLICE_1_OAM_OVERLAY_ENABLEf,
        SLICE_2_OAM_OVERLAY_ENABLEf, SLICE_3_OAM_OVERLAY_ENABLEf };

    static const soc_field_t efp_dest_port_selector_flds[][2] = {
             {SLICE_0_F1_DEST_SELf, SLICE_0_F5_DEST_SELf},
             {SLICE_1_F1_DEST_SELf, SLICE_1_F5_DEST_SELf},
             {SLICE_2_F1_DEST_SELf, SLICE_2_F5_DEST_SELf},
             {SLICE_3_F1_DEST_SELf, SLICE_3_F5_DEST_SELf},
        };
#endif


    if (NULL == fg) {
        return BCM_E_PARAM;
    }


    fg->sel_codes[part_idx].egr_class_f1_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f2_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f3_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f4_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f6_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f7_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f8_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key4_dvp_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key8_dvp_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key4_mdl_sel = _FP_SELCODE_DONT_CARE;

    rv = READ_EFP_CLASSID_SELECTORr(unit, &reg_val64);
    reg = EFP_CLASSID_SELECTORr;
    num_fields = sizeof(efp_classid_selector_flds[0]) /
                   sizeof(efp_classid_selector_flds[0][0]);

    if (BCM_SUCCESS(rv)) {
        for (idx = 0 ; idx < num_fields; idx++) {
            field = efp_classid_selector_flds[slice_idx][idx];
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
            }
            fldval = soc_reg_field_get(unit, reg, reg_val64, field);

            switch(idx) {
                case 0:
                     fg->sel_codes[part_idx].egr_class_f1_sel = fldval;
                     break;
                case 1:
                     fg->sel_codes[part_idx].egr_class_f2_sel = fldval;
                     break;
                case 2:
                     fg->sel_codes[part_idx].egr_class_f3_sel = fldval;
                     break;
                case 3:
                     fg->sel_codes[part_idx].egr_class_f4_sel = fldval;
                     break;
                case 4:
                     fg->sel_codes[part_idx].egr_class_f6_sel = fldval;
                     break;
                case 5:
                     fg->sel_codes[part_idx].egr_class_f7_sel = fldval;
                     break;
                case 6:
                     fg->sel_codes[part_idx].egr_class_f8_sel = fldval;
                     break;
                default:
                     LOG_ERROR(BSL_LS_BCM_FP,
                               (BSL_META_U(unit,
                                           "FP(unit %d) Error:Invalid field in efp classid selector \n"),
                                unit));
                     return BCM_E_INTERNAL;
            }
        }
    }

    rv = READ_EFP_KEY4_DVP_SELECTORr(unit, &reg_val32);
    reg = EFP_KEY4_DVP_SELECTORr;
    num_fields = sizeof(efp_dvp_selector_flds[0]) /
                sizeof(efp_dvp_selector_flds[0][0]);

    if (BCM_SUCCESS(rv)) {
        for (idx = 0 ; idx < num_fields; idx++) {
            field = efp_dvp_selector_flds[slice_idx][idx];
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
             }
             fldval = soc_reg_field_get(unit, reg, reg_val32, field);
             switch (idx) {
                 case 0:
                     fg->sel_codes[part_idx].egr_key4_dvp_sel = fldval;
                     break;
                 default:
                     LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                  "FP(unit %d) Error:Invalid field in efp key4 dvp selector \n"),
                                   unit));
                     return BCM_E_INTERNAL;
            }
        }
    }

    rv = READ_EFP_KEY8_DVP_SELECTORr(unit, &reg_val32);
    reg = EFP_KEY8_DVP_SELECTORr;
    num_fields = sizeof(efp_dvp_selector_flds[0]) /
                sizeof(efp_dvp_selector_flds[0][0]);

    if (BCM_SUCCESS(rv)) {
        for (idx = 0 ; idx < num_fields; idx++) {
            field = efp_dvp_selector_flds[slice_idx][idx];
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
             }
             fldval = soc_reg_field_get(unit, reg, reg_val32, field);
             switch (idx) {
                 case 0:
                     fg->sel_codes[part_idx].egr_key8_dvp_sel = fldval;
                     break;
                 default:
                     LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                  "FP(unit %d) Error:Invalid field in efp key8 dvp selector \n"),
                                   unit));
                     return BCM_E_INTERNAL;
            }
        }
    }

    rv = READ_EFP_KEY4_MDL_SELECTORr(unit, &reg_val32);
    reg = EFP_KEY4_MDL_SELECTORr;
    num_fields = sizeof(efp_mdl_selector_flds[0]) /
                   sizeof(efp_mdl_selector_flds[0][0]);

    if (BCM_SUCCESS(rv)) {
        for (idx = 0 ; idx < num_fields; idx++) {
            field = efp_mdl_selector_flds[slice_idx][idx];
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
            }
            fldval = soc_reg_field_get(unit, reg, reg_val32, field);

            switch(idx) {
                case 0:
                     fg->sel_codes[part_idx].egr_key4_mdl_sel = fldval;
                     break;
                default:
                     LOG_ERROR(BSL_LS_BCM_FP,
                               (BSL_META_U(unit,
                                           "FP(unit %d) Error:Invalid field in efp mdl selector \n"),
                                unit));
                     return BCM_E_INTERNAL;
            }
        }
#if defined BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_fp_based_oam)) {
            field = oamoverlaytbl[slice_idx];
            if (soc_reg_field_valid(unit, reg, field)) {
                fldval = soc_reg_field_get(unit, reg, reg_val32, field);
                fg->sel_codes[part_idx].egr_oam_overlay_sel = fldval;
            }
        }
#endif
    }

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_REG_IS_VALID(unit, EFP_DEST_PORT_SELECTORr)) {

        rv = READ_EFP_DEST_PORT_SELECTORr(unit, &reg_val32);
        reg = EFP_DEST_PORT_SELECTORr;
        num_fields = sizeof(efp_dest_port_selector_flds[0]) /
            sizeof(efp_dest_port_selector_flds[0][0]);

        if (BCM_SUCCESS(rv)) {
            for (idx = 0 ; idx < num_fields; idx++) {
                field = efp_dest_port_selector_flds[slice_idx][idx];
                if (!soc_reg_field_valid(unit, reg, field)) {
                    continue;
                }
                fldval = soc_reg_field_get(unit, reg, reg_val32, field);

                switch(idx) {
                    case 0:
                        fg->sel_codes[part_idx].egr_dest_port_f1_sel = fldval;
                        break;
                    case 1:
                        fg->sel_codes[part_idx].egr_dest_port_f5_sel = fldval;
                        break;
                    default:
                        LOG_ERROR(BSL_LS_BCM_FP,
                                (BSL_META_U(unit,
                                            "FP(unit %d) Error:Invalid field in efp dest port selector \n"),
                                 unit));
                        return BCM_E_INTERNAL;
                }
            }
        }

    }
#endif

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_trx_egress_selcode_set
 *
 * Purpose:
 *     Sets the select code based on the EFP slice mode and key match type
 *
 * Parameters:
 *     unit             - (IN) BCM unit number.
 *     fc               - (IN) Device field control structure pointer
 *     fg               - (IN/OUT) Select code information filled into the group
 *     efp_slice_mode   - (IN) EFP slice mode from EFP_SLICE_CONTROl register
 *     efp_key_mode     - (IN) EFP key mode from EFP_SLICE_CONTROl register
 *     key_match_type   - (IN) EFP key match type
 *     parts_count      - (OUT) Number of parts in entry
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_trx_egress_selcode_set(int unit, _field_control_t *fc, _field_group_t *fg,
                                  uint32 efp_slice_mode, uint32 efp_key_mode,
                                  uint32 key_match_type, int *parts_count)
{
    switch (efp_slice_mode) {
        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
            fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
            fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
            *parts_count = 1;
            break;
        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
            fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
            if (key_match_type == ~0 /* No entries */
                        || key_match_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE
               ) {
                /* IPv4 single wide key */
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                *parts_count = 1;
                fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
            } else {
                /* key_match_type == _BCM_FIELD_EFP_KEY2_MATCH_TYPE */
                /* IPv6 single wide key */
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
                *parts_count = 1;
                fg->sel_codes[0].ip6_addr_sel = efp_key_mode;
            }
            break;
        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
            fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
            if ((fc->l2warm) &&
                     (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcIp) ||
                        BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDstIp) ||
                        BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIpFrag))) {
                if (key_match_type == ~0 /* No entries */
                            || key_match_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE) {
                    /* IPv4 single wide key */
                    fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                    *parts_count = 1;
                    fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                }
            } else {
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1_NO_V4;
                *parts_count = 1;
            }
            break;
        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
            fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
            if (key_match_type == ~0 /* No entries */
                        || key_match_type == _BCM_FIELD_EFP_KEY2_KEY3_MATCH_TYPE
                ) {
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY3;
                fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY2;
                fg->sel_codes[1].ip6_addr_sel = efp_key_mode;
            } else { /* _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE */
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
            }
            *parts_count = 2;
            break;
        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
            fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
            if ((fc->l2warm) &&
                       (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcIp) ||
                        BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDstIp) ||
                        BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIpFrag))) {
                if (key_match_type == ~0 /* No entries */
                            || key_match_type == _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE) {
                    /* IPv4 double wide key */
                    fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                    fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                }
            } else {
                fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1_NO_V4;
                fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
            }
            *parts_count = 2;
            break;
        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
            fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
            fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
            fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
            fg->sel_codes[0].ip6_addr_sel = efp_key_mode;
            *parts_count = 2;
            break;
        default:
            break;
    }

    return (BCM_E_NONE);
}


int
_field_tr2_stage_egress_reinit(int unit, _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    int idx, idx1, slice_idx, vslice_idx, index_min, index_max, rv = BCM_E_NONE;
    int mem_sz, slice_ent_cnt, parts_count = 1;
    int i, pri_tcam_idx, part_index, slice_number, phys_tcam_idx;
    int prev_prio, expanded[4], slice_master_idx[4];
    uint32 *efp_tcam_buf = NULL; /* Buffer to read the EFP_TCAM table */
    char *efp_policy_buf = NULL; /* Buffer to read the EFP_POLICY table */
    uint32 rval, efp_slice_mode, efp_key_mode, temp;
    bcm_field_group_t gid;
    int priority = 0, multigroup, max, master_slice;
    int group_flags = 0;
    efp_tcam_entry_t *efp_tcam_entry;
    efp_policy_table_entry_t *efp_policy_entry;
    _field_slice_t *fs;
    _field_group_t *fg;
    _field_entry_t *f_ent = NULL;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    bcm_field_qset_t qset;
    uint8 old_physical_slice, slice_num;
    uint32 entry_flags;
    bcm_pbmp_t all_pbmp;
    bcm_pbmp_t group_pbmp;
    uint32              key_match_type[2];
#if defined(BCM_TRIDENT2_SUPPORT)
    uint32              entry_type = 0;
    int8                fpf3 = ~0;
    _field_action_t     *fa = NULL;
    int8                fpf3_temp[2];
#endif
    int action_res_id;
    _field_entry_oam_wb_t *f_ent_oam_wb = NULL;
    _field_entry_policer_wb_t *f_ent_policer_wb = NULL;
    _field_slice_t *fs_temp = NULL;
    int8               efp_key_info[2];

    soc_field_t efp_en_flds[4] = {SLICE_ENABLE_SLICE_0f, SLICE_ENABLE_SLICE_1f,
                                  SLICE_ENABLE_SLICE_2f, SLICE_ENABLE_SLICE_3f};

    soc_field_t efp_lk_en_flds[4] =
                     {LOOKUP_ENABLE_SLICE_0f, LOOKUP_ENABLE_SLICE_1f,
                      LOOKUP_ENABLE_SLICE_2f, LOOKUP_ENABLE_SLICE_3f};
    _field_action_bmp_t action_bmp;
    _field_entry_wb_info_t f_ent_wb_info;

    /* Reset Action bitmap to NULL. */
    action_bmp.w = NULL;

    sal_memset(expanded, 0, 4 * sizeof(int));
    sal_memset(slice_master_idx, 0, 4 * sizeof(int));

    if (fc->l2warm) {
        rv = _field_scache_stage_hdr_chk(fc, _FIELD_EFP_DATA_START);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }

    /* DMA various tables */
    efp_tcam_buf = soc_cm_salloc(unit, sizeof(efp_tcam_entry_t) *
                                 soc_mem_index_count(unit, EFP_TCAMm),
                                 "EFP TCAM buffer");
    if (NULL == efp_tcam_buf) {
        return BCM_E_MEMORY;
    }
    sal_memset(efp_tcam_buf, 0, sizeof(efp_tcam_entry_t) *
               soc_mem_index_count(unit, EFP_TCAMm));
    index_min = soc_mem_index_min(unit, EFP_TCAMm);
    index_max = soc_mem_index_max(unit, EFP_TCAMm);
    fs = stage_fc->slices[_FP_DEF_INST];
    if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
        slice_ent_cnt = fs->entry_count * 2;
        /* DMA in chunks */
        for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
            if ((rv = soc_mem_read_range(unit, EFP_TCAMm, MEM_BLOCK_ALL,
                                         slice_idx * slice_ent_cnt,
                                         slice_idx * slice_ent_cnt +
                                             fs->entry_count - 1,
                                         efp_tcam_buf + slice_idx *
                                             slice_ent_cnt *
                                  soc_mem_entry_words(unit, EFP_TCAMm))) < 0 ) {
                goto cleanup;
            }
        }
    } else {
        slice_ent_cnt = fs->entry_count;
        if ((rv = soc_mem_read_range(unit, EFP_TCAMm, MEM_BLOCK_ALL,
                                     index_min, index_max,
                                     efp_tcam_buf)) < 0 ) {
            goto cleanup;
        }
    }
    efp_policy_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES
                                  (unit, EFP_POLICY_TABLEm),
                                  "EFP POLICY TABLE buffer");
    if (NULL == efp_policy_buf) {
        return BCM_E_MEMORY;
    }
    index_min = soc_mem_index_min(unit, EFP_POLICY_TABLEm);
    index_max = soc_mem_index_max(unit, EFP_POLICY_TABLEm);
    if ((rv = soc_mem_read_range(unit, EFP_POLICY_TABLEm, MEM_BLOCK_ALL,
                                 index_min, index_max,
                                 efp_policy_buf)) < 0 ) {
        goto cleanup;
    }

    /* Get slice expansion status and virtual map */
    if ((rv = _field_slice_expanded_status_get(unit, fc, stage_fc, expanded, slice_master_idx)) < 0) {
        goto cleanup;
    }

    /* Iterate over the slices */
    if ((rv = READ_EFP_SLICE_CONTROLr(unit, &rval)) < 0) {
        goto cleanup;
    }
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        /* Ignore disabled slice */
        if ((soc_reg_field_get(unit, EFP_SLICE_CONTROLr, rval,
                               efp_en_flds[slice_idx]) == 0) ||
            (soc_reg_field_get(unit, EFP_SLICE_CONTROLr, rval,
                               efp_lk_en_flds[slice_idx]) == 0)) {
            continue;
        }

        efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr, rval,
                                           _trx_efp_slice_mode[slice_idx][0]);
        efp_key_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr, rval,
                                         _trx_efp_slice_mode[slice_idx][1]);
        /* Skip if slice has no valid groups and entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        key_match_type[0] = ~0;
        key_match_type[1] = ~0;
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            /* Get KEY_MATCH_TYPE from the valid entries of EFP_TCAM */
            for (idx = 0; idx < slice_ent_cnt; idx++) {
                efp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, EFP_TCAMm, efp_tcam_entry_t *,
                                  efp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
                if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry,
                                          VALIDf) != 0) {
                    /* In TD2, EFP_TCAM entry KEY field width is
                       (230 + 2b VALID) */
                    if (key_match_type[0] == ~0) {
                    _field_extract((uint32 *)efp_tcam_entry, 230 + 2, 4,
                                 &key_match_type[0]);
                        continue;
                    }
                    if (key_match_type[1] == ~0) {
                        _field_extract((uint32 *)efp_tcam_entry, 230 + 2, 4,
                                &key_match_type[1]);
                        if (key_match_type[0] == key_match_type[1]) {
                            key_match_type[1] = ~0;
                        } else {
                            /* break once possible two key match types are
                               extracted from the valid entries */
                            break;
                        }
                    }
                }
            }
            if (key_match_type[0] == ~0 && !fc->l2warm) {
                continue;
            }
        } else
#endif
        {
            for (idx = 0; idx < slice_ent_cnt; idx++) {
                efp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, EFP_TCAMm, efp_tcam_entry_t *,
                                  efp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
                if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry,
                                          VALIDf) != 0) {
                    /* Get KEY_MATCH_TYPE from first valid entry */
#if defined(BCM_TRIUMPH3_SUPPORT)
                    /* In TR3, EFP_TCAM entry KEY field width is
                       (231 + 2b VALID) */
                    if (SOC_IS_TRIUMPH3(unit)) {
                        _field_extract((uint32 *)efp_tcam_entry, 231 + 2, 3,
                                &key_match_type[0]);
                    } else
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
                    /* In GH2, EFP_TCAM entry KEY field width is
                       (214 + 2b VALID) */
                    if (SOC_IS_GREYHOUND2(unit)) {
                        _field_extract((uint32 *)efp_tcam_entry, 214 + 2, 3,
                                &key_match_type[0]);
                    } else
#endif
                    {
                        _field_extract((uint32 *)efp_tcam_entry, 211 + 2, 3,
                                &key_match_type[0]);
                    }
                    break;
                }
            }
            if (idx == slice_ent_cnt && !fc->l2warm) {
                continue;
            }
        }
        /* Skip second part of slice pair */
        if (((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) &&
            (slice_idx % 2)) {
            continue;
        }
        /* Don't need to read selectors for expanded slice */
        if (expanded[slice_idx]) {
            continue;
        }
        fg = NULL;
        if (efp_slice_mode <= 6) { /* Valid values */
            /* If Level 2, retrieve the GIDs in this slice */
            if (fc->l2warm) {
                rv = _field_trx_scache_slice_group_recover(unit,
                                                           fc, _FP_DEF_INST,
                                                           slice_idx,
                                                           NULL,
                                                           stage_fc,
                                                           0);
                if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                    fc->l2warm = 0;
                    goto cleanup;
                }
                if (rv == BCM_E_NOT_FOUND) {
                    rv = BCM_E_NONE;
                    continue;
                }
            }

            rv = _field_tr2_group_construct_alloc(unit, &fg);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }

            action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

            group_flags = 0;
            if (fc->l2warm) {
                /* Get stored group ID and QSET for Level 2 */
                rv = _field_group_info_retrieve(unit, -1, _FP_DEF_INST,
                                                &gid, &priority,
                                                &action_res_id,
                                                &group_pbmp,
                                                efp_key_info,
                                                &group_flags,
                                                &qset,
                                                fc
                                                );
                if (gid != -1) {
                    sal_memcpy(&fg->qset, &qset, sizeof(bcm_field_qset_t));
                } else {
                    sal_free(fg);
                    rv = BCM_E_INTERNAL;
                    goto cleanup;
                }
            } else {
                if ((rv = _bcm_field_group_id_generate(unit, &gid)) == BCM_E_NONE) {
                    unsigned vmap, vslice;

                    for (priority = -1, vmap = 0; priority == -1 && vmap < _FP_VMAP_CNT; ++vmap) {
                        for (vslice = 0; vslice < COUNTOF(stage_fc->vmap[_FP_DEF_INST][0]); ++vslice) {
                            if (stage_fc->vmap[_FP_DEF_INST][vmap][vslice].vmap_key == slice_idx) {
                                priority = stage_fc->vmap[_FP_DEF_INST][vmap][vslice].priority;

                                break;
                            }
                        }
                    }

                    if (priority == -1) {
                        rv = BCM_E_INTERNAL;
                    }
                }
            }
            if (BCM_FAILURE(rv)) {
                sal_free(fg);
                goto cleanup;
            }

            fg->gid      = gid;
            fg->priority = priority;
            fg->action_res_id = action_res_id;
            if (group_flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
                fg->flags = fg->flags | _FP_GROUP_SELECT_AUTO_EXPANSION;
            }
            fg->stage_id = stage_fc->stage_id;

            /* Set the selector code based on the EFP slice mode and
               key_match_type[0] */
#if defined(BCM_TRIDENT2_SUPPORT)
            if (fc->l2warm && ((((fc->wb_recovered_version)
                            >= BCM_FIELD_WB_VERSION_1_15)
                            && SOC_IS_TRIDENT2X(unit)) ||
                        (((fc->wb_recovered_version)
                         >= BCM_FIELD_WB_VERSION_1_16) &&
                         SOC_IS_TITAN2PLUS(unit)))) {
                /* Update efp primary key value */
                fg->sel_codes[0].fpf3 = efp_key_info[0];

                /* Update efp secondary key value based on mode */
                if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
                        (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
                        (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6) ||
                        (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE)) {
                    fg->sel_codes[1].fpf3 = efp_key_info[1];
                    parts_count = 2;
                    fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
                } else {
                    parts_count = 1;
                    fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
                }
                if (efp_key_info[0] == _BCM_FIELD_EFP_KEY2) {
                    fg->sel_codes[0].ip6_addr_sel = efp_key_mode;
                } else if (efp_key_info[1] == _BCM_FIELD_EFP_KEY2) {
                    fg->sel_codes[1].ip6_addr_sel = efp_key_mode;
                }
                fpf3 = fg->sel_codes[0].fpf3;
            } else if (SOC_IS_TD2_TT2(unit)) {
                rv = _bcm_field_td2_egress_selcode_set(unit, fg, efp_slice_mode,
                                 efp_key_mode, key_match_type[0], &parts_count);
                if (BCM_FAILURE(rv)) {
                    sal_free(fg);
                    goto cleanup;
                }

                fpf3 = fg->sel_codes[0].fpf3;
            } else
#endif
            {
                rv = _bcm_field_trx_egress_selcode_set(unit, fc, fg,
                                        efp_slice_mode, efp_key_mode,
                                        key_match_type[0], &parts_count);
                if (BCM_FAILURE(rv)) {
                    sal_free(fg);
                    goto cleanup;
                }
            }

            for (part_index = 0; part_index < parts_count; part_index++) {
                /* Populate all secondary selectors for the given group */
                rv = _bcm_field_trx_egress_secondary_selcodes_set(unit, fg,
                                                    slice_idx + part_index,
                                                                part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(fg);
                    goto cleanup;
                }
            }

            part_index = 0;

            /* Recover all qualifiers for the given group, based on its
               selector codes */
            rv = _field_tr2_group_construct_quals_add(unit, fc, stage_fc, fg);
            if (BCM_FAILURE(rv)) {
                sal_free(fg);
                goto cleanup;
            }

#if defined(BCM_TRIDENT2_SUPPORT)
            if (fc->l2warm && ((((fc->wb_recovered_version)
                            >= BCM_FIELD_WB_VERSION_1_15)
                            && SOC_IS_TRIDENT2X(unit)) ||
                        (((fc->wb_recovered_version)
                         >= BCM_FIELD_WB_VERSION_1_16) &&
                         SOC_IS_TITAN2PLUS(unit)))) {
                /* Store primary key's */
                fpf3_temp[0] = fg->sel_codes[0].fpf3;
                fpf3_temp[1] = fg->sel_codes[1].fpf3;
                if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                    /* Get new qset that is part of _BCM_FIELD_EFP_KEY1
                       and _BCM_FIELD_EFP_KEY4 */
                    fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                    fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                } else {
                    /* Get new qset that is part of _BCM_FIELD_EFP_KEY4 */
                    fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
                }

                /* Recover all qualifiers for the new qset of the group,
                   based on its selector codes */
                rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                        stage_fc,
                        _FP_ENTRY_TYPE_1, fg, fpf3_temp[0], fpf3_temp[1]);
                if (BCM_FAILURE(rv)) {
                    sal_free(fg);
                    goto cleanup;
                }
                /* Restore primary key's */
                fg->sel_codes[0].fpf3 = fpf3_temp[0];
                fg->sel_codes[1].fpf3 = fpf3_temp[1];
            } else if (SOC_IS_TD2_TT2(unit)) {
                if ((key_match_type[1] != ~0) &&
                                (key_match_type[0] != key_match_type[1])) {
                    fpf3_temp[0] = fg->sel_codes[0].fpf3;
                    fpf3_temp[1] = fg->sel_codes[1].fpf3;
                    if (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY4) {
                        /* Set the select code based on the EFP slice mode and
                           key_match_type[1] */
                        rv = _bcm_field_td2_egress_selcode_set(unit, fg,
                                            efp_slice_mode, efp_key_mode,
                                            key_match_type[1], &parts_count);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }

                        /* Recover all qualifiers for the new qset of the group,
                           based on its selector codes */
                        rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                                stage_fc,
                                                _FP_ENTRY_TYPE_1, fg, fpf3_temp[0], fpf3_temp[1]);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }

                    } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) ||
                               (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2) ||
                               (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4)) {
                        /* Set the select code based on the EFP slice mode and
                           key_match_type[1] */
                        rv = _bcm_field_td2_egress_selcode_set(unit, fg,
                                            efp_slice_mode, efp_key_mode,
                                            key_match_type[1], &parts_count);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }

                        /* Recover all qualifiers for the new qset of the group,
                           based on its selector codes */
                        rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                                stage_fc,
                                                _FP_ENTRY_TYPE_1, fg, fpf3_temp[0], fpf3_temp[1]);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }

                    } else if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4)&&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) ||
                              ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) ||
                              ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY3) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY2))) {
                        /* Set the select code based on the EFP slice mode and
                           key_match_type[1] */
                        rv = _bcm_field_td2_egress_selcode_set(unit, fg,
                                               efp_slice_mode, efp_key_mode,
                                               key_match_type[1], &parts_count);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }

                        /* Recover all qualifiers for the new qset of the group,
                           based on its selector codes */
                        rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                                    stage_fc,
                                                    _FP_ENTRY_TYPE_1, fg, fpf3_temp[0], fpf3_temp[1]);
                        if (BCM_FAILURE(rv)) {
                            sal_free(fg);
                            goto cleanup;
                        }
                    }
                }
            }
#endif
            /* Associate slice(s) to group */
            fg->slices = stage_fc->slices[_FP_DEF_INST] + slice_idx;
            SOC_PBMP_CLEAR(all_pbmp);
            SOC_PBMP_ASSIGN(all_pbmp, PBMP_PORT_ALL(unit));
            SOC_PBMP_OR(all_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
            if (soc_feature(unit, soc_feature_linkphy_coe) ||
                soc_feature(unit, soc_feature_subtag_coe)) {
                _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
            }
#endif
            SOC_PBMP_ASSIGN(fg->pbmp, all_pbmp);
            BCM_PBMP_OR(fs->pbmp, fg->pbmp);

            /* Initialize group default ASET list. */
            rv = _field_group_default_aset_set(unit, fg);
            if (BCM_FAILURE(rv)) {
                sal_free(fg);
                goto cleanup;
            }

            if (fc->l2warm
                    && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15)) {
                if (group_flags & _FP_GROUP_LOOKUP_ENABLED) {
                    fg->flags = fg->flags | _FP_GROUP_LOOKUP_ENABLED;
                }
                if (group_flags & _FP_GROUP_WLAN) {
                    fg->flags = fg->flags | _FP_GROUP_WLAN;
                }
            } else {
                fg->flags |= _FP_GROUP_LOOKUP_ENABLED;
            }

            fg->next = fc->groups;
            fc->groups = fg;

            /* Now go over the entries in this slice */
            prev_prio = -1;
            for (idx = 0; idx < slice_ent_cnt; idx++) {
                efp_tcam_entry = soc_mem_table_idx_to_pointer
                                     (unit, EFP_TCAMm, efp_tcam_entry_t *,
                                      efp_tcam_buf, idx +
                                      slice_ent_cnt * slice_idx);
                if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry,
                                              VALIDf) == 0) {
                    continue;
                }
#if defined(BCM_TRIDENT2_SUPPORT)
                if (SOC_IS_TD2_TT2(unit)) {
                    _field_extract((uint32 *)efp_tcam_entry, 230 + 2, 4,
                                 &entry_type);
                }
#endif
                /* Allocate memory for this entry */
                mem_sz = parts_count * sizeof (_field_entry_t);
                _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
                if (f_ent == NULL) {
                    rv = BCM_E_MEMORY;
                    goto cleanup;
                }

                for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                     f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
                }

                sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
                f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
                if (fc->l2warm) {
                    /* Recover f_ent_oam_wb structure from here */
                    /* Allocate f_ent_oam_wb structure and pass it to
                     * corresponding function */
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_11) {
                        _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                                "Field Entry Warmboot");
                        if (f_ent_oam_wb == NULL) {
                            sal_free (f_ent);
                            return BCM_E_MEMORY;
                        }
                    }
                    f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                        action_bmp.w = NULL;
                        _FP_XGS3_ALLOC(action_bmp.w,
                             SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                             "Action No Param Bitmap");
                        if (action_bmp.w == NULL) {
                           rv = BCM_E_MEMORY;
                           sal_free(f_ent);
                           goto cleanup;
                        }
                    }
                    f_ent_wb_info.action_bmp = &action_bmp;

                    /* Recover f_ent_policer_wb structure from here */
                    /* Allocate f_ent_policer_wb structure and pass it to
                     * corresponding function */
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                        _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                                "Field Entry Warmboot");
                        if (f_ent_policer_wb == NULL) {
                            rv = BCM_E_MEMORY;
                            sal_free (f_ent);
                            goto cleanup;
                        }
                    }
                    f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;

                    rv = _field_trx_entry_info_retrieve(unit,
                                                        fc,
                                                        stage_fc,
                                                        0,
                                                        &prev_prio,
                                                        &f_ent_wb_info
                                                        );
                    
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                } else {
                    _bcm_field_last_alloc_eid_incr(unit);
                }

#if defined(BCM_TRIDENT2_SUPPORT)
                if (fc->l2warm && ((((fc->wb_recovered_version)
                                >= BCM_FIELD_WB_VERSION_1_15)
                                && SOC_IS_TRIDENT2X(unit)) ||
                            (((fc->wb_recovered_version)
                             >= BCM_FIELD_WB_VERSION_1_16) &&
                             SOC_IS_TITAN2PLUS(unit)))) {
                    switch (efp_slice_mode) {
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY4)
                                    && (entry_type == _BCM_FIELD_EFP_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                            } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY6)
                                    && (entry_type == _BCM_FIELD_EFP_KEY6_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) &&
                                        (entry_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                            } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2) &&
                                     (entry_type == _BCM_FIELD_EFP_KEY2_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                            } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5) &&
                                     (entry_type == _BCM_FIELD_EFP_KEY5_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                            if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) ||
                                        (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4)) &&
                                    (entry_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE))  {
                                f_ent->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                            if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY3)
                                        && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY2))
                                    && (entry_type == _BCM_FIELD_EFP_KEY2_KEY3_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5)
                                        && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4))
                                    && (entry_type == _BCM_FIELD_EFP_KEY5_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1)
                                        && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4))
                                    && (entry_type == _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                                (f_ent+1)->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                            if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) ||
                                        (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4))
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                    && (entry_type == _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                                (f_ent+1)->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2)
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                    && (entry_type == _BCM_FIELD_EFP_KEY2_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                                (f_ent+1)->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5)
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                    && (entry_type == _BCM_FIELD_EFP_KEY5_KEY4_MATCH_TYPE)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else {
                                f_ent->efp_key_match_type = 1;
                                (f_ent+1)->efp_key_match_type = 1;
                            }
                            break;
                        default:
                            rv = BCM_E_INTERNAL;
                            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                            sal_free(f_ent);
                            goto cleanup;
                    }
                } else if (SOC_IS_TD2_TT2(unit)) {
                /* Populate entry type based on the slice mode and entry
                   key match type */
                    switch (efp_slice_mode) {
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY4)
                                && (entry_type == 5)) {
                                f_ent->efp_key_match_type = 0;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                            if (((fpf3 == _BCM_FIELD_EFP_KEY1) &&
                                                    (entry_type == 1)) ||
                                ((fpf3 == _BCM_FIELD_EFP_KEY2) &&
                                                    (entry_type == 2))) {
                                f_ent->efp_key_match_type = 1;
                            } else if ((fg->sel_codes[0].fpf3 ==
                                                _BCM_FIELD_EFP_KEY4) &&
                                       (entry_type == 5)) {
                                f_ent->efp_key_match_type = 0;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                            if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY3)
                               && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY2))
                               && (entry_type == 3)) {
                                f_ent->efp_key_match_type = 1;
                            } else if (((fg->sel_codes[0].fpf3 ==
                                                    _BCM_FIELD_EFP_KEY1)  &&
                                    (fg->sel_codes[1].fpf3 ==
                                                    _BCM_FIELD_EFP_KEY4)) &&
                                    (entry_type == 4)) {
                                f_ent->efp_key_match_type = 0;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                            if ((fpf3 == _BCM_FIELD_EFP_KEY4) &&
                                                    (entry_type == 5))  {
                                f_ent->efp_key_match_type = 0;
                            } else if ((fg->sel_codes[0].fpf3 ==
                                                    _BCM_FIELD_EFP_KEY1) &&
                                    (entry_type == 1)) {
                                f_ent->efp_key_match_type = 1;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1)
                               && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                               && (entry_type == 4)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            }
                            break;
                        case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                            if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2)
                               && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                               && (entry_type == 6)) {
                                f_ent->efp_key_match_type = 0;
                                (f_ent+1)->efp_key_match_type = 0;
                            } else if ((fg->sel_codes[0].fpf3 ==
                                                    _BCM_FIELD_EFP_KEY1) &&
                                   (fg->sel_codes[1].fpf3 ==
                                                    _BCM_FIELD_EFP_KEY4) &&
                                   (entry_type == 4)) {
                                f_ent->efp_key_match_type = 1;
                                (f_ent+1)->efp_key_match_type = 1;
                            }
                            break;
                        default:
                            rv = BCM_E_INTERNAL;
                            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                            sal_free(f_ent);
                            goto cleanup;
                    }
                }
#endif
                vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                        slice_idx, stage_fc);
                if (vslice_idx < 0) {
                    rv = BCM_E_INTERNAL;

                    goto cleanup;
                }

                pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
                for (i = 0; i < parts_count; i++) {
                    if (fc->l2warm) {
                        f_ent[i].eid = f_ent_wb_info.eid;
                        /* Set retrieved dvp_type and svp_type */
                        f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                        f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                        f_ent[i].prio = f_ent_wb_info.prio;

                    } else {
                        f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                        f_ent[i].prio = (vslice_idx << 10)
                                        | (slice_ent_cnt - idx);
                    }
                    f_ent[i].group = fg;
                    rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                             &f_ent[i].flags);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    if (f_ent_wb_info.color_independent) {
                        f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                    }
                    rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                            pri_tcam_idx,
                                                            i, &part_index);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                             _FP_DEF_INST,
                                                             part_index,
                                                             &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    f_ent[i].fs = stage_fc->slices[_FP_DEF_INST]
                                    + slice_number;
                    if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                        /* Decrement slice free entry count for primary
                           entries. */
                        f_ent[i].fs->free_count--;
                    }
                    /* Assign entry to a slice */
                    f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                    f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                    if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry, VALIDf) == 3) {
                        f_ent[i].flags |= _FP_ENTRY_ENABLED;
                    }

                    /* Get the actions associated with this entry part */
                    efp_policy_entry = soc_mem_table_idx_to_pointer
                                               (unit, EFP_POLICY_TABLEm,
                                                efp_policy_table_entry_t *,
                                                efp_policy_buf, part_index);
                    rv = _field_tr2_actions_recover(unit,
                                                    EFP_POLICY_TABLEm,
                                                    (uint32 *) efp_policy_entry,
                                                    f_ent,
                                                    i,
                                                    &f_ent_wb_info);
                    if (BCM_FAILURE(rv)) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    if (action_bmp.w != NULL) {
                       _FP_ACTION_BMP_FREE(action_bmp);
                       action_bmp.w = NULL;
                    }
                }
#if defined BCM_TRIDENT2_SUPPORT
                /* Set action stat flags */
                if (SOC_IS_TD2_TT2(unit)) {
                    fa = f_ent->actions;
                    while (fa != NULL) {
                          rv = _bcm_field_action_stat_flag_update(unit, f_ent,
                                                                  fa, TRUE);
                          if (rv < 0) {
                             goto cleanup;
                          }
                          fa = fa->next;
                    }
                }
#endif
                /* Add to the group */
                rv = _field_group_entry_add(unit, fg, f_ent);
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    sal_free(f_ent);
                    goto cleanup;
                }
                f_ent = NULL;

                /* Entry has been added to group,
                 * so free f_ent_oam_wb structure */
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                if (f_ent_policer_wb != NULL) {
                    sal_free(f_ent_policer_wb);
                    f_ent_policer_wb = NULL;
                }
            }
        }
        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }
    }

    /* Now go over the expanded slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        if (!expanded[slice_idx]) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
        efp_slice_mode = soc_reg_field_get(unit, EFP_SLICE_CONTROLr, rval,
                                           _trx_efp_slice_mode[slice_idx][0]);
        if (((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
             (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) &&
            (slice_idx % 2)) {
            continue;
        }
        /* Skip if slice has no valid entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        slice_ent_cnt = fs->entry_count;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            if (_bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                  _FP_DEF_INST, slice_idx, idx, &phys_tcam_idx) != BCM_E_NONE) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                             EFP_TCAMm, efp_tcam_entry_t *,
                             efp_tcam_buf, phys_tcam_idx);
            if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry, VALIDf) != 0) {
                break;
            }
        }
        if (idx == slice_ent_cnt) {
            continue;
        }
        /* If Level 2, retrieve the GIDs in this slice */
        if (fc->l2warm) {
            rv = _field_trx_scache_slice_group_recover(unit,
                                                       fc, _FP_DEF_INST,
                                                       slice_idx,
                                                       &multigroup,
                                                       stage_fc,
                                                       0);

            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                fc->l2warm = 0;
                goto cleanup;
            }
            if (rv == BCM_E_NOT_FOUND) {
                rv = BCM_E_NONE;
                continue;
            }
        }
        /* Now find the master slice for this virtual group */
        vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                slice_idx, stage_fc);
        if (vslice_idx < 0) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        if (fc->l2warm
                && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
            master_slice = slice_master_idx[slice_idx];
        } else {
        max = -1;
        for (i = 0; i < stage_fc->tcam_slices; i++) {
            if ((stage_fc->vmap[_FP_DEF_INST][0][vslice_idx].virtual_group ==
                stage_fc->vmap[_FP_DEF_INST][0][i].virtual_group) && (i != vslice_idx)) {
                if (i > max) {
                    max = i;
                }
            }
        }
        if (max < 0) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        master_slice = stage_fc->vmap[_FP_DEF_INST][0][max].vmap_key;
        }
        /* See which group is in this slice - can be only one */
        fg = fc->groups;
        while (fg != NULL) {
            /* Check if group is in this slice */
            fs = &fg->slices[0];
            if ((fg->stage_id == stage_fc->stage_id)
                    && (fs->slice_number == master_slice)) {
                break;
            }
            fg = fg->next;
        }
        if (fg == NULL) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        old_physical_slice = fs->slice_number;

        /* Set up the new physical slice parameters in Software */
        for(part_index = parts_count - 1; part_index >= 0; part_index--) {
            /* Get entry flags. */
            rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg, &entry_flags);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice id for entry part */
            rv = _bcm_field_tcam_part_to_slice_number(unit, part_index,
                                                      fg, &slice_num);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice pointer. */
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx + slice_num;

            if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
                /* Set per slice configuration &  number of free entries in the slice.*/
                fs->free_count = fs->entry_count;
                if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                    fs->free_count >>= 1;
                }
                /* Set group flags in in slice.*/
                fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

                /* Add slice to slices linked list . */
                fs_temp = stage_fc->slices[_FP_DEF_INST] + old_physical_slice + slice_num;
                /* To handle more than one auto expanded slice in a group */
                while (fs_temp->next != NULL) {
                    fs_temp = fs_temp->next;
                }
                fs_temp->next = fs;
                fs->prev = fs_temp;
            }
        }

        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

        prev_prio = -1;
        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_PORT_ALL(unit));
        SOC_PBMP_OR(all_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif
        SOC_PBMP_ASSIGN(fg->pbmp, all_pbmp);
        BCM_PBMP_OR(fs->pbmp, fg->pbmp);
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            if (_bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                  _FP_DEF_INST, slice_idx, idx, &phys_tcam_idx) != BCM_E_NONE) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                             EFP_TCAMm, efp_tcam_entry_t *,
                             efp_tcam_buf, phys_tcam_idx);
            if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry, VALIDf) == 0) {
                continue;
            }
#if defined(BCM_TRIDENT2_SUPPORT)
                if (SOC_IS_TD2_TT2(unit)) {
                    _field_extract((uint32 *)efp_tcam_entry, 230 + 2, 4,
                                 &entry_type);
                }
#endif

            /* Allocate memory for the entry */
            rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                   fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            mem_sz = parts_count * sizeof (_field_entry_t);
            _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                /* Recover f_ent_oam_wb structure from here */
                /* Allocate f_ent_oam_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_11) {
                    _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_oam_wb == NULL) {
                        sal_free (f_ent);
                        return BCM_E_MEMORY;
                    }
                }
                f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                    action_bmp.w = NULL;
                    _FP_XGS3_ALLOC(action_bmp.w,
                             SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                             "Action No Param Bitmap");
                    if (action_bmp.w == NULL) {
                       rv = BCM_E_MEMORY;
                       sal_free(f_ent);
                       goto cleanup;
                    }
                }
                f_ent_wb_info.action_bmp = &action_bmp;

                /* Recover f_ent_policer_wb structure from here */
                /* Allocate f_ent_policer_wb structure and pass it to
                 * corresponding function */
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                    _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                            "Field Entry Warmboot");
                    if (f_ent_policer_wb == NULL) {
                        rv = BCM_E_MEMORY;
                        sal_free (f_ent);
                        goto cleanup;
                    }
                }
                f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;

                rv = _field_trx_entry_info_retrieve(unit,
                         fc, stage_fc, multigroup, &prev_prio, &f_ent_wb_info);
                
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }
#if defined(BCM_TRIDENT2_SUPPORT)
            if (fc->l2warm && ((((fc->wb_recovered_version)
                            >= BCM_FIELD_WB_VERSION_1_15)
                            && SOC_IS_TRIDENT2X(unit)) ||
                        (((fc->wb_recovered_version)
                         >= BCM_FIELD_WB_VERSION_1_16) &&
                         SOC_IS_TITAN2PLUS(unit)))) {
                switch (efp_slice_mode) {
                    case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                        if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY4)
                                && (entry_type == _BCM_FIELD_EFP_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                        } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY6)
                                && (entry_type == _BCM_FIELD_EFP_KEY6_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                        if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) &&
                                (entry_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                        } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2) &&
                                (entry_type == _BCM_FIELD_EFP_KEY2_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                        } else if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5) &&
                                (entry_type == _BCM_FIELD_EFP_KEY5_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                        if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) ||
                                    (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4)) &&
                                (entry_type == _BCM_FIELD_EFP_KEY1_MATCH_TYPE))  {
                            f_ent->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                        if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY3)
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY2))
                                && (entry_type == _BCM_FIELD_EFP_KEY2_KEY3_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5)
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4))
                                && (entry_type == _BCM_FIELD_EFP_KEY5_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1)
                                    && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4))
                                && (entry_type == _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                            (f_ent+1)->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                        if (((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) ||
                                    (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1_NO_V4))
                                && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                && (entry_type == _BCM_FIELD_EFP_KEY1_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                            (f_ent+1)->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                        if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY2)
                                && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                && (entry_type == _BCM_FIELD_EFP_KEY2_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                            (f_ent+1)->efp_key_match_type = 1;
                        }
                        break;
                    case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE:
                        if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5)
                                && (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)
                                && (entry_type == _BCM_FIELD_EFP_KEY5_KEY4_MATCH_TYPE)) {
                            f_ent->efp_key_match_type = 0;
                            (f_ent+1)->efp_key_match_type = 0;
                        } else {
                            f_ent->efp_key_match_type = 1;
                            (f_ent+1)->efp_key_match_type = 1;
                        }
                        break;
                    default:
                        rv = BCM_E_INTERNAL;
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                }
            }
#endif
            pri_tcam_idx = phys_tcam_idx;
            for (i = 0; i < parts_count; i++) {
                if (fc->l2warm) {
                    /* Use retrieved EID */
                    f_ent[i].eid = f_ent_wb_info.eid;
                    /* Set retrieved dvp_type and svp_type */
                    f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                    f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                    f_ent[i].prio = f_ent_wb_info.prio;
                } else {
                    f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    f_ent[i].prio = (vslice_idx << 10) | (slice_ent_cnt - idx);
                }
                f_ent[i].group = fg;

                rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                         &f_ent[i].flags);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                if (f_ent_wb_info.color_independent) {
                    f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                }
                rv = _bcm_field_entry_part_tcam_idx_get(unit,
                         f_ent, pri_tcam_idx, i, &part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                rv = _bcm_field_tcam_idx_to_slice_offset(unit,
                         stage_fc, _FP_DEF_INST, part_index, &slice_number,
                         (int *)&f_ent[i].slice_idx);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    goto cleanup;
                }
                f_ent[i].fs = stage_fc->slices[_FP_DEF_INST] + slice_number;
                if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Decrement slice free entry count for primary
                       entries. */
                    f_ent[i].fs->free_count--;
                }
                /* Assign entry to a slice */
                f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                if (soc_EFP_TCAMm_field32_get(unit, efp_tcam_entry, VALIDf) == 3) {
                    f_ent[i].flags |= _FP_ENTRY_ENABLED;
                }

                /* Get the actions associated with this part of the entry */
                efp_policy_entry = soc_mem_table_idx_to_pointer(
                    unit, EFP_POLICY_TABLEm, efp_policy_table_entry_t *,
                    efp_policy_buf, part_index);
                rv = _field_tr2_actions_recover(unit,
                    EFP_POLICY_TABLEm, (uint32 *) efp_policy_entry,
                    f_ent, i, &f_ent_wb_info);
                if (BCM_FAILURE(rv)) {
                    _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (action_bmp.w != NULL) {
                   _FP_ACTION_BMP_FREE(action_bmp);
                   action_bmp.w = NULL;
                }
            }

#if defined BCM_TRIDENT2_SUPPORT
            /* Set action stat flags */
            if (SOC_IS_TD2_TT2(unit)) {
                fa = f_ent->actions;
                while (fa != NULL) {
                      rv = _bcm_field_action_stat_flag_update(unit, f_ent,
                                                              fa, TRUE);
                      if (rv < 0) {
                          sal_free(f_ent);
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          goto cleanup;
                      }
                      fa = fa->next;
                }
            }
#endif

            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                goto cleanup;
            }
            f_ent = NULL;

            /* Entry has been added to group,
             * so free f_ent_oam_wb structure */
            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
            if (f_ent_policer_wb != NULL) {
                sal_free(f_ent_policer_wb);
                f_ent_policer_wb = NULL;
            }
        }
        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            _field_scache_slice_group_free(unit, fc, slice_idx);
        }
    }

    if (fc->l2warm) {

        /* Mark end of Slice Info */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            fc->scache_pos++;
        }

        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Recovering hint Ids "
                                        "from pos = %d\r\n"), fc->scache_pos));
                    BCM_IF_ERROR_RETURN (_bcm_hints_scache_hintid_recover(unit, stage_fc,
                                fc, &buf[fc->scache_pos]));
                }
            }
        }

        /* Group Slice Selectors */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            rv = (_field_group_slice_selectors_recover(unit,
                           &buf[fc->scache_pos], stage_fc->stage_id));
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        temp = 0;
        temp |= buf[fc->scache_pos];
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        if (temp != _FIELD_EFP_DATA_END) {
            fc->l2warm = 0;
            rv = BCM_E_INTERNAL;
        }

        if (NULL != buf1) {
            temp = 0;
            temp |= buf1[fc->scache_pos1];
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 8;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 16;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 24;
            fc->scache_pos1++;
            if (temp != _FIELD_EFP_DATA_END) {
                fc->l2warm = 0;
                rv = BCM_E_INTERNAL;
            }
        }

    }

    if (BCM_SUCCESS(rv)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

    _field_tr2_stage_reinit_all_groups_cleanup(unit, fc,
                                               _BCM_FIELD_STAGE_EGRESS,
                                               NULL);

cleanup:
    if (efp_tcam_buf) {
        soc_cm_sfree(unit, efp_tcam_buf);
    }
    if (efp_policy_buf) {
        soc_cm_sfree(unit, efp_policy_buf);
    }
    if (action_bmp.w != NULL) {
        _FP_ACTION_BMP_FREE(action_bmp);
        action_bmp.w = NULL;
    }
    if (f_ent_policer_wb != NULL) {
        sal_free(f_ent_policer_wb);
        f_ent_policer_wb = NULL;
    }
    return rv;
}

int
_field_tr2_stage_lookup_reinit(int unit, _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    int vslice_idx, max, master_slice;
    int idx, idx1, slice_idx, index_min, index_max, ratio, rv = BCM_E_NONE;
    int group_found, mem_sz, parts_count, slice_ent_cnt, expanded[4], slice_master_idx[4];
    int i, pri_tcam_idx, part_index, slice_number, prev_prio;
    uint32 *vfp_tcam_buf = NULL; /* Buffer to read the VFP_TCAM table */
    char *vfp_policy_buf = NULL; /* Buffer to read the VFP_POLICY table */
    uint32 rval, paired, intraslice, dbl_wide_key, dbl_wide_key_sec;
    uint32 vfp_key, temp;
    uint32 vfp_key2 = 0;
#if defined(BCM_KATANA2_SUPPORT)
    uint64 vfp_key_1 = 0;
#endif
    soc_field_t fld;
    vfp_tcam_entry_t *vfp_tcam_entry;
    vfp_policy_table_entry_t *vfp_policy_entry;
    _field_hw_qual_info_t hw_sels;
    _field_slice_t *fs;
    _field_group_t *fg;
    _field_entry_t *f_ent = NULL;
    bcm_pbmp_t entry_pbmp, temp_pbmp;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
#if defined(BCM_KATANA_SUPPORT)
    _field_stat_t *f_st = NULL;
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    uint32                  pool_num;     /* Flex Stat Hw Pool No.          */
    uint32                  base_index;   /* Flex Stat counter base index.  */
#endif
    uint8 old_physical_slice, slice_num;
    uint32 entry_flags;
    _field_slice_t *fs_temp = NULL;
#if defined(BCM_KATANA_SUPPORT)
    int offset_mode = 0, policer_index = 0;
#endif
    soc_field_t vfp_en_flds[4] = {SLICE_ENABLE_SLICE_0f, SLICE_ENABLE_SLICE_1f,
                                  SLICE_ENABLE_SLICE_2f, SLICE_ENABLE_SLICE_3f};

    soc_field_t vfp_lk_en_flds[4] =
                     {LOOKUP_ENABLE_SLICE_0f, LOOKUP_ENABLE_SLICE_1f,
                      LOOKUP_ENABLE_SLICE_2f, LOOKUP_ENABLE_SLICE_3f};

    _field_action_bmp_t action_bmp;
    _field_entry_wb_info_t f_ent_wb_info;

    /* Reset Action bitmap to NULL. */
    action_bmp.w = NULL;

    SOC_PBMP_CLEAR(entry_pbmp);
    sal_memset(expanded, 0, 4 * sizeof(int));
    sal_memset(slice_master_idx, 0, 4 * sizeof(int));

    if (fc->l2warm) {
        rv = _field_scache_stage_hdr_chk(fc, _FIELD_VFP_DATA_START);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
    }

    /* DMA various tables */
    vfp_tcam_buf = soc_cm_salloc(unit, sizeof(vfp_tcam_entry_t) *
                                soc_mem_index_count(unit, VFP_TCAMm),
                                "VFP TCAM buffer");
    if (NULL == vfp_tcam_buf) {
        return BCM_E_MEMORY;
    }
    sal_memset(vfp_tcam_buf, 0, sizeof(vfp_tcam_entry_t) *
               soc_mem_index_count(unit, VFP_TCAMm));
    index_min = soc_mem_index_min(unit, VFP_TCAMm);
    index_max = soc_mem_index_max(unit, VFP_TCAMm);
    fs = stage_fc->slices[_FP_DEF_INST];
    if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
        slice_ent_cnt = fs->entry_count * 2;
        /* DMA in chunks */
        for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
            if ((rv = soc_mem_read_range(unit, VFP_TCAMm, MEM_BLOCK_ALL,
                                         slice_idx * slice_ent_cnt,
                                         slice_idx * slice_ent_cnt +
                                             fs->entry_count / 2 - 1,
                                         vfp_tcam_buf + slice_idx *
                                             slice_ent_cnt *
                                  soc_mem_entry_words(unit, VFP_TCAMm))) < 0 ) {
                goto cleanup;
            }
            if ((rv = soc_mem_read_range(unit, VFP_TCAMm, MEM_BLOCK_ALL,
                                         slice_idx * slice_ent_cnt +
                                         fs->entry_count,
                                         slice_idx * slice_ent_cnt +
                                         fs->entry_count +
                                             fs->entry_count / 2 - 1,
                                         vfp_tcam_buf + (slice_idx *
                                         slice_ent_cnt + fs->entry_count) *
                                   soc_mem_entry_words(unit, VFP_TCAMm))) < 0 ) {
                goto cleanup;
            }
        }
    } else {
        slice_ent_cnt = fs->entry_count;
        if ((rv = soc_mem_read_range(unit, VFP_TCAMm, MEM_BLOCK_ALL,
                                     index_min, index_max,
                                     vfp_tcam_buf)) < 0 ) {
            goto cleanup;
        }
    }
    vfp_policy_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES
                                  (unit, VFP_POLICY_TABLEm),
                                  "VFP POLICY TABLE buffer");
    if (NULL == vfp_policy_buf) {
        return BCM_E_MEMORY;
    }
    index_min = soc_mem_index_min(unit, VFP_POLICY_TABLEm);
    index_max = soc_mem_index_max(unit, VFP_POLICY_TABLEm);
    if ((rv = soc_mem_read_range(unit, VFP_POLICY_TABLEm, MEM_BLOCK_ALL,
                                 index_min, index_max,
                                 vfp_policy_buf)) < 0 ) {
        goto cleanup;
    }

    /* Get slice expansion status and virtual map */
    if ((rv = _field_slice_expanded_status_get(unit, fc, stage_fc, expanded, slice_master_idx)) < 0) {
        goto cleanup;
    }

    /* Iterate over the slices */
    if ((rv = READ_VFP_SLICE_CONTROLr(unit, &rval)) < 0) {
        goto cleanup;
    }
    if ((rv = READ_VFP_KEY_CONTROLr(unit, &vfp_key)) < 0) {
        goto cleanup;
    }
    if (SOC_REG_IS_VALID(unit, VFP_KEY_CONTROL_2r)) {
        if ((rv = READ_VFP_KEY_CONTROL_2r(unit, &vfp_key2)) < 0) {
            goto cleanup;
        }
    }
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        /* Ignore disabled slice */
        if ((soc_reg_field_get(unit, VFP_SLICE_CONTROLr, rval,
                               vfp_en_flds[slice_idx]) == 0) ||
            (soc_reg_field_get(unit, VFP_SLICE_CONTROLr, rval,
                               vfp_lk_en_flds[slice_idx]) == 0)) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
        fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
        paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, vfp_key, fld);
        fld = _vfp_slice_wide_mode_field[slice_idx];
        if (soc_reg_field_valid(unit, VFP_KEY_CONTROLr, fld)) {
            intraslice = soc_reg_field_get(unit, VFP_KEY_CONTROLr, vfp_key, fld);
        } else {
            intraslice = 0;
        }
        if (paired && (slice_idx % 2)) {
            continue;
        }
        /* Don't need to read selectors for expanded slice */
        if (expanded[slice_idx]) {
            continue;
        }
        /* Skip if slice has no valid groups and entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, VFP_TCAMm, vfp_tcam_entry_t *,
                                  vfp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
            if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry,
                                          VALIDf) != 0) {
                break;
            }
        }
        if (idx == slice_ent_cnt && !fc->l2warm) {
            continue;
        }
        /* If Level 2, retrieve the GIDs in this slice */
        if (fc->l2warm) {
            rv = _field_trx_scache_slice_group_recover(unit,
                                                       fc, _FP_DEF_INST,
                                                       slice_idx,
                                                       NULL,
                                                       stage_fc,
                                                       0);
            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                fc->l2warm = 0;
                goto cleanup;
            }
            if (rv == BCM_E_NOT_FOUND) {
                rv = BCM_E_NONE;
                continue;
            }
        }

        /* Construct the group based on HW selector values */
        _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[0]);
        hw_sels.pri_slice[0].intraslice = _FP_SELCODE_DONT_USE;
        _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[1]);
        hw_sels.pri_slice[1].intraslice = _FP_SELCODE_DONT_USE;
        _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[0]);
        hw_sels.sec_slice[0].intraslice = _FP_SELCODE_DONT_USE;
        _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[1]);
        hw_sels.sec_slice[1].intraslice = _FP_SELCODE_DONT_USE;

        /* Get primary slice's selectors */
        hw_sels.pri_slice[0].fpf1 = 0;
        hw_sels.pri_slice[0].fpf2
            = soc_reg_field_get(unit,
                                VFP_KEY_CONTROLr,
                                vfp_key,
                                _bcm_field_trx_vfp_field_sel[slice_idx][0]
                                );
        hw_sels.pri_slice[0].fpf3
            = soc_reg_field_get(unit,
                                VFP_KEY_CONTROLr,
                                vfp_key,
                                _bcm_field_trx_vfp_field_sel[slice_idx][1]
                                );
        if (SOC_REG_IS_VALID(unit, VFP_KEY_CONTROL_2r)) {
            hw_sels.pri_slice[0].ip_header_sel
                = soc_reg_field_get(unit,
                                VFP_KEY_CONTROL_2r,
                                vfp_key2,
                                _bcm_field_trx_vfp_ip_header_sel[slice_idx]
                                );
        }
#if defined(BCM_KATANA_SUPPORT)
        if (SOC_IS_KATANA(unit)) {
           hw_sels.pri_slice[0].src_entity_sel
               = soc_reg_field_get(unit,
                                   VFP_KEY_CONTROL_2r,
                                   vfp_key2,
                                   _trx_vfp_src_type_sel[slice_idx]
                                   );
         }
#endif
#if defined (BCM_KATANA2_SUPPORT)
         if (SOC_IS_KATANA2(unit)) {
            hw_sels.pri_slice[0].src_entity_sel
                = soc_reg_field_get(unit,
                                    VFP_KEY_CONTROL_1r,
                                    vfp_key_1,
                                    _trx_vfp_src_type_sel[slice_idx]
                                    );
         }
#endif
        /* If intraslice, get double-wide key - only 2 options */
        if (intraslice) {
            dbl_wide_key = soc_reg_field_get(
                               unit,
                               VFP_KEY_CONTROLr,
                               vfp_key,
                               _bcm_field_trx_vfp_double_wide_sel[slice_idx]
                                             );
            hw_sels.pri_slice[1].intraslice = TRUE;
            hw_sels.pri_slice[1].fpf2 = dbl_wide_key;
            hw_sels.pri_slice[1].fpf3 = 0;
            if (SOC_REG_IS_VALID(unit, VFP_KEY_CONTROL_2r)) {
                hw_sels.pri_slice[1].ip_header_sel
                    = soc_reg_field_get(unit,
                                    VFP_KEY_CONTROL_2r, vfp_key2,
                                    _bcm_field_trx_vfp_ip_header_sel[slice_idx]
                                    );
            }
#if defined(BCM_KATANA_SUPPORT)
            if (SOC_IS_KATANA(unit)) {
               hw_sels.pri_slice[1].src_entity_sel
                   = soc_reg_field_get(unit,
                                       VFP_KEY_CONTROL_2r,
                                       vfp_key2,
                                       _trx_vfp_src_type_sel[slice_idx]
                                       );
            }
#endif
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
               hw_sels.pri_slice[1].src_entity_sel
                   = soc_reg_field_get(unit,
                                       VFP_KEY_CONTROL_1r,
                                       vfp_key_1,
                                       _trx_vfp_src_type_sel[slice_idx]
                                       );
            }
#endif
        }
        /* If paired, get secondary slice's selectors */
        if (paired) {
            hw_sels.sec_slice[0].fpf1 = 0;
            hw_sels.sec_slice[0].fpf2
                = soc_reg_field_get(
                      unit,
                      VFP_KEY_CONTROLr,
                      vfp_key,
                      _bcm_field_trx_vfp_field_sel[slice_idx + 1][0]
                                    );
            hw_sels.sec_slice[0].fpf3
                = soc_reg_field_get(
                      unit,
                      VFP_KEY_CONTROLr,
                      vfp_key,
                      _bcm_field_trx_vfp_field_sel[slice_idx + 1][1]
                                    );
            if (SOC_REG_IS_VALID(unit, VFP_KEY_CONTROL_2r)) {
                hw_sels.sec_slice[0].ip_header_sel
                    = soc_reg_field_get(unit,
                               VFP_KEY_CONTROL_2r, vfp_key2,
                               _bcm_field_trx_vfp_ip_header_sel[slice_idx + 1]);
            }
#if defined(BCM_KATANA_SUPPORT)
            if (SOC_IS_KATANA(unit)) {
               hw_sels.sec_slice[0].src_entity_sel
                   = soc_reg_field_get(unit,
                                       VFP_KEY_CONTROL_2r,
                                       vfp_key2,
                                       _trx_vfp_src_type_sel[slice_idx + 1]
                                       );
            }
#endif
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
               hw_sels.sec_slice[0].src_entity_sel
                   = soc_reg_field_get(unit,
                                       VFP_KEY_CONTROL_1r,
                                       vfp_key_1,
                                       _trx_vfp_src_type_sel[slice_idx + 1]
                                       );
            }
#endif
            if (intraslice) {
                dbl_wide_key_sec
                    = soc_reg_field_get(
                          unit,
                          VFP_KEY_CONTROLr,
                          vfp_key,
                          _bcm_field_trx_vfp_double_wide_sel[slice_idx + 1]
                                        );
                hw_sels.sec_slice[1].intraslice = TRUE;
                hw_sels.sec_slice[1].fpf2 = dbl_wide_key_sec;
                hw_sels.sec_slice[1].fpf3 = 0;
                if (SOC_REG_IS_VALID(unit, VFP_KEY_CONTROL_2r)) {
                    hw_sels.sec_slice[1].ip_header_sel
                        = soc_reg_field_get(
                          unit,
                          VFP_KEY_CONTROL_2r,
                          vfp_key2,
                          _bcm_field_trx_vfp_ip_header_sel[slice_idx + 1]
                                        );
                }
#if defined(BM_KATANA_SUPPORT)
                if (SOC_IS_KATANA(unit)) {
                   hw_sels.sec_slice[1].src_entity_sel
                       = soc_reg_field_get(unit,
                                           VFP_KEY_CONTROL_2r,
                                           vfp_key2,
                                           _trx_vfp_src_type_sel[slice_idx + 1]
                                           );
                }
#endif
#if defined (BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                  hw_sels.sec_slice[1].src_entity_sel
                      = soc_reg_field_get(unit,
                                          VFP_KEY_CONTROL_1r,
                                          vfp_key_1,
                                          _trx_vfp_src_type_sel[slice_idx + 1]
                                          );
                }
#endif
            }
        }
        /* Create a group based on HW qualifiers (or find existing) */
        rv = _field_tr2_group_construct(unit, _FP_DEF_INST, &hw_sels, intraslice,
                                        paired, fc, -1,
                                        _BCM_FIELD_STAGE_LOOKUP,
                                        slice_idx
                                        );
        if (BCM_FAILURE(rv)) {
            goto cleanup;
        }
        /* Now go over the entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            fs->free_count >>= 1;
            ratio = 2;
        } else {
            ratio = 1;
        }
        prev_prio = -1;
        for (idx = 0; idx < slice_ent_cnt / ratio; idx++) {
            group_found = 0;
            vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, VFP_TCAMm, vfp_tcam_entry_t *,
                                  vfp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
            if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry,
                                          VALIDf) == 0) {
                continue;
            }
            /* All ports are applicable to this entry */
            SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PORT_ALL(unit));
            SOC_PBMP_OR(entry_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
            if (soc_feature(unit, soc_feature_linkphy_coe) ||
                soc_feature(unit, soc_feature_subtag_coe)) {
                _bcm_kt2_subport_pbmp_update(unit, &entry_pbmp);
            }
#endif
            /* Search groups to find match */
            fg = fc->groups;
            while (fg != NULL) {
                /* Check if group is in this slice */
                fs = &fg->slices[0];
                if (fs->slice_number != slice_idx) {
                    fg = fg->next;
                    continue;
                }
                /* Check if entry_pbmp is a subset of group pbmp */
                SOC_PBMP_ASSIGN(temp_pbmp, fg->pbmp);
                SOC_PBMP_AND(temp_pbmp, entry_pbmp);
                if (SOC_PBMP_EQ(temp_pbmp, entry_pbmp)) {
                    group_found = 1;
                    break;
                }
                fg = fg->next;
            }
            if (!group_found) {
                return BCM_E_INTERNAL; /* Should never happen */
            }
            /* Allocate memory for the entry */
            rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                   fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            mem_sz = parts_count * sizeof (_field_entry_t);
            _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                    action_bmp.w = NULL;
                    _FP_XGS3_ALLOC(action_bmp.w,
                             SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                             "Action No Param Bitmap");
                    if (action_bmp.w == NULL) {
                       rv = BCM_E_MEMORY;
                       sal_free(f_ent);
                       goto cleanup;
                    }
                }
                f_ent_wb_info.action_bmp = &action_bmp;

                rv = _field_trx_entry_info_retrieve(unit,
                                                    fc,
                                                    stage_fc,
                                                    0,
                                                    &prev_prio,
                                                    &f_ent_wb_info
                                                    );
                
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }
            vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                    slice_idx, stage_fc);
            if (vslice_idx < 0) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }

            pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
            for (i = 0; i < parts_count; i++) {
                if (fc->l2warm) {
                    /* Use retrieved EID */
                    f_ent[i].eid = f_ent_wb_info.eid;
                    /* Set retrieved dvp_type and svp_type */
                    f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                    f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                    f_ent[i].prio = f_ent_wb_info.prio;
                } else {
                    f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    f_ent[i].prio = (vslice_idx << 10) | (slice_ent_cnt - idx);
                }
                f_ent[i].group = fg;
                rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                         &f_ent[i].flags);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (f_ent_wb_info.color_independent) {
                    f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                }
                rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                        pri_tcam_idx,
                                                        i, &part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                         _FP_DEF_INST,
                                                         part_index,
                                                         &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                f_ent[i].fs = stage_fc->slices[_FP_DEF_INST] + slice_number;
                if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Decrement slice free entry count for primary
                       entries. */
                    f_ent[i].fs->free_count--;
                }
                /* Assign entry to a slice */
                f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry, VALIDf) == 3) {
                    f_ent[i].flags |= _FP_ENTRY_ENABLED;
                }

                /* Get the actions associated with this part of the entry */
                vfp_policy_entry = soc_mem_table_idx_to_pointer
                                                (unit, VFP_POLICY_TABLEm,
                                                 vfp_policy_table_entry_t *,
                                                 vfp_policy_buf, part_index);
                rv = _field_tr2_actions_recover(unit,
                                                VFP_POLICY_TABLEm,
                                                (uint32 *) vfp_policy_entry,
                                                f_ent,
                                                i,
                                                &f_ent_wb_info);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (action_bmp.w != NULL) {
                   _FP_ACTION_BMP_FREE(action_bmp);
                   action_bmp.w = NULL;
                }
#if defined(BCM_KATANA_SUPPORT)
                if (SOC_IS_KATANAX(unit)) {
                    if ((flex_info[unit].valid == 1) && (flex_info[unit].flex_mode != 0)) {
                        BCM_IF_ERROR_RETURN(_bcm_field_stat_get(
                                            unit, f_ent->statistic.sid, &f_st));
                        f_st->flex_mode = flex_info[unit].flex_mode;
                        f_st->hw_flags = flex_info[unit].hw_flags;
                        _bcm_esw_stat_get_counter_id_info(unit, f_st->flex_mode,
                                          &stat_mode,
                                          &stat_obj,
                                          (uint32 *)&offset_mode,
                                          &pool_num,
                                          &base_index
                                          );
                        f_st->hw_index = base_index;
                        f_st->pool_index = pool_num;
                        f_st->hw_mode = stat_mode; /* Shouldn't be offset_mode*/
                        f_st->hw_entry_count = 1; /* PlsNote:For SingleMode=1 */
                        /* Currently OnlySingleMode is supportes so above OK */
                        /* else decision will be based on stat_mode
                           Probably one helper function will be required */
                    }
                    flex_info[unit].valid=0;
                }
#endif
#if defined(BCM_TRIUMPH2_SUPPORT)
                if (soc_feature(unit, soc_feature_field_vfp_flex_counter)) {
                    _field_vfp_flex_stat_info_retrieve(unit, f_ent->statistic.sid);
                }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
                if (soc_feature(unit, soc_feature_flowcnt)) {
                    rv = _field_flowcnt_stat_info_retrieve(unit,
                        f_ent->statistic.sid);
                    if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                    }
                }

#endif /* BCM_HURRICANE3_SUPPORT */

#if defined(BCM_KATANA_SUPPORT)
                if (SOC_IS_KATANAX(unit)) {
                    policer_index = PolicyGet(unit,
                                          VFP_POLICY_TABLEm,
                                          vfp_policy_entry,
                                          SVC_METER_INDEXf);
                    offset_mode  = PolicyGet(unit,
                                   VFP_POLICY_TABLEm,
                                   vfp_policy_entry,
                                   SVC_METER_OFFSET_MODEf);
                    rv = _bcm_esw_get_policer_id_from_index_offset(unit,
                                            policer_index, offset_mode,
                                            &(f_ent->global_meter_policer.pid));
                    if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                    }
                    f_ent->global_meter_policer.flags = PolicyGet(unit,
                                                    VFP_POLICY_TABLEm,
                                                    vfp_policy_entry,
                                                    SVC_METER_INDEX_PRIORITYf);
                }
#endif  /* BCM_KATANA_SUPPORT */
            }
            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                goto cleanup;
            }
            f_ent = NULL;
        }
        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) {
                /* update selcode and construct group qual offset */
                rv = _field_tr2_group_construct_quals_with_sel_update(unit, fc, stage_fc);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
            }
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }
    }

    /* Now go over the expanded slices */
    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
        if (!expanded[slice_idx]) {
            continue;
        }
        /* Ignore secondary slice in paired mode */
        fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
        paired = soc_reg_field_get(unit, VFP_KEY_CONTROLr, vfp_key, fld);
        if (paired && (slice_idx % 2)) {
            continue;
        }
        /* Skip if slice has no valid groups and entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        for (idx = 0; idx < slice_ent_cnt; idx++) {
            vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, VFP_TCAMm, vfp_tcam_entry_t *,
                                  vfp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
            if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry,
                                          VALIDf) != 0) {
                break;
            }
        }

        if (idx == slice_ent_cnt) {
            continue;
        }

        /* If Level 2, retrieve the GIDs in this slice */
        if (fc->l2warm) {
            rv = _field_trx_scache_slice_group_recover(unit,
                                                       fc, _FP_DEF_INST,
                                                       slice_idx,
                                                       NULL,
                                                       stage_fc,
                                                       0);
            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                fc->l2warm = 0;
                goto cleanup;
            }
            if (rv == BCM_E_NOT_FOUND) {
                rv = BCM_E_NONE;
                continue;
            }
        }

        /* Now find the master slice for this virtual group */
        vslice_idx = _field_physical_to_virtual(unit, _FP_DEF_INST,
                                                slice_idx, stage_fc);
        if (vslice_idx < 0) {
            rv = BCM_E_INTERNAL;
            goto cleanup;
        }

        if (fc->l2warm
                && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
            master_slice = slice_master_idx[slice_idx];
        } else {
        max = -1;
        for (i = 0; i < stage_fc->tcam_slices; i++) {
            if ((stage_fc->vmap[_FP_DEF_INST][0][vslice_idx].virtual_group ==
                stage_fc->vmap[_FP_DEF_INST][0][i].virtual_group) && (i != vslice_idx)) {
                if (i > max) {
                    max = i;
                }
            }
        }
        if (max < 0) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

        master_slice = stage_fc->vmap[_FP_DEF_INST][0][max].vmap_key;
        }
        /* See which group is in this slice - can be only one */
        fg = fc->groups;
        while (fg != NULL) {
            /* Check if group is in this slice */
            fs = &fg->slices[0];
            if ((fg->stage_id == stage_fc->stage_id)
                    && (fs->slice_number == master_slice)) {
                break;
            }
            fg = fg->next;
        }
        if (fg == NULL) {
            rv = BCM_E_INTERNAL;

            goto cleanup;
        }

      /* Get number of entry parts for the group. */
        rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                                fg->flags, &parts_count);
        BCM_IF_ERROR_RETURN(rv);

        old_physical_slice = fs->slice_number;

        /* Set up the new physical slice parameters in Software */
        for(part_index = parts_count - 1; part_index >= 0; part_index--) {
            /* Get entry flags. */
            rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg, &entry_flags);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice id for entry part */
            rv = _bcm_field_tcam_part_to_slice_number(unit, part_index,
                                                      fg, &slice_num);
            BCM_IF_ERROR_RETURN(rv);

            /* Get slice pointer. */
            fs = stage_fc->slices[_FP_DEF_INST] + slice_idx
                    + slice_num;

            if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
                /* Set per slice configuration &  number of free entries in the slice.*/
                fs->free_count = fs->entry_count;
                if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                    fs->free_count >>= 1;
                }
                /* Set group flags in in slice.*/
                fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

                /* Add slice to slices linked list . */
                fs_temp = stage_fc->slices[_FP_DEF_INST] + old_physical_slice + slice_num;
                /* To handle more than one auto expanded slice in a group */
                while (fs_temp->next != NULL) {
                    fs_temp = fs_temp->next;
                }
                fs_temp->next = fs;
                fs->prev = fs_temp;
            }
        }

        /* Now go over the entries */
        fs = stage_fc->slices[_FP_DEF_INST] + slice_idx;
        fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;
        if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
            ratio = 2;
            fs->free_count >>= 1;
        } else {
            ratio = 1;
        }

        prev_prio = -1;
        for (idx = 0; idx < slice_ent_cnt / ratio; idx++) {
            group_found = 0;
            vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                 (unit, VFP_TCAMm, vfp_tcam_entry_t *,
                                  vfp_tcam_buf, idx +
                                  slice_ent_cnt * slice_idx);
            if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry,
                                          VALIDf) == 0) {
                continue;
            }

            /* All ports are applicable to this entry */
            SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PORT_ALL(unit));
            SOC_PBMP_OR(entry_pbmp, PBMP_CMIC(unit));
#if defined(BCM_KATANA2_SUPPORT)
            if (soc_feature(unit, soc_feature_linkphy_coe) ||
                soc_feature(unit, soc_feature_subtag_coe)) {
                _bcm_kt2_subport_pbmp_update(unit, &entry_pbmp);
            }
#endif
            /* Search groups to find match */
            fg = fc->groups;
            while (fg != NULL) {
                /* Check if group is in this slice */
                fs = &fg->slices[0];
                if ((fg->stage_id != stage_fc->stage_id)
                        || (fs->slice_number != master_slice)) {
                    fg = fg->next;
                    continue;
                }
                /* Check if entry_pbmp is a subset of group pbmp */
                SOC_PBMP_ASSIGN(temp_pbmp, fg->pbmp);
                SOC_PBMP_AND(temp_pbmp, entry_pbmp);
                if (SOC_PBMP_EQ(temp_pbmp, entry_pbmp)) {
                    group_found = 1;
                    break;
                }
                fg = fg->next;
            }
            if (!group_found) {
                return BCM_E_INTERNAL; /* Should never happen */
            }
            /* Allocate memory for the entry */
            rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                   fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            mem_sz = parts_count * sizeof (_field_entry_t);
            _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                   action_bmp.w = NULL;
                   _FP_XGS3_ALLOC(action_bmp.w,
                            SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                            "Action No Param Bitmap");
                   if (action_bmp.w == NULL) {
                      rv = BCM_E_MEMORY;
                      sal_free(f_ent);
                      goto cleanup;
                   }
                }
                f_ent_wb_info.action_bmp = &action_bmp;
                rv = _field_trx_entry_info_retrieve(unit,
                                                    fc,
                                                    stage_fc,
                                                    0,
                                                    &prev_prio,
                                                    &f_ent_wb_info
                                                    );
                
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }
            pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
            for (i = 0; i < parts_count; i++) {
                if (fc->l2warm) {
                    /* Use retrieved EID */
                    f_ent[i].eid = f_ent_wb_info.eid;
                    /* Set retrieved dvp_type and svp_type */
                    f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                    f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                    f_ent[i].prio = f_ent_wb_info.prio;
                } else {
                    f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    f_ent[i].prio = (vslice_idx << 10) | (slice_ent_cnt - idx);
                }
                f_ent[i].group = fg;
                rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                         &f_ent[i].flags);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (f_ent_wb_info.color_independent) {
                    f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                }
                rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                        pri_tcam_idx,
                                                        i, &part_index);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                         _FP_DEF_INST,
                                                         part_index,
                                                         &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                f_ent[i].fs = stage_fc->slices[_FP_DEF_INST] + slice_number;
                if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Decrement slice free entry count for primary
                       entries. */
                    f_ent[i].fs->free_count--;
                }
                /* Assign entry to a slice */
                f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                if (soc_VFP_TCAMm_field32_get(unit, vfp_tcam_entry, VALIDf) == 3) {
                    f_ent[i].flags |= _FP_ENTRY_ENABLED;
                }

                /* Get the actions associated with this part of the entry */
                vfp_policy_entry = soc_mem_table_idx_to_pointer
                                                (unit, VFP_POLICY_TABLEm,
                                                 vfp_policy_table_entry_t *,
                                                 vfp_policy_buf, part_index);
                rv = _field_tr2_actions_recover(unit,
                                                VFP_POLICY_TABLEm,
                                                (uint32 *) vfp_policy_entry,
                                                f_ent,
                                                i,
                                                &f_ent_wb_info);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                if (action_bmp.w != NULL) {
                   _FP_ACTION_BMP_FREE(action_bmp);
                   action_bmp.w = NULL;
                }
#if defined(BCM_KATANA_SUPPORT)
                if (SOC_IS_KATANAX(unit)) {
                    if ((flex_info[unit].valid == 1) && (flex_info[unit].flex_mode != 0)) {
                        BCM_IF_ERROR_RETURN(_bcm_field_stat_get(
                                            unit, f_ent->statistic.sid, &f_st));
                        f_st->flex_mode = flex_info[unit].flex_mode;
                        f_st->hw_flags = flex_info[unit].hw_flags;
                        _bcm_esw_stat_get_counter_id_info(unit, f_st->flex_mode,
                                          &stat_mode,
                                          &stat_obj,
                                          (uint32 *)&offset_mode,
                                          &pool_num,
                                          &base_index
                                          );
                        f_st->hw_index = base_index;
                        f_st->pool_index = pool_num;
                        f_st->hw_mode = stat_mode; /* Shouldn't be offset_mode*/
                        f_st->hw_entry_count = 1; /* PlsNote:For SingleMode=1 */
                        /* Currently OnlySingleMode is supportes so above OK */
                        /* else decision will be based on stat_mode
                           Probably one helper function will be required */
                    }
                    flex_info[unit].valid=0;
                }
#endif
#if defined(BCM_TRIUMPH2_SUPPORT)
                if (soc_feature(unit, soc_feature_field_vfp_flex_counter)) {
                    _field_vfp_flex_stat_info_retrieve(unit, f_ent->statistic.sid);
                }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
                if (soc_feature(unit, soc_feature_flowcnt)) {
                    rv = _field_flowcnt_stat_info_retrieve(unit,
                        f_ent->statistic.sid);
                    if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                    }
                }
#endif /* BCM_HURRICANE3_SUPPORT */


#if defined(BCM_KATANA_SUPPORT) /* Retrieving meter flags. */
                if (SOC_IS_KATANAX(unit)) {
                    policer_index = PolicyGet(unit,
                                          VFP_POLICY_TABLEm,
                                          vfp_policy_entry,
                                          SVC_METER_INDEXf);
                    offset_mode  = PolicyGet(unit,
                                   VFP_POLICY_TABLEm,
                                   vfp_policy_entry,
                                   SVC_METER_OFFSET_MODEf);
                    rv = _bcm_esw_get_policer_id_from_index_offset(unit,
                                            policer_index, offset_mode,
                                            &(f_ent->global_meter_policer.pid));
                    if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                    }
                    f_ent->global_meter_policer.flags = PolicyGet(unit,
                                                    VFP_POLICY_TABLEm,
                                                    vfp_policy_entry,
                                                    SVC_METER_INDEX_PRIORITYf);
                }
#endif  /* BCM_KATANA_SUPPORT */
            }
            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                sal_free(f_ent);
                goto cleanup;
            }
            f_ent = NULL;
        }
        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }
    }

    if (fc->l2warm) {

        /* Mark end of Slice Info */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            fc->scache_pos++;
        }

        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                if (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                            (BSL_META_U(unit,"Recovering hint Ids "
                                        "from pos = %d\r\n"), fc->scache_pos));
                    BCM_IF_ERROR_RETURN (_bcm_hints_scache_hintid_recover(unit, stage_fc,
                                fc, &buf[fc->scache_pos]));
                }
            }
        }

        /* Group Slice Selectors */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            rv = (_field_group_slice_selectors_recover(unit,
                        &buf[fc->scache_pos], stage_fc->stage_id));
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        temp = 0;
        temp |= buf[fc->scache_pos];
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        if (temp != _FIELD_VFP_DATA_END) {
            fc->l2warm = 0;
            rv = BCM_E_INTERNAL;
        }
        if (NULL != buf1) {
            temp = 0;
            temp |= buf1[fc->scache_pos1];
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 8;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 16;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 24;
            fc->scache_pos1++;
            if (temp != _FIELD_VFP_DATA_END) {
                fc->l2warm = 0;
                rv = BCM_E_INTERNAL;
            }
        }

    }

    if (BCM_SUCCESS(rv)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

    _field_tr2_stage_reinit_all_groups_cleanup(unit, fc,
                                               _BCM_FIELD_STAGE_LOOKUP,
                                               NULL);

cleanup:

    if (vfp_tcam_buf) {
        soc_cm_sfree(unit, vfp_tcam_buf);
    }
    if (vfp_policy_buf) {
        soc_cm_sfree(unit, vfp_policy_buf);
    }
    if (action_bmp.w != NULL) {
        _FP_ACTION_BMP_FREE(action_bmp);
        action_bmp.w = NULL;
    }
    return rv;
}

#if 0
/* Returns:  1 if any bit of buf is set between offset->offset and
 *             offset->offset + offset->width
 *           0 otherwise
 */
STATIC int
_ext_mask_is_set(int unit,
                 _bcm_field_qual_offset_t *offset,
                 soc_mem_t mem,
                 uint32 *buf
                 )

{
    soc_mem_info_t *meminfo = &SOC_MEM_INFO(unit, mem);
    int len = offset->width, bp = offset->offset;
    uint32 temp;

    switch (mem) {
    case EXT_ACL144_TCAM_L2m:
    case EXT_ACL144_TCAM_IPV4m:
    case EXT_ACL144_TCAM_IPV6m:
        bp += 144;
        break;

    case EXT_ACL288_TCAM_L2m:
    case EXT_ACL288_TCAM_IPV4m:
        bp += 288;
        break;

    default:
        ;
    }

#define FIX_MEM_ORDER_E(v,m) (((m)->flags & SOC_MEM_FLAG_BE) ? \
                                BYTES2WORDS((m)->bytes)-1-(v) : \
                                (v))
    while (len > 0) {
        temp = 0;
        do {
            /* coverity [forward_null] */
            temp =
                (temp << 1) |
                ((buf[FIX_MEM_ORDER_E(bp / 32, meminfo)] >>
                  (bp & (32 - 1))) & 1);
            if (temp > 0) {
                return TRUE;
            }
            len--;
            bp++;
        } while (len & (32 - 1));
    }
    return FALSE;
}
#endif

/***************************************************************************
 *
 * Support for use of external memory as scache
 *
 ***************************************************************************/

#define FIELD_SIZE(t, f)  (sizeof(((t *) 0)->f))

STATIC void
_field_tr2_ext_part_mems(int unit, unsigned part_idx, soc_mem_t *mems)
{
    /* mems[0] = policy mem
       mems[1] = data mem or data-and-mask mem
       mems[2] = mask mem or INVALIDm
    */

    mems[0] = _bcm_field_ext_policy_mems[part_idx];
    if ((mems[1] = _bcm_field_ext_data_mask_mems[part_idx]) == 0) {
        mems[1] = _bcm_field_ext_data_mems[part_idx];
        mems[2] = _bcm_field_ext_mask_mems[part_idx];
    } else {
        mems[2] = INVALIDm;
    }
}


STATIC unsigned
_field_tr2_ext_scache_usable_bytes_per_word(int       unit,
                                            soc_mem_t *mems,
                                            unsigned  mem_idx
                                            )
{
    switch (mem_idx) {
    case 0:                     /* policy mem */
        return (SOC_MEM_BYTES(unit, mems[0]) - 3);
    case 1:                     /* data+mask or data mem */
        return (soc_mem_field_length(unit, mems[1], DATAf) >> 3);
    default:
        ;
    }

    return (0);
}


STATIC uint32
_field_tr2_ext_scache_size_prop_get(int unit, unsigned part_idx)
{
    static const char * const scache_size_props[] = {
        spn_EXT_L2C_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_L2_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_IP4C_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_IP4_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_L2IP4_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_IP6C_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_IP6S_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_IP6F_ACL_TABLE_SCACHE_SIZE,
        spn_EXT_L2IP6_ACL_TABLE_SCACHE_SIZE
    };

    return (soc_property_get(unit, scache_size_props[part_idx], 0xffffffff));
}


unsigned
_field_trx_ext_scache_size(int       unit,
                           unsigned  part_idx,
                           soc_mem_t *mems
                           )
{
    uint32 sz;

    if ((sz = _field_tr2_ext_scache_size_prop_get(unit, part_idx)) == 0xffffffff) {
        /* Scache size not specified => Don't reserve any entries */

        return (0);
    }

    if (sz == 0) {
        /* Scache size specified as 0
           => Calculate space needed to store all entries */

        /* Calculate usable bytes (i.e. width) of an entry in TCAM and policy memory
         * - Consider both data and mask mems, as appicable
         * - Last byte in a data or mask entry might be a partial byte (i.e. less
         * than 8 bits), so don't include it
         */

        unsigned  i, w, f, n, T;

        for (w = 0, i = 0; i < 2; ++i) {
            w += _field_tr2_ext_scache_usable_bytes_per_word(unit, mems, i);
        }

        /* Let
           T = total number of entries in slice
           S = number of entries reserved for scache
           E = number of usable entries

           Thus, E + S = T

           Let
           f = Fixed scache storage required, in bytes
           n = Number of bytes of scache storage per entry
           w = Width of an scache word, in bytes

           So, S = ceiling((f + nE) / w)

           Therefore, (f + nE) <= wS <= (f + nE + w - 1)
           [aobve as inequalify, all values are whole numbers]

           But, E = T - S [from above]

           So, (f + nT) <= (n + w)S <= (f + nT + w - 1)

           Therefore, S = floor((f + nT + w - 1) / (n + w))
        */

        f =
            /* header */
            4
            /* group-present flag */
            + 1
            /* group id */
            + FIELD_SIZE(_field_group_t, gid)
            /* group priority */
            + FIELD_SIZE(_field_group_t, priority)
            /* group qset (a guess at a reasonable upper limit) */
            + 20
            /* trailer */
            + 4;
        n =
            /* entry id */
            FIELD_SIZE(_field_entry_t, eid)
            /* priority/stat/policer flags */
            + 1
            /* entry priority */
            + FIELD_SIZE(_field_entry_t, prio)
            /* stat id */
            + FIELD_SIZE(_field_entry_t, statistic.sid)
            /* policer id */
            + FIELD_SIZE(_field_entry_t, policer[0].pid);
        T = soc_mem_index_count(unit, mems[0]);

        return((f + n * T + w - 1) / (n + w));
    }

    /* Otherwise, use specified value */

    return (sz);
}


int
_bcm_esw_field_tr2_ext_scache_size(int       unit,
                                   unsigned  part_idx
                                   )
{
    soc_mem_t mems[3];

    _field_tr2_ext_part_mems(unit, part_idx, mems);
    return (_field_trx_ext_scache_size(unit, part_idx, mems));
}


struct _field_tr2_ext_scache_rw {
    int              unit;
    _field_control_t *fc;
    soc_mem_t mems[3];
    unsigned  scache_nwords, scache_idx_min, scache_idx_max;
    struct _field_tr2_scache_mem_info {
        uint32 bytes_per_word;
        uint32 *buf;
    } mem_info[3];
    struct _field_tr2_scache_chunk {
        uint8  usable_bytes_per_word;
        uint32 *pos, *limit, w;
    } chunk[2];
    unsigned  cur_chunk_idx;
};

STATIC int
_field_tr2_ext_scache_init(struct _field_tr2_ext_scache_rw *h,
                           int                             unit,
                           unsigned                        part_idx
                           )
{
    struct _field_tr2_scache_chunk *ch;
    unsigned n, i;

    sal_memset(h, 0, sizeof(*h));

    h->unit = unit;
    BCM_IF_ERROR_RETURN(_field_control_get(h->unit, &h->fc));
    _field_tr2_ext_part_mems(unit, part_idx, h->mems);
    for (i = 0; i < COUNTOF(h->mems); ++i) {
        if (h->mems[i] == INVALIDm) {
            break;
        }
        h->mem_info[i].bytes_per_word
            = WORDS2BYTES(SOC_MEM_WORDS(h->unit, h->mems[i]));
    }
    h->scache_nwords = _field_trx_ext_scache_size(h->unit,
                                                  part_idx,
                                                  h->mems
                                                  );
    if (h->scache_nwords != 0) {
        /* Set up for ext mem as scache */

        h->scache_idx_max = soc_mem_index_max(h->unit, h->mems[0]);
        h->scache_idx_min = h->scache_idx_max + 1 - h->scache_nwords;

        for (i = 0, ch = h->chunk, n = COUNTOF(h->chunk); n; --n, ++ch, ++i) {
            ch->usable_bytes_per_word
                = _field_tr2_ext_scache_usable_bytes_per_word(h->unit, h->mems, i);
        }
    }

    return (BCM_E_NONE);
}

STATIC void
_field_tr2_ext_scache_release(struct _field_tr2_ext_scache_rw *h)
{
    unsigned i;

    for (i = 0; i < COUNTOF(h->mem_info); ++i) {
        if (h->mem_info[i].buf) {
            soc_cm_sfree(h->unit, h->mem_info[i].buf);

            h->mem_info[i].buf = 0;
        }
    }
}

STATIC int
_field_tr2_ext_scache_wr_init(struct _field_tr2_ext_scache_rw *h,
                              int                             unit,
                              unsigned                        part_idx
                              )
{
    struct _field_tr2_scache_chunk *ch;
    unsigned n, i;

    _field_tr2_ext_scache_init(h, unit, part_idx);

    if (h->scache_nwords != 0) {
        for (ch = h->chunk, i = 0, n = COUNTOF(h->chunk); n; --n, ++i, ++ch) {
            unsigned s;
            uint32   *buf;

            s = h->scache_nwords * h->mem_info[i].bytes_per_word;
            if ((buf = soc_cm_salloc(unit, s, "")) == 0) {
                _field_tr2_ext_scache_release(h);
                return (BCM_E_MEMORY);
            }
            h->mem_info[i].buf = buf;

            ch->pos   = buf;
            ch->limit = (uint32 *)((uint8 *) buf + s);
        }
    }

    return (BCM_E_NONE);
}

STATIC int
_field_tr2_ext_scache_wr(struct _field_tr2_ext_scache_rw *h, uint8 val)
{
    if (h->scache_nwords != 0) {
        struct _field_tr2_scache_chunk *ch = &h->chunk[h->cur_chunk_idx];
        unsigned sh;
        uint32   *p;

        if (ch->pos >= ch->limit) {
            if (++h->cur_chunk_idx >= COUNTOF(h->chunk)) {
                _field_tr2_ext_scache_release(h);
                return (BCM_E_FAIL);
            }
            ch = &h->chunk[h->cur_chunk_idx];
        }

        sh = (ch->w & 3) << 3;
        p  = &ch->pos[ch->w >> 2];
        *p = (*p & ~(0xff << sh)) | val << sh;

        if (++ch->w >= ch->usable_bytes_per_word) {
            ch->pos = (uint32 *)((uint8 *) ch->pos
                                 + h->mem_info[h->cur_chunk_idx].bytes_per_word
                                 );
            ch->w = 0;
        }
    } else {
        _field_control_t *fc = h->fc;
        uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
        buf[fc->scache_pos] = val;
        ++fc->scache_pos;
    }

    return (BCM_E_NONE);
}

STATIC int
_field_tr2_ext_scache_wr_uint(struct _field_tr2_ext_scache_rw *h,
                              uint32                          val,
                              unsigned                        nbytes
                              )
{
    return (_field_tr2_ext_scache_wr(h, val) != BCM_E_NONE
            || (nbytes > 1 && _field_tr2_ext_scache_wr(h, val >> 8) != BCM_E_NONE)
            || (nbytes > 2 && _field_tr2_ext_scache_wr(h, val >> 16) != BCM_E_NONE)
            || (nbytes > 2 && _field_tr2_ext_scache_wr(h, val >> 24) != BCM_E_NONE)
            ? BCM_E_FAIL : BCM_E_NONE
            );
}

#define _FIELD_TR2_EXT_SCACHE_WR_UINT(h, x) \
    (_field_tr2_ext_scache_wr_uint((h), (x), sizeof(x)))

STATIC int
_field_tr2_ext_scache_wr_commit(struct _field_tr2_ext_scache_rw *h)
{
    int result = BCM_E_NONE;

    if (h->scache_nwords != 0) {
        uint32 m[(432 + 31) >> 5];

        result = soc_mem_write_range(h->unit,
                                     h->mems[0],
                                     MEM_BLOCK_ALL,
                                     h->scache_idx_min,
                                     h->scache_idx_max,
                                     h->mem_info[0].buf
                                     );
        if (result != BCM_E_NONE) {
            goto cleanup;
        }

        sal_memset(m, 0xff, sizeof(m));

        if (h->mems[2] == INVALIDm) {
            unsigned n;
            uint32   *p;

            for (p = h->mem_info[1].buf, n = h->scache_nwords;
                 n;
                 --n, p = (uint32 *)((uint8 *) p + h->mem_info[1].bytes_per_word)
                 ) {
                soc_mem_mask_field_set(h->unit, h->mems[1], p, MASKf, m);
            }
        } else {
            uint32 mm[COUNTOF(m)];

            soc_mem_mask_field_set(h->unit, h->mems[2], mm, MASKf, m);
            soc_mem_write(h->unit, h->mems[2], MEM_BLOCK_ALL, 0, mm);
        }

        result = soc_mem_write_range(h->unit,
                                     h->mems[1],
                                     MEM_BLOCK_ALL,
                                     h->scache_idx_min,
                                     h->scache_idx_max,
                                     h->mem_info[1].buf
                                     );

    cleanup:
        _field_tr2_ext_scache_release(h);
    }

    return (result);
}

STATIC int
_field_tr2_ext_scache_rd_init(struct _field_tr2_ext_scache_rw *h,
                              int                             unit,
                              unsigned                        part_idx
                              )
{
    int      result = BCM_E_NONE;
    unsigned i;

    _field_tr2_ext_scache_init(h, unit, part_idx);

    for (i = 0; i < COUNTOF(h->mem_info); ++i) {
        uint32 *buf;

        if (h->mems[i] == INVALIDm) {
            break;
        }

        if ((buf = soc_cm_salloc(unit,
                                 soc_mem_index_count(unit, h->mems[0])
                                 * h->mem_info[i].bytes_per_word,
                                 ""
                                 )
             )
            == 0
            ) {
            _field_tr2_ext_scache_release(h);
            return (BCM_E_MEMORY);
        }

        h->mem_info[i].buf = buf;
    }

    result = soc_mem_read_range(h->unit,
                                h->mems[0],
                                MEM_BLOCK_ANY,
                                soc_mem_index_min(h->unit, h->mems[0]),
                                soc_mem_index_max(h->unit, h->mems[0]),
                                h->mem_info[0].buf
                                );

    if (result != BCM_E_NONE) {
        goto done;
    }

    if (h->mems[2] == INVALIDm) {
        result = soc_mem_read_range(h->unit,
                                    h->mems[1],
                                    MEM_BLOCK_ANY,
                                    soc_mem_index_min(h->unit, h->mems[1]),
                                    soc_mem_index_max(h->unit, h->mems[1]),
                                    h->mem_info[1].buf
                                    );
    } else {
        unsigned n;
        uint32   *p1, *p2;

        for (p1 = h->mem_info[1].buf, p2 = h->mem_info[2].buf,
                 i = soc_mem_index_min(h->unit, h->mems[1]),
                 n = soc_mem_index_count(h->unit, h->mems[1]);
             n;
             --n, ++i,
                 p1 = (uint32 *)((uint8 *) p1 + h->mem_info[1].bytes_per_word),
                 p2 = (uint32 *)((uint8 *) p2 + h->mem_info[2].bytes_per_word)
             ) {
            if ((result = soc_mem_read(h->unit,
                                       h->mems[1],
                                       MEM_BLOCK_ANY,
                                       i,
                                       p1
                                       )
                 )
                != BCM_E_NONE
                || (result = soc_mem_read(h->unit,
                                          h->mems[2],
                                          MEM_BLOCK_ANY,
                                          0,
                                          p2
                                          )
                    )
                != BCM_E_NONE
                ) {
                goto done;
            }
        }
    }

    if (h->scache_nwords != 0) {
        for (i = 0; i < COUNTOF(h->chunk); ++i) {
            h->chunk[i].pos   = (uint32 *)((uint8 *) h->mem_info[i].buf
                                           + h->scache_idx_min
                                           * h->mem_info[i].bytes_per_word
                                           );
            h->chunk[i].limit = (uint32 *)((uint8 *) h->chunk[i].pos
                                           + h->scache_nwords
                                           * h->mem_info[i].bytes_per_word
                                           );
        }
    }

 done:
    if (result != BCM_E_NONE) {
        _field_tr2_ext_scache_release(h);
    }

    return (result);
}

STATIC int
_field_tr2_ext_scache_rd(struct _field_tr2_ext_scache_rw *h, uint8 *val)
{
    if (h->scache_nwords != 0) {
        struct _field_tr2_scache_chunk *ch = &h->chunk[h->cur_chunk_idx];

        if (ch->pos >= ch->limit) {
            if (++h->cur_chunk_idx >= COUNTOF(h->chunk)) {
                _field_tr2_ext_scache_release(h);
                return (BCM_E_FAIL);
            }
            ch = &h->chunk[h->cur_chunk_idx];
        }

        *val = ch->pos[ch->w >> 2] >> ((ch->w & 3) << 3);

        if (++ch->w >= ch->usable_bytes_per_word) {
            ch->pos = (uint32 *)((uint8 *) ch->pos
                                 + h->mem_info[h->cur_chunk_idx].bytes_per_word
                                 );
            ch->w = 0;
        }
    } else {
        _field_control_t *fc = h->fc;
        uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
        *val = buf[fc->scache_pos];
        ++fc->scache_pos;
    }

    return (BCM_E_NONE);
}

STATIC int
_field_tr2_ext_scache_rd_uint(struct _field_tr2_ext_scache_rw *h,
                              uint32                          *val,
                              unsigned                        nbytes
                              )
{
    uint8  b;
    uint32 result;

    BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd(h, &b));
    result = b;
    if (nbytes > 1) {
        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd(h, &b));
        result |= b << 8;
    }
    if (nbytes > 2) {
        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd(h, &b));
        result |= b << 16;
        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd(h, &b));
        result |= b << 24;
    }

    *val = result;

    return (BCM_E_NONE);
}

#define _FIELD_TR2_EXT_SCACHE_RD_UINT(h, x) \
    (_field_tr2_ext_scache_rd_uint((h), &(x), sizeof(x)))

STATIC uint32 *
_field_tr2_ext_scache_rd_rec_ptr(struct _field_tr2_ext_scache_rw *h,
                                 unsigned                        mem_idx,
                                 unsigned                        rec_idx
                                 )
{
    return ((uint32 *)((uint8 *) h->mem_info[mem_idx].buf
                       + rec_idx * h->mem_info[mem_idx].bytes_per_word
                       )
            );
}


STATIC int
_field_tr2_ext_scache_sync_chk(int              unit,
                               _field_control_t *fc,
                               _field_stage_t   *stage_fc
                               )
{
    unsigned slice_idx;

    for (slice_idx = 0; slice_idx < _FP_EXT_NUM_PARTITIONS; ++slice_idx) {
        if (_bcm_esw_field_tr2_ext_scache_size(unit, slice_idx) != 0) {
            return (TRUE);
        }
    }

    return (FALSE);
}


STATIC int
_field_tr2_ext_scache_sync(int              unit,
                           _field_control_t *fc,
                           _field_stage_t   *stage_fc
                           )
{
    unsigned slice_idx;

    for (slice_idx = 0; slice_idx < _FP_EXT_NUM_PARTITIONS; ++slice_idx) {
        _field_slice_t                 *fs;
        _field_group_t                 *fg;
        struct _field_tr2_ext_scache_rw h[1];

        fs = &stage_fc->slices[_FP_DEF_INST][slice_idx];

        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr_init(h, unit, slice_idx));

        /* Write start sequence */
        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr_uint(h,
                                                         _FIELD_EXTFP_DATA_START,
                                                         4
                                                         )
                            );

        /* Find group for partition (slice) */
        for (fg = fc->groups; fg; fg = fg->next) {
            if (fg->stage_id == _BCM_FIELD_STAGE_EXTERNAL
                && fg->slices->slice_number == slice_idx
                ) {
                break;
            }
        }
        if (fg == 0) {
            /* No group found */

            /* Write group-present flag as FALSE */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr(h, FALSE));
        } else {
            /* Group found */

            unsigned       n, q;
            _field_entry_t **p, *f_ent;
            int            prev_pri = 0;

            /* Write group-present flag as TRUE */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr(h, TRUE));

            /* Write group id */
            BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(h, fg->gid));

            /* Write group priority */
            BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(h, fg->priority));

            /* Write group qset */
            n = 0;
            _FIELD_QSET_INCL_INTERNAL_ITER(fg->qset, q) {
                ++n;
            }
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr(h, n));
            _FIELD_QSET_INCL_INTERNAL_ITER(fg->qset, q) {
                BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr(h, q));
            }

            /* Write entries */
            for (p = fs->entries, n = fs->entry_count; n; --n, ++p) {
                unsigned ent_prif, ent_statf, ent_polf;

                if ((f_ent = *p) == 0) {
                    continue;
                }

                /* Write entry id */
                BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(h,
                                                                 f_ent->eid
                                                                 )
                                    );

                ent_prif = (n == fs->entry_count || f_ent->prio != prev_pri);
                ent_statf = (f_ent->statistic.flags & _FP_ENTRY_STAT_INSTALLED)
                    ? 1 : 0;
                ent_polf = (f_ent->policer[0].flags & _FP_POLICER_INSTALLED)
                    ? 1 : 0;

                BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr(
                                        h,
                                        (ent_prif << 2)
                                            | (ent_statf << 1)
                                            | ent_polf
                                                             )
                                    );

                if (ent_prif) {
                    /* First entry, or priority differs from previous entry */

                    /* Write entry priority */
                    BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(
                                            h,
                                            f_ent->prio
                                                                      )
                                        );
                }

                if (ent_statf) {
                    /* Stat defined for entry */

                    /* Write stat id */
                    BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(
                                            h,
                                            f_ent->statistic.sid
                                                                      )
                                        );
                }

                if (ent_polf) {
                    /* Policer defined for entry */

                    /* Write policer id */
                    BCM_IF_ERROR_RETURN(_FIELD_TR2_EXT_SCACHE_WR_UINT(
                                            h,
                                            f_ent->policer[0].pid
                                                                      )
                                        );
                }

                prev_pri = f_ent->prio;
            }
        }

        BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_wr_uint(h,
                                                         _FIELD_EXTFP_DATA_END,
                                                         4
                                                         )
                            );

        _field_tr2_ext_scache_wr_commit(h);
    }

    return (BCM_E_NONE);
}


STATIC int
_field_tr2_ext_slice_to_pkt_type(_field_slice_t *fs, unsigned *pkt_type)
{
    switch (fs->slice_number) {
    case _FP_EXT_ACL_144_L2:
    case _FP_EXT_ACL_L2:
        *pkt_type = _FP_EXT_L2;
        break;
    case _FP_EXT_ACL_144_IPV4:
    case _FP_EXT_ACL_IPV4:
    case _FP_EXT_ACL_L2_IPV4:
        *pkt_type = _FP_EXT_IP4;
        break;
    case _FP_EXT_ACL_144_IPV6:
    case _FP_EXT_ACL_IPV6_SHORT:
    case _FP_EXT_ACL_IPV6_FULL:
    case _FP_EXT_ACL_L2_IPV6:
        *pkt_type = _FP_EXT_IP6;
        break;
    default:
        return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}


STATIC int
_field_tr2_stage_ext_group_construct(
    int               unit,
    _field_control_t  *fc,
    _field_stage_t    *stage_fc,
    _field_slice_t    *fs,
    unsigned          pkt_type,
    bcm_field_group_t gid,
    int               pri,
    bcm_field_qset_t  *qset,
    _field_group_t    **pfg
                                          )
{
    int                    result = BCM_E_NONE;
    uint8                  e_type = _FP_ENTRY_TYPE_DEFAULT; /* Entry type */
    _field_group_t         *fg = 0;
    unsigned               i, j;
    bcm_port_t             port;
    unsigned               qual_idx;
    _bcm_field_qual_info_t *f_qual_arr;
    int                    idx;

    _FP_XGS3_ALLOC(fg, sizeof(*fg), "field group");
    if (fg == NULL) {
        result = BCM_E_MEMORY;
        goto done;
    }

    /* Initialize action res id and VMAP group to default */
    fg->action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
        fg->vmap_group[idx] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
    }

    fg->gid      = gid;
    fg->priority = pri;
    fg->qset     = *qset;

    /* Recover group's qual_arr */

    for (fg->qual_arr[e_type][0].size = qual_idx = 0;
         qual_idx < _bcmFieldQualifyCount; ++qual_idx) {
        if (BCM_FIELD_QSET_TEST(fg->qset, qual_idx)) {
            ++fg->qual_arr[e_type][0].size;
        }
    }

    _FP_XGS3_ALLOC(fg->qual_arr[e_type][0].qid_arr,
                   (fg->qual_arr[e_type][0].size *
                    sizeof(fg->qual_arr[e_type][0].qid_arr[0])),
                   "Group qual id"
                   );
    _FP_XGS3_ALLOC(fg->qual_arr[e_type][0].offset_arr,
                   (fg->qual_arr[e_type][0].size *
                    sizeof(fg->qual_arr[e_type][0].offset_arr[0])),
                   "Group qual offset"
                   );

    for (i = qual_idx = 0; qual_idx < _bcmFieldQualifyCount; ++qual_idx) {
        if (!BCM_FIELD_QSET_TEST(fg->qset, qual_idx)) {
            continue;
        }

        fg->qual_arr[e_type][0].qid_arr[i] = qual_idx;

        f_qual_arr = stage_fc->f_qual_arr[qual_idx];

        for (j = 0; j < f_qual_arr->conf_sz; ++j) {
            /* assert(f_qual_arr->conf_arr[i].selector.pri_sel) == _bcmFieldSliceSelExternal */

            if (f_qual_arr->conf_arr[j].selector.pri_sel_val == fs->slice_number) {
                fg->qual_arr[e_type][0].offset_arr[i] =
                                              f_qual_arr->conf_arr[j].offset;
                break;
            }
        }

        ++i;
    }

    fg->stage_id          =  stage_fc->stage_id;
    for (i = 0; i < COUNTOF(fg->sel_codes); ++i) {
        _FIELD_SELCODE_CLEAR(fg->sel_codes[i]);
    }
    fg->sel_codes[0].intraslice = fg->sel_codes[0].secondary = _FP_SELCODE_DONT_USE;
    fg->sel_codes[0].extn =  fs->slice_number;
    fg->flags             = _FP_GROUP_SPAN_SINGLE_SLICE | _FP_GROUP_LOOKUP_ENABLED;
    fg->slices            =  fs;
    fs->group_flags       = _FP_GROUP_SPAN_SINGLE_SLICE;

    /* Recover ports for group */

    BCM_PBMP_CLEAR(fg->pbmp);
    PBMP_ALL_ITER(unit, port) {
        uint32 esm_port_mode;

        result = soc_reg32_read(unit, soc_reg_addr(unit, ESM_MODE_PER_PORTr, port, 0), &esm_port_mode);
        if (result != BCM_E_NONE) {
            goto done;
        }

        switch (pkt_type) {
        case _FP_EXT_L2:
            if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, L2_ACL_ENf) != 0) {
                BCM_PBMP_PORT_ADD(fg->pbmp, port);
            }
            break;
        case _FP_EXT_IP4:
            if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, IPV4_ACL_MODEf) != 0) {
                BCM_PBMP_PORT_ADD(fg->pbmp, port);
            }
            break;
        case _FP_EXT_IP6:
            if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, IPV6_ACL_MODEf) != 0) {
                BCM_PBMP_PORT_ADD(fg->pbmp, port);
            }
            break;
        default:
            ;
        }
    }

    fs->pbmp = fg->pbmp;

    _bcm_field_group_status_init(unit, &fg->group_status);

    /* Hook new group into stage */

    fg->next = fc->groups;
    fc->groups = fg;

 done:
    if (result == BCM_E_NONE) {
        *pfg = fg;
    } else if (fg) {
        sal_free(fg);
    }

    return (result);
}


STATIC int
_field_tr2_stage_external_reinit_old(int              unit,
                                     _field_control_t *fc,
                                     _field_stage_t   *stage_fc
                                     )
{
    int      rv = BCM_E_NONE, i, j;
    uint8    e_type = _FP_ENTRY_TYPE_DEFAULT; /* Entry type */
    unsigned slice_idx, cum_slice_entry_cnt[TCAM_PARTITION_ACL_L2IP6 + 1 - TCAM_PARTITION_ACL_L2];
    _field_group_t *fg    = 0;
    _field_entry_t *f_ent = 0;
    int      group_flags = 0;
    int action_res_id;
    bcm_pbmp_t group_pbmp;
    int idx;
    _field_entry_wb_info_t f_ent_wb_info;


    for (j = 0, i = stage_fc->tcam_slices - 1; i >= 0; --i) {
        cum_slice_entry_cnt[i] = j
            + stage_fc->slices[_FP_DEF_INST][i].entry_count;
        j = cum_slice_entry_cnt[i];
    }

    /* For each slice, ... */

    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; ++slice_idx) {
        _field_slice_t *fs = &stage_fc->slices[_FP_DEF_INST][slice_idx];
        int            port;
        unsigned       pkt_type=0, entry_idx, entry_cnt;
        soc_mem_t      tcam_data_mask_mem = _bcm_field_ext_data_mask_mems[slice_idx];
        soc_mem_t      tcam_data_mem      = _bcm_field_ext_data_mems[slice_idx];
        soc_mem_t      tcam_mask_mem      = _bcm_field_ext_mask_mems[slice_idx];
        soc_mem_t      policy_mem         = _bcm_field_ext_policy_mems[slice_idx];

        switch (slice_idx) {
        case _FP_EXT_ACL_144_L2:
        case _FP_EXT_ACL_L2:
            pkt_type = _FP_EXT_L2;
            break;
        case _FP_EXT_ACL_144_IPV4:
        case _FP_EXT_ACL_IPV4:
        case _FP_EXT_ACL_L2_IPV4:
            pkt_type = _FP_EXT_IP4;
            break;
        case _FP_EXT_ACL_144_IPV6:
        case _FP_EXT_ACL_IPV6_SHORT:
        case _FP_EXT_ACL_IPV6_FULL:
        case _FP_EXT_ACL_L2_IPV6:
            pkt_type = _FP_EXT_IP6;
            break;
        default:
            ;
        }

        /* Find all valid entries in slice's TCAM */

        for (entry_cnt = entry_idx = 0;
             entry_idx < fs->entry_count;
             ++entry_idx
             ) {
            ext_fp_policy_entry_t          policy_buf;
            ext_ifp_action_profile_entry_t ext_ifp_action_buf;
            int               multigroup=0;
            int               prev_prio = -1;
            unsigned          qual_idx;
            _bcm_field_qual_info_t *f_qual_arr;


            rv = soc_mem_read(unit, policy_mem, MEM_BLOCK_ANY, entry_idx, policy_buf.entry_data);
            if (rv != BCM_E_NONE) {
                goto cleanup;
            }
            if (soc_mem_field32_get(unit, policy_mem, policy_buf.entry_data, VALIDf) == 0) {
                /* TCAM entry not in use => Skip */

                continue;
            }

            /* TCAM entry in use */

            if (entry_cnt == 0) {
                /* First in-use entry found => Create group */

                int multigroup = FALSE; /* Will always be FALSE for external */
                bcm_field_group_t gid;
                int               priority;
                bcm_field_qset_t  qset;

                /* If Level 2, retrieve the GIDs in this slice */
                /* For external, will be exactly 1 group */
                if (fc->l2warm) {
                    rv = _field_trx_scache_slice_group_recover(unit,
                                                               fc, _FP_DEF_INST,
                                                               slice_idx,
                                                               &multigroup,
                                                               stage_fc,
                                                               0);
                    if (BCM_FAILURE(rv)) {
                        goto cleanup;
                    }
                }

                _FP_XGS3_ALLOC(fg, sizeof(*fg), "field group");
                if (fg == NULL) {
                    return BCM_E_MEMORY;
                }

                /* Initialize action res id and VMAP group to default */
                action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
                for (idx = 0; idx < _FP_PAIR_MAX; idx++) {
                    fg->vmap_group[idx] = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;
                }

                group_flags = 0;
                if (fc->l2warm) {
                    /* Get stored group ID and QSET for Level 2 */
                    rv = _field_group_info_retrieve(unit, 0 /* port */,
                                                    _FP_DEF_INST, &gid,
                                                    &priority,
                                                    &action_res_id,
                                                    &group_pbmp,
                                                    NULL,
                                                    &group_flags,
                                                    &qset,
                                                    fc);
                    if (gid != -1) {
                        sal_memcpy(&fg->qset, &qset, sizeof(fg->qset));
                    } else {
                        rv = BCM_E_INTERNAL;
                    }
                } else {
                    /* Generate group ID (a ++ operation) for Level 1 */

                    if ((rv = _bcm_field_group_id_generate(unit, &gid))
                         == BCM_E_NONE) {
                        unsigned vmap, vslice;

                        for (priority = -1, vmap = 0; priority == -1 && vmap < _FP_VMAP_CNT; ++vmap) {
                            for (vslice = 0; vslice < COUNTOF(stage_fc->vmap[_FP_DEF_INST][0]); ++vslice) {
                                if (stage_fc->vmap[_FP_DEF_INST][vmap][vslice].vmap_key == slice_idx) {
                                    priority = stage_fc->vmap[_FP_DEF_INST][vmap][vslice].priority;

                                    break;
                                }
                            }
                        }

                        if (priority == -1) {
                            rv = BCM_E_INTERNAL;
                        }
                    }

                    /* Recover group's qset */

                    BCM_FIELD_QSET_INIT(fg->qset);
                    BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyStage);
                    BCM_FIELD_QSET_ADD(fg->qset, bcmFieldQualifyStageExternal);

                    for (qual_idx = 0; qual_idx < _bcmFieldQualifyCount; ++qual_idx) {
                        f_qual_arr = stage_fc->f_qual_arr[qual_idx];

                        if (f_qual_arr == NULL) {
                            continue; /* Qualifier does not exist in this stage */
                        }

                        for (i = 0; i < f_qual_arr->conf_sz; ++i) {
                            /* assert(f_qual_arr->conf_arr[i].selector.pri_sel) == _bcmFieldSliceSelExternal */

                            if (f_qual_arr->conf_arr[i].selector.pri_sel_val == slice_idx) {
                                BCM_FIELD_QSET_ADD(fg->qset, qual_idx);

                                break;
                            }
                        }
                    }
                }

                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
                /* Recover group's qual_arr */

                for (fg->qual_arr[e_type][0].size = qual_idx = 0;
                     qual_idx < _bcmFieldQualifyCount; ++qual_idx) {
                    if (BCM_FIELD_QSET_TEST(fg->qset, qual_idx)) {
                        ++fg->qual_arr[e_type][0].size;
                    }
                }

                _FP_XGS3_ALLOC(fg->qual_arr[e_type][0].qid_arr,
                               (fg->qual_arr[e_type][0].size *
                                sizeof(fg->qual_arr[e_type][0].qid_arr[0])),
                               "Group qual id"
                               );
                _FP_XGS3_ALLOC(fg->qual_arr[e_type][0].offset_arr,
                               (fg->qual_arr[e_type][0].size *
                                sizeof(fg->qual_arr[e_type][0].offset_arr[0])),
                               "Group qual offset"
                               );

                for (j = qual_idx = 0; qual_idx < _bcmFieldQualifyCount; ++qual_idx) {
                    if (!BCM_FIELD_QSET_TEST(fg->qset, qual_idx)) {
                        continue;
                    }

                    fg->qual_arr[e_type][0].qid_arr[j] = qual_idx;

                    f_qual_arr = stage_fc->f_qual_arr[qual_idx];

                    for (i = 0; i < f_qual_arr->conf_sz; ++i) {
                        /* assert(f_qual_arr->conf_arr[i].selector.pri_sel) == _bcmFieldSliceSelExternal */

                        if (f_qual_arr->conf_arr[i].selector.pri_sel_val == slice_idx) {
                            fg->qual_arr[e_type][0].offset_arr[j] =
                                                 f_qual_arr->conf_arr[i].offset;

                            break;
                        }
                    }

                    ++j;
                }

                fg->gid               =  gid;
                fg->priority          =  priority;
                fg->action_res_id     =  action_res_id;
                fg->stage_id          =  stage_fc->stage_id;
                fg->sel_codes[0].extn =  slice_idx;
                fg->slices            =  fs;
                fg->flags             |= _FP_GROUP_SPAN_SINGLE_SLICE;
                if (fc->l2warm
                        && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15)) {
                    if (group_flags & _FP_GROUP_LOOKUP_ENABLED) {
                        fg->flags = fg->flags | _FP_GROUP_LOOKUP_ENABLED;
                    }
                    if (group_flags & _FP_GROUP_WLAN) {
                        fg->flags = fg->flags | _FP_GROUP_WLAN;
                    }
                } else {
                    fg->flags |= _FP_GROUP_LOOKUP_ENABLED;
                }

                /* Recover ports for group */

                BCM_PBMP_CLEAR(fg->pbmp);
                PBMP_ALL_ITER(unit, port) {
                    uint32 esm_port_mode;

                    rv = soc_reg32_read(unit, soc_reg_addr(unit, ESM_MODE_PER_PORTr, port, 0), &esm_port_mode);
                    if (rv != BCM_E_NONE) {
                        goto cleanup;
                    }

                    switch (pkt_type) {
                    case _FP_EXT_L2:
                        if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, L2_ACL_ENf) != 0) {
                            BCM_PBMP_PORT_ADD(fg->pbmp, port);
                        }
                        break;
                    case _FP_EXT_IP4:
                        if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, IPV4_ACL_MODEf) != 0) {
                            BCM_PBMP_PORT_ADD(fg->pbmp, port);
                        }
                        break;
                    case _FP_EXT_IP6:
                        if (soc_reg_field_get(unit, ESM_MODE_PER_PORTr, esm_port_mode, IPV6_ACL_MODEf) != 0) {
                            BCM_PBMP_PORT_ADD(fg->pbmp, port);
                        }
                        break;
                    default:
                        ;
                    }
                }

                fs->pbmp = fg->pbmp;

                /* Hook new group into stage */

                fg->next = fc->groups;
                fc->groups = fg;
            }

            /* Add entry to group */

            _FP_XGS3_ALLOC(f_ent, sizeof(*f_ent), "field entry");
            if (f_ent == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }

            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                rv = _field_trx_entry_info_retrieve(unit,
                                                    fc,
                                                    stage_fc,
                                                    multigroup,
                                                    &prev_prio,
                                                    &f_ent_wb_info
                                                    );
                
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
            } else {
                _bcm_field_last_alloc_eid_incr(unit);
            }

            if (fc->l2warm) {
                /* Use retrieved EID */
                f_ent->eid = f_ent_wb_info.eid;
                /* Set retrieved dvp_type and svp_type */
                f_ent->dvp_type = f_ent_wb_info.dvp_type[0];
                f_ent->svp_type = f_ent_wb_info.svp_type[0];
            } else {
                f_ent->eid = _bcm_field_last_alloc_eid_get(unit);
            }
            f_ent->group = fg;

            /* ???
            BCM_PBMP_ASSIGN(f_ent[i].pbmp.data, entry_pbmp);
            BCM_PBMP_ASSIGN(f_ent[i].pbmp.mask, PBMP_ALL(unit));
            */

            f_ent->flags     = _FP_ENTRY_PRIMARY;
            f_ent->slice_idx = entry_idx;
            f_ent->fs        = fs;

            if (f_ent_wb_info.color_independent) {
                f_ent->flags |= _FP_ENTRY_COLOR_INDEPENDENT;
            }

            f_ent->tcam.key_size = ((soc_mem_field_length(unit, tcam_data_mask_mem ? tcam_data_mask_mem : tcam_data_mem, DATAf) + 31) & ~31) >> (5 - 2);

            f_ent->tcam.key_hw  = sal_alloc(f_ent->tcam.key_size, "TCAM data buf");
            f_ent->tcam.mask_hw = sal_alloc(f_ent->tcam.key_size, "TCAM mask buf");

            if (tcam_data_mask_mem != 0) {
                ext_acl288_tcam_entry_t tcam_buf;

                rv = soc_mem_read(unit, tcam_data_mask_mem, MEM_BLOCK_ANY, entry_idx, tcam_buf.entry_data);
                if (rv != BCM_E_NONE) {
                    goto cleanup;
                }
                soc_mem_field_get(unit, tcam_data_mask_mem, tcam_buf.entry_data, DATAf, f_ent->tcam.key_hw);
                soc_mem_mask_field_get(unit, tcam_data_mask_mem, tcam_buf.entry_data, MASKf, f_ent->tcam.mask_hw);
            } else {
                ext_acl432_tcam_data_entry_t tcam_buf;

                rv = soc_mem_read(unit, tcam_data_mem, MEM_BLOCK_ANY, entry_idx, tcam_buf.entry_data);
                if (rv != BCM_E_NONE) {
                    goto cleanup;
                }
                soc_mem_field_get(unit, tcam_data_mem, tcam_buf.entry_data, DATAf, f_ent->tcam.key_hw);

                /* Depth of EXT_ACL432_TCAM_MASKm table is one, i.e. has only one valid index */
                rv = soc_mem_read(unit, tcam_mask_mem, MEM_BLOCK_ANY, 0, tcam_buf.entry_data);
                if (rv != BCM_E_NONE) {
                    goto cleanup;
                }
                soc_mem_mask_field_get(unit, tcam_mask_mem, tcam_buf.entry_data, MASKf, f_ent->tcam.mask_hw);
            }

            /* Assign entry to a slice */
            fs->entries[entry_idx] = f_ent;
            f_ent->flags |= _FP_ENTRY_INSTALLED;

            /* Recover actions */

            rv = _field_tr2_actions_recover(unit,
                                       policy_mem,
                                       policy_buf.entry_data,
                                       f_ent,
                                       0,
                                       &f_ent_wb_info);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }

            /* Recover actions in EXT_IFP_ACTION_PROFILEm */

            rv = soc_mem_read(unit,
                         EXT_IFP_ACTION_PROFILEm,
                         MEM_BLOCK_ANY,
                         soc_mem_field32_get(unit, policy_mem, policy_buf.entry_data, PROFILE_PTRf),
                         ext_ifp_action_buf.entry_data
                         );
            if (rv != BCM_E_NONE) {
                goto cleanup;
            }
            rv = _field_tr2_actions_recover(unit,
                                       EXT_IFP_ACTION_PROFILEm,
                                       ext_ifp_action_buf.entry_data,
                                       f_ent,
                                       0,
                                       &f_ent_wb_info);

            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
            /* Add to the group */
            if (fc->l2warm) {
                f_ent->prio = f_ent_wb_info.prio;
            } else {
                f_ent->prio = cum_slice_entry_cnt[slice_idx] - entry_idx;
            }
            rv = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }

            f_ent = 0;

            ++entry_cnt;
        }

        /* Free up the temporary slice group info */
        if (fc->l2warm) {
            _field_scache_slice_group_free(unit,
                                           fc,
                                           slice_idx
                                           );
        }

        fg = 0;
    }

 cleanup:
    if (f_ent) {
        sal_free(f_ent);
    }
    if (fg) {
        sal_free(fg);
    }

    return (rv);
}


int
_field_tr2_stage_external_reinit(int              unit,
                                 _field_control_t *fc,
                                 _field_stage_t   *stage_fc
                                 )
{
    int      result = BCM_E_NONE;
    int      i, j, idx1;
    unsigned slice_idx;
    unsigned cum_slice_entry_cnt[
                 TCAM_PARTITION_ACL_L2IP6 + 1 - TCAM_PARTITION_ACL_L2
                                 ];
    _field_group_t *fg    = 0;
    _field_entry_t *f_ent = 0;
    _field_entry_wb_info_t f_ent_wb_info;

    if (!_field_tr2_ext_scache_sync_chk(unit, fc, stage_fc)) {
        return (_field_tr2_stage_external_reinit_old(unit, fc, stage_fc));
    }

    /* Compute cumulative entry counts (number of entries in each and all
       preceding slices) */

    for (j = 0, i = stage_fc->tcam_slices - 1; i >= 0; --i) {
        cum_slice_entry_cnt[i] = j
            + stage_fc->slices[_FP_DEF_INST][i].entry_count;
        j = cum_slice_entry_cnt[i];
    }

    /* For each slice, ... */

    for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; ++slice_idx) {
        _field_slice_t *fs = &stage_fc->slices[_FP_DEF_INST][slice_idx];
        unsigned       entry_idx, entry_cnt;
        struct _field_tr2_ext_scache_rw h[1];
        bcm_field_group_t gid;
        bcm_field_qset_t  qset;
        int               pri;
        unsigned          n, pkt_type = 0;
        uint32 x;

        _field_tr2_ext_slice_to_pkt_type(fs, &pkt_type);

        _field_tr2_ext_scache_rd_init(h, unit, slice_idx);

        if (fc->l2warm) {
            /* Check for start sequence */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(h, &x, 4));
            if (x != _FIELD_EXTFP_DATA_START) {
                /* Start sequence not found */

                result = BCM_E_INTERNAL;
                goto error;
            }

            /* Read group-present flag */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(h, &x, 1));
            if (!x) {
                /* Group not present */

                /* Skip to next slice */
                goto slice_done;
            }

            /* Group is present */

            /* Read group's id, priority and qset */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(
                                    h,
                                    &x,
                                    sizeof(fg->gid)
                                                              )
                                );
            gid = (bcm_field_group_t) x;
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(
                                    h,
                                    &x,
                                    sizeof(fg->priority)
                                                              )
                                );
            pri = (bcm_field_group_t) x;

            bcm_field_qset_t_init(&qset);
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(h, &x, 1));
            for (n = x; n; --n) {
                BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(h, &x, 1));
                BCM_FIELD_QSET_ADD(qset, x);
            }

            /* Create group */
            _field_tr2_stage_ext_group_construct(unit,
                                                 fc,
                                                 stage_fc,
                                                 fs,
                                                 pkt_type,
                                                 gid,
                                                 pri,
                                                 &qset,
                                                 &fg
                                                 );
        }

        /* Find all valid entries in slice's TCAM */

        for (entry_cnt = entry_idx = 0;
             entry_idx < fs->entry_count;
             ++entry_idx
             ) {
            uint32                         *policy;
            ext_ifp_action_profile_entry_t ext_ifp_action_buf;
            int               prev_pri = 0;
            unsigned          profile_ptr;

            policy = _field_tr2_ext_scache_rd_rec_ptr(h, 0, entry_idx);
            if (soc_mem_field32_get(unit, h->mems[0], policy, VALIDf) == 0) {
                /* TCAM entry not in use => Skip */

                continue;
            }

            /* TCAM entry in use */

            if (entry_cnt == 0 && !fc->l2warm) {
                /* First in-use entry found, and level-1 warm start
                   => Create group
                */

                unsigned               qual_idx;
                _bcm_field_qual_info_t *f_qual_arr;
                _field_stage_t         *stage_fc_ifp;
                unsigned               vslice;

                /* Generate group ID (a ++ operation) for Level 1 */

                result = _bcm_field_group_id_generate(unit, &gid);
                if (result != BCM_E_NONE) {
                    goto error;
                }

                /* Recover group's qset */

                BCM_FIELD_QSET_INIT(qset);
                BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStage);
                BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageExternal);

                for (qual_idx = 0;
                     qual_idx < _bcmFieldQualifyCount;
                     ++qual_idx
                     ) {
                    f_qual_arr = stage_fc->f_qual_arr[qual_idx];

                    if (f_qual_arr == NULL) {
                        continue; /* Qualifier does not exist in this stage */
                    }

                    for (i = 0; i < f_qual_arr->conf_sz; ++i) {
                        /* assert(f_qual_arr->conf_arr[i].selector.pri_sel)
                           == _bcmFieldSliceSelExternal */

                        if (f_qual_arr->conf_arr[i].selector.pri_sel_val
                            == slice_idx
                            ) {
                            BCM_FIELD_QSET_ADD(qset, qual_idx);

                            break;
                        }
                    }
                }

                result = _field_stage_control_get(unit,
                                                  _BCM_FIELD_STAGE_INGRESS,
                                                  &stage_fc_ifp
                                                  );
                if (result != BCM_E_NONE) {
                    goto error;
                }

                for (pri = -1, vslice = 0;
                     vslice < COUNTOF(stage_fc_ifp->vmap[_FP_DEF_INST][0]);
                     ++vslice
                     ) {
                    if (stage_fc_ifp->vmap[_FP_DEF_INST][pkt_type][vslice].vmap_key
                        == slice_idx
                        ) {
                        pri = stage_fc->vmap[_FP_DEF_INST][pkt_type][vslice].priority;

                        break;
                    }
                }

                if (pri == -1) {
                    result = BCM_E_INTERNAL;
                    goto error;
                }

                _field_tr2_stage_ext_group_construct(unit,
                                                     fc,
                                                     stage_fc,
                                                     fs,
                                                     pkt_type,
                                                     gid,
                                                     pri,
                                                     &qset,
                                                     &fg
                                                     );
            }

            _FP_XGS3_ALLOC(f_ent, sizeof(*f_ent), "field entry");
            if (f_ent == NULL) {
                result = BCM_E_MEMORY;
                goto error;
            }
            for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                 f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
            }


            sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
            f_ent_wb_info.sid = f_ent_wb_info.pid = f_ent_wb_info.pid1 = -1;
            if (fc->l2warm) {
                /* Level-2 warm start */

                uint8 f;

                /* Read entry id */
                _field_tr2_ext_scache_rd_uint(h, &x, sizeof(f_ent->eid));
                f_ent->eid = (bcm_field_entry_t) x;

                /* Read priority/stat/policer flags */
                result = _field_tr2_ext_scache_rd(h, &f);
                if (result != BCM_E_NONE) {
                    goto error;
                }

                if (f & (1 << 2)) {
                    /* Read entry priority */
                    _field_tr2_ext_scache_rd_uint(h, &x, sizeof(f_ent->prio));
                    prev_pri = f_ent->prio = (int) x;
                } else {
                    /* Assign entry same priority as previous entry */
                    f_ent->prio = prev_pri;
                }
                if (f & (1 << 1)) {
                    /* Read stat id */
                    _field_tr2_ext_scache_rd_uint(h,
                                                  &x,
                                                  sizeof(f_ent->statistic.sid)
                                                  );
                    f_ent_wb_info.sid = (int) x;
                }
                if (f & (1 << 0)) {
                    /* Read policer id */
                    _field_tr2_ext_scache_rd_uint(h,
                                                  &x,
                                                  sizeof(f_ent->policer[0].pid)
                                                  );
                    f_ent_wb_info.pid = (bcm_policer_t) x;
                }
                f_ent_wb_info.eid = f_ent->eid;
                f_ent_wb_info.prio = f_ent->prio;
            } else {
                /* Level-1 warm start */

                /* Assign arbitary (last + 1) entry id */
                _bcm_field_last_alloc_eid_incr(unit);
                f_ent->eid = _bcm_field_last_alloc_eid_get(unit);

                /* Assign entry priority based on position in TCAM */
                f_ent->prio = cum_slice_entry_cnt[slice_idx] - entry_idx;
            }

            /* ???
            BCM_PBMP_ASSIGN(f_ent[i].pbmp.data, entry_pbmp);
            BCM_PBMP_ASSIGN(f_ent[i].pbmp.mask, PBMP_ALL(unit));
            */

            f_ent->flags     = _FP_ENTRY_PRIMARY;
            f_ent->slice_idx = entry_idx;
            f_ent->fs        = fs;

            f_ent->tcam.key_size = ((soc_mem_field_length(unit,
                                                          h->mems[1],
                                                          DATAf
                                                          )
                                     + 31
                                     )
                                    & ~31
                                    )
                >> (5 - 2);

            f_ent->tcam.key_hw  = sal_alloc(f_ent->tcam.key_size, "TCAM data buf");
            f_ent->tcam.mask_hw = sal_alloc(f_ent->tcam.key_size, "TCAM mask buf");

            if (h->mems[2] == INVALIDm) {
                uint32 *p;

                p = _field_tr2_ext_scache_rd_rec_ptr(h, 1, entry_idx);
                soc_mem_field_get(unit,
                                  h->mems[1],
                                  p,
                                  DATAf,
                                  f_ent->tcam.key_hw
                                  );
                soc_mem_mask_field_get(unit,
                                       h->mems[1],
                                       p,
                                       MASKf,
                                       f_ent->tcam.mask_hw
                                       );
            } else {
                soc_mem_field_get(unit,
                                  h->mems[1],
                                  _field_tr2_ext_scache_rd_rec_ptr(
                                      h,
                                      1,
                                      entry_idx
                                                                   ),
                                  DATAf,
                                  f_ent->tcam.key_hw
                                  );

                soc_mem_mask_field_get(unit,
                                       h->mems[2],
                                       _field_tr2_ext_scache_rd_rec_ptr(
                                           h,
                                           2,
                                           entry_idx
                                                                        ),
                                       MASKf,
                                       f_ent->tcam.mask_hw
                                       );
            }

            /* Assign entry to a slice */
            fs->entries[entry_idx] = f_ent;
            f_ent->flags |= _FP_ENTRY_INSTALLED;
            --fs->free_count;

            /* Assign entry to group */
            f_ent->group = fg;

            /* Recover actions */

            result =_field_tr2_actions_recover(unit,
                                       h->mems[0],
                                       policy,
                                       f_ent,
                                       0,
                                       &f_ent_wb_info);
            if (BCM_FAILURE(result)) {
                goto error;
            }

            /* Recover actions in EXT_IFP_ACTION_PROFILEm */

            profile_ptr = soc_mem_field32_get(unit,
                                              h->mems[0],
                                              policy,
                                              PROFILE_PTRf
                                              );

            soc_profile_mem_reference(unit,
                                      &stage_fc->ext_act_profile,
                                      profile_ptr,
                                      1
                                      );

            result = soc_mem_read(unit,
                                  EXT_IFP_ACTION_PROFILEm,
                                  MEM_BLOCK_ANY,
                                  profile_ptr,
                                  ext_ifp_action_buf.entry_data
                                  );
            if (result != BCM_E_NONE) {
                goto error;
            }
            result = _field_tr2_actions_recover(unit,
                                       EXT_IFP_ACTION_PROFILEm,
                                       ext_ifp_action_buf.entry_data,
                                       f_ent,
                                       0,
                                       &f_ent_wb_info);
            if (BCM_FAILURE(result)) {
                goto error;
            }

            /* Add entry to the group */
            result = _field_group_entry_add(unit, fg, f_ent);
            if (BCM_FAILURE(result)) {
                sal_free(f_ent);
                f_ent = 0;
                goto error;
            }

            f_ent = 0;

            ++entry_cnt;
        }

    slice_done:
        result = _bcm_field_prio_mgmt_slice_reinit(unit, stage_fc, fs);
        if (BCM_FAILURE(result)) {
            goto error;
        }

        if (fc->l2warm) {
            uint32 x;

            /* Check for end sequence */
            BCM_IF_ERROR_RETURN(_field_tr2_ext_scache_rd_uint(h, &x, 4));
            if (x != _FIELD_EXTFP_DATA_END) {
                /* End sequence not found */

                /* Indicate error */
                result = BCM_E_INTERNAL;
            }
        }

    error:
        _field_tr2_ext_scache_release(h);

        if (result != BCM_E_NONE) {
            break;
        }

        fg = 0;
    }

    if (BCM_SUCCESS(result)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

    if (f_ent) {
        sal_free(f_ent);
    }
    if (fg) {
        sal_free(fg);
    }

    return (result);
}

#endif /* BCM_WARM_BOOT_SUPPORT */

/* Function: _bcm_trx_field_egr_ports_recovery_print
 *
 * Purpose:
 *     Print _entry_egr_ports_recovery database.
 * Parameters:

 * Returns:
       BCM_E_NONE - Success
 */
int _bcm_trx_field_egr_ports_recovery_print (int unit)
{
    int port = 0;
    _field_entry_recover_egr_ports_t  *egrPortDbEntry = NULL;
    _field_egr_ports_entry_ids_list_t *tmp = NULL;
    _field_entry_recover_egr_ports_t  *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;
    int entry_count = 0;

    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    _bcm_trx_field_egr_ports_recovery_entry_ids_list_get (unit,
                                                  &tmp,&entry_count);
    LOG_CLI((BSL_META_U(unit,
                    "FP (%d) RECOVER_EGR_PORTS_DB: Entry Count = %d"),
                                                       unit, entry_count));

    while (tmp != NULL)
    {
    LOG_CLI((BSL_META_U(unit,
        "FP (%d) RECOVER_EGR_PORTS_DB: Entry = %d"), unit, tmp->eid));
        tmp=tmp->next;
    }
    _bcm_trx_field_egr_ports_recovery_entry_list_destroy (unit, &tmp);

    for (port = 1; port < SOC_MAX_NUM_PORTS; port++)
    {
        head = f_egr_recovery->entry_recover_egr_ports[port];
        if (NULL != head) {
            egrPortDbEntry = head;
            while (egrPortDbEntry != NULL) {
                LOG_CLI((BSL_META_U(unit,
                                "FP (%d) RECOVER_EGR_PORTS_DB: Port = %d Entry = %d"),
                            unit, port, egrPortDbEntry->eid));
                egrPortDbEntry = egrPortDbEntry->next;
            }
        }
    }

    return BCM_E_NONE;
}


/* Function: _bcm_trx_field_egr_ports_recovery_entry_pbmp_get
 * Purpose :
 *      For an entry, return the Pbmp present in redirect_pbm_recovery database
 * Parameters :
 *           unit  : (IN)  - BCM device number
 *           entry : (IN)  - Entry ID
 *    egrPortsPbmp : (OUT) - EgressPortsAdd for bcmFieldActionEgressPortsAdd
 */
int _bcm_trx_field_egr_ports_recovery_entry_pbmp_get (int unit,
                                  bcm_field_entry_t entry,
                                  bcm_pbmp_t *egrPortsPbmp)
{
    bcm_pbmp_t or_pbmp;
    int port = 0;
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;

    sal_memset (&or_pbmp, 0 , sizeof (bcm_pbmp_t));

    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    for (port = 1; port < SOC_MAX_NUM_PORTS; port++)
    {
        head =
            f_egr_recovery->entry_recover_egr_ports[port];
        if (NULL != head) {
            egrPortDbEntry = head;
            while (egrPortDbEntry != NULL) {
                if (egrPortDbEntry->eid == entry) {
                    /* coverity[overrun-local] */
                    BCM_PBMP_PORT_ADD (or_pbmp,port);
                }
                egrPortDbEntry = egrPortDbEntry->next;
            }
        }
    }

    if (BCM_PBMP_IS_NULL (or_pbmp)) {
        return BCM_E_NOT_FOUND;
    }
    sal_memcpy (egrPortsPbmp, &or_pbmp, sizeof(bcm_pbmp_t));
    return BCM_E_NONE;
}

/* Function: _bcm_trx_field_egr_ports_recovery_entry_list_destroy
 *
 * Purpose:
 *    Destroy the list of entries which was obtained using
 *    _bcm_trx_field_egr_ports_recovery_entry_ids_list_get API
 * Parameters:
 *    entries  -  pointer to link list which will be populated

 * Returns:
       BCM_E_NONE - Success
       BCM_E_MEMORY- pbmp is NULL
 */
int _bcm_trx_field_egr_ports_recovery_entry_list_destroy (int unit,
                           _field_egr_ports_entry_ids_list_t **entries)
{
    _field_egr_ports_entry_ids_list_t *tmp = NULL;

    while ((*entries) != NULL) {
        tmp = *entries;
        *entries = (*entries)->next;
        sal_free(tmp);
        tmp = NULL;
    }
    return BCM_E_NONE;
}


/* Function: _bcm_trx_field_egr_ports_recovery_entry_ids_list_get
 *
 * Purpose:
 *    Return list of entries where EgressPortsAdd action has been configured.
 * Parameters:
 *    entries  -  pointer to link list which will be populated

 * Returns:
       BCM_E_NONE - Success
       BCM_E_MEMORY- pbmp is NULL

 * Note: This entry allocates memory to return list of entries.
         field_egr_ports_recovery_entry_list_destroy
         should be invoked subsequently to free the allocated memory.
 */
int _bcm_trx_field_egr_ports_recovery_entry_ids_list_get (int unit,
        _field_egr_ports_entry_ids_list_t **entryIdList, int *entryIdCnt)
{
    _field_egr_ports_entry_ids_list_t *eId  = NULL;
    _field_egr_ports_entry_ids_list_t *tmp  = NULL;
    _field_egr_ports_entry_ids_list_t *prev = NULL;
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;
    int port = 0;
    int eIdCount = 0;

    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    /* Loop through the redirect_pbm_recovery database and generate a
     * linked-list of FP entry Ids that are present in
     * database*/

    for (port = 1; port < SOC_MAX_NUM_PORTS; port++)
    {
        head =
            f_egr_recovery->entry_recover_egr_ports[port];
        if (NULL != head) {
            egrPortDbEntry = head;
            while (egrPortDbEntry != NULL) {
                eId = NULL;
                tmp = *entryIdList;
                prev = NULL;

                /* if list is empty or if new node is to be inserted
                 * before the first node */
                while(tmp != NULL && (egrPortDbEntry->eid > tmp->eid)){
                    prev = tmp;
                    tmp = tmp->next;
                }
                if ((tmp != NULL) && (tmp->eid == egrPortDbEntry->eid)) {
                    /* Entry already added to list.
                     * Update the Pbmp for the port
                     */
                    /* coverity[overrun-local] */
                    BCM_PBMP_PORT_ADD (tmp->egr_ports_pbmp, port);
                } else {
                    _FP_XGS3_ALLOC (eId,
                            sizeof (_field_egr_ports_entry_ids_list_t),
                            "egr_port_recovery_eid_list");
                    if (eId == NULL) {
                        return BCM_E_MEMORY;
                    }
                    eId->eid = egrPortDbEntry->eid;
                    BCM_PBMP_PORT_ADD (eId->egr_ports_pbmp, port);
                    eIdCount++;

                    if (prev == NULL) {
                        eId->next = (*entryIdList);
                        *entryIdList = eId;
                    } else {
                        prev->next = eId;
                        eId->next = tmp;
                    }
                }
                egrPortDbEntry = egrPortDbEntry->next;
            }
        }
    }
    *entryIdCnt = eIdCount;
    return BCM_E_NONE;
}

/* Function: _bcm_trx_field_egr_ports_recovery_search
 *
 * Purpose:
 *     Search for port-entry combination in
        _field_egr_ports_recovery database.
 * Parameters:
 *     unit  - BCM device number
 *     entry - Entry ID
 *     pbmp  - EgressPortsAdd from bcmFieldActionEgressPortsAdd.

 * Returns:
       BCM_E_NONE - Success
       BCM_E_PARAM - pbmp is NULL
 */
int _bcm_trx_field_egr_ports_recovery_search (int unit,
                   int port, bcm_field_entry_t entry)
{
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;

    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    head = f_egr_recovery->entry_recover_egr_ports[port];
    egrPortDbEntry = head;

    while (egrPortDbEntry != NULL) {
        if (egrPortDbEntry->eid == entry) {
            return BCM_E_EXISTS;
        }
        egrPortDbEntry = egrPortDbEntry->next;
    }
    return BCM_E_NONE;
}

/* Function: _bcm_trx_field_egr_ports_recovery_add
 *
 * Purpose:
 *     Save pbmp from bcmFieldActionEgressPortsAdd action
 *     into _entry_egr_ports_recovery database.
 * Parameters:
 *     unit  - BCM device number
 *     entry - Entry ID
 *     pbmp  - EgressPortsAdd from bcmFieldActionEgressPortsAdd.

 * Returns:
       BCM_E_NONE - Success
       BCM_E_PARAM - pbmp is NULL
 */
int _bcm_trx_field_egr_ports_recovery_add (int unit,
                                  bcm_field_entry_t entry,
                                  bcm_pbmp_t pbmp)
{
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *or_pbm_new = NULL;
    _field_entry_recover_egr_ports_t *head;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;
    int mem_sz;                   /* Memory size. */
    int port;
    int rv;

    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    BCM_PBMP_ITER(pbmp, port) {
        rv = _bcm_trx_field_egr_ports_recovery_search (unit, port, entry);
        if (rv == BCM_E_EXISTS) {
            continue;
        }

        /* If entry doesn't exist, allocate a new entry and update
         * recovery database based on whether head is already available
         * or not.
         */

        mem_sz = sizeof (_field_entry_recover_egr_ports_t);
        _FP_XGS3_ALLOC (or_pbm_new, mem_sz,
                "Field redirect_pbm_recovery Entry");
        if (NULL == or_pbm_new) {
            return (BCM_E_MEMORY);
        }
        or_pbm_new->eid = entry;

        head =
            f_egr_recovery->entry_recover_egr_ports[port];

        if (NULL != head) {
            egrPortDbEntry = head;
            or_pbm_new->next = egrPortDbEntry;
            f_egr_recovery->entry_recover_egr_ports[port] = or_pbm_new;
            or_pbm_new  = NULL;
        } else {
            or_pbm_new->next = NULL;
            f_egr_recovery->entry_recover_egr_ports[port] = or_pbm_new;
            or_pbm_new  = NULL;
        }
    }
    return (BCM_E_NONE);
}

/* Function: _bcm_trx_field_egr_ports_recovery_entry_remove
 *
 * Purpose:
 *     Remove EntryId from _entry_egr_ports_recovery database.
 * Parameters:
 *     unit  - BCM device number
 *     entry - Entry ID

 * Returns:
       BCM_E_NONE - Success
       BCM_E_PARAM - pbmp is NULL
 */
int _bcm_trx_field_egr_ports_recovery_entry_remove (int unit,
                                  bcm_field_entry_t entry)
{
    _field_entry_recover_egr_ports_t *egrPortDbEntry = NULL;
    _field_entry_recover_egr_ports_t *prev_entry= NULL;
    _field_egr_ports_recovery_t *f_egr_recovery = NULL;
    int port;

    LOG_DEBUG(BSL_LS_BCM_FP,(BSL_META_U(unit,
                    "FP (unit %d) Clear Entry %d from redirect_pbm_recovery database))"), unit, entry));
    _field_egr_ports_recovery_control_get (unit, &f_egr_recovery);

    for (port=1; port < SOC_MAX_NUM_PORTS; port++) {
        prev_entry = NULL;
        for (prev_entry = egrPortDbEntry =
                f_egr_recovery->entry_recover_egr_ports[port];
               egrPortDbEntry != NULL; egrPortDbEntry = egrPortDbEntry->next) {
            if (egrPortDbEntry->eid == entry) {
                prev_entry->next = egrPortDbEntry->next;
                if (egrPortDbEntry ==
                       f_egr_recovery->entry_recover_egr_ports[port]) {
                   f_egr_recovery->entry_recover_egr_ports[port] = egrPortDbEntry->next;
                }
                sal_free(egrPortDbEntry);
                egrPortDbEntry = NULL;
                break;
            }
            prev_entry = egrPortDbEntry;
        }
    }
    return BCM_E_NONE;
}


#else /* BCM_TRX_SUPPORT && BCM_FIELD_SUPPORT */
int _trx_field_not_empty;
#endif  /* BCM_TRX_SUPPORT && BCM_FIELD_SUPPORT */
