/**
 * $Id: ocm_diags_c.stg,v 1.20 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * g3p1_diags.c: Guadalupe2k V1.3 microcode diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_diags.h>
#include <soc/sbx/g3p1/g3p1_defs.h>

static uint32 makeOcmMask(int offset, int width) {
    int i;
    uint32 bit = (1 << offset);
    uint32 mask = 0;

    for (i = 0;i < width;i++) {
        mask |= bit;
        bit = bit << 1;
    }

    return mask;
}

/*
 * Utility method
 */
int soc_sbx_g3p1_ocm_update_overlaps(int unit, int table, uint32 *e, char *name, int value) {
  int fidx;
  int i;
  soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
  soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[table];
  int p1;
  int p2;
  int word;
  uint32 mask;

    fidx = soc_sbx_g3p1_field_find(ed, name);
    if (fidx < 0) {
        cli_out("unexpected field name '%s'\n", name);
        return SOC_E_PARAM;
    }

    word = ed->fields[fidx].pos/32;

    for (i = 0;i < ed->nfields;i++) {
        if (i != fidx) {
            if ((ed->fields[i].pos <= (ed->fields[fidx].pos + ed->fields[fidx].width - 1)) && 
                ((ed->fields[i].pos + ed->fields[i].width - 1) >= ed->fields[fidx].pos)) {
                
                if (ed->fields[i].pos < ed->fields[fidx].pos)
                    p1 = ed->fields[fidx].pos;
                else 
                    p1 = ed->fields[i].pos;

                if ((ed->fields[i].pos + ed->fields[i].width) < (ed->fields[fidx].pos + ed->fields[fidx].width))
                    p2 = ed->fields[i].pos + ed->fields[i].width - p1;
                else
                    p2 = ed->fields[fidx].pos + ed->fields[fidx].width - p1;

                p1 = p1 - (word * 32);

                mask = makeOcmMask(p1, p2);
                e[i] = ((!mask) & e[i])  | (mask & value);
                cli_out("Field:%s (value:%d) overlaps with:%s offset:%d width:%d (p1:%d p2:%d m:0x%08x w:%d v:%d)\n", 
                        name,
                        value,
                        ed->fields[i].name,
                        ed->fields[i].pos,
                        ed->fields[i].width, p1, p2, mask, word, e[i]);
            }
        }
    }
    return 0;
}

/*
 * Diag shell print routine for Constants
 */
int
soc_sbx_g3p1_constant_shell_print(int unit, int cid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;

    switch (cid) {  
    case SOC_SBX_G3P1_MAX_PORTS_ID:
        rv = soc_sbx_g3p1_max_ports_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_IP_VRF_BITS_ID:
        rv = soc_sbx_g3p1_ip_vrf_bits_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_STP_BLOCKED_IDX_ID:
        rv = soc_sbx_g3p1_exc_stp_blocked_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_SMAC_DROP_IDX_ID:
        rv = soc_sbx_g3p1_exc_smac_drop_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_SMAC_UNKNOWN_IDX_ID:
        rv = soc_sbx_g3p1_exc_smac_unknown_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_MAC_HAIRPIN_IDX_ID:
        rv = soc_sbx_g3p1_exc_mac_hairpin_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_DMAC_DROP_IDX_ID:
        rv = soc_sbx_g3p1_exc_dmac_drop_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_TTL_EXPIRED_IDX_ID:
        rv = soc_sbx_g3p1_exc_ttl_expired_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_EGR_STP_BLOCKED_IDX_ID:
        rv = soc_sbx_g3p1_exc_egr_stp_blocked_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_SPLIT_IDX_ID:
        rv = soc_sbx_g3p1_exc_split_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_MTU_IDX_ID:
        rv = soc_sbx_g3p1_exc_mtu_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_MISMATCH_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_mismatch_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_PEER_NOT_FOUND_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_peer_not_found_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_NO_ENDPOINT_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_no_endpoint_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_UNK_TYPE_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_unk_type_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_RDI_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_rdi_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_VLAN_DROP_IDX_ID:
        rv = soc_sbx_g3p1_exc_vlan_drop_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_V4MC_RPF_CHECK_IDX_ID:
        rv = soc_sbx_g3p1_exc_v4mc_rpf_check_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_URPF_DROP_IDX_ID:
        rv = soc_sbx_g3p1_exc_urpf_drop_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_IP_SA_DROP_IDX_ID:
        rv = soc_sbx_g3p1_exc_ip_sa_drop_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_MIM_BAD_FORMAT_IDX_ID:
        rv = soc_sbx_g3p1_exc_mim_bad_format_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_ISID2E_MISS_IDX_ID:
        rv = soc_sbx_g3p1_exc_isid2e_miss_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_THRESHOLD_EXCEEDED_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_threshold_exceeded_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_COPY_TO_HOST_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_copy_to_host_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_PARAM_CHANGE_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_param_change_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_BAD_OUTER_LABEL_IDX_ID:
        rv = soc_sbx_g3p1_exc_bad_outer_label_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_BAD_INNER_LABEL_IDX_ID:
        rv = soc_sbx_g3p1_exc_bad_inner_label_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_LSP_PING_IDX_ID:
        rv = soc_sbx_g3p1_exc_lsp_ping_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_TOO_MANY_LABELS_IDX_ID:
        rv = soc_sbx_g3p1_exc_too_many_labels_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_EGR_DROP_TAGGED_IDX_ID:
        rv = soc_sbx_g3p1_exc_egr_drop_tagged_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_EGR_DROP_UNTAGGED_IDX_ID:
        rv = soc_sbx_g3p1_exc_egr_drop_untagged_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_EGR_OAM_LINK_IDX_ID:
        rv = soc_sbx_g3p1_exc_egr_oam_link_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_OAM_INTERNAL_ERROR_IDX_ID:
        rv = soc_sbx_g3p1_exc_oam_internal_error_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_DCN_IDX_ID:
        rv = soc_sbx_g3p1_exc_dcn_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_MPLS_FILTER_IDX_ID:
        rv = soc_sbx_g3p1_exc_mpls_filter_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MIN_FREE_EXCEPTION_ID:
        rv = soc_sbx_g3p1_min_free_exception_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_FREE_EXCEPTION_ID:
        rv = soc_sbx_g3p1_max_free_exception_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_SMAC_LEARN_IDX_ID:
        rv = soc_sbx_g3p1_exc_smac_learn_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_PIM_IDX_ID:
        rv = soc_sbx_g3p1_exc_pim_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_IGMP_IDX_ID:
        rv = soc_sbx_g3p1_exc_igmp_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_RT_COPY_IDX_ID:
        rv = soc_sbx_g3p1_exc_rt_copy_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_L2CP_COPY_IDX_ID:
        rv = soc_sbx_g3p1_exc_l2cp_copy_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_DMAC_COPY_IDX_ID:
        rv = soc_sbx_g3p1_exc_dmac_copy_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_IPREDIRECT_IDX_ID:
        rv = soc_sbx_g3p1_exc_ipredirect_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_BMAC_LEARN_IDX_ID:
        rv = soc_sbx_g3p1_exc_bmac_learn_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXC_COPY_MAX_IDX_ID:
        rv = soc_sbx_g3p1_exc_copy_max_idx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_NULL_ID:
        rv = soc_sbx_g3p1_htype_null_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_NULL_ID:
        rv = soc_sbx_g3p1_hlen_null_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_ETH_ID:
        rv = soc_sbx_g3p1_htype_eth_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_ETH_ID:
        rv = soc_sbx_g3p1_hlen_eth_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_VTAG_ID:
        rv = soc_sbx_g3p1_htype_vtag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_VTAG_ID:
        rv = soc_sbx_g3p1_hlen_vtag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_ETYPE_ID:
        rv = soc_sbx_g3p1_htype_etype_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_ETYPE_ID:
        rv = soc_sbx_g3p1_hlen_etype_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_IPV4_ID:
        rv = soc_sbx_g3p1_htype_ipv4_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_IPV4_ID:
        rv = soc_sbx_g3p1_hlen_ipv4_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_IPV6_ID:
        rv = soc_sbx_g3p1_htype_ipv6_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_IPV6_ID:
        rv = soc_sbx_g3p1_hlen_ipv6_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_MPLS_ID:
        rv = soc_sbx_g3p1_htype_mpls_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_MPLS_ID:
        rv = soc_sbx_g3p1_hlen_mpls_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_ACH_ID:
        rv = soc_sbx_g3p1_htype_ach_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_ACH_ID:
        rv = soc_sbx_g3p1_hlen_ach_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_UDP_ID:
        rv = soc_sbx_g3p1_htype_udp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_UDP_ID:
        rv = soc_sbx_g3p1_hlen_udp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_TCP_ID:
        rv = soc_sbx_g3p1_htype_tcp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_TCP_ID:
        rv = soc_sbx_g3p1_hlen_tcp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_PTP_ID:
        rv = soc_sbx_g3p1_htype_ptp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_PTP_ID:
        rv = soc_sbx_g3p1_hlen_ptp_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_IETH_ID:
        rv = soc_sbx_g3p1_htype_ieth_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_LLC_ID:
        rv = soc_sbx_g3p1_htype_llc_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_LLC_ID:
        rv = soc_sbx_g3p1_hlen_llc_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_SNAP_ID:
        rv = soc_sbx_g3p1_htype_snap_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_SNAP_ID:
        rv = soc_sbx_g3p1_hlen_snap_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_DVTAG_ID:
        rv = soc_sbx_g3p1_htype_dvtag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_MIM_ID:
        rv = soc_sbx_g3p1_htype_mim_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_MIM_ID:
        rv = soc_sbx_g3p1_hlen_mim_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_BFD_ID:
        rv = soc_sbx_g3p1_htype_bfd_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_BFD_ID:
        rv = soc_sbx_g3p1_hlen_bfd_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_EERH_ID:
        rv = soc_sbx_g3p1_htype_eerh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_EERH_ID:
        rv = soc_sbx_g3p1_hlen_eerh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_ERH_ID:
        rv = soc_sbx_g3p1_htype_erh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_ERH_ID:
        rv = soc_sbx_g3p1_hlen_erh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_TMH_ID:
        rv = soc_sbx_g3p1_htype_tmh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_TMH_ID:
        rv = soc_sbx_g3p1_hlen_tmh_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_KSOP_ID:
        rv = soc_sbx_g3p1_htype_ksop_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_KSOP_ID:
        rv = soc_sbx_g3p1_hlen_ksop_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_CUSTOM_ID:
        rv = soc_sbx_g3p1_htype_custom_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_CUSTOM_ID:
        rv = soc_sbx_g3p1_hlen_custom_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_ELEN_ID:
        rv = soc_sbx_g3p1_htype_elen_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HLEN_ELEN_ID:
        rv = soc_sbx_g3p1_hlen_elen_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HTYPE_UNKN_ID:
        rv = soc_sbx_g3p1_htype_unkn_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LSMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g3p1_lsmac_table_size_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_L2CPMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g3p1_l2cpmac_table_size_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAMUPMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g3p1_oamupmac_table_size_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_NUM_ENDPOINTS_ID:
        rv = soc_sbx_g3p1_oam_num_endpoints_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_PTYPE_UNKNOWN_UNICAST_ID:
        rv = soc_sbx_g3p1_ptype_unknown_unicast_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_PTYPE_KNOWN_UNICAST_ID:
        rv = soc_sbx_g3p1_ptype_known_unicast_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_PTYPE_MULTICAST_ID:
        rv = soc_sbx_g3p1_ptype_multicast_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_PTYPE_BROADCAST_ID:
        rv = soc_sbx_g3p1_ptype_broadcast_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_PTYPE_LAST_ID:
        rv = soc_sbx_g3p1_ptype_last_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_TYPE_PVV_ID:
        rv = soc_sbx_g3p1_cuckoo_type_pvv_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_TYPE_ISID_ID:
        rv = soc_sbx_g3p1_cuckoo_type_isid_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_TYPE_PVD_ID:
        rv = soc_sbx_g3p1_cuckoo_type_pvd_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_TYPE_MAIDMEP_ID:
        rv = soc_sbx_g3p1_cuckoo_type_maidmep_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_TYPE_SHIFT_ID:
        rv = soc_sbx_g3p1_cuckoo_type_shift_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_QOS_PROFILE_INDEX_ID:
        rv = soc_sbx_g3p1_max_qos_profile_index_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_QOS_MAP_TABLE_ID:
        rv = soc_sbx_g3p1_max_qos_map_table_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_QOS_REMARK_TABLE_ID:
        rv = soc_sbx_g3p1_max_qos_remark_table_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_L2CP_TYPES_ID:
        rv = soc_sbx_g3p1_max_l2cp_types_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_L2CP_SUBTYPES_ID:
        rv = soc_sbx_g3p1_max_l2cp_subtypes_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_URPF_DEFAULT_PID_ID:
        rv = soc_sbx_g3p1_urpf_default_pid_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_STPSTATE_FORWARD_ID:
        rv = soc_sbx_g3p1_stpstate_forward_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_STPSTATE_BLOCK_ID:
        rv = soc_sbx_g3p1_stpstate_block_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_STPSTATE_LEARN_ID:
        rv = soc_sbx_g3p1_stpstate_learn_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MPLSTP_LOOPBACK_OAM_ID:
        rv = soc_sbx_g3p1_mplstp_loopback_oam_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MPLSTP_LOOPBACK_FULL_ID:
        rv = soc_sbx_g3p1_mplstp_loopback_full_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MPLSTP_LOOPBACK_NONE_ID:
        rv = soc_sbx_g3p1_mplstp_loopback_none_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LABEL_LSR_ID:
        rv = soc_sbx_g3p1_label_lsr_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LABEL_ETH_PWE3_ID:
        rv = soc_sbx_g3p1_label_eth_pwe3_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LABEL_LER_ID:
        rv = soc_sbx_g3p1_label_ler_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LABEL_CES_PWE3_ID:
        rv = soc_sbx_g3p1_label_ces_pwe3_get(unit, &v); 
        break;

    }
    if (rv) {
        cli_out("constant %s get timeout\n",
                tm->constants[cid].name);
        return rv;
    }
    cli_out("%s=", tm->constants[cid].name);
    soc_sbx_g3p1_print(-1, v);
    cli_out("\n");
    return SOC_E_NONE;
}



/*
 * Diag shell print routine for Globals
 */
int soc_sbx_g3p1_global_shell_print(int unit, int gid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;

    switch (gid) {
    case SOC_SBX_G3P1_CONTEXTS_ID:
        rv = soc_sbx_g3p1_contexts_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_TPID0_ID:
        rv = soc_sbx_g3p1_tpid0_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_TPID1_ID:
        rv = soc_sbx_g3p1_tpid1_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_TPID2_ID:
        rv = soc_sbx_g3p1_tpid2_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_DEFITAG_ID:
        rv = soc_sbx_g3p1_defitag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_AGE_ID:
        rv = soc_sbx_g3p1_age_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_ABSEED_ID:
        rv = soc_sbx_g3p1_cuckoo_abseed_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID:
        rv = soc_sbx_g3p1_labelcuckoo_abseed_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_NODE_ID:
        rv = soc_sbx_g3p1_node_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_VLAN_FT_BASE_ID:
        rv = soc_sbx_g3p1_vlan_ft_base_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_VPWS_VLAN_ID:
        rv = soc_sbx_g3p1_vpws_vlan_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_VPWS_FT_OFFSET_ID:
        rv = soc_sbx_g3p1_vpws_ft_offset_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MAX_PIDS_ID:
        rv = soc_sbx_g3p1_max_pids_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MC_FT_OFFSET_ID:
        rv = soc_sbx_g3p1_mc_ft_offset_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_DROP_BIT_ID:
        rv = soc_sbx_g3p1_oam_drop_bit_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID:
        rv = soc_sbx_g3p1_oam_enet_continue_byte_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID:
        rv = soc_sbx_g3p1_oam_mpls_continue_byte_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID:
        rv = soc_sbx_g3p1_oam_enet_frame_len_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID:
        rv = soc_sbx_g3p1_oam_mpls_frame_len_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID:
        rv = soc_sbx_g3p1_oam_source_queue_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_DEST_QUEUE_ID:
        rv = soc_sbx_g3p1_oam_dest_queue_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID:
        rv = soc_sbx_g3p1_oam_source_buffer_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID:
        rv = soc_sbx_g3p1_oam_bubble_timer_offset_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_LM_ID:
        rv = soc_sbx_g3p1_oam_sa_lm_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_DM_ID:
        rv = soc_sbx_g3p1_oam_sa_dm_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID:
        rv = soc_sbx_g3p1_oam_mpls_sa_lm_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID:
        rv = soc_sbx_g3p1_oam_mpls_sa_dm_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_PWE_IP_SA_ID:
        rv = soc_sbx_g3p1_oam_pwe_ip_sa_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID:
        rv = soc_sbx_g3p1_oam_pwe_udp_dest_port_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID:
        rv = soc_sbx_g3p1_oam_loopback_qid_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_4LO_ID:
        rv = soc_sbx_g3p1_oam_sa_4lo_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_2HI_ID:
        rv = soc_sbx_g3p1_oam_sa_2hi_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID:
        rv = soc_sbx_g3p1_oam_sa_4lo_aux_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID:
        rv = soc_sbx_g3p1_oam_sa_2hi_aux_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID:
        rv = soc_sbx_g3p1_oam_bfd_state_table_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID:
        rv = soc_sbx_g3p1_oam_bfd_rdi_diag_code_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID:
        rv = soc_sbx_g3p1_oam_tx_packets_per_bubble_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID:
        rv = soc_sbx_g3p1_oam_tx_packets_per_bubble_ca_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID:
        rv = soc_sbx_g3p1_oam_psc_rx_filter_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID:
        rv = soc_sbx_g3p1_oam_local_fe_qid_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_ETE_BASE_ID:
        rv = soc_sbx_g3p1_oam_ete_base_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_RSVD_OIP_ID:
        rv = soc_sbx_g3p1_oam_rsvd_oip_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_BLACKHOLE_VLAN_ID:
        rv = soc_sbx_g3p1_blackhole_vlan_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_IGMP_PROXY_MODE_ID:
        rv = soc_sbx_g3p1_igmp_proxy_mode_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_STATIC_LAG_ID:
        rv = soc_sbx_g3p1_static_lag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID:
        rv = soc_sbx_g3p1_ipv4_checksum_mode_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID:
        rv = soc_sbx_g3p1_exit_filter_on_btag_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID:
        rv = soc_sbx_g3p1_switch_meter_adjust_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID:
        rv = soc_sbx_g3p1_rc1_rule_startidx_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID:
        rv = soc_sbx_g3p1_ipv6_acl_enable_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OI2EOFF_ID:
        rv = soc_sbx_g3p1_oi2eoff_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_ete_segment_num_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_ep_segment_num_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_local_segment_num_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_peer_segment_num_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_sample_dm1_segment_num_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_ARAD_FWDACTION_ID:
        rv = soc_sbx_g3p1_arad_fwdaction_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID:
        rv = soc_sbx_g3p1_interlaken_offset_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID:
        rv = soc_sbx_g3p1_higig_loop_enable_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID:
        rv = soc_sbx_g3p1_maclearn_filter_enable_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID:
        rv = soc_sbx_g3p1_debug_stream_elen_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID:
        rv = soc_sbx_g3p1_c3_sws_static_page_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_g3p1_c3_sws_ingress_bubble_squeue_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID:
        rv = soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid0_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID:
        rv = soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid1_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_g3p1_c3_sws_egress_bubble_squeue_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID:
        rv = soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid0_get(unit, &v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID:
        rv = soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid1_get(unit, &v); 
        break;

    }
    if (rv) {
        cli_out("global %s get timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    cli_out("%s=", tm->globals[gid].name);
    soc_sbx_g3p1_print(tm->globals[gid].range, v);
    cli_out("\n");
    return SOC_E_NONE;
}

/*
 * Diag shell set routine for Globals
 */
int
soc_sbx_g3p1_global_shell_set(int unit, 
         int gid, int argc, char **argv)
{
    int rv;
    uint32 v;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;

    if (argc == 0) {
        cli_out("missing value\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g3p1_read(argv[0], tm->globals[gid].range, &v);
    if (rv) {
        cli_out("illegal value '%s'\n", argv[0]);
        return SOC_E_PARAM;
    }
    switch (gid) {
    case SOC_SBX_G3P1_CONTEXTS_ID:
        rv = soc_sbx_g3p1_contexts_set(unit, v); 
        break;

    case SOC_SBX_G3P1_TPID0_ID:
        rv = soc_sbx_g3p1_tpid0_set(unit, v); 
        break;

    case SOC_SBX_G3P1_TPID1_ID:
        rv = soc_sbx_g3p1_tpid1_set(unit, v); 
        break;

    case SOC_SBX_G3P1_TPID2_ID:
        rv = soc_sbx_g3p1_tpid2_set(unit, v); 
        break;

    case SOC_SBX_G3P1_DEFITAG_ID:
        rv = soc_sbx_g3p1_defitag_set(unit, v); 
        break;

    case SOC_SBX_G3P1_AGE_ID:
        rv = soc_sbx_g3p1_age_set(unit, v); 
        break;

    case SOC_SBX_G3P1_CUCKOO_ABSEED_ID:
        rv = soc_sbx_g3p1_cuckoo_abseed_set(unit, v); 
        break;

    case SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID:
        rv = soc_sbx_g3p1_labelcuckoo_abseed_set(unit, v); 
        break;

    case SOC_SBX_G3P1_NODE_ID:
        rv = soc_sbx_g3p1_node_set(unit, v); 
        break;

    case SOC_SBX_G3P1_VLAN_FT_BASE_ID:
        rv = soc_sbx_g3p1_vlan_ft_base_set(unit, v); 
        break;

    case SOC_SBX_G3P1_VPWS_VLAN_ID:
        rv = soc_sbx_g3p1_vpws_vlan_set(unit, v); 
        break;

    case SOC_SBX_G3P1_VPWS_FT_OFFSET_ID:
        rv = soc_sbx_g3p1_vpws_ft_offset_set(unit, v); 
        break;

    case SOC_SBX_G3P1_MAX_PIDS_ID:
        rv = soc_sbx_g3p1_max_pids_set(unit, v); 
        break;

    case SOC_SBX_G3P1_MC_FT_OFFSET_ID:
        rv = soc_sbx_g3p1_mc_ft_offset_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_DROP_BIT_ID:
        rv = soc_sbx_g3p1_oam_drop_bit_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID:
        rv = soc_sbx_g3p1_oam_enet_continue_byte_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID:
        rv = soc_sbx_g3p1_oam_mpls_continue_byte_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID:
        rv = soc_sbx_g3p1_oam_enet_frame_len_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID:
        rv = soc_sbx_g3p1_oam_mpls_frame_len_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID:
        rv = soc_sbx_g3p1_oam_source_queue_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_DEST_QUEUE_ID:
        rv = soc_sbx_g3p1_oam_dest_queue_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID:
        rv = soc_sbx_g3p1_oam_source_buffer_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID:
        rv = soc_sbx_g3p1_oam_bubble_timer_offset_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_LM_ID:
        rv = soc_sbx_g3p1_oam_sa_lm_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_DM_ID:
        rv = soc_sbx_g3p1_oam_sa_dm_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID:
        rv = soc_sbx_g3p1_oam_mpls_sa_lm_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID:
        rv = soc_sbx_g3p1_oam_mpls_sa_dm_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_PWE_IP_SA_ID:
        rv = soc_sbx_g3p1_oam_pwe_ip_sa_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID:
        rv = soc_sbx_g3p1_oam_pwe_udp_dest_port_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID:
        rv = soc_sbx_g3p1_oam_loopback_qid_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_4LO_ID:
        rv = soc_sbx_g3p1_oam_sa_4lo_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_2HI_ID:
        rv = soc_sbx_g3p1_oam_sa_2hi_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID:
        rv = soc_sbx_g3p1_oam_sa_4lo_aux_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID:
        rv = soc_sbx_g3p1_oam_sa_2hi_aux_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID:
        rv = soc_sbx_g3p1_oam_bfd_state_table_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID:
        rv = soc_sbx_g3p1_oam_bfd_rdi_diag_code_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID:
        rv = soc_sbx_g3p1_oam_tx_packets_per_bubble_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID:
        rv = soc_sbx_g3p1_oam_tx_packets_per_bubble_ca_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID:
        rv = soc_sbx_g3p1_oam_psc_rx_filter_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID:
        rv = soc_sbx_g3p1_oam_local_fe_qid_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_ETE_BASE_ID:
        rv = soc_sbx_g3p1_oam_ete_base_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_RSVD_OIP_ID:
        rv = soc_sbx_g3p1_oam_rsvd_oip_set(unit, v); 
        break;

    case SOC_SBX_G3P1_BLACKHOLE_VLAN_ID:
        rv = soc_sbx_g3p1_blackhole_vlan_set(unit, v); 
        break;

    case SOC_SBX_G3P1_IGMP_PROXY_MODE_ID:
        rv = soc_sbx_g3p1_igmp_proxy_mode_set(unit, v); 
        break;

    case SOC_SBX_G3P1_STATIC_LAG_ID:
        rv = soc_sbx_g3p1_static_lag_set(unit, v); 
        break;

    case SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID:
        rv = soc_sbx_g3p1_ipv4_checksum_mode_set(unit, v); 
        break;

    case SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID:
        rv = soc_sbx_g3p1_exit_filter_on_btag_set(unit, v); 
        break;

    case SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID:
        rv = soc_sbx_g3p1_switch_meter_adjust_set(unit, v); 
        break;

    case SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID:
        rv = soc_sbx_g3p1_rc1_rule_startidx_set(unit, v); 
        break;

    case SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID:
        rv = soc_sbx_g3p1_ipv6_acl_enable_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OI2EOFF_ID:
        rv = soc_sbx_g3p1_oi2eoff_set(unit, v); 
        break;

    case SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_ete_segment_num_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_ep_segment_num_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_local_segment_num_set(unit, v); 
        break;

    case SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_oam_peer_segment_num_set(unit, v); 
        break;

    case SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID:
        rv = soc_sbx_g3p1_sample_dm1_segment_num_set(unit, v); 
        break;

    case SOC_SBX_G3P1_ARAD_FWDACTION_ID:
        rv = soc_sbx_g3p1_arad_fwdaction_set(unit, v); 
        break;

    case SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID:
        rv = soc_sbx_g3p1_interlaken_offset_set(unit, v); 
        break;

    case SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID:
        rv = soc_sbx_g3p1_higig_loop_enable_set(unit, v); 
        break;

    case SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID:
        rv = soc_sbx_g3p1_maclearn_filter_enable_set(unit, v); 
        break;

    case SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID:
        rv = soc_sbx_g3p1_debug_stream_elen_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID:
        rv = soc_sbx_g3p1_c3_sws_static_page_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_g3p1_c3_sws_ingress_bubble_squeue_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID:
        rv = soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid0_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID:
        rv = soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid1_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_g3p1_c3_sws_egress_bubble_squeue_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID:
        rv = soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid0_set(unit, v); 
        break;

    case SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID:
        rv = soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid1_set(unit, v); 
        break;

    }
    if (rv) {
        cli_out("global %s set timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    return SOC_E_NONE;
}


/* Shell const get command usage string */
char soc_sbx_g3p1_constant_usage[] =
"g3p1constantget <constant>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        MAX_PORTS       (constant) \n"
"        IP_VRF_BITS       (constant) \n"
"        EXC_STP_BLOCKED_IDX       (constant) \n"
"        EXC_SMAC_DROP_IDX       (constant) \n"
"        EXC_SMAC_UNKNOWN_IDX       (constant) \n"
"        EXC_MAC_HAIRPIN_IDX       (constant) \n"
"        EXC_DMAC_DROP_IDX       (constant) \n"
"        EXC_TTL_EXPIRED_IDX       (constant) \n"
"        EXC_EGR_STP_BLOCKED_IDX       (constant) \n"
"        EXC_SPLIT_IDX       (constant) \n"
"        EXC_MTU_IDX       (constant) \n"
"        EXC_OAM_MISMATCH_IDX       (constant) \n"
"        EXC_OAM_PEER_NOT_FOUND_IDX       (constant) \n"
"        EXC_OAM_NO_ENDPOINT_IDX       (constant) \n"
"        EXC_OAM_UNK_TYPE_IDX       (constant) \n"
"        EXC_OAM_RDI_IDX       (constant) \n"
"        EXC_VLAN_DROP_IDX       (constant) \n"
"        EXC_V4MC_RPF_CHECK_IDX       (constant) \n"
"        EXC_URPF_DROP_IDX       (constant) \n"
"        EXC_IP_SA_DROP_IDX       (constant) \n"
"        EXC_MIM_BAD_FORMAT_IDX       (constant) \n"
"        EXC_ISID2E_MISS_IDX       (constant) \n"
"        EXC_OAM_THRESHOLD_EXCEEDED_IDX       (constant) \n"
"        EXC_OAM_COPY_TO_HOST_IDX       (constant) \n"
"        EXC_OAM_PARAM_CHANGE_IDX       (constant) \n"
"        EXC_BAD_OUTER_LABEL_IDX       (constant) \n"
"        EXC_BAD_INNER_LABEL_IDX       (constant) \n"
"        EXC_LSP_PING_IDX       (constant) \n"
"        EXC_TOO_MANY_LABELS_IDX       (constant) \n"
"        EXC_EGR_DROP_TAGGED_IDX       (constant) \n"
"        EXC_EGR_DROP_UNTAGGED_IDX       (constant) \n"
"        EXC_EGR_OAM_LINK_IDX       (constant) \n"
"        EXC_OAM_INTERNAL_ERROR_IDX       (constant) \n"
"        EXC_DCN_IDX       (constant) \n"
"        EXC_MPLS_FILTER_IDX       (constant) \n"
"        MIN_FREE_EXCEPTION       (constant) \n"
"        MAX_FREE_EXCEPTION       (constant) \n"
"        EXC_SMAC_LEARN_IDX       (constant) \n"
"        EXC_PIM_IDX       (constant) \n"
"        EXC_IGMP_IDX       (constant) \n"
"        EXC_RT_COPY_IDX       (constant) \n"
"        EXC_L2CP_COPY_IDX       (constant) \n"
"        EXC_DMAC_COPY_IDX       (constant) \n"
"        EXC_IPREDIRECT_IDX       (constant) \n"
"        EXC_BMAC_LEARN_IDX       (constant) \n"
"        EXC_COPY_MAX_IDX       (constant) \n"
"        HTYPE_NULL       (constant) \n"
"        HLEN_NULL       (constant) \n"
"        HTYPE_ETH       (constant) \n"
"        HLEN_ETH       (constant) \n"
"        HTYPE_VTAG       (constant) \n"
"        HLEN_VTAG       (constant) \n"
"        HTYPE_ETYPE       (constant) \n"
"        HLEN_ETYPE       (constant) \n"
"        HTYPE_IPV4       (constant) \n"
"        HLEN_IPV4       (constant) \n"
"        HTYPE_IPV6       (constant) \n"
"        HLEN_IPV6       (constant) \n"
"        HTYPE_MPLS       (constant) \n"
"        HLEN_MPLS       (constant) \n"
"        HTYPE_ACH       (constant) \n"
"        HLEN_ACH       (constant) \n"
"        HTYPE_UDP       (constant) \n"
"        HLEN_UDP       (constant) \n"
"        HTYPE_TCP       (constant) \n"
"        HLEN_TCP       (constant) \n"
"        HTYPE_PTP       (constant) \n"
"        HLEN_PTP       (constant) \n"
"        HTYPE_IETH       (constant) \n"
"        HTYPE_LLC       (constant) \n"
"        HLEN_LLC       (constant) \n"
"        HTYPE_SNAP       (constant) \n"
"        HLEN_SNAP       (constant) \n"
"        HTYPE_DVTAG       (constant) \n"
"        HTYPE_MIM       (constant) \n"
"        HLEN_MIM       (constant) \n"
"        HTYPE_BFD       (constant) \n"
"        HLEN_BFD       (constant) \n"
"        HTYPE_EERH       (constant) \n"
"        HLEN_EERH       (constant) \n"
"        HTYPE_ERH       (constant) \n"
"        HLEN_ERH       (constant) \n"
"        HTYPE_TMH       (constant) \n"
"        HLEN_TMH       (constant) \n"
"        HTYPE_KSOP       (constant) \n"
"        HLEN_KSOP       (constant) \n"
"        HTYPE_CUSTOM       (constant) \n"
"        HLEN_CUSTOM       (constant) \n"
"        HTYPE_ELEN       (constant) \n"
"        HLEN_ELEN       (constant) \n"
"        HTYPE_UNKN       (constant) \n"
"        LSMAC_TABLE_SIZE       (constant) \n"
"        L2CPMAC_TABLE_SIZE       (constant) \n"
"        OAMUPMAC_TABLE_SIZE       (constant) \n"
"        OAM_NUM_ENDPOINTS       (constant) \n"
"        PTYPE_UNKNOWN_UNICAST       (constant) \n"
"        PTYPE_KNOWN_UNICAST       (constant) \n"
"        PTYPE_MULTICAST       (constant) \n"
"        PTYPE_BROADCAST       (constant) \n"
"        PTYPE_LAST       (constant) \n"
"        CUCKOO_TYPE_PVV       (constant) \n"
"        CUCKOO_TYPE_ISID       (constant) \n"
"        CUCKOO_TYPE_PVD       (constant) \n"
"        CUCKOO_TYPE_MAIDMEP       (constant) \n"
"        CUCKOO_TYPE_SHIFT       (constant) \n"
"        MAX_QOS_PROFILE_INDEX       (constant) \n"
"        MAX_QOS_MAP_TABLE       (constant) \n"
"        MAX_QOS_REMARK_TABLE       (constant) \n"
"        MAX_L2CP_TYPES       (constant) \n"
"        MAX_L2CP_SUBTYPES       (constant) \n"
"        URPF_DEFAULT_PID       (constant) \n"
"        STPSTATE_FORWARD       (constant) \n"
"        STPSTATE_BLOCK       (constant) \n"
"        STPSTATE_LEARN       (constant) \n"
"        MPLSTP_LOOPBACK_OAM       (constant) \n"
"        MPLSTP_LOOPBACK_FULL       (constant) \n"
"        MPLSTP_LOOPBACK_NONE       (constant) \n"
"        LABEL_LSR       (constant) \n"
"        LABEL_ETH_PWE3       (constant) \n"
"        LABEL_LER       (constant) \n"
"        LABEL_CES_PWE3       (constant) \n"
#endif
;


/* Shell global get command usage string */
char soc_sbx_g3p1_global_get_usage[] =
"g3p1globalget <global>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
 "        CONTEXTS        (global) \n" 
 "        TPID0        (global) \n" 
 "        TPID1        (global) \n" 
 "        TPID2        (global) \n" 
 "        DEFITAG        (global) \n" 
 "        AGE        (global) \n" 
 "        CUCKOO_ABSEED        (global) \n" 
 "        LABELCUCKOO_ABSEED        (global) \n" 
 "        NODE        (global) \n" 
 "        VLAN_FT_BASE        (global) \n" 
 "        VPWS_VLAN        (global) \n" 
 "        VPWS_FT_OFFSET        (global) \n" 
 "        MAX_PIDS        (global) \n" 
 "        MC_FT_OFFSET        (global) \n" 
 "        OAM_DROP_BIT        (global) \n" 
 "        OAM_ENET_CONTINUE_BYTE        (global) \n" 
 "        OAM_MPLS_CONTINUE_BYTE        (global) \n" 
 "        OAM_ENET_FRAME_LEN        (global) \n" 
 "        OAM_MPLS_FRAME_LEN        (global) \n" 
 "        OAM_SOURCE_QUEUE        (global) \n" 
 "        OAM_DEST_QUEUE        (global) \n" 
 "        OAM_SOURCE_BUFFER        (global) \n" 
 "        OAM_BUBBLE_TIMER_OFFSET        (global) \n" 
 "        OAM_SA_LM        (global) \n" 
 "        OAM_SA_DM        (global) \n" 
 "        OAM_MPLS_SA_LM        (global) \n" 
 "        OAM_MPLS_SA_DM        (global) \n" 
 "        OAM_PWE_IP_SA        (global) \n" 
 "        OAM_PWE_UDP_DEST_PORT        (global) \n" 
 "        OAM_LOOPBACK_QID        (global) \n" 
 "        OAM_SA_4LO        (global) \n" 
 "        OAM_SA_2HI        (global) \n" 
 "        OAM_SA_4LO_AUX        (global) \n" 
 "        OAM_SA_2HI_AUX        (global) \n" 
 "        OAM_BFD_STATE_TABLE        (global) \n" 
 "        OAM_BFD_RDI_DIAG_CODE        (global) \n" 
 "        OAM_TX_PACKETS_PER_BUBBLE        (global) \n" 
 "        OAM_TX_PACKETS_PER_BUBBLE_CA        (global) \n" 
 "        OAM_PSC_RX_FILTER        (global) \n" 
 "        OAM_LOCAL_FE_QID        (global) \n" 
 "        OAM_ETE_BASE        (global) \n" 
 "        OAM_RSVD_OIP        (global) \n" 
 "        BLACKHOLE_VLAN        (global) \n" 
 "        IGMP_PROXY_MODE        (global) \n" 
 "        STATIC_LAG        (global) \n" 
 "        IPV4_CHECKSUM_MODE        (global) \n" 
 "        EXIT_FILTER_ON_BTAG        (global) \n" 
 "        SWITCH_METER_ADJUST        (global) \n" 
 "        RC1_RULE_STARTIDX        (global) \n" 
 "        IPV6_ACL_ENABLE        (global) \n" 
 "        OI2EOFF        (global) \n" 
 "        ETE_SEGMENT_NUM        (global) \n" 
 "        OAM_EP_SEGMENT_NUM        (global) \n" 
 "        OAM_LOCAL_SEGMENT_NUM        (global) \n" 
 "        OAM_PEER_SEGMENT_NUM        (global) \n" 
 "        SAMPLE_DM1_SEGMENT_NUM        (global) \n" 
 "        ARAD_FWDACTION        (global) \n" 
 "        INTERLAKEN_OFFSET        (global) \n" 
 "        HIGIG_LOOP_ENABLE        (global) \n" 
 "        MACLEARN_FILTER_ENABLE        (global) \n" 
 "        DEBUG_STREAM_ELEN        (global) \n" 
 "        C3_SWS_STATIC_PAGE        (global) \n" 
 "        C3_SWS_INGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID1        (global) \n" 
 "        C3_SWS_EGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID1        (global) \n" 
#endif
;

char soc_sbx_g3p1_global_set_usage[] =
"g3p1globalset <global> <value>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
 "        CONTEXTS        (global) \n" 
 "        TPID0        (global) \n" 
 "        TPID1        (global) \n" 
 "        TPID2        (global) \n" 
 "        DEFITAG        (global) \n" 
 "        AGE        (global) \n" 
 "        CUCKOO_ABSEED        (global) \n" 
 "        LABELCUCKOO_ABSEED        (global) \n" 
 "        NODE        (global) \n" 
 "        VLAN_FT_BASE        (global) \n" 
 "        VPWS_VLAN        (global) \n" 
 "        VPWS_FT_OFFSET        (global) \n" 
 "        MAX_PIDS        (global) \n" 
 "        MC_FT_OFFSET        (global) \n" 
 "        OAM_DROP_BIT        (global) \n" 
 "        OAM_ENET_CONTINUE_BYTE        (global) \n" 
 "        OAM_MPLS_CONTINUE_BYTE        (global) \n" 
 "        OAM_ENET_FRAME_LEN        (global) \n" 
 "        OAM_MPLS_FRAME_LEN        (global) \n" 
 "        OAM_SOURCE_QUEUE        (global) \n" 
 "        OAM_DEST_QUEUE        (global) \n" 
 "        OAM_SOURCE_BUFFER        (global) \n" 
 "        OAM_BUBBLE_TIMER_OFFSET        (global) \n" 
 "        OAM_SA_LM        (global) \n" 
 "        OAM_SA_DM        (global) \n" 
 "        OAM_MPLS_SA_LM        (global) \n" 
 "        OAM_MPLS_SA_DM        (global) \n" 
 "        OAM_PWE_IP_SA        (global) \n" 
 "        OAM_PWE_UDP_DEST_PORT        (global) \n" 
 "        OAM_LOOPBACK_QID        (global) \n" 
 "        OAM_SA_4LO        (global) \n" 
 "        OAM_SA_2HI        (global) \n" 
 "        OAM_SA_4LO_AUX        (global) \n" 
 "        OAM_SA_2HI_AUX        (global) \n" 
 "        OAM_BFD_STATE_TABLE        (global) \n" 
 "        OAM_BFD_RDI_DIAG_CODE        (global) \n" 
 "        OAM_TX_PACKETS_PER_BUBBLE        (global) \n" 
 "        OAM_TX_PACKETS_PER_BUBBLE_CA        (global) \n" 
 "        OAM_PSC_RX_FILTER        (global) \n" 
 "        OAM_LOCAL_FE_QID        (global) \n" 
 "        OAM_ETE_BASE        (global) \n" 
 "        OAM_RSVD_OIP        (global) \n" 
 "        BLACKHOLE_VLAN        (global) \n" 
 "        IGMP_PROXY_MODE        (global) \n" 
 "        STATIC_LAG        (global) \n" 
 "        IPV4_CHECKSUM_MODE        (global) \n" 
 "        EXIT_FILTER_ON_BTAG        (global) \n" 
 "        SWITCH_METER_ADJUST        (global) \n" 
 "        RC1_RULE_STARTIDX        (global) \n" 
 "        IPV6_ACL_ENABLE        (global) \n" 
 "        OI2EOFF        (global) \n" 
 "        ETE_SEGMENT_NUM        (global) \n" 
 "        OAM_EP_SEGMENT_NUM        (global) \n" 
 "        OAM_LOCAL_SEGMENT_NUM        (global) \n" 
 "        OAM_PEER_SEGMENT_NUM        (global) \n" 
 "        SAMPLE_DM1_SEGMENT_NUM        (global) \n" 
 "        ARAD_FWDACTION        (global) \n" 
 "        INTERLAKEN_OFFSET        (global) \n" 
 "        HIGIG_LOOP_ENABLE        (global) \n" 
 "        MACLEARN_FILTER_ENABLE        (global) \n" 
 "        DEBUG_STREAM_ELEN        (global) \n" 
 "        C3_SWS_STATIC_PAGE        (global) \n" 
 "        C3_SWS_INGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID1        (global) \n" 
 "        C3_SWS_EGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID1        (global) \n" 
#endif
;



/* entry print accessor implementation for qos */
void soc_sbx_g3p1_qos_print(int unit, soc_sbx_g3p1_qos_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->e; w = 1;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->cos; w = 3;  break;
        case 3: v = e->fcos; w = 4;  break;
        case 4: v = e->mefcos; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for qos */
int soc_sbx_g3p1_qos_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_qos_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_qos_t e0;
    soc_sbx_g3p1_qos_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int ide;
    int ipri;
    int iprof;
    void *indexpointers[3];
    indexpointers[0] = &ide;
    indexpointers[1] = &ipri;
    indexpointers[2] = &iprof;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_qos_get(unit,
                  ide , ipri , iprof  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_qos_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for qos */
int soc_sbx_g3p1_qos_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_qos_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_qos_t e0;
    soc_sbx_g3p1_qos_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int ide;
    int ipri;
    int iprof;
    void *indexpointers[3];
    indexpointers[0] = &ide;
    indexpointers[1] = &ipri;
    indexpointers[2] = &iprof;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_qos_t_init(e);

    rv = soc_sbx_g3p1_qos_get(unit,
                  ide , ipri , iprof  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->e,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->dp,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->cos,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->fcos,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->mefcos,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_QOS_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_qos_set(unit,
                  ide , ipri , iprof  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for dscpqos */
void soc_sbx_g3p1_dscpqos_print(int unit, soc_sbx_g3p1_dscpqos_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->e; w = 1;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->cos; w = 3;  break;
        case 3: v = e->fcos; w = 4;  break;
        case 4: v = e->mefcos; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_dscpqos_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_dscpqos_t e0;
    soc_sbx_g3p1_dscpqos_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int idscp;
    int iprof;
    void *indexpointers[2];
    indexpointers[0] = &idscp;
    indexpointers[1] = &iprof;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_dscpqos_get(unit,
                  idscp , iprof  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_dscpqos_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_dscpqos_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_dscpqos_t e0;
    soc_sbx_g3p1_dscpqos_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int idscp;
    int iprof;
    void *indexpointers[2];
    indexpointers[0] = &idscp;
    indexpointers[1] = &iprof;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_dscpqos_t_init(e);

    rv = soc_sbx_g3p1_dscpqos_get(unit,
                  idscp , iprof  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->e,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->dp,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->cos,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->fcos,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->mefcos,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_DSCPQOS_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_dscpqos_set(unit,
                  idscp , iprof  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for irt */
void soc_sbx_g3p1_irt_print(int unit, soc_sbx_g3p1_irt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->mirror; w = 6;  break;
        case 3: v = e->usevlan; w = 7;  break;
        case 4: v = e->useftidx; w = 8;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->cos; w = 3;  break;
        case 8: v = e->fcos; w = 4;  break;
        case 9: v = e->usedp; w = 5;  break;
        case 10: v = e->usecos; w = 6;  break;
        case 11: v = e->policer; w = 7;  break;
        case 12: v = e->typedpolice; w = 11;  break;
        case 13: v = e->mefcos; w = 6;  break;
        case 14: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for irt */
int soc_sbx_g3p1_irt_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_irt_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_irt_t e0;
    soc_sbx_g3p1_irt_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_irt_get(unit,
                  iirule  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_irt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for irt */
int soc_sbx_g3p1_irt_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_irt_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_irt_t e0;
    soc_sbx_g3p1_irt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_irt_t_init(e);

    rv = soc_sbx_g3p1_irt_get(unit,
                  iirule  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->mirror,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->usevlan,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->useftidx,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->copy,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->dp,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->cos,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->fcos,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->usedp,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_g3p1_value_read(&e->usecos,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_g3p1_value_read(&e->policer,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_g3p1_value_read(&e->typedpolice,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        case 13: rv = soc_sbx_g3p1_value_read(&e->mefcos,
                                        ed->fields[13].range, 0, argc, argv);
                    break;

        case 14: rv = soc_sbx_g3p1_value_read(&e->mef,
                                        ed->fields[14].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_IRT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_irt_set(unit,
                  iirule  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lag */
void soc_sbx_g3p1_lag_print(int unit, soc_sbx_g3p1_lag_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->qid; w = 3;  break;
        case 1: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for lag */
int soc_sbx_g3p1_lag_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_lag_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lag_t e0;
    soc_sbx_g3p1_lag_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int ilagi;
    void *indexpointers[1];
    indexpointers[0] = &ilagi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_lag_get(unit,
                  ilagi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_lag_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lag */
int soc_sbx_g3p1_lag_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_lag_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lag_t e0;
    soc_sbx_g3p1_lag_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int ilagi;
    void *indexpointers[1];
    indexpointers[0] = &ilagi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_lag_t_init(e);

    rv = soc_sbx_g3p1_lag_get(unit,
                  ilagi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->qid,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->oi,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_LAG_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_lag_set(unit,
                  ilagi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for rrt */
void soc_sbx_g3p1_rrt_print(int unit, soc_sbx_g3p1_rrt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->backup; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for rrt */
int soc_sbx_g3p1_rrt_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_rrt_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_rrt_t e0;
    soc_sbx_g3p1_rrt_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int irri;
    void *indexpointers[1];
    indexpointers[0] = &irri;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_rrt_get(unit,
                  irri  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_rrt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for rrt */
int soc_sbx_g3p1_rrt_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_rrt_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_rrt_t e0;
    soc_sbx_g3p1_rrt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int irri;
    void *indexpointers[1];
    indexpointers[0] = &irri;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_rrt_t_init(e);

    rv = soc_sbx_g3p1_rrt_get(unit,
                  irri  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->backup,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_RRT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_rrt_set(unit,
                  irri  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for xt */
void soc_sbx_g3p1_xt_print(int unit, soc_sbx_g3p1_xt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->forward; w = 7;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->qid; w = 3;  break;
        case 3: v = e->fwdid; w = 5;  break;
        case 4: v = e->trunc; w = 5;  break;
        case 5: v = e->learn; w = 5;  break;
        case 6: v = e->ppspolice; w = 9;  break;
        case 7: v = e->policer; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for xt */
int soc_sbx_g3p1_xt_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_xt_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_xt_t e0;
    soc_sbx_g3p1_xt_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int ixi;
    void *indexpointers[1];
    indexpointers[0] = &ixi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_xt_get(unit,
                  ixi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_xt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for xt */
int soc_sbx_g3p1_xt_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_xt_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_xt_t e0;
    soc_sbx_g3p1_xt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int ixi;
    void *indexpointers[1];
    indexpointers[0] = &ixi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_xt_t_init(e);

    rv = soc_sbx_g3p1_xt_get(unit,
                  ixi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->forward,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->dp,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->qid,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->fwdid,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->trunc,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->learn,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->ppspolice,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->policer,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_XT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_xt_set(unit,
                  ixi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for mirror */
void soc_sbx_g3p1_mirror_print(int unit, soc_sbx_g3p1_mirror_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->yellow; w = 6;  break;
        case 1: v = e->qid; w = 3;  break;
        case 2: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for mirror */
int soc_sbx_g3p1_mirror_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_mirror_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mirror_t e0;
    soc_sbx_g3p1_mirror_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int imi;
    void *indexpointers[1];
    indexpointers[0] = &imi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_mirror_get(unit,
                  imi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_mirror_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mirror */
int soc_sbx_g3p1_mirror_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_mirror_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mirror_t e0;
    soc_sbx_g3p1_mirror_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int imi;
    void *indexpointers[1];
    indexpointers[0] = &imi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_mirror_t_init(e);

    rv = soc_sbx_g3p1_mirror_get(unit,
                  imi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->yellow,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->qid,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->oi,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_MIRROR_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_mirror_set(unit,
                  imi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emirror */
void soc_sbx_g3p1_emirror_print(int unit, soc_sbx_g3p1_emirror_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->yellow; w = 6;  break;
        case 1: v = e->qid; w = 3;  break;
        case 2: v = e->oi; w = 2;  break;
        case 3: v = e->dqueue; w = 6;  break;
        case 4: v = e->local; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for emirror */
int soc_sbx_g3p1_emirror_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_emirror_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_emirror_t e0;
    soc_sbx_g3p1_emirror_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int imi;
    void *indexpointers[1];
    indexpointers[0] = &imi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_emirror_get(unit,
                  imi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_emirror_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emirror */
int soc_sbx_g3p1_emirror_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_emirror_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_emirror_t e0;
    soc_sbx_g3p1_emirror_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int imi;
    void *indexpointers[1];
    indexpointers[0] = &imi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_emirror_t_init(e);

    rv = soc_sbx_g3p1_emirror_get(unit,
                  imi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->yellow,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->qid,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->oi,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->dqueue,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->local,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_EMIRROR_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_emirror_set(unit,
                  imi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for macage */
void soc_sbx_g3p1_macage_print(int unit, soc_sbx_g3p1_macage_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->age; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for macage */
int soc_sbx_g3p1_macage_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_macage_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_macage_t e0;
    soc_sbx_g3p1_macage_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_macage_get(unit,
                  imacindex  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_macage_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for macage */
int soc_sbx_g3p1_macage_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_macage_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_macage_t e0;
    soc_sbx_g3p1_macage_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_macage_t_init(e);

    rv = soc_sbx_g3p1_macage_get(unit,
                  imacindex  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->age,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_MACAGE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_macage_set(unit,
                  imacindex  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for mst */
void soc_sbx_g3p1_mst_print(int unit, soc_sbx_g3p1_mst_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->learn; w = 5;  break;
        case 1: v = e->pim; w = 3;  break;
        case 2: v = e->igmp; w = 4;  break;
        case 3: v = e->rtcopy; w = 6;  break;
        case 4: v = e->l2cpcopy; w = 8;  break;
        case 5: v = e->dcopy; w = 5;  break;
        case 6: v = e->ipredirect; w = 10;  break;
        case 7: v = e->learn_bmac; w = 10;  break;
        case 8: v = e->mirroridx; w = 9;  break;
        case 9: v = e->vsi; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for mst */
int soc_sbx_g3p1_mst_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_mst_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mst_t e0;
    soc_sbx_g3p1_mst_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int imsti;
    void *indexpointers[1];
    indexpointers[0] = &imsti;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_mst_get(unit,
                  imsti  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_mst_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mst */
int soc_sbx_g3p1_mst_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_mst_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mst_t e0;
    soc_sbx_g3p1_mst_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int imsti;
    void *indexpointers[1];
    indexpointers[0] = &imsti;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_mst_t_init(e);

    rv = soc_sbx_g3p1_mst_get(unit,
                  imsti  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->learn,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->pim,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->igmp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->rtcopy,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->l2cpcopy,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->dcopy,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->ipredirect,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->learn_bmac,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->mirroridx,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->vsi,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_MST_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_mst_set(unit,
                  imsti  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pv2e */
void soc_sbx_g3p1_pv2e_print(int unit, soc_sbx_g3p1_pv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->lpi; w = 3;  break;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        case 3: v = e->vpws; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for pv2e */
int soc_sbx_g3p1_pv2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_pv2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pv2e_t e0;
    soc_sbx_g3p1_pv2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_pv2e_get(unit,
                  ivid , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_pv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pv2e */
int soc_sbx_g3p1_pv2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_pv2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pv2e_t e0;
    soc_sbx_g3p1_pv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_pv2e_t_init(e);

    rv = soc_sbx_g3p1_pv2e_get(unit,
                  ivid , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->lpi,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->stpstate,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->vpws,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_PV2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_pv2e_set(unit,
                  ivid , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2appdata */
void soc_sbx_g3p1_p2appdata_print(int unit, soc_sbx_g3p1_p2appdata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ifilteren; w = 9;  break;
        case 1: v = e->efilteren; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_p2appdata_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_p2appdata_t e0;
    soc_sbx_g3p1_p2appdata_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int iport;
    void *indexpointers[1];
    indexpointers[0] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_p2appdata_get(unit,
                  iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_p2appdata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_p2appdata_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_p2appdata_t e0;
    soc_sbx_g3p1_p2appdata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int iport;
    void *indexpointers[1];
    indexpointers[0] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_p2appdata_t_init(e);

    rv = soc_sbx_g3p1_p2appdata_get(unit,
                  iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->ifilteren,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->efilteren,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_P2APPDATA_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_p2appdata_set(unit,
                  iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pv2appdata */
void soc_sbx_g3p1_pv2appdata_print(int unit, soc_sbx_g3p1_pv2appdata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->member; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_pv2appdata_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pv2appdata_t e0;
    soc_sbx_g3p1_pv2appdata_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_pv2appdata_get(unit,
                  ivid , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_pv2appdata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_pv2appdata_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pv2appdata_t e0;
    soc_sbx_g3p1_pv2appdata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_pv2appdata_t_init(e);

    rv = soc_sbx_g3p1_pv2appdata_get(unit,
                  ivid , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->member,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_PV2APPDATA_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_pv2appdata_set(unit,
                  ivid , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pvv2edata */
void soc_sbx_g3p1_pvv2edata_print(int unit, soc_sbx_g3p1_pvv2edata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vpws; w = 4;  break;
        case 1: v = e->stpstate; w = 8;  break;
        case 2: v = e->vlan; w = 4;  break;
        case 3: v = e->lpi; w = 3;  break;
        case 4: v = e->hit; w = 3;  break;
        case 5: v = e->keeporstrip; w = 11;  break;
        case 6: v = e->replace; w = 7;  break;
        case 7: v = e->vid; w = 3;  break;
        case 8: v = e->vidop; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_pvv2edata_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pvv2edata_t e0;
    soc_sbx_g3p1_pvv2edata_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int ipvv2eindex;
    void *indexpointers[1];
    indexpointers[0] = &ipvv2eindex;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_pvv2edata_get(unit,
                  ipvv2eindex  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_pvv2edata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_pvv2edata_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pvv2edata_t e0;
    soc_sbx_g3p1_pvv2edata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int ipvv2eindex;
    void *indexpointers[1];
    indexpointers[0] = &ipvv2eindex;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_pvv2edata_t_init(e);

    rv = soc_sbx_g3p1_pvv2edata_get(unit,
                  ipvv2eindex  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->vpws,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->stpstate,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->lpi,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->hit,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->keeporstrip,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->replace,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->vid,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->vidop,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_PVV2EDATA_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_pvv2edata_set(unit,
                  ipvv2eindex  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v2e */
void soc_sbx_g3p1_v2e_print(int unit, soc_sbx_g3p1_v2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pim; w = 3;  break;
        case 1: v = e->igmp; w = 4;  break;
        case 2: v = e->policerbypass; w = 13;  break;
        case 3: v = e->forceflood; w = 10;  break;
        case 4: v = e->dropunksmac; w = 11;  break;
        case 5: v = e->dropunkucast; w = 12;  break;
        case 6: v = e->dontlearn; w = 9;  break;
        case 7: v = e->vrf; w = 3;  break;
        case 8: v = e->v6mc; w = 4;  break;
        case 9: v = e->v4mc; w = 4;  break;
        case 10: v = e->laghash; w = 7;  break;
        case 11: v = e->v4uc; w = 4;  break;
        case 12: v = e->v6uc; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v2e */
int soc_sbx_g3p1_v2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_v2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v2e_t e0;
    soc_sbx_g3p1_v2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v2e_get(unit,
                  ivlan  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v2e */
int soc_sbx_g3p1_v2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_v2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v2e_t e0;
    soc_sbx_g3p1_v2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v2e_t_init(e);

    rv = soc_sbx_g3p1_v2e_get(unit,
                  ivlan  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pim,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->igmp,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->policerbypass,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->forceflood,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->dropunksmac,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->dropunkucast,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->dontlearn,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->vrf,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->v6mc,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->v4mc,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_g3p1_value_read(&e->laghash,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_g3p1_value_read(&e->v4uc,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_g3p1_value_read(&e->v6uc,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_V2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v2e_set(unit,
                  ivlan  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for vrid2e */
void soc_sbx_g3p1_vrid2e_print(int unit, soc_sbx_g3p1_vrid2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->v4_vrid0; w = 8;  break;
        case 1: v = e->v4_vrid1; w = 8;  break;
        case 2: v = e->v6_vrid0; w = 8;  break;
        case 3: v = e->v6_vrid1; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_vrid2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_vrid2e_t e0;
    soc_sbx_g3p1_vrid2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_vrid2e_get(unit,
                  ivlan  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_vrid2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_vrid2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_vrid2e_t e0;
    soc_sbx_g3p1_vrid2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_vrid2e_t_init(e);

    rv = soc_sbx_g3p1_vrid2e_get(unit,
                  ivlan  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->v4_vrid0,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->v4_vrid1,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->v6_vrid0,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->v6_vrid1,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_VRID2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_vrid2e_set(unit,
                  ivlan  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lp */
void soc_sbx_g3p1_lp_print(int unit, soc_sbx_g3p1_lp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pid; w = 3;  break;
        case 1: v = e->qos; w = 3;  break;
        case 2: v = e->useexp; w = 6;  break;
        case 3: v = e->usedscp; w = 7;  break;
        case 4: v = e->updatefdp; w = 9;  break;
        case 5: v = e->mirror; w = 6;  break;
        case 6: v = e->updaterdp; w = 9;  break;
        case 7: v = e->policer; w = 7;  break;
        case 8: v = e->typedpolice; w = 11;  break;
        case 9: v = e->mefcos; w = 6;  break;
        case 10: v = e->mef; w = 3;  break;
        case 11: v = e->ccounter; w = 8;  break;
        case 12: v = e->priclass; w = 8;  break;
        case 13: v = e->allpri; w = 6;  break;
        case 14: v = e->xtpolreplace; w = 12;  break;
        case 15: v = e->counter; w = 7;  break;
        case 16: v = e->typedcount; w = 10;  break;
        case 17: v = e->color; w = 5;  break;
        case 18: v = e->usecolor; w = 8;  break;
        case 19: v = e->oamepi; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for lp */
int soc_sbx_g3p1_lp_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_lp_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lp_t e0;
    soc_sbx_g3p1_lp_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int ilpi;
    void *indexpointers[1];
    indexpointers[0] = &ilpi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_lp_get(unit,
                  ilpi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_lp_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lp */
int soc_sbx_g3p1_lp_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_lp_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lp_t e0;
    soc_sbx_g3p1_lp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int ilpi;
    void *indexpointers[1];
    indexpointers[0] = &ilpi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_lp_t_init(e);

    rv = soc_sbx_g3p1_lp_get(unit,
                  ilpi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pid,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->qos,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->useexp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->usedscp,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->updatefdp,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->mirror,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->updaterdp,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->policer,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->typedpolice,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->mefcos,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_g3p1_value_read(&e->mef,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_g3p1_value_read(&e->ccounter,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_g3p1_value_read(&e->priclass,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        case 13: rv = soc_sbx_g3p1_value_read(&e->allpri,
                                        ed->fields[13].range, 0, argc, argv);
                    break;

        case 14: rv = soc_sbx_g3p1_value_read(&e->xtpolreplace,
                                        ed->fields[14].range, 0, argc, argv);
                    break;

        case 15: rv = soc_sbx_g3p1_value_read(&e->counter,
                                        ed->fields[15].range, 0, argc, argv);
                    break;

        case 16: rv = soc_sbx_g3p1_value_read(&e->typedcount,
                                        ed->fields[16].range, 0, argc, argv);
                    break;

        case 17: rv = soc_sbx_g3p1_value_read(&e->color,
                                        ed->fields[17].range, 0, argc, argv);
                    break;

        case 18: rv = soc_sbx_g3p1_value_read(&e->usecolor,
                                        ed->fields[18].range, 0, argc, argv);
                    break;

        case 19: rv = soc_sbx_g3p1_value_read(&e->oamepi,
                                        ed->fields[19].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_LP_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_lp_set(unit,
                  ilpi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cp */
void soc_sbx_g3p1_l2cp_print(int unit, soc_sbx_g3p1_l2cp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for l2cp */
int soc_sbx_g3p1_l2cp_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_l2cp_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cp_t e0;
    soc_sbx_g3p1_l2cp_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int ilsb;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ilsb;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_l2cp_get(unit,
                  ilsb , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_l2cp_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cp */
int soc_sbx_g3p1_l2cp_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_l2cp_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cp_t e0;
    soc_sbx_g3p1_l2cp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int ilsb;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ilsb;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_l2cp_t_init(e);

    rv = soc_sbx_g3p1_l2cp_get(unit,
                  ilsb , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->forward,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->passstp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->copy,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_L2CP_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_l2cp_set(unit,
                  ilsb , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cpslow */
void soc_sbx_g3p1_l2cpslow_print(int unit, soc_sbx_g3p1_l2cpslow_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_l2cpslow_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpslow_t e0;
    soc_sbx_g3p1_l2cpslow_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int isubcode;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &isubcode;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_l2cpslow_get(unit,
                  isubcode , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_l2cpslow_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_l2cpslow_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpslow_t e0;
    soc_sbx_g3p1_l2cpslow_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int isubcode;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &isubcode;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_l2cpslow_t_init(e);

    rv = soc_sbx_g3p1_l2cpslow_get(unit,
                  isubcode , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->forward,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->passstp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->copy,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_L2CPSLOW_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_l2cpslow_set(unit,
                  isubcode , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cpnop */
void soc_sbx_g3p1_l2cpnop_print(int unit, soc_sbx_g3p1_l2cpnop_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_l2cpnop_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpnop_t e0;
    soc_sbx_g3p1_l2cpnop_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int ii;
    void *indexpointers[1];
    indexpointers[0] = &ii;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_l2cpnop_get(unit,
                  ii  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_l2cpnop_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_l2cpnop_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpnop_t e0;
    soc_sbx_g3p1_l2cpnop_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int ii;
    void *indexpointers[1];
    indexpointers[0] = &ii;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_l2cpnop_t_init(e);

    rv = soc_sbx_g3p1_l2cpnop_get(unit,
                  ii  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->forward,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->passstp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->copy,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_L2CPNOP_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_l2cpnop_set(unit,
                  ii  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ft */
void soc_sbx_g3p1_ft_print(int unit, soc_sbx_g3p1_ft_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rridx; w = 5;  break;
        case 1: v = e->excidx; w = 6;  break;
        case 2: v = e->lenadj; w = 6;  break;
        case 3: v = e->mc; w = 2;  break;
        case 4: v = e->t; w = 1;  break;
        case 5: v = e->hc; w = 2;  break;
        case 6: v = e->oi; w = 2;  break;
        case 7: v = e->qid; w = 3;  break;
        case 8: v = e->lagbase; w = 7;  break;
        case 9: v = e->lagsize; w = 7;  break;
        case 10: v = e->lag; w = 3;  break;
        case 11: v = e->oib; w = 3;  break;
        case 12: v = e->qidb; w = 4;  break;
        case 13: v = e->lagbaseb; w = 8;  break;
        case 14: v = e->lagsizeb; w = 8;  break;
        case 15: v = e->lagb; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for ft */
int soc_sbx_g3p1_ft_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_ft_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ft_t e0;
    soc_sbx_g3p1_ft_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int ifti;
    void *indexpointers[1];
    indexpointers[0] = &ifti;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_ft_get(unit,
                  ifti  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_ft_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ft */
int soc_sbx_g3p1_ft_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_ft_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ft_t e0;
    soc_sbx_g3p1_ft_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int ifti;
    void *indexpointers[1];
    indexpointers[0] = &ifti;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_ft_t_init(e);

    rv = soc_sbx_g3p1_ft_get(unit,
                  ifti  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rridx,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->excidx,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->lenadj,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->mc,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->t,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->hc,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->oi,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->qid,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->lagbase,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->lagsize,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_g3p1_value_read(&e->lag,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_g3p1_value_read(&e->oib,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_g3p1_value_read(&e->qidb,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        case 13: rv = soc_sbx_g3p1_value_read(&e->lagbaseb,
                                        ed->fields[13].range, 0, argc, argv);
                    break;

        case 14: rv = soc_sbx_g3p1_value_read(&e->lagsizeb,
                                        ed->fields[14].range, 0, argc, argv);
                    break;

        case 15: rv = soc_sbx_g3p1_value_read(&e->lagb,
                                        ed->fields[15].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_FT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_ft_set(unit,
                  ifti  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for evp2e */
void soc_sbx_g3p1_evp2e_print(int unit, soc_sbx_g3p1_evp2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->eteptr; w = 6;  break;
        case 1: v = e->counter; w = 7;  break;
        case 2: v = e->ccounter; w = 8;  break;
        case 3: v = e->priclass; w = 8;  break;
        case 4: v = e->allpri; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for evp2e */
int soc_sbx_g3p1_evp2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_evp2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_evp2e_t e0;
    soc_sbx_g3p1_evp2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int ivlan;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivlan;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_evp2e_get(unit,
                  ivlan , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_evp2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for evp2e */
int soc_sbx_g3p1_evp2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_evp2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_evp2e_t e0;
    soc_sbx_g3p1_evp2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int ivlan;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivlan;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_evp2e_t_init(e);

    rv = soc_sbx_g3p1_evp2e_get(unit,
                  ivlan , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->eteptr,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->counter,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->ccounter,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->priclass,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->allpri,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_EVP2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_evp2e_set(unit,
                  ivlan , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oi2e */
void soc_sbx_g3p1_oi2e_print(int unit, soc_sbx_g3p1_oi2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->eteptr; w = 6;  break;
        case 1: v = e->counter; w = 7;  break;
        case 2: v = e->ccounter; w = 8;  break;
        case 3: v = e->priclass; w = 8;  break;
        case 4: v = e->allpri; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oi2e */
int soc_sbx_g3p1_oi2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_oi2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oi2e_t e0;
    soc_sbx_g3p1_oi2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int ioi;
    void *indexpointers[1];
    indexpointers[0] = &ioi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oi2e_get(unit,
                  ioi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oi2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oi2e */
int soc_sbx_g3p1_oi2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_oi2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oi2e_t e0;
    soc_sbx_g3p1_oi2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int ioi;
    void *indexpointers[1];
    indexpointers[0] = &ioi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oi2e_t_init(e);

    rv = soc_sbx_g3p1_oi2e_get(unit,
                  ioi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->eteptr,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->counter,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->ccounter,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->priclass,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->allpri,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_OI2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oi2e_set(unit,
                  ioi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for remark */
void soc_sbx_g3p1_remark_print(int unit, soc_sbx_g3p1_remark_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->cfi; w = 3;  break;
        case 1: v = e->pri; w = 3;  break;
        case 2: v = e->exp; w = 3;  break;
        case 3: v = e->dscp; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for remark */
int soc_sbx_g3p1_remark_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_remark_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_remark_t e0;
    soc_sbx_g3p1_remark_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int ie;
    int idp;
    int icos;
    int iprof;
    void *indexpointers[4];
    indexpointers[0] = &ie;
    indexpointers[1] = &idp;
    indexpointers[2] = &icos;
    indexpointers[3] = &iprof;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_remark_get(unit,
                  ie , idp , icos , iprof  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_remark_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for remark */
int soc_sbx_g3p1_remark_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_remark_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_remark_t e0;
    soc_sbx_g3p1_remark_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int ie;
    int idp;
    int icos;
    int iprof;
    void *indexpointers[4];
    indexpointers[0] = &ie;
    indexpointers[1] = &idp;
    indexpointers[2] = &icos;
    indexpointers[3] = &iprof;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_remark_t_init(e);

    rv = soc_sbx_g3p1_remark_get(unit,
                  ie , idp , icos , iprof  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->cfi,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->pri,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->exp,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->dscp,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_REMARK_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_remark_set(unit,
                  ie , idp , icos , iprof  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for epv2e */
void soc_sbx_g3p1_epv2e_print(int unit, soc_sbx_g3p1_epv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->drop; w = 4;  break;
        case 1: v = e->strip; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for epv2e */
int soc_sbx_g3p1_epv2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_epv2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_epv2e_t e0;
    soc_sbx_g3p1_epv2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_epv2e_get(unit,
                  ivid , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_epv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for epv2e */
int soc_sbx_g3p1_epv2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_epv2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_epv2e_t e0;
    soc_sbx_g3p1_epv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_epv2e_t_init(e);

    rv = soc_sbx_g3p1_epv2e_get(unit,
                  ivid , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->drop,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->strip,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_EPV2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_epv2e_set(unit,
                  ivid , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ert */
void soc_sbx_g3p1_ert_print(int unit, soc_sbx_g3p1_ert_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mirror; w = 6;  break;
        case 1: v = e->drop; w = 4;  break;
        case 2: v = e->counter; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for ert */
int soc_sbx_g3p1_ert_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_ert_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ert_t e0;
    soc_sbx_g3p1_ert_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_ert_get(unit,
                  iirule  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_ert_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ert */
int soc_sbx_g3p1_ert_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_ert_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ert_t e0;
    soc_sbx_g3p1_ert_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_ert_t_init(e);

    rv = soc_sbx_g3p1_ert_get(unit,
                  iirule  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->mirror,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->drop,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->counter,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_ERT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_ert_set(unit,
                  iirule  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_bubble */
void soc_sbx_g3p1_oam_bubble_print(int unit, soc_sbx_g3p1_oam_bubble_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->bubble_mode; w = 11;  break;
        case 1: v = e->je; w = 2;  break;
        case 2: v = e->i; w = 1;  break;
        case 3: v = e->bubble_stream; w = 13;  break;
        case 4: v = e->t; w = 1;  break;
        case 5: v = e->interval_index; w = 14;  break;
        case 6: v = e->reserved; w = 8;  break;
        case 7: v = e->count; w = 5;  break;
        case 8: v = e->timeout; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_oam_bubble_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_bubble_t e0;
    soc_sbx_g3p1_oam_bubble_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int ioamepi;
    void *indexpointers[1];
    indexpointers[0] = &ioamepi;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_bubble_get(unit,
                  ioamepi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_bubble_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_oam_bubble_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_bubble_t e0;
    soc_sbx_g3p1_oam_bubble_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int ioamepi;
    void *indexpointers[1];
    indexpointers[0] = &ioamepi;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_bubble_t_init(e);

    rv = soc_sbx_g3p1_oam_bubble_get(unit,
                  ioamepi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->bubble_mode,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->je,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->i,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->bubble_stream,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->t,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->interval_index,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->reserved,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->count,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->timeout,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_OAM_BUBBLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_bubble_set(unit,
                  ioamepi  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oamrx_p2e */
void soc_sbx_g3p1_oamrx_p2e_print(int unit, soc_sbx_g3p1_oamrx_p2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->svc_hdl; w = 7;  break;
        case 1: v = e->not_used; w = 8;  break;
        case 2: v = e->mdlvl_0_m; w = 9;  break;
        case 3: v = e->mdlvl_0_p; w = 9;  break;
        case 4: v = e->mdlvl_0_d; w = 9;  break;
        case 5: v = e->mdlvl_0_f; w = 9;  break;
        case 6: v = e->mdlvl_1_m; w = 9;  break;
        case 7: v = e->mdlvl_1_p; w = 9;  break;
        case 8: v = e->mdlvl_1_d; w = 9;  break;
        case 9: v = e->mdlvl_1_f; w = 9;  break;
        case 10: v = e->mdlvl_2_m; w = 9;  break;
        case 11: v = e->mdlvl_2_p; w = 9;  break;
        case 12: v = e->mdlvl_2_d; w = 9;  break;
        case 13: v = e->mdlvl_2_f; w = 9;  break;
        case 14: v = e->mdlvl_3_m; w = 9;  break;
        case 15: v = e->mdlvl_3_p; w = 9;  break;
        case 16: v = e->mdlvl_3_d; w = 9;  break;
        case 17: v = e->mdlvl_3_f; w = 9;  break;
        case 18: v = e->mdlvl_4_m; w = 9;  break;
        case 19: v = e->mdlvl_4_p; w = 9;  break;
        case 20: v = e->mdlvl_4_d; w = 9;  break;
        case 21: v = e->mdlvl_4_f; w = 9;  break;
        case 22: v = e->mdlvl_5_m; w = 9;  break;
        case 23: v = e->mdlvl_5_p; w = 9;  break;
        case 24: v = e->mdlvl_5_d; w = 9;  break;
        case 25: v = e->mdlvl_5_f; w = 9;  break;
        case 26: v = e->mdlvl_6_m; w = 9;  break;
        case 27: v = e->mdlvl_6_p; w = 9;  break;
        case 28: v = e->mdlvl_6_d; w = 9;  break;
        case 29: v = e->mdlvl_6_f; w = 9;  break;
        case 30: v = e->mdlvl_7_m; w = 9;  break;
        case 31: v = e->mdlvl_7_p; w = 9;  break;
        case 32: v = e->mdlvl_7_d; w = 9;  break;
        case 33: v = e->mdlvl_7_f; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_oamrx_p2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oamrx_p2e_t e0;
    soc_sbx_g3p1_oamrx_p2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int idir;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &idir;
    indexpointers[1] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oamrx_p2e_get(unit,
                  idir , iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oamrx_p2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_oamrx_p2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oamrx_p2e_t e0;
    soc_sbx_g3p1_oamrx_p2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int idir;
    int iport;
    void *indexpointers[2];
    indexpointers[0] = &idir;
    indexpointers[1] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oamrx_p2e_t_init(e);

    rv = soc_sbx_g3p1_oamrx_p2e_get(unit,
                  idir , iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->svc_hdl,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->not_used,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_m,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_p,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_d,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_f,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_m,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_p,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_d,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_f,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_m,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_p,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_d,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        case 13: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_f,
                                        ed->fields[13].range, 0, argc, argv);
                    break;

        case 14: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_m,
                                        ed->fields[14].range, 0, argc, argv);
                    break;

        case 15: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_p,
                                        ed->fields[15].range, 0, argc, argv);
                    break;

        case 16: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_d,
                                        ed->fields[16].range, 0, argc, argv);
                    break;

        case 17: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_f,
                                        ed->fields[17].range, 0, argc, argv);
                    break;

        case 18: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_m,
                                        ed->fields[18].range, 0, argc, argv);
                    break;

        case 19: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_p,
                                        ed->fields[19].range, 0, argc, argv);
                    break;

        case 20: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_d,
                                        ed->fields[20].range, 0, argc, argv);
                    break;

        case 21: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_f,
                                        ed->fields[21].range, 0, argc, argv);
                    break;

        case 22: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_m,
                                        ed->fields[22].range, 0, argc, argv);
                    break;

        case 23: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_p,
                                        ed->fields[23].range, 0, argc, argv);
                    break;

        case 24: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_d,
                                        ed->fields[24].range, 0, argc, argv);
                    break;

        case 25: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_f,
                                        ed->fields[25].range, 0, argc, argv);
                    break;

        case 26: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_m,
                                        ed->fields[26].range, 0, argc, argv);
                    break;

        case 27: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_p,
                                        ed->fields[27].range, 0, argc, argv);
                    break;

        case 28: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_d,
                                        ed->fields[28].range, 0, argc, argv);
                    break;

        case 29: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_f,
                                        ed->fields[29].range, 0, argc, argv);
                    break;

        case 30: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_m,
                                        ed->fields[30].range, 0, argc, argv);
                    break;

        case 31: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_p,
                                        ed->fields[31].range, 0, argc, argv);
                    break;

        case 32: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_d,
                                        ed->fields[32].range, 0, argc, argv);
                    break;

        case 33: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_f,
                                        ed->fields[33].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_OAMRX_P2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oamrx_p2e_set(unit,
                  idir , iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_peer_state */
void soc_sbx_g3p1_oam_peer_state_print(int unit, soc_sbx_g3p1_oam_peer_state_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rdi_ack; w = 7;  break;
        case 1: v = e->rdi_state; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_oam_peer_state_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_peer_state_t e0;
    soc_sbx_g3p1_oam_peer_state_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int ipeer_idx;
    void *indexpointers[1];
    indexpointers[0] = &ipeer_idx;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_peer_state_get(unit,
                  ipeer_idx  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_peer_state_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_oam_peer_state_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_peer_state_t e0;
    soc_sbx_g3p1_oam_peer_state_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int ipeer_idx;
    void *indexpointers[1];
    indexpointers[0] = &ipeer_idx;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_peer_state_t_init(e);

    rv = soc_sbx_g3p1_oam_peer_state_get(unit,
                  ipeer_idx  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rdi_ack,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->rdi_state,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_OAM_PEER_STATE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_peer_state_set(unit,
                  ipeer_idx  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ptp_compensation */
void soc_sbx_g3p1_ptp_compensation_print(int unit, soc_sbx_g3p1_ptp_compensation_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->compensation; w = 12;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_ptp_compensation_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ptp_compensation_t e0;
    soc_sbx_g3p1_ptp_compensation_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int iport;
    void *indexpointers[1];
    indexpointers[0] = &iport;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_ptp_compensation_get(unit,
                  iport  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_ptp_compensation_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_ptp_compensation_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ptp_compensation_t e0;
    soc_sbx_g3p1_ptp_compensation_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int iport;
    void *indexpointers[1];
    indexpointers[0] = &iport;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_ptp_compensation_t_init(e);

    rv = soc_sbx_g3p1_ptp_compensation_get(unit,
                  iport  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->compensation,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_PTP_COMPENSATION_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_ptp_compensation_set(unit,
                  iport  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for bfd_ld2edata */
void soc_sbx_g3p1_bfd_ld2edata_print(int unit, soc_sbx_g3p1_bfd_ld2edata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->wdg_id; w = 6;  break;
        case 1: v = e->slowstart; w = 9;  break;
        case 2: v = e->rdmode; w = 6;  break;
        case 3: v = e->rstate; w = 6;  break;
        case 4: v = e->f; w = 1;  break;
        case 5: v = e->poll; w = 4;  break;
        case 6: v = e->sta; w = 3;  break;
        case 7: v = e->ldiag; w = 5;  break;
        case 8: v = e->version; w = 7;  break;
        case 9: v = e->rdiscri; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_bfd_ld2edata_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2edata_t e0;
    soc_sbx_g3p1_bfd_ld2edata_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int iptr;
    void *indexpointers[1];
    indexpointers[0] = &iptr;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_bfd_ld2edata_get(unit,
                  iptr  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_bfd_ld2edata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_bfd_ld2edata_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2edata_t e0;
    soc_sbx_g3p1_bfd_ld2edata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int iptr;
    void *indexpointers[1];
    indexpointers[0] = &iptr;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_bfd_ld2edata_t_init(e);

    rv = soc_sbx_g3p1_bfd_ld2edata_get(unit,
                  iptr  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->wdg_id,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->slowstart,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_g3p1_value_read(&e->rdmode,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_g3p1_value_read(&e->rstate,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_g3p1_value_read(&e->f,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_g3p1_value_read(&e->poll,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_g3p1_value_read(&e->sta,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_g3p1_value_read(&e->ldiag,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_g3p1_value_read(&e->version,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_g3p1_value_read(&e->rdiscri,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_BFD_LD2EDATA_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_bfd_ld2edata_set(unit,
                  iptr  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for bfd_ld2edatac */
void soc_sbx_g3p1_bfd_ld2edatac_print(int unit, soc_sbx_g3p1_bfd_ld2edatac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rMinRxInterval; w = 14;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_bfd_ld2edatac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2edatac_t e0;
    soc_sbx_g3p1_bfd_ld2edatac_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int iptr;
    void *indexpointers[1];
    indexpointers[0] = &iptr;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_bfd_ld2edatac_get(unit,
                  iptr  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_bfd_ld2edatac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_bfd_ld2edatac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2edatac_t e0;
    soc_sbx_g3p1_bfd_ld2edatac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int iptr;
    void *indexpointers[1];
    indexpointers[0] = &iptr;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_bfd_ld2edatac_t_init(e);

    rv = soc_sbx_g3p1_bfd_ld2edatac_get(unit,
                  iptr  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rMinRxInterval,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_BFD_LD2EDATAC_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_bfd_ld2edatac_set(unit,
                  iptr  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for sample6 */
void soc_sbx_g3p1_sample6_print(int unit, soc_sbx_g3p1_sample6_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->test6; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for sample6 */
int soc_sbx_g3p1_sample6_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_sample6_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample6_t e0;
    soc_sbx_g3p1_sample6_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int itest6i;
    void *indexpointers[1];
    indexpointers[0] = &itest6i;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_sample6_get(unit,
                  itest6i  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_sample6_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for sample6 */
int soc_sbx_g3p1_sample6_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_sample6_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample6_t e0;
    soc_sbx_g3p1_sample6_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int itest6i;
    void *indexpointers[1];
    indexpointers[0] = &itest6i;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_sample6_t_init(e);

    rv = soc_sbx_g3p1_sample6_get(unit,
                  itest6i  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->test6,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_SAMPLE6_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_sample6_set(unit,
                  itest6i  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for sample8 */
void soc_sbx_g3p1_sample8_print(int unit, soc_sbx_g3p1_sample8_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->test8; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for sample8 */
int soc_sbx_g3p1_sample8_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_sample8_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample8_t e0;
    soc_sbx_g3p1_sample8_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int itest8i;
    void *indexpointers[1];
    indexpointers[0] = &itest8i;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_sample8_get(unit,
                  itest8i  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_sample8_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for sample8 */
int soc_sbx_g3p1_sample8_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_sample8_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample8_t e0;
    soc_sbx_g3p1_sample8_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int itest8i;
    void *indexpointers[1];
    indexpointers[0] = &itest8i;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_sample8_t_init(e);

    rv = soc_sbx_g3p1_sample8_get(unit,
                  itest8i  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->test8,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_SAMPLE8_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_sample8_set(unit,
                  itest8i  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for sample9 */
void soc_sbx_g3p1_sample9_print(int unit, soc_sbx_g3p1_sample9_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->test9; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for sample9 */
int soc_sbx_g3p1_sample9_shell_print(int unit, int argc, char **argv);

int soc_sbx_g3p1_sample9_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample9_t e0;
    soc_sbx_g3p1_sample9_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int itest9i;
    void *indexpointers[1];
    indexpointers[0] = &itest9i;

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_sample9_get(unit,
                  itest9i  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_sample9_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for sample9 */
int soc_sbx_g3p1_sample9_shell_set(int unit, int argc, char **argv);
int soc_sbx_g3p1_sample9_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample9_t e0;
    soc_sbx_g3p1_sample9_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int itest9i;
    void *indexpointers[1];
    indexpointers[0] = &itest9i;


    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_sample9_t_init(e);

    rv = soc_sbx_g3p1_sample9_get(unit,
                  itest9i  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_g3p1_value_read(&e->test9,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_g3p1_ocm_update_overlaps(unit, SOC_SBX_G3P1_SAMPLE9_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_sample9_set(unit,
                  itest9i  ,
                e);
    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/*
 * Shell entry print implementation
 */
int soc_sbx_g3p1_entries_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_g3p1_entries_shell_print(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G3P1_QOS_ID:
        rv = soc_sbx_g3p1_qos_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_DSCPQOS_ID:
        rv = soc_sbx_g3p1_dscpqos_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_IRT_ID:
        rv = soc_sbx_g3p1_irt_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_LAG_ID:
        rv = soc_sbx_g3p1_lag_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_RRT_ID:
        rv = soc_sbx_g3p1_rrt_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_XT_ID:
        rv = soc_sbx_g3p1_xt_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_MIRROR_ID:
        rv = soc_sbx_g3p1_mirror_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_EMIRROR_ID:
        rv = soc_sbx_g3p1_emirror_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_MACAGE_ID:
        rv = soc_sbx_g3p1_macage_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_MST_ID:
        rv = soc_sbx_g3p1_mst_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_PV2E_ID:
        rv = soc_sbx_g3p1_pv2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_P2APPDATA_ID:
        rv = soc_sbx_g3p1_p2appdata_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_PV2APPDATA_ID:
        rv = soc_sbx_g3p1_pv2appdata_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_PVV2EDATA_ID:
        rv = soc_sbx_g3p1_pvv2edata_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_V2E_ID:
        rv = soc_sbx_g3p1_v2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_VRID2E_ID:
        rv = soc_sbx_g3p1_vrid2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_LP_ID:
        rv = soc_sbx_g3p1_lp_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_L2CP_ID:
        rv = soc_sbx_g3p1_l2cp_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_L2CPSLOW_ID:
        rv = soc_sbx_g3p1_l2cpslow_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_L2CPNOP_ID:
        rv = soc_sbx_g3p1_l2cpnop_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_FT_ID:
        rv = soc_sbx_g3p1_ft_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_EVP2E_ID:
        rv = soc_sbx_g3p1_evp2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_OI2E_ID:
        rv = soc_sbx_g3p1_oi2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_REMARK_ID:
        rv = soc_sbx_g3p1_remark_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_EPV2E_ID:
        rv = soc_sbx_g3p1_epv2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_ERT_ID:
        rv = soc_sbx_g3p1_ert_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_OAM_BUBBLE_ID:
        rv = soc_sbx_g3p1_oam_bubble_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_OAMRX_P2E_ID:
        rv = soc_sbx_g3p1_oamrx_p2e_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_OAM_PEER_STATE_ID:
        rv = soc_sbx_g3p1_oam_peer_state_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_PTP_COMPENSATION_ID:
        rv = soc_sbx_g3p1_ptp_compensation_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_BFD_LD2EDATA_ID:
        rv = soc_sbx_g3p1_bfd_ld2edata_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_BFD_LD2EDATAC_ID:
        rv = soc_sbx_g3p1_bfd_ld2edatac_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_SAMPLE6_ID:
        rv = soc_sbx_g3p1_sample6_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_SAMPLE8_ID:
        rv = soc_sbx_g3p1_sample8_shell_print(unit, argc, argv); 
        break;

    case SOC_SBX_G3P1_SAMPLE9_ID:
        rv = soc_sbx_g3p1_sample9_shell_print(unit, argc, argv); 
        break;

    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
int soc_sbx_g3p1_entries_shell_set(int unit, int eid, int argc, char **argv);
int soc_sbx_g3p1_entries_shell_set(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G3P1_QOS_ID:
        rv = soc_sbx_g3p1_qos_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_DSCPQOS_ID:
        rv = soc_sbx_g3p1_dscpqos_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_IRT_ID:
        rv = soc_sbx_g3p1_irt_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_LAG_ID:
        rv = soc_sbx_g3p1_lag_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_RRT_ID:
        rv = soc_sbx_g3p1_rrt_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_XT_ID:
        rv = soc_sbx_g3p1_xt_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_MIRROR_ID:
        rv = soc_sbx_g3p1_mirror_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_EMIRROR_ID:
        rv = soc_sbx_g3p1_emirror_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_MACAGE_ID:
        rv = soc_sbx_g3p1_macage_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_MST_ID:
        rv = soc_sbx_g3p1_mst_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_PV2E_ID:
        rv = soc_sbx_g3p1_pv2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_P2APPDATA_ID:
        rv = soc_sbx_g3p1_p2appdata_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_PV2APPDATA_ID:
        rv = soc_sbx_g3p1_pv2appdata_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_PVV2EDATA_ID:
        rv = soc_sbx_g3p1_pvv2edata_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_V2E_ID:
        rv = soc_sbx_g3p1_v2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_VRID2E_ID:
        rv = soc_sbx_g3p1_vrid2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_LP_ID:
        rv = soc_sbx_g3p1_lp_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_L2CP_ID:
        rv = soc_sbx_g3p1_l2cp_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_L2CPSLOW_ID:
        rv = soc_sbx_g3p1_l2cpslow_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_L2CPNOP_ID:
        rv = soc_sbx_g3p1_l2cpnop_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_FT_ID:
        rv = soc_sbx_g3p1_ft_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_EVP2E_ID:
        rv = soc_sbx_g3p1_evp2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_OI2E_ID:
        rv = soc_sbx_g3p1_oi2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_REMARK_ID:
        rv = soc_sbx_g3p1_remark_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_EPV2E_ID:
        rv = soc_sbx_g3p1_epv2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_ERT_ID:
        rv = soc_sbx_g3p1_ert_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_OAM_BUBBLE_ID:
        rv = soc_sbx_g3p1_oam_bubble_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_OAMRX_P2E_ID:
        rv = soc_sbx_g3p1_oamrx_p2e_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_OAM_PEER_STATE_ID:
        rv = soc_sbx_g3p1_oam_peer_state_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_PTP_COMPENSATION_ID:
        rv = soc_sbx_g3p1_ptp_compensation_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_BFD_LD2EDATA_ID:
        rv = soc_sbx_g3p1_bfd_ld2edata_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_BFD_LD2EDATAC_ID:
        rv = soc_sbx_g3p1_bfd_ld2edatac_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_SAMPLE6_ID:
        rv = soc_sbx_g3p1_sample6_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_SAMPLE8_ID:
        rv = soc_sbx_g3p1_sample8_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_G3P1_SAMPLE9_ID:
        rv = soc_sbx_g3p1_sample9_shell_set(unit, argc, argv); 
        break;
        
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}


/* entry diag shell delete implementation for ifp */


int
soc_sbx_g3p1_memory_shell_print(int unit,
         int mid, int argc, char **argv)
{
    int rv, i;
    uint32 addr, v, range;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_bank_t *tb = NULL; 
    soc_sbx_g3p1_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int sidx, eidx;
    uint32 segment;

    if (argc < 2) {
        cli_out("missing parameters\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g3p1_read(argv[0], 128 , &segment);
    if (rv) {
        cli_out("illegal segment %s\n", argv[0]);
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g3p1_read(argv[1], 1 << 23, &addr);
    if (rv) {
        cli_out("illegal address %s\n", argv[1]);
        return SOC_E_PARAM;
    }

    range = 1;
    if (argc > 2) {
        rv = soc_sbx_g3p1_read(argv[2], 1 << 23, &range);
        if (rv) {
            cli_out("illegal range %s\n", argv[1]);
            return SOC_E_PARAM;
        }
    }

    rv = soc_sbx_g3p1_table_bank_get(tm, md->ocmport, segment, (int) addr, &tb);
    if (rv) {
        cli_out("Segment(%d) Not mapped or Address 0x%x Out Of Range\n", segment, addr);
        return rv;
    }

    if (range > tb->limit - tb->base) {
        cli_out("Range %d beyond segment limits\n", range);
        return SOC_E_PARAM;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    sidx = addr;
    eidx = addr + ((range << 6) / tb->width);

    rv = soc_sbx_caladan3_ocm_port_mem_read(unit, tb->memory, tb->segment, 
                   sidx, eidx, (uint32 *)tm->entrydmabuf);
    if (SOC_SUCCESS(rv)) 
        soc_sbx_caladan3_cmic_endian(tm->entrydmabuf, mwidth/8);
    if (rv) {
        cli_out("memory read from %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    for (i = 0; i < 2*range; i++) {
      if (!(i & 1)) {
        cli_out("%s[0x%x]=",  tm->memories[mid].name, addr+(i>>1));
      }

      v = tm->entrydmabuf[i * 4 + 3]
          | (tm->entrydmabuf[i * 4 + 2] << 8)
          | (tm->entrydmabuf[i * 4 + 1] << 16)
          | (tm->entrydmabuf[i * 4 + 0] << 24); 

      soc_sbx_g3p1_print(-1, v);
      cli_out(" ");
      if ((i & 1)) {
        cli_out("\n");
      }
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}
/* Diag shell set memory contents */
int
soc_sbx_g3p1_memory_shell_set(int unit, 
         int mid, int argc, char **argv)
{
    int rv, i;
    uint32 v, addr, range;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_bank_t *tb = NULL; 
    soc_sbx_g3p1_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int sidx = 0;
    int eidx = 0;
    uint32 segment;

    if (argc < 4) {
        cli_out("missing parameters\n");
        return SOC_E_PARAM;
    }

    rv = soc_sbx_g3p1_read(argv[0], 128 , &segment);
    if (rv) {
        cli_out("illegal segment %s\n", argv[0]);
        return SOC_E_PARAM;
    }
    argc--;
    argv++;

    rv = soc_sbx_g3p1_read(argv[0], 1 << 23, &addr);
    if (rv) {
        cli_out("illegal address %s\n", argv[1]);
        return SOC_E_PARAM;
    }
    argc--;
    argv++;

    range = 1;
    rv = soc_sbx_g3p1_read(argv[0], 1 << 23, &range);

    if (rv) {
        cli_out("illegal range %s\n", argv[1]);
        return SOC_E_PARAM;
    }

    argc--;
    argv++;

    rv = soc_sbx_g3p1_table_bank_get(tm, md->ocmport, segment, (int) addr, &tb);
    if (rv) {
        cli_out("Segment(%d) Not mapped or Address 0x%x out of range\n", segment, addr);
        return rv;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    for (i = 0; i < 2*range; i++) {
        if (!argc) {
            cli_out("missing value\n");
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }

        rv = soc_sbx_g3p1_read(argv[0], -1, &v);
 
        if (rv) {
            cli_out("illegal value '%s'\n", argv[i + 1]);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }

        tm->entrydmabuf[i * 4 + 3] = v;
        tm->entrydmabuf[i * 4 + 2] = v >> 8;
        tm->entrydmabuf[i * 4 + 1] = v >> 16;
        tm->entrydmabuf[i * 4 + 0] = v >> 24; 

        argc--;
        argv++;
    }

    sidx = addr;
    eidx = addr + ((range << 6) / tb->width);

    soc_sbx_caladan3_cmic_endian(tm->entrydmabuf, mwidth/8);
    rv = soc_sbx_caladan3_ocm_port_mem_write(unit, tb->memory, tb->segment,
                   sidx, eidx, (uint32 *)tm->entrydmabuf);
    if (rv) {
        cli_out("memory write to %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_g3p1_ocm_associated_table_info_dump(int unit, 
                                                     soc_sbx_g3p1_table_id_t table_id,
                                                     int table_bank_id, int detail)
 {
     int index;
     int entry;
     soc_sbx_g3p1_state_t *fe =
         (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
     soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
     soc_sbx_g3p1_entry_desc_t *ed;
     soc_sbx_g3p1_table_desc_t *tablePtr;

     /* The Entry Ids and Table Ids correspond one for one throughout 
      * all of g3p1_defs.[c|h] code. If that EVER changes this function will
      * require a conversion routine to covert between the two ID number spaces!
      */
     if (table_id > SOC_SBX_G3P1_TABLE_MAX_ID) {
         return 1;
     }
     ed = &tm->entries[table_id];

     tablePtr = &tm->tables[table_id];

     if (!ed->name) {
        return 1;
     }

     if (!tablePtr->name) {
         return 1;
     }

     if (!detail) {
         cli_out("%12s  %2d    %2d         %-24s:%2d  %2d\n",
                 tablePtr->name, table_id, table_bank_id,
                 soc_sbx_ocm_port_num_to_name(
                 tm->tables[table_id].banks[table_bank_id].memory),
                 tm->tables[table_id].banks[table_bank_id].memory,
                 tm->tables[table_id].banks[table_bank_id].segment);
         return 0;
     }
     cli_out("\n======\n");
     cli_out("Table [%s]  Id [%d]  Bank [%d] --> OCM Port[%s:%d]   Segment[%d]\n", 
             tablePtr->name, table_id, table_bank_id, 
             soc_sbx_ocm_port_num_to_name(tm->tables[table_id].banks[table_bank_id].memory),
             tm->tables[table_id].banks[table_bank_id].memory,
             tm->tables[table_id].banks[table_bank_id].segment);

     cli_out("\nTable INDEX:");

     for (index = 0; index < ed->nindexes; index++) {
     cli_out("%s%s[%d:%d]",
             (index? ",  ":"\n    < "), 
             ed->indexes[index].name, 
             ed->indexes[index].pos, 
             ed->indexes[index].pos + (ed->indexes[index].width - 1) );
     }
     cli_out(" >\n");

     cli_out("\nTable FIELD(s):");
     for (entry = 0; entry < ed->nfields; entry++) {
         cli_out("%s%s[%d:%d]",
                 (entry? "":"\n    { "),  
                 ed->fields[entry].name, 
                 ed->fields[entry].pos, 
                 ed->fields[entry].pos + (ed->fields[entry].width - 1));

         if (!((entry+1)%4) && entry != ed->nfields - 1) {
             cli_out(",\n      ");
         } else {
             if (entry == ed->nfields - 1) {
                 cli_out(" }\n");
             } else {
                 cli_out(",  ");
             }
         }
     }

     cli_out("\nTable BANK Info:\n");

     cli_out("\n    Sz[%d](unused by OCM)   Limit[%d]  Base[%d]  Width[%d]",
             tm->tables[table_id].banks[table_bank_id].size,
             tm->tables[table_id].banks[table_bank_id].limit,
             tm->tables[table_id].banks[table_bank_id].base,
             tm->tables[table_id].banks[table_bank_id].width);

     cli_out("\n==================================================================");
     cli_out("\n\n");

     return 0;
 }

STATIC 
char* soc_sbx_g3p1_ocm_port_to_lrp_port(int unit, sbx_caladan3_ocm_port_e_t mem) 
{
    int i;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    for (i=0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) { 
        if (tm->memories[i].ocmport == mem) { 
            break; 
        }
    }
    return ((i < SOC_SBX_G3P1_MEMORY_MAX_ID) ? tm->memories[i].name : "not found");
}    

int soc_sbx_g3p1_memory_map_shell_print(int unit, char *name);
int soc_sbx_g3p1_memory_map_shell_print(int unit, char *name)
{
    int i, j, base0, size0, slen;
    int fw = 20;
    char *s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = NULL;
    soc_sbx_g3p1_memory_bank_desc_t *mb;

    if (name) {
        for (i = 0; i < SOC_SBX_G3P1_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            if (!sal_strcasecmp(td->name, name)) {
                cli_out("\nMemory map for table %s\n", name);
                cli_out("Bank   LRPPort CPUPort  Segment Width    Base       Size\n");
                cli_out("-----------------------------------------"
                        "---------------\n");

                for (j = 0; j < td->nbanks; j++) {
                    cli_out("%-6d%-11s%-8d%-8d%-7d0x%08x 0x%06x\n",
                            j, soc_sbx_g3p1_ocm_port_to_lrp_port(unit, td->banks[j].memory),
                            td->banks[j].memory,
                            td->banks[j].segment,
                            td->banks[j].width,
                            td->banks[j].base, td->banks[j].limit - td->banks[j].base);
                }
                cli_out("\n");
                return SOC_E_NONE;
            }
        }
        return SOC_E_PARAM;
    } else {
        for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
            if (tm->memories[i].nbanks) {
                cli_out("\nMemory map for %s", tm->memories[i].name);
                if (tm->memories[i].dma) {
                    cli_out(" (cpu port %d)", tm->memories[i].ocmport);
                }
                cli_out("\n%-*s%s\n",
                        fw, "Element", "Segment    Width    Base      Size");
                cli_out("------------------------------------------"
                        "------------------------\n");
                for (j = 0; j < tm->memories[i].nbanks; j++) {
                    mb = &tm->memories[i].banks[j];
                    soc_sbx_g3p1_memory_bank_params_get(&base0, &size0, mb, tm);
                    
                    switch (mb->type) {
                    case SOC_SBX_G3P1_TABLE_BANK_TYPE:
                        td = &tm->tables[mb->number];
                        cli_out("%s", td->name);
                        slen = sal_strlen(td->name);
                        if (td->nbanks > 1) {
                            cli_out("%c", '0' + mb->bank);
                            slen++;
                        }
                        cli_out("%*s", fw - slen, "");
                        break;
                    case SOC_SBX_G3P1_COUNTER_BANK_TYPE:
                        s = "counter bank";
                        slen = sal_strlen(s);
                        cli_out("%s %-2d", s, mb->number);
                        cli_out("%*s", fw - slen - 3, "");
                        break;
                    case SOC_SBX_G3P1_POLICER_BANK_TYPE:
                        s = "policer bank";
                        slen = sal_strlen(s);
                        cli_out("%s %-2d", s, mb->number);
                        cli_out("%*s", fw - slen - 3, "");
                    }

                    if (td != NULL) {
                      cli_out("%3d%10d    0x%06x 0x%06x\n",
                              td->banks[mb->bank].segment, 
                              td->banks[mb->bank].width, 
                              base0, size0);
                    } else {
                      cli_out("\n");
                    }
                }
            }
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell constant print driver implementation
 */
int soc_sbx_g3p1_shell_print_constants(int unit, int argc, char **argv)
{
    int i;
    int bank_id = 0;
    int table_id = 0;
    int detail = 0;
    int  ocmmemdump = 0;    
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

   if (!sal_strcasecmp(argv[0], "ocmmemdetail")) {
       detail = 1;
       ocmmemdump = 1;

       if (argc > 2) {
           cli_out("extra arguments to ocmmemmap command\n");
       }
   }

   if (!sal_strcasecmp(argv[0], "ocmmemmap")) {
       detail = 0;
       ocmmemdump = 1;

       if (argc > 2) {
           cli_out("extra arguments to ocmmemmap command\n");
       }
   }

   if (ocmmemdump) {
       cli_out("\n===================================================\n");
       cli_out("OCM Memory Info");
       cli_out("\n===================================================\n\n");

       if (!detail) {
           cli_out("Table: Name   Id    Bank  --->  OCM Port                          Seg\n"); 
           cli_out("======================================================================\n");
       }

       for (table_id = 0; table_id < SOC_SBX_G3P1_TABLE_MAX_ID; table_id++) {
           if (!tm->tables[table_id].name) {
               continue;
           }
           for (bank_id = 0; bank_id < tm->tables[table_id].nbanks; bank_id++) {
               soc_sbx_g3p1_ocm_associated_table_info_dump(unit, 
                                                               table_id, bank_id, detail);
           }
       }
       return SOC_E_NONE;
   }

    for (i = 0; i < SOC_SBX_G3P1_CONSTANT_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0],"all")) {
          soc_sbx_g3p1_constant_shell_print(unit, i);
        } else if (!sal_strcasecmp(argv[0], tm->constants[i].name)) {
          return soc_sbx_g3p1_constant_shell_print(unit, i);
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell global print driver implementation
 */
int soc_sbx_g3p1_shell_print_globals(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
          return soc_sbx_g3p1_global_shell_print(unit, i);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell mem print driver implementation
 */
int soc_sbx_g3p1_shell_print_memories(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g3p1_memory_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_g3p1_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_entries_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    if (!sal_strcasecmp(argv[0], "memmap")) {
        if (argc > 2) {
            cli_out("extra arguments to memmap command\n");
        }
        return soc_sbx_g3p1_memory_map_shell_print(unit,
                         argc > 1 ? argv[1] : NULL);
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell global set driver implementation
 */
int soc_sbx_g3p1_shell_set_globals(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
            return soc_sbx_g3p1_global_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell memory set driver implementation
 */
int soc_sbx_g3p1_shell_set_memories(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g3p1_memory_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_g3p1_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_entries_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
/*
 * Shell entry delete implementation
 */
int soc_sbx_g3p1_entries_shell_delete(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_g3p1_entries_shell_delete(int unit, 
         int eid, int argc, char **argv)
{
    return SOC_E_NOT_FOUND;
}
 
int soc_sbx_g3p1_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_entries_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/* Shell get command usage string */
char soc_sbx_g3p1_mem_get_usage[] =
"g3p1memget <memory> <segment> <addr> [<range>]   \n"
"     supported memories are:                     \n"
"         lrp_port0 lrp_port1 lrp_port2 lrp_port3 \n"
"         lrp_port4 lrp_port5 lrp_port6 lrp_port7 \n"
"         lrp_port8 lrp_port9                     \n"
;

/* Shell set command usage string */
char soc_sbx_g3p1_mem_set_usage[] =
"g3p1memset <memory>  <segment> <addr> <range> <32'h value> <32'h value> ... \n"
"     supported memories are:                     \n"
"         lrp_port0 lrp_port1 lrp_port2 lrp_port3 \n"
"         lrp_port4 lrp_port5 lrp_port6 lrp_port7 \n"
"         lrp_port8 lrp_port9                     \n"
;

/* Shell get command usage string */
char soc_sbx_g3p1_get_usage[] =
"g3p1get [<table> idx0=<i0> ...|\n"
"          |memmap [table]]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        qos               \n"
"                         de=<de> \n" 
"                         pri=<pri> \n" 
"                         prof=<prof> \n" 
"        dscpqos               \n"
"                         dscp=<dscp> \n" 
"                         prof=<prof> \n" 
"        irt               \n"
"                         irule=<irule> \n" 
"        lag               \n"
"                         lagi=<lagi> \n" 
"        rrt               \n"
"                         rri=<rri> \n" 
"        xt               \n"
"                         xi=<xi> \n" 
"        mirror               \n"
"                         mi=<mi> \n" 
"        emirror               \n"
"                         mi=<mi> \n" 
"        macage               \n"
"                         macindex=<macindex> \n" 
"        mst               \n"
"                         msti=<msti> \n" 
"        pv2e               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"        p2appdata               \n"
"                         port=<port> \n" 
"        pv2appdata               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"        pvv2edata               \n"
"                         pvv2eindex=<pvv2eindex> \n" 
"        v2e               \n"
"                         vlan=<vlan> \n" 
"        vrid2e               \n"
"                         vlan=<vlan> \n" 
"        lp               \n"
"                         lpi=<lpi> \n" 
"        l2cp               \n"
"                         lsb=<lsb> \n" 
"                         port=<port> \n" 
"        l2cpslow               \n"
"                         subcode=<subcode> \n" 
"                         port=<port> \n" 
"        l2cpnop               \n"
"                         i=<i> \n" 
"        ft               \n"
"                         fti=<fti> \n" 
"        evp2e               \n"
"                         vlan=<vlan> \n" 
"                         port=<port> \n" 
"        oi2e               \n"
"                         oi=<oi> \n" 
"        remark               \n"
"                         e=<e> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         prof=<prof> \n" 
"        epv2e               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"        ert               \n"
"                         irule=<irule> \n" 
"        oam_bubble               \n"
"                         oamepi=<oamepi> \n" 
"        oamrx_p2e               \n"
"                         dir=<dir> \n" 
"                         port=<port> \n" 
"        oam_peer_state               \n"
"                         peer_idx=<peer_idx> \n" 
"        ptp_compensation               \n"
"                         port=<port> \n" 
"        bfd_ld2edata               \n"
"                         ptr=<ptr> \n" 
"        bfd_ld2edatac               \n"
"                         ptr=<ptr> \n" 
"        sample6               \n"
"                         test6i=<test6i> \n" 
"        sample8               \n"
"                         test8i=<test8i> \n" 
"        sample9               \n"
"                         test9i=<test9i> \n" 
#endif
;
/* Shell set command usage string */
char soc_sbx_g3p1_set_usage[] =
"g3p1set [<table> idx0=<i0> ...[field0=<f0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        qos               \n"
"                         de=<de> \n" 
"                         pri=<pri> \n" 
"                         prof=<prof> \n" 
"                         [ \n"
"                         e=<e> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         fcos=<fcos> \n" 
"                         mefcos=<mefcos> \n" 
"                         ] \n"
"        dscpqos               \n"
"                         dscp=<dscp> \n" 
"                         prof=<prof> \n" 
"                         [ \n"
"                         e=<e> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         fcos=<fcos> \n" 
"                         mefcos=<mefcos> \n" 
"                         ] \n"
"        irt               \n"
"                         irule=<irule> \n" 
"                         [ \n"
"                         vlan=<vlan> \n" 
"                         ftidx=<ftidx> \n" 
"                         mirror=<mirror> \n" 
"                         usevlan=<usevlan> \n" 
"                         useftidx=<useftidx> \n" 
"                         copy=<copy> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         fcos=<fcos> \n" 
"                         usedp=<usedp> \n" 
"                         usecos=<usecos> \n" 
"                         policer=<policer> \n" 
"                         typedpolice=<typedpolice> \n" 
"                         mefcos=<mefcos> \n" 
"                         mef=<mef> \n" 
"                         ] \n"
"        lag               \n"
"                         lagi=<lagi> \n" 
"                         [ \n"
"                         qid=<qid> \n" 
"                         oi=<oi> \n" 
"                         ] \n"
"        rrt               \n"
"                         rri=<rri> \n" 
"                         [ \n"
"                         backup=<backup> \n" 
"                         ] \n"
"        xt               \n"
"                         xi=<xi> \n" 
"                         [ \n"
"                         forward=<forward> \n" 
"                         dp=<dp> \n" 
"                         qid=<qid> \n" 
"                         fwdid=<fwdid> \n" 
"                         trunc=<trunc> \n" 
"                         learn=<learn> \n" 
"                         ppspolice=<ppspolice> \n" 
"                         policer=<policer> \n" 
"                         ] \n"
"        mirror               \n"
"                         mi=<mi> \n" 
"                         [ \n"
"                         yellow=<yellow> \n" 
"                         qid=<qid> \n" 
"                         oi=<oi> \n" 
"                         ] \n"
"        emirror               \n"
"                         mi=<mi> \n" 
"                         [ \n"
"                         yellow=<yellow> \n" 
"                         qid=<qid> \n" 
"                         oi=<oi> \n" 
"                         dqueue=<dqueue> \n" 
"                         local=<local> \n" 
"                         ] \n"
"        macage               \n"
"                         macindex=<macindex> \n" 
"                         [ \n"
"                         age=<age> \n" 
"                         ] \n"
"        mst               \n"
"                         msti=<msti> \n" 
"                         [ \n"
"                         learn=<learn> \n" 
"                         pim=<pim> \n" 
"                         igmp=<igmp> \n" 
"                         rtcopy=<rtcopy> \n" 
"                         l2cpcopy=<l2cpcopy> \n" 
"                         dcopy=<dcopy> \n" 
"                         ipredirect=<ipredirect> \n" 
"                         learn_bmac=<learn_bmac> \n" 
"                         mirroridx=<mirroridx> \n" 
"                         vsi=<vsi> \n" 
"                         ] \n"
"        pv2e               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         lpi=<lpi> \n" 
"                         vlan=<vlan> \n" 
"                         stpstate=<stpstate> \n" 
"                         vpws=<vpws> \n" 
"                         ] \n"
"        p2appdata               \n"
"                         port=<port> \n" 
"                         [ \n"
"                         ifilteren=<ifilteren> \n" 
"                         efilteren=<efilteren> \n" 
"                         ] \n"
"        pv2appdata               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         member=<member> \n" 
"                         ] \n"
"        pvv2edata               \n"
"                         pvv2eindex=<pvv2eindex> \n" 
"                         [ \n"
"                         vpws=<vpws> \n" 
"                         stpstate=<stpstate> \n" 
"                         vlan=<vlan> \n" 
"                         lpi=<lpi> \n" 
"                         hit=<hit> \n" 
"                         keeporstrip=<keeporstrip> \n" 
"                         replace=<replace> \n" 
"                         vid=<vid> \n" 
"                         vidop=<vidop> \n" 
"                         ] \n"
"        v2e               \n"
"                         vlan=<vlan> \n" 
"                         [ \n"
"                         pim=<pim> \n" 
"                         igmp=<igmp> \n" 
"                         policerbypass=<policerbypass> \n" 
"                         forceflood=<forceflood> \n" 
"                         dropunksmac=<dropunksmac> \n" 
"                         dropunkucast=<dropunkucast> \n" 
"                         dontlearn=<dontlearn> \n" 
"                         vrf=<vrf> \n" 
"                         v6mc=<v6mc> \n" 
"                         v4mc=<v4mc> \n" 
"                         laghash=<laghash> \n" 
"                         v4uc=<v4uc> \n" 
"                         v6uc=<v6uc> \n" 
"                         ] \n"
"        vrid2e               \n"
"                         vlan=<vlan> \n" 
"                         [ \n"
"                         v4_vrid0=<v4_vrid0> \n" 
"                         v4_vrid1=<v4_vrid1> \n" 
"                         v6_vrid0=<v6_vrid0> \n" 
"                         v6_vrid1=<v6_vrid1> \n" 
"                         ] \n"
"        lp               \n"
"                         lpi=<lpi> \n" 
"                         [ \n"
"                         pid=<pid> \n" 
"                         qos=<qos> \n" 
"                         useexp=<useexp> \n" 
"                         usedscp=<usedscp> \n" 
"                         updatefdp=<updatefdp> \n" 
"                         mirror=<mirror> \n" 
"                         updaterdp=<updaterdp> \n" 
"                         policer=<policer> \n" 
"                         typedpolice=<typedpolice> \n" 
"                         mefcos=<mefcos> \n" 
"                         mef=<mef> \n" 
"                         ccounter=<ccounter> \n" 
"                         priclass=<priclass> \n" 
"                         allpri=<allpri> \n" 
"                         xtpolreplace=<xtpolreplace> \n" 
"                         counter=<counter> \n" 
"                         typedcount=<typedcount> \n" 
"                         color=<color> \n" 
"                         usecolor=<usecolor> \n" 
"                         oamepi=<oamepi> \n" 
"                         ] \n"
"        l2cp               \n"
"                         lsb=<lsb> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         ftidx=<ftidx> \n" 
"                         forward=<forward> \n" 
"                         passstp=<passstp> \n" 
"                         copy=<copy> \n" 
"                         ] \n"
"        l2cpslow               \n"
"                         subcode=<subcode> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         ftidx=<ftidx> \n" 
"                         forward=<forward> \n" 
"                         passstp=<passstp> \n" 
"                         copy=<copy> \n" 
"                         ] \n"
"        l2cpnop               \n"
"                         i=<i> \n" 
"                         [ \n"
"                         ftidx=<ftidx> \n" 
"                         forward=<forward> \n" 
"                         passstp=<passstp> \n" 
"                         copy=<copy> \n" 
"                         ] \n"
"        ft               \n"
"                         fti=<fti> \n" 
"                         [ \n"
"                         rridx=<rridx> \n" 
"                         excidx=<excidx> \n" 
"                         lenadj=<lenadj> \n" 
"                         mc=<mc> \n" 
"                         t=<t> \n" 
"                         hc=<hc> \n" 
"                         oi=<oi> \n" 
"                         qid=<qid> \n" 
"                         lagbase=<lagbase> \n" 
"                         lagsize=<lagsize> \n" 
"                         lag=<lag> \n" 
"                         oib=<oib> \n" 
"                         qidb=<qidb> \n" 
"                         lagbaseb=<lagbaseb> \n" 
"                         lagsizeb=<lagsizeb> \n" 
"                         lagb=<lagb> \n" 
"                         ] \n"
"        evp2e               \n"
"                         vlan=<vlan> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         eteptr=<eteptr> \n" 
"                         counter=<counter> \n" 
"                         ccounter=<ccounter> \n" 
"                         priclass=<priclass> \n" 
"                         allpri=<allpri> \n" 
"                         ] \n"
"        oi2e               \n"
"                         oi=<oi> \n" 
"                         [ \n"
"                         eteptr=<eteptr> \n" 
"                         counter=<counter> \n" 
"                         ccounter=<ccounter> \n" 
"                         priclass=<priclass> \n" 
"                         allpri=<allpri> \n" 
"                         ] \n"
"        remark               \n"
"                         e=<e> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         prof=<prof> \n" 
"                         [ \n"
"                         cfi=<cfi> \n" 
"                         pri=<pri> \n" 
"                         exp=<exp> \n" 
"                         dscp=<dscp> \n" 
"                         ] \n"
"        epv2e               \n"
"                         vid=<vid> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         drop=<drop> \n" 
"                         strip=<strip> \n" 
"                         ] \n"
"        ert               \n"
"                         irule=<irule> \n" 
"                         [ \n"
"                         mirror=<mirror> \n" 
"                         drop=<drop> \n" 
"                         counter=<counter> \n" 
"                         ] \n"
"        oam_bubble               \n"
"                         oamepi=<oamepi> \n" 
"                         [ \n"
"                         bubble_mode=<bubble_mode> \n" 
"                         je=<je> \n" 
"                         i=<i> \n" 
"                         bubble_stream=<bubble_stream> \n" 
"                         t=<t> \n" 
"                         interval_index=<interval_index> \n" 
"                         reserved=<reserved> \n" 
"                         count=<count> \n" 
"                         timeout=<timeout> \n" 
"                         ] \n"
"        oamrx_p2e               \n"
"                         dir=<dir> \n" 
"                         port=<port> \n" 
"                         [ \n"
"                         svc_hdl=<svc_hdl> \n" 
"                         not_used=<not_used> \n" 
"                         mdlvl_0_m=<mdlvl_0_m> \n" 
"                         mdlvl_0_p=<mdlvl_0_p> \n" 
"                         mdlvl_0_d=<mdlvl_0_d> \n" 
"                         mdlvl_0_f=<mdlvl_0_f> \n" 
"                         mdlvl_1_m=<mdlvl_1_m> \n" 
"                         mdlvl_1_p=<mdlvl_1_p> \n" 
"                         mdlvl_1_d=<mdlvl_1_d> \n" 
"                         mdlvl_1_f=<mdlvl_1_f> \n" 
"                         mdlvl_2_m=<mdlvl_2_m> \n" 
"                         mdlvl_2_p=<mdlvl_2_p> \n" 
"                         mdlvl_2_d=<mdlvl_2_d> \n" 
"                         mdlvl_2_f=<mdlvl_2_f> \n" 
"                         mdlvl_3_m=<mdlvl_3_m> \n" 
"                         mdlvl_3_p=<mdlvl_3_p> \n" 
"                         mdlvl_3_d=<mdlvl_3_d> \n" 
"                         mdlvl_3_f=<mdlvl_3_f> \n" 
"                         mdlvl_4_m=<mdlvl_4_m> \n" 
"                         mdlvl_4_p=<mdlvl_4_p> \n" 
"                         mdlvl_4_d=<mdlvl_4_d> \n" 
"                         mdlvl_4_f=<mdlvl_4_f> \n" 
"                         mdlvl_5_m=<mdlvl_5_m> \n" 
"                         mdlvl_5_p=<mdlvl_5_p> \n" 
"                         mdlvl_5_d=<mdlvl_5_d> \n" 
"                         mdlvl_5_f=<mdlvl_5_f> \n" 
"                         mdlvl_6_m=<mdlvl_6_m> \n" 
"                         mdlvl_6_p=<mdlvl_6_p> \n" 
"                         mdlvl_6_d=<mdlvl_6_d> \n" 
"                         mdlvl_6_f=<mdlvl_6_f> \n" 
"                         mdlvl_7_m=<mdlvl_7_m> \n" 
"                         mdlvl_7_p=<mdlvl_7_p> \n" 
"                         mdlvl_7_d=<mdlvl_7_d> \n" 
"                         mdlvl_7_f=<mdlvl_7_f> \n" 
"                         ] \n"
"        oam_peer_state               \n"
"                         peer_idx=<peer_idx> \n" 
"                         [ \n"
"                         rdi_ack=<rdi_ack> \n" 
"                         rdi_state=<rdi_state> \n" 
"                         ] \n"
"        ptp_compensation               \n"
"                         port=<port> \n" 
"                         [ \n"
"                         compensation=<compensation> \n" 
"                         ] \n"
"        bfd_ld2edata               \n"
"                         ptr=<ptr> \n" 
"                         [ \n"
"                         wdg_id=<wdg_id> \n" 
"                         slowstart=<slowstart> \n" 
"                         rdmode=<rdmode> \n" 
"                         rstate=<rstate> \n" 
"                         f=<f> \n" 
"                         poll=<poll> \n" 
"                         sta=<sta> \n" 
"                         ldiag=<ldiag> \n" 
"                         version=<version> \n" 
"                         rdiscri=<rdiscri> \n" 
"                         ] \n"
"        bfd_ld2edatac               \n"
"                         ptr=<ptr> \n" 
"                         [ \n"
"                         rMinRxInterval=<rMinRxInterval> \n" 
"                         ] \n"
"        sample6               \n"
"                         test6i=<test6i> \n" 
"                         [ \n"
"                         pad=<pad> \n" 
"                         test6=<test6> \n" 
"                         ] \n"
"        sample8               \n"
"                         test8i=<test8i> \n" 
"                         [ \n"
"                         pad=<pad> \n" 
"                         test8=<test8> \n" 
"                         ] \n"
"        sample9               \n"
"                         test9i=<test9i> \n" 
"                         [ \n"
"                         pad=<pad> \n" 
"                         test9=<test9> \n" 
"                         ] \n"
#endif
;

/* Shell delete command usage string */
char soc_sbx_g3p1_delete_usage[] =
"g3p1delete <table> idx0=<i0> ...\n"
"        ifp             rule=<rule> \n"
;


#endif
