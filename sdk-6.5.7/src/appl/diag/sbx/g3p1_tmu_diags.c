
/**
 * 
 *
 * $Id: tmu_diags_c.stg,v 1.17 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * g3p1_tmu_diags.c: Guadalupe2k V1.3 microcode diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_defs.h>
#include <soc/sbx/g3p1/g3p1_tmu.h>
#include <soc/sbx/g3p1/g3p1_diags.h>
#include <soc/sbx/g3p1/g3p1_tmu_diags.h>

/* entry print accessor implementation for mac */
void soc_sbx_g3p1_mac_print(int unit, soc_sbx_g3p1_mac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ageid; w = 5;  break;
        case 1: v = e->smac_hit; w = 8;  break;
        case 2: v = e->sdrop; w = 5;  break;
        case 3: v = e->dontage; w = 7;  break;
        case 4: v = e->sreserved; w = 9;  break;
        case 5: v = e->pending; w = 7;  break;
        case 6: v = e->poe; w = 3;  break;
        case 7: v = e->dmac_hit; w = 8;  break;
        case 8: v = e->dcopy; w = 5;  break;
        case 9: v = e->ddrop; w = 5;  break;
        case 10: v = e->dreserved; w = 9;  break;
        case 11: v = e->ftidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for mac */
static int soc_sbx_g3p1_mac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mac_t e0;
    soc_sbx_g3p1_mac_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];

    soc_sbx_g3p1_6_byte_t imac;
    int ivsi;
    

    void *indexpointers[2];
    
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_mac_get(unit,  imac ,  ivsi  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_mac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mac */
static int soc_sbx_g3p1_mac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_mac_t e0;
    soc_sbx_g3p1_mac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];

    soc_sbx_g3p1_6_byte_t imac;
    int ivsi;

    void *indexpointers[2];
    
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_mac_t_init(e);

    rv = soc_sbx_g3p1_mac_get(unit,  imac ,  ivsi  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->ageid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->smac_hit,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->sdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->dontage,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->sreserved,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->pending,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->poe,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->dmac_hit,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->dcopy,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->ddrop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->dreserved,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[11].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_MAC_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_mac_set(unit,  imac ,  ivsi  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pvv2e */
void soc_sbx_g3p1_pvv2e_print(int unit, soc_sbx_g3p1_pvv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->vpws; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->lpi; w = 3;  break;
        case 5: v = e->hit; w = 3;  break;
        case 6: v = e->keeporstrip; w = 11;  break;
        case 7: v = e->replace; w = 7;  break;
        case 8: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for pvv2e */
static int soc_sbx_g3p1_pvv2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pvv2e_t e0;
    soc_sbx_g3p1_pvv2e_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];

    int iivid;
    int iovid;
    int iport;
    

    void *indexpointers[3];
    
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_pvv2e_get(unit,  iivid ,  iovid ,  iport  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_pvv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pvv2e */
static int soc_sbx_g3p1_pvv2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_pvv2e_t e0;
    soc_sbx_g3p1_pvv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];

    int iivid;
    int iovid;
    int iport;

    void *indexpointers[3];
    
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_pvv2e_t_init(e);

    rv = soc_sbx_g3p1_pvv2e_get(unit,  iivid ,  iovid ,  iport  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->vpws,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->stpstate,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->lpi,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->keeporstrip,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->replace,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->vid,
                                ed->fields[8].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_pvv2e_set(unit,  iivid ,  iovid ,  iport  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for labels */
void soc_sbx_g3p1_labels_print(int unit, soc_sbx_g3p1_labels_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->opcode; w = 6;  break;
        case 2: v = e->ftidx; w = 5;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->hit; w = 3;  break;
        case 5: v = e->lock; w = 4;  break;
        case 6: v = e->keep_sdtag; w = 10;  break;
        case 7: v = e->pipe; w = 4;  break;
        case 8: v = e->elsp; w = 4;  break;
        case 9: v = e->stpstate; w = 8;  break;
        case 10: v = e->vpws; w = 4;  break;
        case 11: v = e->loop; w = 4;  break;
        case 12: v = e->cos; w = 3;  break;
        case 13: v = e->lpi; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for labels */
static int soc_sbx_g3p1_labels_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_labels_t e0;
    soc_sbx_g3p1_labels_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];

    int ilabel2;
    int iresv;
    int iport;
    int ilabel1;
    

    void *indexpointers[4];
    
    indexpointers[0] = &ilabel2;
    indexpointers[1] = &iresv;
    indexpointers[2] = &iport;
    indexpointers[3] = &ilabel1;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_labels_get(unit,  ilabel2 ,  iresv ,  iport ,  ilabel1  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_labels_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for labels */
static int soc_sbx_g3p1_labels_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_labels_t e0;
    soc_sbx_g3p1_labels_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];

    int ilabel2;
    int iresv;
    int iport;
    int ilabel1;

    void *indexpointers[4];
    
    indexpointers[0] = &ilabel2;
    indexpointers[1] = &iresv;
    indexpointers[2] = &iport;
    indexpointers[3] = &ilabel1;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_labels_t_init(e);

    rv = soc_sbx_g3p1_labels_get(unit,  ilabel2 ,  iresv ,  iport ,  ilabel1  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->opcode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->lock,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->keep_sdtag,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->pipe,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->elsp,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->stpstate,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->vpws,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->loop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->cos,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->lpi,
                                ed->fields[13].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_LABELS_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_labels_set(unit,  ilabel2 ,  iresv ,  iport ,  ilabel1  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4da */
void soc_sbx_g3p1_v4da_print(int unit, soc_sbx_g3p1_v4da_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vid; w = 3;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->ftidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v4da */
static int soc_sbx_g3p1_v4da_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4da_t e0;
    soc_sbx_g3p1_v4da_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];

    int ivrf;
    int ida;
    int inetmask_num_bits;    

    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida;
    indexpointers[2] = &inetmask_num_bits;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v4da_get(unit,  ivrf ,  ida , inetmask_num_bits , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v4da_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4da */
static int soc_sbx_g3p1_v4da_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4da_t e0;
    soc_sbx_g3p1_v4da_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];

    int ivrf;
    int ida;
    int inetmask_num_bits;
    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida;
    indexpointers[2] = &inetmask_num_bits;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v4da_t_init(e);

    rv = soc_sbx_g3p1_v4da_get(unit,  ivrf ,  ida , inetmask_num_bits , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->vid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V4DA_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v4da_set(unit,  ivrf ,  ida , inetmask_num_bits , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4sa */
void soc_sbx_g3p1_v4sa_print(int unit, soc_sbx_g3p1_v4sa_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->srccnt; w = 6;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->rpfmode; w = 7;  break;
        case 4: v = e->poe; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v4sa */
static int soc_sbx_g3p1_v4sa_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4sa_t e0;
    soc_sbx_g3p1_v4sa_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];

    int ivrf;
    int isa;
    int inetmask_num_bits;    

    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa;
    indexpointers[2] = &inetmask_num_bits;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v4sa_get(unit,  ivrf ,  isa , inetmask_num_bits , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v4sa_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4sa */
static int soc_sbx_g3p1_v4sa_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4sa_t e0;
    soc_sbx_g3p1_v4sa_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];

    int ivrf;
    int isa;
    int inetmask_num_bits;
    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa;
    indexpointers[2] = &inetmask_num_bits;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v4sa_t_init(e);

    rv = soc_sbx_g3p1_v4sa_get(unit,  ivrf ,  isa , inetmask_num_bits , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->srccnt,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rpfmode,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->poe,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V4SA_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v4sa_set(unit,  ivrf ,  isa , inetmask_num_bits , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4mc_sgv */
void soc_sbx_g3p1_v4mc_sgv_print(int unit, soc_sbx_g3p1_v4mc_sgv_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rpfunion; w = 8;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->hit; w = 3;  break;
        case 3: v = e->rsvd; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4mc_sgv_t e0;
    soc_sbx_g3p1_v4mc_sgv_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];

    int ivsi;
    int isa;
    int iga;
    

    void *indexpointers[3];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa;
    indexpointers[2] = &iga;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v4mc_sgv_get(unit,  ivsi ,  isa ,  iga  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v4mc_sgv_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4mc_sgv_t e0;
    soc_sbx_g3p1_v4mc_sgv_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];

    int ivsi;
    int isa;
    int iga;

    void *indexpointers[3];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa;
    indexpointers[2] = &iga;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v4mc_sgv_t_init(e);

    rv = soc_sbx_g3p1_v4mc_sgv_get(unit,  ivsi ,  isa ,  iga  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rpfunion,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rsvd,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v4mc_sgv_set(unit,  ivsi ,  isa ,  iga  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4mc_gv */
void soc_sbx_g3p1_v4mc_gv_print(int unit, soc_sbx_g3p1_v4mc_gv_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rpfunion; w = 8;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->hit; w = 3;  break;
        case 3: v = e->rsvd; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4mc_gv_t e0;
    soc_sbx_g3p1_v4mc_gv_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];

    int ivsi;
    int iga;
    

    void *indexpointers[2];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v4mc_gv_get(unit,  ivsi ,  iga  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v4mc_gv_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v4mc_gv_t e0;
    soc_sbx_g3p1_v4mc_gv_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];

    int ivsi;
    int iga;

    void *indexpointers[2];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v4mc_gv_t_init(e);

    rv = soc_sbx_g3p1_v4mc_gv_get(unit,  ivsi ,  iga  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rpfunion,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rsvd,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v4mc_gv_set(unit,  ivsi ,  iga  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v6da */
void soc_sbx_g3p1_v6da_print(int unit, soc_sbx_g3p1_v6da_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vid; w = 3;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->ftidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v6da */
static int soc_sbx_g3p1_v6da_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6da_t e0;
    soc_sbx_g3p1_v6da_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];

    int ivrf;
    int ida0;
    int ida1;
    int ida2;
    int ida3;
    int inetmask_num_bits;    

    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida0;
    indexpointers[2] = &ida1;
    indexpointers[3] = &ida2;
    indexpointers[4] = &ida3;
    indexpointers[5] = &inetmask_num_bits;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v6da_get(unit,  ivrf ,  ida0 ,  ida1 ,  ida2 ,  ida3 , inetmask_num_bits , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v6da_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v6da */
static int soc_sbx_g3p1_v6da_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6da_t e0;
    soc_sbx_g3p1_v6da_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];

    int ivrf;
    int ida0;
    int ida1;
    int ida2;
    int ida3;
    int inetmask_num_bits;
    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida0;
    indexpointers[2] = &ida1;
    indexpointers[3] = &ida2;
    indexpointers[4] = &ida3;
    indexpointers[5] = &inetmask_num_bits;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v6da_t_init(e);

    rv = soc_sbx_g3p1_v6da_get(unit,  ivrf ,  ida0 ,  ida1 ,  ida2 ,  ida3 , inetmask_num_bits , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->vid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V6DA_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v6da_set(unit,  ivrf ,  ida0 ,  ida1 ,  ida2 ,  ida3 , inetmask_num_bits , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v6sa */
void soc_sbx_g3p1_v6sa_print(int unit, soc_sbx_g3p1_v6sa_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->srccnt; w = 6;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->rpfmode; w = 7;  break;
        case 4: v = e->poe; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v6sa */
static int soc_sbx_g3p1_v6sa_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6sa_t e0;
    soc_sbx_g3p1_v6sa_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];

    int ivrf;
    int isa0;
    int isa1;
    int isa2;
    int isa3;
    int inetmask_num_bits;    

    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &inetmask_num_bits;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v6sa_get(unit,  ivrf ,  isa0 ,  isa1 ,  isa2 ,  isa3 , inetmask_num_bits , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v6sa_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v6sa */
static int soc_sbx_g3p1_v6sa_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6sa_t e0;
    soc_sbx_g3p1_v6sa_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];

    int ivrf;
    int isa0;
    int isa1;
    int isa2;
    int isa3;
    int inetmask_num_bits;
    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &inetmask_num_bits;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v6sa_t_init(e);

    rv = soc_sbx_g3p1_v6sa_get(unit,  ivrf ,  isa0 ,  isa1 ,  isa2 ,  isa3 , inetmask_num_bits , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->srccnt,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rpfmode,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->poe,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V6SA_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v6sa_set(unit,  ivrf ,  isa0 ,  isa1 ,  isa2 ,  isa3 , inetmask_num_bits , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v6mc_gv */
void soc_sbx_g3p1_v6mc_gv_print(int unit, soc_sbx_g3p1_v6mc_gv_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rpfunion; w = 8;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->hit; w = 3;  break;
        case 3: v = e->rsvd; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6mc_gv_t e0;
    soc_sbx_g3p1_v6mc_gv_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];

    int ivsi;
    int iga0;
    int iga1;
    int iga2;
    int iga3;
    

    void *indexpointers[5];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga0;
    indexpointers[2] = &iga1;
    indexpointers[3] = &iga2;
    indexpointers[4] = &iga3;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v6mc_gv_get(unit,  ivsi ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v6mc_gv_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6mc_gv_t e0;
    soc_sbx_g3p1_v6mc_gv_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];

    int ivsi;
    int iga0;
    int iga1;
    int iga2;
    int iga3;

    void *indexpointers[5];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga0;
    indexpointers[2] = &iga1;
    indexpointers[3] = &iga2;
    indexpointers[4] = &iga3;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v6mc_gv_t_init(e);

    rv = soc_sbx_g3p1_v6mc_gv_get(unit,  ivsi ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rpfunion,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rsvd,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v6mc_gv_set(unit,  ivsi ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v6mc_sgv */
void soc_sbx_g3p1_v6mc_sgv_print(int unit, soc_sbx_g3p1_v6mc_sgv_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rpfunion; w = 8;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->hit; w = 3;  break;
        case 3: v = e->rsvd; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6mc_sgv_t e0;
    soc_sbx_g3p1_v6mc_sgv_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];

    int ivsi;
    int isa0;
    int isa1;
    int isa2;
    int isa3;
    int iga0;
    int iga1;
    int iga2;
    int iga3;
    

    void *indexpointers[9];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &iga0;
    indexpointers[6] = &iga1;
    indexpointers[7] = &iga2;
    indexpointers[8] = &iga3;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_v6mc_sgv_get(unit,  ivsi ,  isa0 ,  isa1 ,  isa2 ,  isa3 ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_v6mc_sgv_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_v6mc_sgv_t e0;
    soc_sbx_g3p1_v6mc_sgv_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];

    int ivsi;
    int isa0;
    int isa1;
    int isa2;
    int isa3;
    int iga0;
    int iga1;
    int iga2;
    int iga3;

    void *indexpointers[9];
    
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &iga0;
    indexpointers[6] = &iga1;
    indexpointers[7] = &iga2;
    indexpointers[8] = &iga3;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_v6mc_sgv_t_init(e);

    rv = soc_sbx_g3p1_v6mc_sgv_get(unit,  ivsi ,  isa0 ,  isa1 ,  isa2 ,  isa3 ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->rpfunion,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->rsvd,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_v6mc_sgv_set(unit,  ivsi ,  isa0 ,  isa1 ,  isa2 ,  isa3 ,  iga0 ,  iga1 ,  iga2 ,  iga3  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oamrx */
void soc_sbx_g3p1_oamrx_print(int unit, soc_sbx_g3p1_oamrx_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->hit; w = 3;  break;
        case 1: v = e->svc_hdl; w = 7;  break;
        case 2: v = e->mdlvl_7_f; w = 9;  break;
        case 3: v = e->mdlvl_7_d; w = 9;  break;
        case 4: v = e->mdlvl_7_p; w = 9;  break;
        case 5: v = e->mdlvl_7_m; w = 9;  break;
        case 6: v = e->mdlvl_6_f; w = 9;  break;
        case 7: v = e->mdlvl_6_d; w = 9;  break;
        case 8: v = e->mdlvl_6_p; w = 9;  break;
        case 9: v = e->mdlvl_6_m; w = 9;  break;
        case 10: v = e->mdlvl_5_f; w = 9;  break;
        case 11: v = e->mdlvl_5_d; w = 9;  break;
        case 12: v = e->mdlvl_5_p; w = 9;  break;
        case 13: v = e->mdlvl_5_m; w = 9;  break;
        case 14: v = e->mdlvl_4_f; w = 9;  break;
        case 15: v = e->mdlvl_4_d; w = 9;  break;
        case 16: v = e->mdlvl_4_p; w = 9;  break;
        case 17: v = e->mdlvl_4_m; w = 9;  break;
        case 18: v = e->mdlvl_3_f; w = 9;  break;
        case 19: v = e->mdlvl_3_d; w = 9;  break;
        case 20: v = e->mdlvl_3_p; w = 9;  break;
        case 21: v = e->mdlvl_3_m; w = 9;  break;
        case 22: v = e->mdlvl_2_f; w = 9;  break;
        case 23: v = e->mdlvl_2_d; w = 9;  break;
        case 24: v = e->mdlvl_2_p; w = 9;  break;
        case 25: v = e->mdlvl_2_m; w = 9;  break;
        case 26: v = e->mdlvl_1_f; w = 9;  break;
        case 27: v = e->mdlvl_1_d; w = 9;  break;
        case 28: v = e->mdlvl_1_p; w = 9;  break;
        case 29: v = e->mdlvl_1_m; w = 9;  break;
        case 30: v = e->mdlvl_0_f; w = 9;  break;
        case 31: v = e->mdlvl_0_d; w = 9;  break;
        case 32: v = e->mdlvl_0_p; w = 9;  break;
        case 33: v = e->mdlvl_0_m; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oamrx */
static int soc_sbx_g3p1_oamrx_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oamrx_t e0;
    soc_sbx_g3p1_oamrx_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];

    int iivid;
    int iovid;
    int idir;
    int iport;
    int ivid_mode;
    

    void *indexpointers[5];
    
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &idir;
    indexpointers[3] = &iport;
    indexpointers[4] = &ivid_mode;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oamrx_get(unit,  iivid ,  iovid ,  idir ,  iport ,  ivid_mode  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oamrx_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamrx */
static int soc_sbx_g3p1_oamrx_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oamrx_t e0;
    soc_sbx_g3p1_oamrx_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];

    int iivid;
    int iovid;
    int idir;
    int iport;
    int ivid_mode;

    void *indexpointers[5];
    
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &idir;
    indexpointers[3] = &iport;
    indexpointers[4] = &ivid_mode;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oamrx_t_init(e);

    rv = soc_sbx_g3p1_oamrx_get(unit,  iivid ,  iovid ,  idir ,  iport ,  ivid_mode  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->svc_hdl,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_f,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_d,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_p,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->mdlvl_7_m,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_f,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_d,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_p,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->mdlvl_6_m,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_f,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_d,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_p,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->mdlvl_5_m,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_f,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_d,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_p,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->mdlvl_4_m,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_f,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_d,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_p,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->mdlvl_3_m,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_f,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_d,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_p,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g3p1_value_read(&e->mdlvl_2_m,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_f,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_d,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_p,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g3p1_value_read(&e->mdlvl_1_m,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_f,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_d,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_p,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g3p1_value_read(&e->mdlvl_0_m,
                                ed->fields[33].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oamrx_set(unit,  iivid ,  iovid ,  idir ,  iport ,  ivid_mode  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for maidmep */
void soc_sbx_g3p1_maidmep_print(int unit, soc_sbx_g3p1_maidmep_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->hit; w = 3;  break;
        case 1: v = e->peer_idx; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for maidmep */
static int soc_sbx_g3p1_maidmep_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_maidmep_t e0;
    soc_sbx_g3p1_maidmep_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];

    int isvc_hdl;
    int imepid;
    int imsg_type;
    int imdlvl;
    

    void *indexpointers[4];
    
    indexpointers[0] = &isvc_hdl;
    indexpointers[1] = &imepid;
    indexpointers[2] = &imsg_type;
    indexpointers[3] = &imdlvl;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_maidmep_get(unit,  isvc_hdl ,  imepid ,  imsg_type ,  imdlvl  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_maidmep_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for maidmep */
static int soc_sbx_g3p1_maidmep_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_maidmep_t e0;
    soc_sbx_g3p1_maidmep_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];

    int isvc_hdl;
    int imepid;
    int imsg_type;
    int imdlvl;

    void *indexpointers[4];
    
    indexpointers[0] = &isvc_hdl;
    indexpointers[1] = &imepid;
    indexpointers[2] = &imsg_type;
    indexpointers[3] = &imdlvl;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_maidmep_t_init(e);

    rv = soc_sbx_g3p1_maidmep_get(unit,  isvc_hdl ,  imepid ,  imsg_type ,  imdlvl  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->peer_idx,
                                ed->fields[1].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_maidmep_set(unit,  isvc_hdl ,  imepid ,  imsg_type ,  imdlvl  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emlfilter */
void soc_sbx_g3p1_emlfilter_print(int unit, soc_sbx_g3p1_emlfilter_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->reserved_0; w = 10;  break;
        case 1: v = e->reserved_1; w = 10;  break;
        case 2: v = e->reserved_2; w = 10;  break;
        case 3: v = e->reserved_3; w = 10;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for emlfilter */
static int soc_sbx_g3p1_emlfilter_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_emlfilter_t e0;
    soc_sbx_g3p1_emlfilter_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];

    int iemlindex;
    

    void *indexpointers[1];
    
    indexpointers[0] = &iemlindex;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_emlfilter_get(unit,  iemlindex  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_emlfilter_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emlfilter */
static int soc_sbx_g3p1_emlfilter_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_emlfilter_t e0;
    soc_sbx_g3p1_emlfilter_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];

    int iemlindex;

    void *indexpointers[1];
    
    indexpointers[0] = &iemlindex;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_emlfilter_t_init(e);

    rv = soc_sbx_g3p1_emlfilter_get(unit,  iemlindex  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->reserved_0,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->reserved_1,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->reserved_2,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->reserved_3,
                                ed->fields[3].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_emlfilter_set(unit,  iemlindex  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ete */
void soc_sbx_g3p1_ete_print(int unit, soc_sbx_g3p1_ete_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dmacset; w = 7;  break;
        case 1: v = e->dmacsetlsb; w = 10;  break;
        case 2: v = e->dscpremark; w = 10;  break;
        case 3: v = e->remark; w = 6;  break;
        case 4: v = e->mplsttldec; w = 10;  break;
        case 5: v = e->encaplen; w = 8;  break;
        case 6: v = e->encapmac; w = 8;  break;
        case 7: v = e->nostrip; w = 7;  break;
        case 8: v = e->noclass; w = 7;  break;
        case 9: v = e->etepid; w = 6;  break;
        case 10: v = e->tunnelenter; w = 11;  break;
        case 11: v = e->exp0remark; w = 10;  break;
        case 12: v = e->exp1remark; w = 10;  break;
        case 13: v = e->exp2remark; w = 10;  break;
        case 14: v = e->ttl0dec; w = 7;  break;
        case 15: v = e->ttl1dec; w = 7;  break;
        case 16: v = e->ttl2dec; w = 7;  break;
        case 17: v = e->smacset; w = 7;  break;
        case 18: v = e->nosplitcheck; w = 12;  break;
        case 19: v = e->ttlcheck; w = 8;  break;
        case 20: v = e->ipttldec; w = 8;  break;
        case 21: v = e->add_pwcw; w = 8;  break;
        case 22: v = e->comp_encaplen; w = 13;  break;
        case 23: v = e->etype2; w = 6;  break;
        case 24: v = e->ttl2; w = 4;  break;
        case 25: v = e->s2; w = 2;  break;
        case 26: v = e->exp2; w = 4;  break;
        case 27: v = e->label2; w = 6;  break;
        case 28: v = e->encap_vid; w = 9;  break;
        case 29: v = e->pricfi; w = 6;  break;
        case 30: v = e->etype; w = 5;  break;
        case 31: v = e->tpid; w = 4;  break;
        case 32: v = e->pid; w = 3;  break;
        case 33: v = e->dmac5; w = 5;  break;
        case 34: v = e->dmac4; w = 5;  break;
        case 35: v = e->dmac3; w = 5;  break;
        case 36: v = e->dmac2; w = 5;  break;
        case 37: v = e->dmac1; w = 5;  break;
        case 38: v = e->dmac0; w = 5;  break;
        case 39: v = e->vlan; w = 4;  break;
        case 40: v = e->defpricfi; w = 9;  break;
        case 41: v = e->usetag; w = 6;  break;
        case 42: v = e->l2_reserved; w = 11;  break;
        case 43: v = e->dropuntagged; w = 12;  break;
        case 44: v = e->droptagged; w = 10;  break;
        case 45: v = e->smacindex; w = 9;  break;
        case 46: v = e->stpcheck; w = 8;  break;
        case 47: v = e->vid; w = 3;  break;
        case 48: v = e->ttl0; w = 4;  break;
        case 49: v = e->s0; w = 2;  break;
        case 50: v = e->exp0; w = 4;  break;
        case 51: v = e->label0; w = 6;  break;
        case 52: v = e->ttl1; w = 4;  break;
        case 53: v = e->s1; w = 2;  break;
        case 54: v = e->exp1; w = 4;  break;
        case 55: v = e->label1; w = 6;  break;
        case 56: v = e->smac5; w = 5;  break;
        case 57: v = e->smac4; w = 5;  break;
        case 58: v = e->smac3; w = 5;  break;
        case 59: v = e->smac2; w = 5;  break;
        case 60: v = e->smac1; w = 5;  break;
        case 61: v = e->smac0; w = 5;  break;
        case 62: v = e->mtu; w = 3;  break;
        case 63: v = e->usevid; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for ete */
static int soc_sbx_g3p1_ete_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ete_t e0;
    soc_sbx_g3p1_ete_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];

    int ietei;
    

    void *indexpointers[1];
    
    indexpointers[0] = &ietei;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_ete_get(unit,  ietei  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_ete_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ete */
static int soc_sbx_g3p1_ete_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ete_t e0;
    soc_sbx_g3p1_ete_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_ETE_TABLE_ID];

    int ietei;

    void *indexpointers[1];
    
    indexpointers[0] = &ietei;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_ete_t_init(e);

    rv = soc_sbx_g3p1_ete_get(unit,  ietei  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->dmacset,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->dmacsetlsb,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->dscpremark,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->remark,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->mplsttldec,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->encaplen,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->encapmac,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->nostrip,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->noclass,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->etepid,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->tunnelenter,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->exp0remark,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->exp1remark,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->exp2remark,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->ttl0dec,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->ttl1dec,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->ttl2dec,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->smacset,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->nosplitcheck,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->ttlcheck,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->ipttldec,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->add_pwcw,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->comp_encaplen,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->etype2,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->ttl2,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g3p1_value_read(&e->s2,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g3p1_value_read(&e->exp2,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g3p1_value_read(&e->label2,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g3p1_value_read(&e->encap_vid,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g3p1_value_read(&e->pricfi,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g3p1_value_read(&e->etype,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g3p1_value_read(&e->tpid,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g3p1_value_read(&e->pid,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g3p1_value_read(&e->dmac5,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g3p1_value_read(&e->dmac4,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g3p1_value_read(&e->dmac3,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g3p1_value_read(&e->dmac2,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g3p1_value_read(&e->dmac1,
                                ed->fields[37].range, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g3p1_value_read(&e->dmac0,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                ed->fields[39].range, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g3p1_value_read(&e->defpricfi,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g3p1_value_read(&e->usetag,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g3p1_value_read(&e->l2_reserved,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g3p1_value_read(&e->dropuntagged,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g3p1_value_read(&e->droptagged,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g3p1_value_read(&e->smacindex,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g3p1_value_read(&e->stpcheck,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        case 47: rv = soc_sbx_g3p1_value_read(&e->vid,
                                ed->fields[47].range, 0, argc, argv);
                 break;
        case 48: rv = soc_sbx_g3p1_value_read(&e->ttl0,
                                ed->fields[48].range, 0, argc, argv);
                 break;
        case 49: rv = soc_sbx_g3p1_value_read(&e->s0,
                                ed->fields[49].range, 0, argc, argv);
                 break;
        case 50: rv = soc_sbx_g3p1_value_read(&e->exp0,
                                ed->fields[50].range, 0, argc, argv);
                 break;
        case 51: rv = soc_sbx_g3p1_value_read(&e->label0,
                                ed->fields[51].range, 0, argc, argv);
                 break;
        case 52: rv = soc_sbx_g3p1_value_read(&e->ttl1,
                                ed->fields[52].range, 0, argc, argv);
                 break;
        case 53: rv = soc_sbx_g3p1_value_read(&e->s1,
                                ed->fields[53].range, 0, argc, argv);
                 break;
        case 54: rv = soc_sbx_g3p1_value_read(&e->exp1,
                                ed->fields[54].range, 0, argc, argv);
                 break;
        case 55: rv = soc_sbx_g3p1_value_read(&e->label1,
                                ed->fields[55].range, 0, argc, argv);
                 break;
        case 56: rv = soc_sbx_g3p1_value_read(&e->smac5,
                                ed->fields[56].range, 0, argc, argv);
                 break;
        case 57: rv = soc_sbx_g3p1_value_read(&e->smac4,
                                ed->fields[57].range, 0, argc, argv);
                 break;
        case 58: rv = soc_sbx_g3p1_value_read(&e->smac3,
                                ed->fields[58].range, 0, argc, argv);
                 break;
        case 59: rv = soc_sbx_g3p1_value_read(&e->smac2,
                                ed->fields[59].range, 0, argc, argv);
                 break;
        case 60: rv = soc_sbx_g3p1_value_read(&e->smac1,
                                ed->fields[60].range, 0, argc, argv);
                 break;
        case 61: rv = soc_sbx_g3p1_value_read(&e->smac0,
                                ed->fields[61].range, 0, argc, argv);
                 break;
        case 62: rv = soc_sbx_g3p1_value_read(&e->mtu,
                                ed->fields[62].range, 0, argc, argv);
                 break;
        case 63: rv = soc_sbx_g3p1_value_read(&e->usevid,
                                ed->fields[63].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_ETE_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_ete_set(unit,  ietei  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_ep */
void soc_sbx_g3p1_oam_ep_print(int unit, soc_sbx_g3p1_oam_ep_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->smac1; w = 5;  break;
        case 1: v = e->smac0; w = 5;  break;
        case 2: v = e->dmac5; w = 5;  break;
        case 3: v = e->dmac4; w = 5;  break;
        case 4: v = e->dmac3; w = 5;  break;
        case 5: v = e->dmac2; w = 5;  break;
        case 6: v = e->dmac1; w = 5;  break;
        case 7: v = e->dmac0; w = 5;  break;
        case 8: v = e->smac5; w = 5;  break;
        case 9: v = e->smac4; w = 5;  break;
        case 10: v = e->smac3; w = 5;  break;
        case 11: v = e->smac2; w = 5;  break;
        case 12: v = e->vid; w = 3;  break;
        case 13: v = e->num_vlan_tags; w = 13;  break;
        case 14: v = e->dir; w = 3;  break;
        case 15: v = e->reqMinEchoRxInterval; w = 20;  break;
        case 16: v = e->localDiscr; w = 10;  break;
        case 17: v = e->ftidx; w = 5;  break;
        case 18: v = e->dport; w = 5;  break;
        case 19: v = e->dqueue; w = 6;  break;
        case 20: v = e->tlv_offset; w = 10;  break;
        case 21: v = e->period; w = 6;  break;
        case 22: v = e->flags_rsvd; w = 10;  break;
        case 23: v = e->rdi; w = 3;  break;
        case 24: v = e->opcode; w = 6;  break;
        case 25: v = e->version; w = 7;  break;
        case 26: v = e->mdlvl; w = 5;  break;
        case 27: v = e->mepid; w = 5;  break;
        case 28: v = e->func; w = 4;  break;
        case 29: v = e->type; w = 4;  break;
        case 30: v = e->unused; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_ep */
static int soc_sbx_g3p1_oam_ep_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_ep_t e0;
    soc_sbx_g3p1_oam_ep_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];

    int ioam_epi;
    

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_epi;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_ep_get(unit,  ioam_epi  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_ep_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_ep */
static int soc_sbx_g3p1_oam_ep_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_ep_t e0;
    soc_sbx_g3p1_oam_ep_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID];

    int ioam_epi;

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_epi;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_ep_t_init(e);

    rv = soc_sbx_g3p1_oam_ep_get(unit,  ioam_epi  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->smac1,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->smac0,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->dmac5,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->dmac4,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->dmac3,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->dmac2,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->dmac1,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->dmac0,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->smac5,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->smac4,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->smac3,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->smac2,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->vid,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->num_vlan_tags,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->dir,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->reqMinEchoRxInterval,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->localDiscr,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->dport,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->dqueue,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->tlv_offset,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->period,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->flags_rsvd,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->rdi,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->opcode,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g3p1_value_read(&e->version,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g3p1_value_read(&e->mdlvl,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g3p1_value_read(&e->mepid,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g3p1_value_read(&e->func,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g3p1_value_read(&e->type,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g3p1_value_read(&e->unused,
                                ed->fields[30].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_ep_set(unit,  ioam_epi  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_local */
void soc_sbx_g3p1_oam_local_print(int unit, soc_sbx_g3p1_oam_local_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->maid_w1; w = 7;  break;
        case 1: v = e->maid_w0; w = 7;  break;
        case 2: v = e->maid_w3; w = 7;  break;
        case 3: v = e->maid_w2; w = 7;  break;
        case 4: v = e->maid_w5; w = 7;  break;
        case 5: v = e->maid_w4; w = 7;  break;
        case 6: v = e->unused_w6; w = 9;  break;
        case 7: v = e->maid_w7; w = 7;  break;
        case 8: v = e->maid_w6; w = 7;  break;
        case 9: v = e->maid_w9; w = 7;  break;
        case 10: v = e->maid_w8; w = 7;  break;
        case 11: v = e->maid_w11; w = 8;  break;
        case 12: v = e->maid_w10; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_local */
static int soc_sbx_g3p1_oam_local_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_local_t e0;
    soc_sbx_g3p1_oam_local_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];

    int ioam_locali;
    

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_locali;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_local_get(unit,  ioam_locali  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_local_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_local */
static int soc_sbx_g3p1_oam_local_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_local_t e0;
    soc_sbx_g3p1_oam_local_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID];

    int ioam_locali;

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_locali;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_local_t_init(e);

    rv = soc_sbx_g3p1_oam_local_get(unit,  ioam_locali  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->maid_w1,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->maid_w0,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->maid_w3,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->maid_w2,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->maid_w5,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->maid_w4,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->unused_w6,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->maid_w7,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->maid_w6,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->maid_w9,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->maid_w8,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->maid_w11,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->maid_w10,
                                ed->fields[12].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_local_set(unit,  ioam_locali  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_peer */
void soc_sbx_g3p1_oam_peer_print(int unit, soc_sbx_g3p1_oam_peer_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->maid_crc; w = 8;  break;
        case 1: v = e->pol_id_wdg; w = 10;  break;
        case 2: v = e->fwd_to_host; w = 11;  break;
        case 3: v = e->period; w = 6;  break;
        case 4: v = e->pad1; w = 4;  break;
        case 5: v = e->w2; w = 2;  break;
        case 6: v = e->w3; w = 2;  break;
        case 7: v = e->w4; w = 2;  break;
        case 8: v = e->w5; w = 2;  break;
        case 9: v = e->w6; w = 2;  break;
        case 10: v = e->w7; w = 2;  break;
        case 11: v = e->e_w7; w = 4;  break;
        case 12: v = e->code_w7; w = 7;  break;
        case 13: v = e->reserved_w7; w = 11;  break;
        case 14: v = e->w8; w = 2;  break;
        case 15: v = e->w9; w = 2;  break;
        case 16: v = e->w10; w = 3;  break;
        case 17: v = e->w11; w = 3;  break;
        case 18: v = e->w12; w = 3;  break;
        case 19: v = e->w13; w = 3;  break;
        case 20: v = e->w14; w = 3;  break;
        case 21: v = e->w15; w = 3;  break;
        case 22: v = e->e_w15; w = 5;  break;
        case 23: v = e->code_w15; w = 8;  break;
        case 24: v = e->reserved_w15; w = 12;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_peer */
static int soc_sbx_g3p1_oam_peer_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_peer_t e0;
    soc_sbx_g3p1_oam_peer_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];

    int ioam_peer_idx;
    

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_peer_idx;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_peer_get(unit,  ioam_peer_idx  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_peer_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_peer */
static int soc_sbx_g3p1_oam_peer_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_peer_t e0;
    soc_sbx_g3p1_oam_peer_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID];

    int ioam_peer_idx;

    void *indexpointers[1];
    
    indexpointers[0] = &ioam_peer_idx;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_peer_t_init(e);

    rv = soc_sbx_g3p1_oam_peer_get(unit,  ioam_peer_idx  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->maid_crc,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->pol_id_wdg,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->fwd_to_host,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->period,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->pad1,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->w2,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->w3,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->w4,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->w5,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->w6,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->w7,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->e_w7,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->code_w7,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->reserved_w7,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->w8,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->w9,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->w10,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->w11,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->w12,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->w13,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->w14,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->w15,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->e_w15,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->code_w15,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->reserved_w15,
                                ed->fields[24].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_peer_set(unit,  ioam_peer_idx  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for labels3 */
void soc_sbx_g3p1_labels3_print(int unit, soc_sbx_g3p1_labels3_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pad; w = 3;  break;
        case 1: v = e->opcode; w = 6;  break;
        case 2: v = e->ftidx; w = 5;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->hit; w = 3;  break;
        case 5: v = e->lock; w = 4;  break;
        case 6: v = e->keep_sdtag; w = 10;  break;
        case 7: v = e->pipe; w = 4;  break;
        case 8: v = e->elsp; w = 4;  break;
        case 9: v = e->stpstate; w = 8;  break;
        case 10: v = e->vpws; w = 4;  break;
        case 11: v = e->loop; w = 4;  break;
        case 12: v = e->cos; w = 3;  break;
        case 13: v = e->lpi; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for labels3 */
static int soc_sbx_g3p1_labels3_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_labels3_t e0;
    soc_sbx_g3p1_labels3_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];

    int ilabel3;
    int ilabel2;
    int ilabel1;
    int iresv1;
    int iport;
    

    void *indexpointers[5];
    
    indexpointers[0] = &ilabel3;
    indexpointers[1] = &ilabel2;
    indexpointers[2] = &ilabel1;
    indexpointers[3] = &iresv1;
    indexpointers[4] = &iport;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_labels3_get(unit,  ilabel3 ,  ilabel2 ,  ilabel1 ,  iresv1 ,  iport  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_labels3_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for labels3 */
static int soc_sbx_g3p1_labels3_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_labels3_t e0;
    soc_sbx_g3p1_labels3_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];

    int ilabel3;
    int ilabel2;
    int ilabel1;
    int iresv1;
    int iport;

    void *indexpointers[5];
    
    indexpointers[0] = &ilabel3;
    indexpointers[1] = &ilabel2;
    indexpointers[2] = &ilabel1;
    indexpointers[3] = &iresv1;
    indexpointers[4] = &iport;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_labels3_t_init(e);

    rv = soc_sbx_g3p1_labels3_get(unit,  ilabel3 ,  ilabel2 ,  ilabel1 ,  iresv1 ,  iport  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->pad,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->opcode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->ftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->lock,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->keep_sdtag,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->pipe,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->elsp,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->stpstate,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->vpws,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->loop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->cos,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->lpi,
                                ed->fields[13].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_labels3_set(unit,  ilabel3 ,  ilabel2 ,  ilabel1 ,  iresv1 ,  iport  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for bfd_ld2e */
void soc_sbx_g3p1_bfd_ld2e_print(int unit, soc_sbx_g3p1_bfd_ld2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->bubble_id; w = 9;  break;
        case 1: v = e->hit; w = 3;  break;
        case 2: v = e->c; w = 1;  break;
        case 3: v = e->a; w = 1;  break;
        case 4: v = e->d; w = 1;  break;
        case 5: v = e->m; w = 1;  break;
        case 6: v = e->detectMulti; w = 11;  break;
        case 7: v = e->length; w = 6;  break;
        case 8: v = e->desiredMinTxInterval; w = 20;  break;
        case 9: v = e->reqMinRxInterval; w = 16;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2e_t e0;
    soc_sbx_g3p1_bfd_ld2e_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];

    int ilocalDiscri;
    

    void *indexpointers[1];
    
    indexpointers[0] = &ilocalDiscri;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_bfd_ld2e_get(unit,  ilocalDiscri  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_bfd_ld2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_bfd_ld2e_t e0;
    soc_sbx_g3p1_bfd_ld2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];

    int ilocalDiscri;

    void *indexpointers[1];
    
    indexpointers[0] = &ilocalDiscri;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_bfd_ld2e_t_init(e);

    rv = soc_sbx_g3p1_bfd_ld2e_get(unit,  ilocalDiscri  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->bubble_id,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->hit,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->c,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->a,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->d,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->m,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->detectMulti,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->length,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->desiredMinTxInterval,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->reqMinRxInterval,
                                ed->fields[9].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_bfd_ld2e_set(unit,  ilocalDiscri  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for sample_dm1 */
void soc_sbx_g3p1_sample_dm1_print(int unit, soc_sbx_g3p1_sample_dm1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->w0; w = 2;  break;
        case 1: v = e->w1; w = 2;  break;
        case 2: v = e->w2; w = 2;  break;
        case 3: v = e->w3; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for sample_dm1 */
static int soc_sbx_g3p1_sample_dm1_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample_dm1_t e0;
    soc_sbx_g3p1_sample_dm1_t *e = &e0;
    int rv;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];

    int iindex_1;
    int iindex_2;
    

    void *indexpointers[2];
    
    indexpointers[0] = &iindex_1;
    indexpointers[1] = &iindex_2;       
    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_sample_dm1_get(unit,  iindex_1 ,  iindex_2  , e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_sample_dm1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for sample_dm1 */
static int soc_sbx_g3p1_sample_dm1_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_sample_dm1_t e0;
    soc_sbx_g3p1_sample_dm1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID];

    int iindex_1;
    int iindex_2;

    void *indexpointers[2];
    
    indexpointers[0] = &iindex_1;
    indexpointers[1] = &iindex_2;

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_sample_dm1_t_init(e);

    rv = soc_sbx_g3p1_sample_dm1_get(unit,  iindex_1 ,  iindex_2  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->w0,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->w1,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->w2,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->w3,
                                ed->fields[3].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_update_overlaps(unit, SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_sample_dm1_set(unit,  iindex_1 ,  iindex_2  , e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for mac */
static int soc_sbx_g3p1_mac_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAC_TABLE_ID];
    soc_sbx_g3p1_6_byte_t imac, nimac = {0,0,0,0,0,0};
    int ivsi=0, nivsi=0;
    void *indexpointers[2];
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_mac_first(unit,  imac ,  &ivsi  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            int i;
            for (i=0; i<6; i++) { imac[i] = nimac[i]; }
   
            ivsi = nivsi;            

            rv = soc_sbx_g3p1_mac_next(unit,  imac ,  ivsi  ,  nimac ,  &nivsi  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_mac_delete(unit,  imac ,  ivsi  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for pvv2e */
static int soc_sbx_g3p1_pvv2e_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID];
    int iivid=0, niivid=0;
    int iovid=0, niovid=0;
    int iport=0, niport=0;
    void *indexpointers[3];
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_pvv2e_first(unit,  &iivid ,  &iovid ,  &iport  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            iivid = niivid;
   
            iovid = niovid;
   
            iport = niport;            

            rv = soc_sbx_g3p1_pvv2e_next(unit,  iivid ,  iovid ,  iport  ,  &niivid ,  &niovid ,  &niport  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_pvv2e_delete(unit,  iivid ,  iovid ,  iport  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for labels */
static int soc_sbx_g3p1_labels_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS_TABLE_ID];
    int ilabel2=0, nilabel2=0;
    int iresv=0, niresv=0;
    int iport=0, niport=0;
    int ilabel1=0, nilabel1=0;
    void *indexpointers[4];
    indexpointers[0] = &ilabel2;
    indexpointers[1] = &iresv;
    indexpointers[2] = &iport;
    indexpointers[3] = &ilabel1;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_labels_first(unit,  &ilabel2 ,  &iresv ,  &iport ,  &ilabel1  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ilabel2 = nilabel2;
   
            iresv = niresv;
   
            iport = niport;
   
            ilabel1 = nilabel1;            

            rv = soc_sbx_g3p1_labels_next(unit,  ilabel2 ,  iresv ,  iport ,  ilabel1  ,  &nilabel2 ,  &niresv ,  &niport ,  &nilabel1  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_labels_delete(unit,  ilabel2 ,  iresv ,  iport ,  ilabel1  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v4da */
static int soc_sbx_g3p1_v4da_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4DA_TABLE_ID];
    int ivrf=0, nivrf=0;
    int ida=0, nida=0;
    int inetmask_num_bits;  
    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida;
    indexpointers[2] = &inetmask_num_bits;
   
            ivrf = nivrf;
   
            ida = nida;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
      return SOC_E_PARAM;
    }

    if (rv != argc) {
      cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
      return SOC_E_PARAM;
    }

    rv0 = soc_sbx_g3p1_v4da_delete(unit,  ivrf ,  ida  , inetmask_num_bits);
    if (rv0) {
      cli_out("delete of %s failed\n", ed->name);
      return rv0;
    }
    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v4sa */
static int soc_sbx_g3p1_v4sa_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4SA_TABLE_ID];
    int ivrf=0, nivrf=0;
    int isa=0, nisa=0;
    int inetmask_num_bits;  
    void *indexpointers[3];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa;
    indexpointers[2] = &inetmask_num_bits;
   
            ivrf = nivrf;
   
            isa = nisa;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
      return SOC_E_PARAM;
    }

    if (rv != argc) {
      cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
      return SOC_E_PARAM;
    }

    rv0 = soc_sbx_g3p1_v4sa_delete(unit,  ivrf ,  isa  , inetmask_num_bits);
    if (rv0) {
      cli_out("delete of %s failed\n", ed->name);
      return rv0;
    }
    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v4mc_sgv */
static int soc_sbx_g3p1_v4mc_sgv_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID];
    int ivsi=0, nivsi=0;
    int isa=0, nisa=0;
    int iga=0, niga=0;
    void *indexpointers[3];
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa;
    indexpointers[2] = &iga;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_v4mc_sgv_first(unit,  &ivsi ,  &isa ,  &iga  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ivsi = nivsi;
   
            isa = nisa;
   
            iga = niga;            

            rv = soc_sbx_g3p1_v4mc_sgv_next(unit,  ivsi ,  isa ,  iga  ,  &nivsi ,  &nisa ,  &niga  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_v4mc_sgv_delete(unit,  ivsi ,  isa ,  iga  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v4mc_gv */
static int soc_sbx_g3p1_v4mc_gv_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID];
    int ivsi=0, nivsi=0;
    int iga=0, niga=0;
    void *indexpointers[2];
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_v4mc_gv_first(unit,  &ivsi ,  &iga  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ivsi = nivsi;
   
            iga = niga;            

            rv = soc_sbx_g3p1_v4mc_gv_next(unit,  ivsi ,  iga  ,  &nivsi ,  &niga  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_v4mc_gv_delete(unit,  ivsi ,  iga  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v6da */
static int soc_sbx_g3p1_v6da_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6DA_TABLE_ID];
    int ivrf=0, nivrf=0;
    int ida0=0, nida0=0;
    int ida1=0, nida1=0;
    int ida2=0, nida2=0;
    int ida3=0, nida3=0;
    int inetmask_num_bits;  
    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &ida0;
    indexpointers[2] = &ida1;
    indexpointers[3] = &ida2;
    indexpointers[4] = &ida3;
    indexpointers[5] = &inetmask_num_bits;
   
            ivrf = nivrf;
   
            ida0 = nida0;
   
            ida1 = nida1;
   
            ida2 = nida2;
   
            ida3 = nida3;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
      return SOC_E_PARAM;
    }

    if (rv != argc) {
      cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
      return SOC_E_PARAM;
    }

    rv0 = soc_sbx_g3p1_v6da_delete(unit,  ivrf ,  ida0 ,  ida1 ,  ida2 ,  ida3  , inetmask_num_bits);
    if (rv0) {
      cli_out("delete of %s failed\n", ed->name);
      return rv0;
    }
    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v6sa */
static int soc_sbx_g3p1_v6sa_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6SA_TABLE_ID];
    int ivrf=0, nivrf=0;
    int isa0=0, nisa0=0;
    int isa1=0, nisa1=0;
    int isa2=0, nisa2=0;
    int isa3=0, nisa3=0;
    int inetmask_num_bits;  
    void *indexpointers[6];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &inetmask_num_bits;
   
            ivrf = nivrf;
   
            isa0 = nisa0;
   
            isa1 = nisa1;
   
            isa2 = nisa2;
   
            isa3 = nisa3;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
      return SOC_E_PARAM;
    }

    if (rv != argc) {
      cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
      return SOC_E_PARAM;
    }

    rv0 = soc_sbx_g3p1_v6sa_delete(unit,  ivrf ,  isa0 ,  isa1 ,  isa2 ,  isa3  , inetmask_num_bits);
    if (rv0) {
      cli_out("delete of %s failed\n", ed->name);
      return rv0;
    }
    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v6mc_gv */
static int soc_sbx_g3p1_v6mc_gv_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID];
    int ivsi=0, nivsi=0;
    int iga0=0, niga0=0;
    int iga1=0, niga1=0;
    int iga2=0, niga2=0;
    int iga3=0, niga3=0;
    void *indexpointers[5];
    indexpointers[0] = &ivsi;
    indexpointers[1] = &iga0;
    indexpointers[2] = &iga1;
    indexpointers[3] = &iga2;
    indexpointers[4] = &iga3;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_v6mc_gv_first(unit,  &ivsi ,  &iga0 ,  &iga1 ,  &iga2 ,  &iga3  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ivsi = nivsi;
   
            iga0 = niga0;
   
            iga1 = niga1;
   
            iga2 = niga2;
   
            iga3 = niga3;            

            rv = soc_sbx_g3p1_v6mc_gv_next(unit,  ivsi ,  iga0 ,  iga1 ,  iga2 ,  iga3  ,  &nivsi ,  &niga0 ,  &niga1 ,  &niga2 ,  &niga3  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_v6mc_gv_delete(unit,  ivsi ,  iga0 ,  iga1 ,  iga2 ,  iga3  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for v6mc_sgv */
static int soc_sbx_g3p1_v6mc_sgv_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID];
    int ivsi=0, nivsi=0;
    int isa0=0, nisa0=0;
    int isa1=0, nisa1=0;
    int isa2=0, nisa2=0;
    int isa3=0, nisa3=0;
    int iga0=0, niga0=0;
    int iga1=0, niga1=0;
    int iga2=0, niga2=0;
    int iga3=0, niga3=0;
    void *indexpointers[9];
    indexpointers[0] = &ivsi;
    indexpointers[1] = &isa0;
    indexpointers[2] = &isa1;
    indexpointers[3] = &isa2;
    indexpointers[4] = &isa3;
    indexpointers[5] = &iga0;
    indexpointers[6] = &iga1;
    indexpointers[7] = &iga2;
    indexpointers[8] = &iga3;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_v6mc_sgv_first(unit,  &ivsi ,  &isa0 ,  &isa1 ,  &isa2 ,  &isa3 ,  &iga0 ,  &iga1 ,  &iga2 ,  &iga3  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ivsi = nivsi;
   
            isa0 = nisa0;
   
            isa1 = nisa1;
   
            isa2 = nisa2;
   
            isa3 = nisa3;
   
            iga0 = niga0;
   
            iga1 = niga1;
   
            iga2 = niga2;
   
            iga3 = niga3;            

            rv = soc_sbx_g3p1_v6mc_sgv_next(unit,  ivsi ,  isa0 ,  isa1 ,  isa2 ,  isa3 ,  iga0 ,  iga1 ,  iga2 ,  iga3  ,  &nivsi ,  &nisa0 ,  &nisa1 ,  &nisa2 ,  &nisa3 ,  &niga0 ,  &niga1 ,  &niga2 ,  &niga3  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_v6mc_sgv_delete(unit,  ivsi ,  isa0 ,  isa1 ,  isa2 ,  isa3 ,  iga0 ,  iga1 ,  iga2 ,  iga3  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for oamrx */
static int soc_sbx_g3p1_oamrx_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID];
    int iivid=0, niivid=0;
    int iovid=0, niovid=0;
    int idir=0, nidir=0;
    int iport=0, niport=0;
    int ivid_mode=0, nivid_mode=0;
    void *indexpointers[5];
    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &idir;
    indexpointers[3] = &iport;
    indexpointers[4] = &ivid_mode;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_oamrx_first(unit,  &iivid ,  &iovid ,  &idir ,  &iport ,  &ivid_mode  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            iivid = niivid;
   
            iovid = niovid;
   
            idir = nidir;
   
            iport = niport;
   
            ivid_mode = nivid_mode;            

            rv = soc_sbx_g3p1_oamrx_next(unit,  iivid ,  iovid ,  idir ,  iport ,  ivid_mode  ,  &niivid ,  &niovid ,  &nidir ,  &niport ,  &nivid_mode  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_oamrx_delete(unit,  iivid ,  iovid ,  idir ,  iport ,  ivid_mode  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for maidmep */
static int soc_sbx_g3p1_maidmep_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID];
    int isvc_hdl=0, nisvc_hdl=0;
    int imepid=0, nimepid=0;
    int imsg_type=0, nimsg_type=0;
    int imdlvl=0, nimdlvl=0;
    void *indexpointers[4];
    indexpointers[0] = &isvc_hdl;
    indexpointers[1] = &imepid;
    indexpointers[2] = &imsg_type;
    indexpointers[3] = &imdlvl;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_maidmep_first(unit,  &isvc_hdl ,  &imepid ,  &imsg_type ,  &imdlvl  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            isvc_hdl = nisvc_hdl;
   
            imepid = nimepid;
   
            imsg_type = nimsg_type;
   
            imdlvl = nimdlvl;            

            rv = soc_sbx_g3p1_maidmep_next(unit,  isvc_hdl ,  imepid ,  imsg_type ,  imdlvl  ,  &nisvc_hdl ,  &nimepid ,  &nimsg_type ,  &nimdlvl  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_maidmep_delete(unit,  isvc_hdl ,  imepid ,  imsg_type ,  imdlvl  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for emlfilter */
static int soc_sbx_g3p1_emlfilter_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID];
    int iemlindex=0, niemlindex=0;
    void *indexpointers[1];
    indexpointers[0] = &iemlindex;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_emlfilter_first(unit,  &iemlindex  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            iemlindex = niemlindex;            

            rv = soc_sbx_g3p1_emlfilter_next(unit,  iemlindex  ,  &niemlindex  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_emlfilter_delete(unit,  iemlindex  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for labels3 */
static int soc_sbx_g3p1_labels3_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID];
    int ilabel3=0, nilabel3=0;
    int ilabel2=0, nilabel2=0;
    int ilabel1=0, nilabel1=0;
    int iresv1=0, niresv1=0;
    int iport=0, niport=0;
    void *indexpointers[5];
    indexpointers[0] = &ilabel3;
    indexpointers[1] = &ilabel2;
    indexpointers[2] = &ilabel1;
    indexpointers[3] = &iresv1;
    indexpointers[4] = &iport;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_labels3_first(unit,  &ilabel3 ,  &ilabel2 ,  &ilabel1 ,  &iresv1 ,  &iport  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ilabel3 = nilabel3;
   
            ilabel2 = nilabel2;
   
            ilabel1 = nilabel1;
   
            iresv1 = niresv1;
   
            iport = niport;            

            rv = soc_sbx_g3p1_labels3_next(unit,  ilabel3 ,  ilabel2 ,  ilabel1 ,  iresv1 ,  iport  ,  &nilabel3 ,  &nilabel2 ,  &nilabel1 ,  &niresv1 ,  &niport  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_labels3_delete(unit,  ilabel3 ,  ilabel2 ,  ilabel1 ,  iresv1 ,  iport  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for bfd_ld2e */
static int soc_sbx_g3p1_bfd_ld2e_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID];
    int ilocalDiscri=0, nilocalDiscri=0;
    void *indexpointers[1];
    indexpointers[0] = &ilocalDiscri;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g3p1_bfd_ld2e_first(unit,  &ilocalDiscri  );
        if (rv == SOC_E_NOT_FOUND) {
               cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
               cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            ilocalDiscri = nilocalDiscri;            

            rv = soc_sbx_g3p1_bfd_ld2e_next(unit,  ilocalDiscri  ,  &nilocalDiscri  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g3p1_bfd_ld2e_delete(unit,  ilocalDiscri  );
        if (rv0) {
               cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

int soc_sbx_g3p1_tmu_table_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_g3p1_tmu_table_shell_print(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G3P1_TMU_MAC_TABLE_ID:
        rv = soc_sbx_g3p1_mac_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID:
        rv = soc_sbx_g3p1_pvv2e_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_LABELS_TABLE_ID:
        rv = soc_sbx_g3p1_labels_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V4DA_TABLE_ID:
        rv = soc_sbx_g3p1_v4da_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V4SA_TABLE_ID:
        rv = soc_sbx_g3p1_v4sa_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID:
        rv = soc_sbx_g3p1_v4mc_sgv_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID:
        rv = soc_sbx_g3p1_v4mc_gv_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V6DA_TABLE_ID:
        rv = soc_sbx_g3p1_v6da_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V6SA_TABLE_ID:
        rv = soc_sbx_g3p1_v6sa_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID:
        rv = soc_sbx_g3p1_v6mc_gv_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID:
        rv = soc_sbx_g3p1_v6mc_sgv_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID:
        rv = soc_sbx_g3p1_oamrx_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID:
        rv = soc_sbx_g3p1_maidmep_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID:
        rv = soc_sbx_g3p1_emlfilter_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_ETE_TABLE_ID:
        rv = soc_sbx_g3p1_ete_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID:
        rv = soc_sbx_g3p1_oam_ep_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID:
        rv = soc_sbx_g3p1_oam_local_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID:
        rv = soc_sbx_g3p1_oam_peer_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID:
        rv = soc_sbx_g3p1_labels3_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID:
        rv = soc_sbx_g3p1_bfd_ld2e_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID:
        rv = soc_sbx_g3p1_sample_dm1_shell_print(unit, argc, argv); 
        break;    
    default: rv = SOC_E_NOT_FOUND;
    }
    
    return rv;
}    

/*
 * Shell entry set implementation
 */
static int soc_sbx_g3p1_tmu_table_shell_set(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
        case SOC_SBX_G3P1_TMU_MAC_TABLE_ID:
            rv = soc_sbx_g3p1_mac_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID:
            rv = soc_sbx_g3p1_pvv2e_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_LABELS_TABLE_ID:
            rv = soc_sbx_g3p1_labels_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4DA_TABLE_ID:
            rv = soc_sbx_g3p1_v4da_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4SA_TABLE_ID:
            rv = soc_sbx_g3p1_v4sa_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID:
            rv = soc_sbx_g3p1_v4mc_sgv_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID:
            rv = soc_sbx_g3p1_v4mc_gv_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6DA_TABLE_ID:
            rv = soc_sbx_g3p1_v6da_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6SA_TABLE_ID:
            rv = soc_sbx_g3p1_v6sa_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID:
            rv = soc_sbx_g3p1_v6mc_gv_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID:
            rv = soc_sbx_g3p1_v6mc_sgv_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID:
            rv = soc_sbx_g3p1_oamrx_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID:
            rv = soc_sbx_g3p1_maidmep_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID:
            rv = soc_sbx_g3p1_emlfilter_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_ETE_TABLE_ID:
            rv = soc_sbx_g3p1_ete_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_OAM_EP_TABLE_ID:
            rv = soc_sbx_g3p1_oam_ep_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_OAM_LOCAL_TABLE_ID:
            rv = soc_sbx_g3p1_oam_local_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_OAM_PEER_TABLE_ID:
            rv = soc_sbx_g3p1_oam_peer_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID:
            rv = soc_sbx_g3p1_labels3_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID:
            rv = soc_sbx_g3p1_bfd_ld2e_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_SAMPLE_DM1_TABLE_ID:
            rv = soc_sbx_g3p1_sample_dm1_shell_set(unit, argc, argv); 
            break;
    default: rv = SOC_E_NOT_FOUND;
    
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
static int soc_sbx_g3p1_tmu_table_shell_delete(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
        case SOC_SBX_G3P1_TMU_MAC_TABLE_ID:
            rv = soc_sbx_g3p1_mac_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_PVV2E_TABLE_ID:
            rv = soc_sbx_g3p1_pvv2e_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_LABELS_TABLE_ID:
            rv = soc_sbx_g3p1_labels_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4MC_SGV_TABLE_ID:
            rv = soc_sbx_g3p1_v4mc_sgv_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4MC_GV_TABLE_ID:
            rv = soc_sbx_g3p1_v4mc_gv_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6MC_GV_TABLE_ID:
            rv = soc_sbx_g3p1_v6mc_gv_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6MC_SGV_TABLE_ID:
            rv = soc_sbx_g3p1_v6mc_sgv_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_OAMRX_TABLE_ID:
            rv = soc_sbx_g3p1_oamrx_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_MAIDMEP_TABLE_ID:
            rv = soc_sbx_g3p1_maidmep_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_EMLFILTER_TABLE_ID:
            rv = soc_sbx_g3p1_emlfilter_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_LABELS3_TABLE_ID:
            rv = soc_sbx_g3p1_labels3_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_BFD_LD2E_TABLE_ID:
            rv = soc_sbx_g3p1_bfd_ld2e_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4DA_TABLE_ID:
            rv = soc_sbx_g3p1_v4da_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V4SA_TABLE_ID:
            rv = soc_sbx_g3p1_v4sa_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6DA_TABLE_ID:
            rv = soc_sbx_g3p1_v6da_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_G3P1_TMU_V6SA_TABLE_ID:
            rv = soc_sbx_g3p1_v6sa_shell_delete(unit, argc, argv); 
            break;
    default: rv = SOC_E_NOT_FOUND;
    
    }
    return rv;
}


static uint32 makeMask(int offset, int width) {
    int i;
    uint32 bit = (1 << offset);
    uint32 mask = 0;

    for (i = 0;i < width;i++) {
        mask |= bit;
        bit = bit << 1;
    }

    return mask;
}

/*
 * Utility method
 */
int soc_sbx_g3p1_update_overlaps(int unit, int table, uint32 *e, char *name, int value) {
  int fidx;
  int i;
  soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  soc_sbx_g3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
  soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[table];
  int p1;
  int p2;
  int word;
  uint32 mask;

    fidx = soc_sbx_g3p1_field_find(ed, name);
    if (fidx < 0) {
      cli_out("unexpected field name '%s'\n", name);
        return SOC_E_PARAM;
    }

    word = ed->fields[fidx].pos/32;

    for (i = 0;i < ed->nfields;i++) {
        if (i != fidx) {
            if ((ed->fields[i].pos <= (ed->fields[fidx].pos + ed->fields[fidx].width - 1)) && 
                ((ed->fields[i].pos + ed->fields[i].width - 1) >= ed->fields[fidx].pos)) {

                if (ed->fields[i].pos < ed->fields[fidx].pos)
                    p1 = ed->fields[fidx].pos;
                else 
                    p1 = ed->fields[i].pos;

                if ((ed->fields[i].pos + ed->fields[i].width) < (ed->fields[fidx].pos + ed->fields[fidx].width))
                    p2 = ed->fields[i].pos + ed->fields[i].width - p1;
                else
                    p2 = ed->fields[fidx].pos + ed->fields[fidx].width - p1;

                p1 = p1 - (word * 32);

                mask = makeMask(p1, p2);
                e[i] = ((!mask) & e[i])  | (mask & value);
 /*              
                cli_out("Field:%s (value:%d) overlaps with:%s offset:%d width:%d (p1:%d p2:%d m:0x%08x w:%d v:%d)\n",
                             name,
                             value,
                             ed->fields[i].name,
                             ed->fields[i].pos,
                        ed->fields[i].width, p1, p2, mask, word, e[i]);
*/
            }
        }
    }
    return 0;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_g3p1_tmu_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_tmu_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_G3P1_TMU_MAX_TABLE_ID; i++) {
        
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_tmu_table_shell_print(unit, i, argc - 1, &argv[1]);
        }
    }

    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_g3p1_tmu_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_tmu_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_G3P1_TMU_MAX_TABLE_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_tmu_table_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
int soc_sbx_g3p1_tmu_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_tmu_table_manager_t *tm;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_G3P1_TMU_MAX_TABLE_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_tmu_table_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

char soc_sbx_g3p1_tmu_get_usage[] = 
"g3p1tmuget [<table> idx0=<i0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>    \n" 
"         pvv2e            ivid=<ivid>  ovid=<ovid>  port=<port>    \n" 
"         labels            label2=<label2>  resv=<resv>  port=<port>  label1=<label1>    \n" 
"         v4da            vrf=<vrf>  da=<da>  <netmask=number of bits in netmask>  \n" 
"         v4sa            vrf=<vrf>  sa=<sa>  <netmask=number of bits in netmask>  \n" 
"         v4mc_sgv            vsi=<vsi>  sa=<sa>  ga=<ga>    \n" 
"         v4mc_gv            vsi=<vsi>  ga=<ga>    \n" 
"         v6da            vrf=<vrf>  da0=<da0>  da1=<da1>  da2=<da2>  da3=<da3>  <netmask=number of bits in netmask>  \n" 
"         v6sa            vrf=<vrf>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>  <netmask=number of bits in netmask>  \n" 
"         v6mc_gv            vsi=<vsi>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>    \n" 
"         v6mc_sgv            vsi=<vsi>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>    \n" 
"         oamrx            ivid=<ivid>  ovid=<ovid>  dir=<dir>  port=<port>  vid_mode=<vid_mode>    \n" 
"         maidmep            svc_hdl=<svc_hdl>  mepid=<mepid>  msg_type=<msg_type>  mdlvl=<mdlvl>    \n" 
"         emlfilter            emlindex=<emlindex>    \n" 
"         ete            etei=<etei>    \n" 
"         oam_ep            oam_epi=<oam_epi>    \n" 
"         oam_local            oam_locali=<oam_locali>    \n" 
"         oam_peer            oam_peer_idx=<oam_peer_idx>    \n" 
"         labels3            label3=<label3>  label2=<label2>  label1=<label1>  resv1=<resv1>  port=<port>    \n" 
"         bfd_ld2e            localDiscri=<localDiscri>    \n" 
"         sample_dm1            index_1=<index_1>  index_2=<index_2>    \n" 
#endif
;

char soc_sbx_g3p1_tmu_set_usage[] =
"g3p1tmuset [<table> idx0=<i0> ...[field0=<f0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>     \n"
 
"                         [ ageid=<ageid> ]        \n" 
"                         [ smac_hit=<smac_hit> ]        \n" 
"                         [ sdrop=<sdrop> ]        \n" 
"                         [ dontage=<dontage> ]        \n" 
"                         [ sreserved=<sreserved> ]        \n" 
"                         [ pending=<pending> ]        \n" 
"                         [ poe=<poe> ]        \n" 
"                         [ dmac_hit=<dmac_hit> ]        \n" 
"                         [ dcopy=<dcopy> ]        \n" 
"                         [ ddrop=<ddrop> ]        \n" 
"                         [ dreserved=<dreserved> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n"  
"         pvv2e            ivid=<ivid>  ovid=<ovid>  port=<port>     \n"
 
"                         [ pad=<pad> ]        \n" 
"                         [ vpws=<vpws> ]        \n" 
"                         [ stpstate=<stpstate> ]        \n" 
"                         [ vlan=<vlan> ]        \n" 
"                         [ lpi=<lpi> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ keeporstrip=<keeporstrip> ]        \n" 
"                         [ replace=<replace> ]        \n" 
"                         [ vid=<vid> ]        \n"  
"         labels            label2=<label2>  resv=<resv>  port=<port>  label1=<label1>     \n"
 
"                         [ pad=<pad> ]        \n" 
"                         [ opcode=<opcode> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ vlan=<vlan> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ lock=<lock> ]        \n" 
"                         [ keep_sdtag=<keep_sdtag> ]        \n" 
"                         [ pipe=<pipe> ]        \n" 
"                         [ elsp=<elsp> ]        \n" 
"                         [ stpstate=<stpstate> ]        \n" 
"                         [ vpws=<vpws> ]        \n" 
"                         [ loop=<loop> ]        \n" 
"                         [ cos=<cos> ]        \n" 
"                         [ lpi=<lpi> ]        \n"  
"         v4da            vrf=<vrf>  da=<da>     <netmask=number of bits in netmask>\n"
 
"                         [ vid=<vid> ]        \n" 
"                         [ ecmpmask=<ecmpmask> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n"  
"         v4sa            vrf=<vrf>  sa=<sa>     <netmask=number of bits in netmask>\n"
 
"                         [ pad=<pad> ]        \n" 
"                         [ srccnt=<srccnt> ]        \n" 
"                         [ srcdrop=<srcdrop> ]        \n" 
"                         [ rpfmode=<rpfmode> ]        \n" 
"                         [ poe=<poe> ]        \n"  
"         v4mc_sgv            vsi=<vsi>  sa=<sa>  ga=<ga>     \n"
 
"                         [ rpfunion=<rpfunion> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ rsvd=<rsvd> ]        \n" 
"                         [ proccopy=<proccopy> ]        \n"  
"         v4mc_gv            vsi=<vsi>  ga=<ga>     \n"
 
"                         [ rpfunion=<rpfunion> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ rsvd=<rsvd> ]        \n" 
"                         [ proccopy=<proccopy> ]        \n"  
"         v6da            vrf=<vrf>  da0=<da0>  da1=<da1>  da2=<da2>  da3=<da3>     <netmask=number of bits in netmask>\n"
 
"                         [ vid=<vid> ]        \n" 
"                         [ ecmpmask=<ecmpmask> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n"  
"         v6sa            vrf=<vrf>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>     <netmask=number of bits in netmask>\n"
 
"                         [ pad=<pad> ]        \n" 
"                         [ srccnt=<srccnt> ]        \n" 
"                         [ srcdrop=<srcdrop> ]        \n" 
"                         [ rpfmode=<rpfmode> ]        \n" 
"                         [ poe=<poe> ]        \n"  
"         v6mc_gv            vsi=<vsi>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>     \n"
 
"                         [ rpfunion=<rpfunion> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ rsvd=<rsvd> ]        \n" 
"                         [ proccopy=<proccopy> ]        \n"  
"         v6mc_sgv            vsi=<vsi>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>     \n"
 
"                         [ rpfunion=<rpfunion> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ rsvd=<rsvd> ]        \n" 
"                         [ proccopy=<proccopy> ]        \n"  
"         oamrx            ivid=<ivid>  ovid=<ovid>  dir=<dir>  port=<port>  vid_mode=<vid_mode>     \n"
 
"                         [ hit=<hit> ]        \n" 
"                         [ svc_hdl=<svc_hdl> ]        \n" 
"                         [ mdlvl_7_f=<mdlvl_7_f> ]        \n" 
"                         [ mdlvl_7_d=<mdlvl_7_d> ]        \n" 
"                         [ mdlvl_7_p=<mdlvl_7_p> ]        \n" 
"                         [ mdlvl_7_m=<mdlvl_7_m> ]        \n" 
"                         [ mdlvl_6_f=<mdlvl_6_f> ]        \n" 
"                         [ mdlvl_6_d=<mdlvl_6_d> ]        \n" 
"                         [ mdlvl_6_p=<mdlvl_6_p> ]        \n" 
"                         [ mdlvl_6_m=<mdlvl_6_m> ]        \n" 
"                         [ mdlvl_5_f=<mdlvl_5_f> ]        \n" 
"                         [ mdlvl_5_d=<mdlvl_5_d> ]        \n" 
"                         [ mdlvl_5_p=<mdlvl_5_p> ]        \n" 
"                         [ mdlvl_5_m=<mdlvl_5_m> ]        \n" 
"                         [ mdlvl_4_f=<mdlvl_4_f> ]        \n" 
"                         [ mdlvl_4_d=<mdlvl_4_d> ]        \n" 
"                         [ mdlvl_4_p=<mdlvl_4_p> ]        \n" 
"                         [ mdlvl_4_m=<mdlvl_4_m> ]        \n" 
"                         [ mdlvl_3_f=<mdlvl_3_f> ]        \n" 
"                         [ mdlvl_3_d=<mdlvl_3_d> ]        \n" 
"                         [ mdlvl_3_p=<mdlvl_3_p> ]        \n" 
"                         [ mdlvl_3_m=<mdlvl_3_m> ]        \n" 
"                         [ mdlvl_2_f=<mdlvl_2_f> ]        \n" 
"                         [ mdlvl_2_d=<mdlvl_2_d> ]        \n" 
"                         [ mdlvl_2_p=<mdlvl_2_p> ]        \n" 
"                         [ mdlvl_2_m=<mdlvl_2_m> ]        \n" 
"                         [ mdlvl_1_f=<mdlvl_1_f> ]        \n" 
"                         [ mdlvl_1_d=<mdlvl_1_d> ]        \n" 
"                         [ mdlvl_1_p=<mdlvl_1_p> ]        \n" 
"                         [ mdlvl_1_m=<mdlvl_1_m> ]        \n" 
"                         [ mdlvl_0_f=<mdlvl_0_f> ]        \n" 
"                         [ mdlvl_0_d=<mdlvl_0_d> ]        \n" 
"                         [ mdlvl_0_p=<mdlvl_0_p> ]        \n" 
"                         [ mdlvl_0_m=<mdlvl_0_m> ]        \n"  
"         maidmep            svc_hdl=<svc_hdl>  mepid=<mepid>  msg_type=<msg_type>  mdlvl=<mdlvl>     \n"
 
"                         [ hit=<hit> ]        \n" 
"                         [ peer_idx=<peer_idx> ]        \n"  
"         emlfilter            emlindex=<emlindex>     \n"
 
"                         [ reserved_0=<reserved_0> ]        \n" 
"                         [ reserved_1=<reserved_1> ]        \n" 
"                         [ reserved_2=<reserved_2> ]        \n" 
"                         [ reserved_3=<reserved_3> ]        \n"  
"         ete            etei=<etei>     \n"
 
"                         [ dmacset=<dmacset> ]        \n" 
"                         [ dmacsetlsb=<dmacsetlsb> ]        \n" 
"                         [ dscpremark=<dscpremark> ]        \n" 
"                         [ remark=<remark> ]        \n" 
"                         [ mplsttldec=<mplsttldec> ]        \n" 
"                         [ encaplen=<encaplen> ]        \n" 
"                         [ encapmac=<encapmac> ]        \n" 
"                         [ nostrip=<nostrip> ]        \n" 
"                         [ noclass=<noclass> ]        \n" 
"                         [ etepid=<etepid> ]        \n" 
"                         [ tunnelenter=<tunnelenter> ]        \n" 
"                         [ exp0remark=<exp0remark> ]        \n" 
"                         [ exp1remark=<exp1remark> ]        \n" 
"                         [ exp2remark=<exp2remark> ]        \n" 
"                         [ ttl0dec=<ttl0dec> ]        \n" 
"                         [ ttl1dec=<ttl1dec> ]        \n" 
"                         [ ttl2dec=<ttl2dec> ]        \n" 
"                         [ smacset=<smacset> ]        \n" 
"                         [ nosplitcheck=<nosplitcheck> ]        \n" 
"                         [ ttlcheck=<ttlcheck> ]        \n" 
"                         [ ipttldec=<ipttldec> ]        \n" 
"                         [ add_pwcw=<add_pwcw> ]        \n" 
"                         [ comp_encaplen=<comp_encaplen> ]        \n" 
"                         [ etype2=<etype2> ]        \n" 
"                         [ ttl2=<ttl2> ]        \n" 
"                         [ s2=<s2> ]        \n" 
"                         [ exp2=<exp2> ]        \n" 
"                         [ label2=<label2> ]        \n" 
"                         [ encap_vid=<encap_vid> ]        \n" 
"                         [ pricfi=<pricfi> ]        \n" 
"                         [ etype=<etype> ]        \n" 
"                         [ tpid=<tpid> ]        \n" 
"                         [ pid=<pid> ]        \n" 
"                         [ dmac5=<dmac5> ]        \n" 
"                         [ dmac4=<dmac4> ]        \n" 
"                         [ dmac3=<dmac3> ]        \n" 
"                         [ dmac2=<dmac2> ]        \n" 
"                         [ dmac1=<dmac1> ]        \n" 
"                         [ dmac0=<dmac0> ]        \n" 
"                         [ vlan=<vlan> ]        \n" 
"                         [ defpricfi=<defpricfi> ]        \n" 
"                         [ usetag=<usetag> ]        \n" 
"                         [ l2_reserved=<l2_reserved> ]        \n" 
"                         [ dropuntagged=<dropuntagged> ]        \n" 
"                         [ droptagged=<droptagged> ]        \n" 
"                         [ smacindex=<smacindex> ]        \n" 
"                         [ stpcheck=<stpcheck> ]        \n" 
"                         [ vid=<vid> ]        \n" 
"                         [ ttl0=<ttl0> ]        \n" 
"                         [ s0=<s0> ]        \n" 
"                         [ exp0=<exp0> ]        \n" 
"                         [ label0=<label0> ]        \n" 
"                         [ ttl1=<ttl1> ]        \n" 
"                         [ s1=<s1> ]        \n" 
"                         [ exp1=<exp1> ]        \n" 
"                         [ label1=<label1> ]        \n" 
"                         [ smac5=<smac5> ]        \n" 
"                         [ smac4=<smac4> ]        \n" 
"                         [ smac3=<smac3> ]        \n" 
"                         [ smac2=<smac2> ]        \n" 
"                         [ smac1=<smac1> ]        \n" 
"                         [ smac0=<smac0> ]        \n" 
"                         [ mtu=<mtu> ]        \n" 
"                         [ usevid=<usevid> ]        \n"  
"         oam_ep            oam_epi=<oam_epi>     \n"
 
"                         [ smac1=<smac1> ]        \n" 
"                         [ smac0=<smac0> ]        \n" 
"                         [ dmac5=<dmac5> ]        \n" 
"                         [ dmac4=<dmac4> ]        \n" 
"                         [ dmac3=<dmac3> ]        \n" 
"                         [ dmac2=<dmac2> ]        \n" 
"                         [ dmac1=<dmac1> ]        \n" 
"                         [ dmac0=<dmac0> ]        \n" 
"                         [ smac5=<smac5> ]        \n" 
"                         [ smac4=<smac4> ]        \n" 
"                         [ smac3=<smac3> ]        \n" 
"                         [ smac2=<smac2> ]        \n" 
"                         [ vid=<vid> ]        \n" 
"                         [ num_vlan_tags=<num_vlan_tags> ]        \n" 
"                         [ dir=<dir> ]        \n" 
"                         [ reqMinEchoRxInterval=<reqMinEchoRxInterval> ]        \n" 
"                         [ localDiscr=<localDiscr> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ dport=<dport> ]        \n" 
"                         [ dqueue=<dqueue> ]        \n" 
"                         [ tlv_offset=<tlv_offset> ]        \n" 
"                         [ period=<period> ]        \n" 
"                         [ flags_rsvd=<flags_rsvd> ]        \n" 
"                         [ rdi=<rdi> ]        \n" 
"                         [ opcode=<opcode> ]        \n" 
"                         [ version=<version> ]        \n" 
"                         [ mdlvl=<mdlvl> ]        \n" 
"                         [ mepid=<mepid> ]        \n" 
"                         [ func=<func> ]        \n" 
"                         [ type=<type> ]        \n" 
"                         [ unused=<unused> ]        \n"  
"         oam_local            oam_locali=<oam_locali>     \n"
 
"                         [ maid_w1=<maid_w1> ]        \n" 
"                         [ maid_w0=<maid_w0> ]        \n" 
"                         [ maid_w3=<maid_w3> ]        \n" 
"                         [ maid_w2=<maid_w2> ]        \n" 
"                         [ maid_w5=<maid_w5> ]        \n" 
"                         [ maid_w4=<maid_w4> ]        \n" 
"                         [ unused_w6=<unused_w6> ]        \n" 
"                         [ maid_w7=<maid_w7> ]        \n" 
"                         [ maid_w6=<maid_w6> ]        \n" 
"                         [ maid_w9=<maid_w9> ]        \n" 
"                         [ maid_w8=<maid_w8> ]        \n" 
"                         [ maid_w11=<maid_w11> ]        \n" 
"                         [ maid_w10=<maid_w10> ]        \n"  
"         oam_peer            oam_peer_idx=<oam_peer_idx>     \n"
 
"                         [ maid_crc=<maid_crc> ]        \n" 
"                         [ pol_id_wdg=<pol_id_wdg> ]        \n" 
"                         [ fwd_to_host=<fwd_to_host> ]        \n" 
"                         [ period=<period> ]        \n" 
"                         [ pad1=<pad1> ]        \n" 
"                         [ w2=<w2> ]        \n" 
"                         [ w3=<w3> ]        \n" 
"                         [ w4=<w4> ]        \n" 
"                         [ w5=<w5> ]        \n" 
"                         [ w6=<w6> ]        \n" 
"                         [ w7=<w7> ]        \n" 
"                         [ e_w7=<e_w7> ]        \n" 
"                         [ code_w7=<code_w7> ]        \n" 
"                         [ reserved_w7=<reserved_w7> ]        \n" 
"                         [ w8=<w8> ]        \n" 
"                         [ w9=<w9> ]        \n" 
"                         [ w10=<w10> ]        \n" 
"                         [ w11=<w11> ]        \n" 
"                         [ w12=<w12> ]        \n" 
"                         [ w13=<w13> ]        \n" 
"                         [ w14=<w14> ]        \n" 
"                         [ w15=<w15> ]        \n" 
"                         [ e_w15=<e_w15> ]        \n" 
"                         [ code_w15=<code_w15> ]        \n" 
"                         [ reserved_w15=<reserved_w15> ]        \n"  
"         labels3            label3=<label3>  label2=<label2>  label1=<label1>  resv1=<resv1>  port=<port>     \n"
 
"                         [ pad=<pad> ]        \n" 
"                         [ opcode=<opcode> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n" 
"                         [ vlan=<vlan> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ lock=<lock> ]        \n" 
"                         [ keep_sdtag=<keep_sdtag> ]        \n" 
"                         [ pipe=<pipe> ]        \n" 
"                         [ elsp=<elsp> ]        \n" 
"                         [ stpstate=<stpstate> ]        \n" 
"                         [ vpws=<vpws> ]        \n" 
"                         [ loop=<loop> ]        \n" 
"                         [ cos=<cos> ]        \n" 
"                         [ lpi=<lpi> ]        \n"  
"         bfd_ld2e            localDiscri=<localDiscri>     \n"
 
"                         [ bubble_id=<bubble_id> ]        \n" 
"                         [ hit=<hit> ]        \n" 
"                         [ c=<c> ]        \n" 
"                         [ a=<a> ]        \n" 
"                         [ d=<d> ]        \n" 
"                         [ m=<m> ]        \n" 
"                         [ detectMulti=<detectMulti> ]        \n" 
"                         [ length=<length> ]        \n" 
"                         [ desiredMinTxInterval=<desiredMinTxInterval> ]        \n" 
"                         [ reqMinRxInterval=<reqMinRxInterval> ]        \n"  
"         sample_dm1            index_1=<index_1>  index_2=<index_2>     \n"
 
"                         [ w0=<w0> ]        \n" 
"                         [ w1=<w1> ]        \n" 
"                         [ w2=<w2> ]        \n" 
"                         [ w3=<w3> ]        \n"  
#endif
;

char soc_sbx_g3p1_tmu_delete_usage[] = 
"g3p1tmudelete [<table> idx0=<i0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>    \n" 
"         pvv2e            ivid=<ivid>  ovid=<ovid>  port=<port>    \n" 
"         labels            label2=<label2>  resv=<resv>  port=<port>  label1=<label1>    \n" 
"         v4da            vrf=<vrf>  da=<da>    \n" 
"         v4sa            vrf=<vrf>  sa=<sa>    \n" 
"         v4mc_sgv            vsi=<vsi>  sa=<sa>  ga=<ga>    \n" 
"         v4mc_gv            vsi=<vsi>  ga=<ga>    \n" 
"         v6da            vrf=<vrf>  da0=<da0>  da1=<da1>  da2=<da2>  da3=<da3>    \n" 
"         v6sa            vrf=<vrf>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>    \n" 
"         v6mc_gv            vsi=<vsi>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>    \n" 
"         v6mc_sgv            vsi=<vsi>  sa0=<sa0>  sa1=<sa1>  sa2=<sa2>  sa3=<sa3>  ga0=<ga0>  ga1=<ga1>  ga2=<ga2>  ga3=<ga3>    \n" 
"         oamrx            ivid=<ivid>  ovid=<ovid>  dir=<dir>  port=<port>  vid_mode=<vid_mode>    \n" 
"         maidmep            svc_hdl=<svc_hdl>  mepid=<mepid>  msg_type=<msg_type>  mdlvl=<mdlvl>    \n" 
"         emlfilter            emlindex=<emlindex>    \n" 
"         labels3            label3=<label3>  label2=<label2>  label1=<label1>  resv1=<resv1>  port=<port>    \n" 
"         bfd_ld2e            localDiscri=<localDiscri>    \n" 
#endif
;


#endif
