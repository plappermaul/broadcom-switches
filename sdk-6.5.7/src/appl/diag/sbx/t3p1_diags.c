/**
 * $Id: ocm_diags_c.stg,v 1.20 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * t3p1_diags.c: Guadalupe2k V1.3 microcode diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/t3p1/t3p1_int.h>
#include <soc/sbx/t3p1/t3p1_diags.h>
#include <soc/sbx/t3p1/t3p1_defs.h>


static uint32 makeOcmMask(int offset, int width) {
    int i;
    uint32 bit = (1 << offset);
    uint32 mask = 0;

    for (i = 0;i < width;i++) {
        mask |= bit;
        bit = bit << 1;
    }

    return mask;
}

/*
 * Utility method
 */
int soc_sbx_t3p1_ocm_update_overlaps(int unit, int table, uint32 *e, char *name, int value) {
  int fidx;
  int i;
  soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
  soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[table];
  int p1;
  int p2;
  int word;
  uint32 mask;

    fidx = soc_sbx_t3p1_field_find(ed, name);
    if (fidx < 0) {
        cli_out("unexpected field name '%s'\n", name);
        return SOC_E_PARAM;
    }

    word = ed->fields[fidx].pos/32;

    for (i = 0;i < ed->nfields;i++) {
        if (i != fidx) {
            if ((ed->fields[i].pos <= (ed->fields[fidx].pos + ed->fields[fidx].width - 1)) && 
                ((ed->fields[i].pos + ed->fields[i].width - 1) >= ed->fields[fidx].pos)) {
                
                if (ed->fields[i].pos < ed->fields[fidx].pos)
                    p1 = ed->fields[fidx].pos;
                else 
                    p1 = ed->fields[i].pos;

                if ((ed->fields[i].pos + ed->fields[i].width) < (ed->fields[fidx].pos + ed->fields[fidx].width))
                    p2 = ed->fields[i].pos + ed->fields[i].width - p1;
                else
                    p2 = ed->fields[fidx].pos + ed->fields[fidx].width - p1;

                p1 = p1 - (word * 32);

                mask = makeOcmMask(p1, p2);
                e[i] = ((!mask) & e[i])  | (mask & value);
                cli_out("Field:%s (value:%d) overlaps with:%s offset:%d width:%d (p1:%d p2:%d m:0x%08x w:%d v:%d)\n", 
                        name,
                        value,
                        ed->fields[i].name,
                        ed->fields[i].pos,
                        ed->fields[i].width, p1, p2, mask, word, e[i]);
            }
        }
    }
    return 0;
}

/*
 * Diag shell print routine for Constants
 */
int
soc_sbx_t3p1_constant_shell_print(int unit, int cid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;

    switch (cid) {  
    case SOC_SBX_T3P1_HTYPE_NULL_ID:
        rv = soc_sbx_t3p1_htype_null_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_NULL_ID:
        rv = soc_sbx_t3p1_hlen_null_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_ETYPE_ID:
        rv = soc_sbx_t3p1_htype_etype_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_ETYPE_ID:
        rv = soc_sbx_t3p1_hlen_etype_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_ETH_ID:
        rv = soc_sbx_t3p1_htype_eth_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_ETH_ID:
        rv = soc_sbx_t3p1_hlen_eth_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_IETH_ID:
        rv = soc_sbx_t3p1_htype_ieth_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_LLC_ID:
        rv = soc_sbx_t3p1_htype_llc_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_LLC_ID:
        rv = soc_sbx_t3p1_hlen_llc_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_SNAP_ID:
        rv = soc_sbx_t3p1_htype_snap_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_SNAP_ID:
        rv = soc_sbx_t3p1_hlen_snap_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_VTAG_ID:
        rv = soc_sbx_t3p1_htype_vtag_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_VTAG_ID:
        rv = soc_sbx_t3p1_hlen_vtag_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_DVTAG_ID:
        rv = soc_sbx_t3p1_htype_dvtag_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_MPLS_ID:
        rv = soc_sbx_t3p1_htype_mpls_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_MPLS_ID:
        rv = soc_sbx_t3p1_hlen_mpls_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_IPV4_ID:
        rv = soc_sbx_t3p1_htype_ipv4_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_IPV4_ID:
        rv = soc_sbx_t3p1_hlen_ipv4_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_IPV6_ID:
        rv = soc_sbx_t3p1_htype_ipv6_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_IPV6_ID:
        rv = soc_sbx_t3p1_hlen_ipv6_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_UDP_ID:
        rv = soc_sbx_t3p1_htype_udp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_UDP_ID:
        rv = soc_sbx_t3p1_hlen_udp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_TCP_ID:
        rv = soc_sbx_t3p1_htype_tcp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_TCP_ID:
        rv = soc_sbx_t3p1_hlen_tcp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_ACH_ID:
        rv = soc_sbx_t3p1_htype_ach_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_ACH_ID:
        rv = soc_sbx_t3p1_hlen_ach_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_PTP_ID:
        rv = soc_sbx_t3p1_htype_ptp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_PTP_ID:
        rv = soc_sbx_t3p1_hlen_ptp_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_MIM_ID:
        rv = soc_sbx_t3p1_htype_mim_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_MIM_ID:
        rv = soc_sbx_t3p1_hlen_mim_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_ELEN_ID:
        rv = soc_sbx_t3p1_htype_elen_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_ELEN_ID:
        rv = soc_sbx_t3p1_hlen_elen_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_ERH_ID:
        rv = soc_sbx_t3p1_htype_erh_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_ERH_ID:
        rv = soc_sbx_t3p1_hlen_erh_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_TMH_ID:
        rv = soc_sbx_t3p1_htype_tmh_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_TMH_ID:
        rv = soc_sbx_t3p1_hlen_tmh_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_KSOP_ID:
        rv = soc_sbx_t3p1_htype_ksop_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_KSOP_ID:
        rv = soc_sbx_t3p1_hlen_ksop_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_CUSTOM_ID:
        rv = soc_sbx_t3p1_htype_custom_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HLEN_CUSTOM_ID:
        rv = soc_sbx_t3p1_hlen_custom_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_HTYPE_UNKN_ID:
        rv = soc_sbx_t3p1_htype_unkn_get(unit, &v); 
        break;

    }
    if (rv) {
        cli_out("constant %s get timeout\n",
                tm->constants[cid].name);
        return rv;
    }
    cli_out("%s=", tm->constants[cid].name);
    soc_sbx_t3p1_print(-1, v);
    cli_out("\n");
    return SOC_E_NONE;
}



/*
 * Diag shell print routine for Globals
 */
int soc_sbx_t3p1_global_shell_print(int unit, int gid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;

    switch (gid) {
    case SOC_SBX_T3P1_CONTEXTS_ID:
        rv = soc_sbx_t3p1_contexts_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID:
        rv = soc_sbx_t3p1_debug_stream_elen_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID:
        rv = soc_sbx_t3p1_c3_sws_static_page_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_t3p1_c3_sws_ingress_bubble_squeue_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID:
        rv = soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid0_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID:
        rv = soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid1_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_t3p1_c3_sws_egress_bubble_squeue_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID:
        rv = soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid0_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID:
        rv = soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid1_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID:
        rv = soc_sbx_t3p1_ingress_replication_count_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID:
        rv = soc_sbx_t3p1_egress_replication_count_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_FLUSH_PORT_ID:
        rv = soc_sbx_t3p1_flush_port_get(unit, &v); 
        break;

    case SOC_SBX_T3P1_MAC_LIMIT_ID:
        rv = soc_sbx_t3p1_mac_limit_get(unit, &v); 
        break;

    }
    if (rv) {
        cli_out("global %s get timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    cli_out("%s=", tm->globals[gid].name);
    soc_sbx_t3p1_print(tm->globals[gid].range, v);
    cli_out("\n");
    return SOC_E_NONE;
}

/*
 * Diag shell set routine for Globals
 */
int
soc_sbx_t3p1_global_shell_set(int unit, 
         int gid, int argc, char **argv)
{
    int rv;
    uint32 v;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;

    if (argc == 0) {
        cli_out("missing value\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_t3p1_read(argv[0], tm->globals[gid].range, &v);
    if (rv) {
        cli_out("illegal value '%s'\n", argv[0]);
        return SOC_E_PARAM;
    }
    switch (gid) {
    case SOC_SBX_T3P1_CONTEXTS_ID:
        rv = soc_sbx_t3p1_contexts_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_DEBUG_STREAM_ELEN_ID:
        rv = soc_sbx_t3p1_debug_stream_elen_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_STATIC_PAGE_ID:
        rv = soc_sbx_t3p1_c3_sws_static_page_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_t3p1_c3_sws_ingress_bubble_squeue_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID:
        rv = soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid0_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID:
        rv = soc_sbx_t3p1_c3_sws_fab_to_line_redirect_qid1_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID:
        rv = soc_sbx_t3p1_c3_sws_egress_bubble_squeue_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID:
        rv = soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid0_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID:
        rv = soc_sbx_t3p1_c3_sws_line_to_fab_redirect_qid1_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_INGRESS_REPLICATION_COUNT_ID:
        rv = soc_sbx_t3p1_ingress_replication_count_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_EGRESS_REPLICATION_COUNT_ID:
        rv = soc_sbx_t3p1_egress_replication_count_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_FLUSH_PORT_ID:
        rv = soc_sbx_t3p1_flush_port_set(unit, v); 
        break;
        
    case SOC_SBX_T3P1_MAC_LIMIT_ID:
        rv = soc_sbx_t3p1_mac_limit_set(unit, v); 
        break;
        
    }   
    if (rv) {
        cli_out("global %s set timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    return SOC_E_NONE;
}


/* Shell const get command usage string */
char soc_sbx_t3p1_constant_usage[] =
"t3p1constantget <constant>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        HTYPE_NULL       (constant) \n"
"        HLEN_NULL       (constant) \n"
"        HTYPE_ETYPE       (constant) \n"
"        HLEN_ETYPE       (constant) \n"
"        HTYPE_ETH       (constant) \n"
"        HLEN_ETH       (constant) \n"
"        HTYPE_IETH       (constant) \n"
"        HTYPE_LLC       (constant) \n"
"        HLEN_LLC       (constant) \n"
"        HTYPE_SNAP       (constant) \n"
"        HLEN_SNAP       (constant) \n"
"        HTYPE_VTAG       (constant) \n"
"        HLEN_VTAG       (constant) \n"
"        HTYPE_DVTAG       (constant) \n"
"        HTYPE_MPLS       (constant) \n"
"        HLEN_MPLS       (constant) \n"
"        HTYPE_IPV4       (constant) \n"
"        HLEN_IPV4       (constant) \n"
"        HTYPE_IPV6       (constant) \n"
"        HLEN_IPV6       (constant) \n"
"        HTYPE_UDP       (constant) \n"
"        HLEN_UDP       (constant) \n"
"        HTYPE_TCP       (constant) \n"
"        HLEN_TCP       (constant) \n"
"        HTYPE_ACH       (constant) \n"
"        HLEN_ACH       (constant) \n"
"        HTYPE_PTP       (constant) \n"
"        HLEN_PTP       (constant) \n"
"        HTYPE_MIM       (constant) \n"
"        HLEN_MIM       (constant) \n"
"        HTYPE_ELEN       (constant) \n"
"        HLEN_ELEN       (constant) \n"
"        HTYPE_ERH       (constant) \n"
"        HLEN_ERH       (constant) \n"
"        HTYPE_TMH       (constant) \n"
"        HLEN_TMH       (constant) \n"
"        HTYPE_KSOP       (constant) \n"
"        HLEN_KSOP       (constant) \n"
"        HTYPE_CUSTOM       (constant) \n"
"        HLEN_CUSTOM       (constant) \n"
"        HTYPE_UNKN       (constant) \n"
#endif
;


/* Shell global get command usage string */
char soc_sbx_t3p1_global_get_usage[] =
"t3p1globalget <global>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
 "        CONTEXTS        (global) \n" 
 "        DEBUG_STREAM_ELEN        (global) \n" 
 "        C3_SWS_STATIC_PAGE        (global) \n" 
 "        C3_SWS_INGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID1        (global) \n" 
 "        C3_SWS_EGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID1        (global) \n" 
 "        INGRESS_REPLICATION_COUNT        (global) \n" 
 "        EGRESS_REPLICATION_COUNT        (global) \n" 
 "        FLUSH_PORT        (global) \n" 
 "        MAC_LIMIT        (global) \n" 
#endif
;

char soc_sbx_t3p1_global_set_usage[] =
"t3p1globalset <global> <value>\n"
#ifndef COMPILER_STRING_CONST_LIMIT
 "        CONTEXTS        (global) \n" 
 "        DEBUG_STREAM_ELEN        (global) \n" 
 "        C3_SWS_STATIC_PAGE        (global) \n" 
 "        C3_SWS_INGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_FAB_TO_LINE_REDIRECT_QID1        (global) \n" 
 "        C3_SWS_EGRESS_BUBBLE_SQUEUE        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID0        (global) \n" 
 "        C3_SWS_LINE_TO_FAB_REDIRECT_QID1        (global) \n" 
 "        INGRESS_REPLICATION_COUNT        (global) \n" 
 "        EGRESS_REPLICATION_COUNT        (global) \n" 
 "        FLUSH_PORT        (global) \n" 
 "        MAC_LIMIT        (global) \n" 
#endif
;



/* entry print accessor implementation for lag */
void soc_sbx_t3p1_lag_print(int unit, soc_sbx_t3p1_lag_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->qid; w = 3;  break;
        case 1: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for lag */
int soc_sbx_t3p1_lag_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_lag_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_lag_t e0;
    soc_sbx_t3p1_lag_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int ilagi;
    void *indexpointers[1];
    indexpointers[0] = &ilagi;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_lag_get(unit,
                  ilagi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_lag_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lag */
int soc_sbx_t3p1_lag_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_lag_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_lag_t e0;
    soc_sbx_t3p1_lag_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_LAG_ID];
    int ilagi;
    void *indexpointers[1];
    indexpointers[0] = &ilagi;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_lag_t_init(e);

    rv = soc_sbx_t3p1_lag_get(unit,
                  ilagi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->qid,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_t3p1_value_read(&e->oi,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_LAG_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_lag_set(unit,
                  ilagi  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for vlan */
void soc_sbx_t3p1_vlan_print(int unit, soc_sbx_t3p1_vlan_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->qid; w = 3;  break;
        case 1: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for vlan */
int soc_sbx_t3p1_vlan_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_vlan_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_vlan_t e0;
    soc_sbx_t3p1_vlan_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_vlan_get(unit,
                  ivlan  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_vlan_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for vlan */
int soc_sbx_t3p1_vlan_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_vlan_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_vlan_t e0;
    soc_sbx_t3p1_vlan_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_VLAN_ID];
    int ivlan;
    void *indexpointers[1];
    indexpointers[0] = &ivlan;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_vlan_t_init(e);

    rv = soc_sbx_t3p1_vlan_get(unit,
                  ivlan  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->qid,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_t3p1_value_read(&e->oi,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_VLAN_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_vlan_set(unit,
                  ivlan  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for irt */
void soc_sbx_t3p1_irt_print(int unit, soc_sbx_t3p1_irt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->mirror; w = 6;  break;
        case 3: v = e->usevlan; w = 7;  break;
        case 4: v = e->useftidx; w = 8;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->cos; w = 3;  break;
        case 8: v = e->fcos; w = 4;  break;
        case 9: v = e->usedp; w = 5;  break;
        case 10: v = e->usecos; w = 6;  break;
        case 11: v = e->policer; w = 7;  break;
        case 12: v = e->typedpolice; w = 11;  break;
        case 13: v = e->mefcos; w = 6;  break;
        case 14: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for irt */
int soc_sbx_t3p1_irt_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_irt_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_irt_t e0;
    soc_sbx_t3p1_irt_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_irt_get(unit,
                  iirule  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_irt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for irt */
int soc_sbx_t3p1_irt_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_irt_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_irt_t e0;
    soc_sbx_t3p1_irt_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_IRT_ID];
    int iirule;
    void *indexpointers[1];
    indexpointers[0] = &iirule;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_irt_t_init(e);

    rv = soc_sbx_t3p1_irt_get(unit,
                  iirule  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->vlan,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_t3p1_value_read(&e->ftidx,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_t3p1_value_read(&e->mirror,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_t3p1_value_read(&e->usevlan,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_t3p1_value_read(&e->useftidx,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_t3p1_value_read(&e->copy,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_t3p1_value_read(&e->dp,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_t3p1_value_read(&e->cos,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_t3p1_value_read(&e->fcos,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        case 9: rv = soc_sbx_t3p1_value_read(&e->usedp,
                                        ed->fields[9].range, 0, argc, argv);
                    break;

        case 10: rv = soc_sbx_t3p1_value_read(&e->usecos,
                                        ed->fields[10].range, 0, argc, argv);
                    break;

        case 11: rv = soc_sbx_t3p1_value_read(&e->policer,
                                        ed->fields[11].range, 0, argc, argv);
                    break;

        case 12: rv = soc_sbx_t3p1_value_read(&e->typedpolice,
                                        ed->fields[12].range, 0, argc, argv);
                    break;

        case 13: rv = soc_sbx_t3p1_value_read(&e->mefcos,
                                        ed->fields[13].range, 0, argc, argv);
                    break;

        case 14: rv = soc_sbx_t3p1_value_read(&e->mef,
                                        ed->fields[14].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_IRT_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_irt_set(unit,
                  iirule  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_bubble */
void soc_sbx_t3p1_oam_bubble_print(int unit, soc_sbx_t3p1_oam_bubble_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->bubble_mode; w = 11;  break;
        case 1: v = e->je; w = 2;  break;
        case 2: v = e->i; w = 1;  break;
        case 3: v = e->bubble_stream; w = 13;  break;
        case 4: v = e->t; w = 1;  break;
        case 5: v = e->interval_index; w = 14;  break;
        case 6: v = e->reserved; w = 8;  break;
        case 7: v = e->count; w = 5;  break;
        case 8: v = e->timeout; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_oam_bubble_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_oam_bubble_t e0;
    soc_sbx_t3p1_oam_bubble_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int ioamepi;
    void *indexpointers[1];
    indexpointers[0] = &ioamepi;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_oam_bubble_get(unit,
                  ioamepi  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_oam_bubble_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_bubble */
int soc_sbx_t3p1_oam_bubble_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_oam_bubble_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_oam_bubble_t e0;
    soc_sbx_t3p1_oam_bubble_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_OAM_BUBBLE_ID];
    int ioamepi;
    void *indexpointers[1];
    indexpointers[0] = &ioamepi;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_oam_bubble_t_init(e);

    rv = soc_sbx_t3p1_oam_bubble_get(unit,
                  ioamepi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->bubble_mode,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_t3p1_value_read(&e->je,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        case 2: rv = soc_sbx_t3p1_value_read(&e->i,
                                        ed->fields[2].range, 0, argc, argv);
                    break;

        case 3: rv = soc_sbx_t3p1_value_read(&e->bubble_stream,
                                        ed->fields[3].range, 0, argc, argv);
                    break;

        case 4: rv = soc_sbx_t3p1_value_read(&e->t,
                                        ed->fields[4].range, 0, argc, argv);
                    break;

        case 5: rv = soc_sbx_t3p1_value_read(&e->interval_index,
                                        ed->fields[5].range, 0, argc, argv);
                    break;

        case 6: rv = soc_sbx_t3p1_value_read(&e->reserved,
                                        ed->fields[6].range, 0, argc, argv);
                    break;

        case 7: rv = soc_sbx_t3p1_value_read(&e->count,
                                        ed->fields[7].range, 0, argc, argv);
                    break;

        case 8: rv = soc_sbx_t3p1_value_read(&e->timeout,
                                        ed->fields[8].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_OAM_BUBBLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_oam_bubble_set(unit,
                  ioamepi  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for demoage */
void soc_sbx_t3p1_demoage_print(int unit, soc_sbx_t3p1_demoage_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->age; w = 3;  break;
        case 1: v = e->age_valid; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for demoage */
int soc_sbx_t3p1_demoage_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_demoage_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_demoage_t e0;
    soc_sbx_t3p1_demoage_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_demoage_get(unit,
                  imacindex  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_demoage_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for demoage */
int soc_sbx_t3p1_demoage_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_demoage_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_demoage_t e0;
    soc_sbx_t3p1_demoage_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGE_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_demoage_t_init(e);

    rv = soc_sbx_t3p1_demoage_get(unit,
                  imacindex  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->age,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        case 1: rv = soc_sbx_t3p1_value_read(&e->age_valid,
                                        ed->fields[1].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_DEMOAGE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_demoage_set(unit,
                  imacindex  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for demoageid */
void soc_sbx_t3p1_demoageid_print(int unit, soc_sbx_t3p1_demoageid_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->age_id; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for demoageid */
int soc_sbx_t3p1_demoageid_shell_print(int unit, int argc, char **argv);

int soc_sbx_t3p1_demoageid_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_demoageid_t e0;
    soc_sbx_t3p1_demoageid_t *e = &e0;
    int rv;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;

    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            cli_out("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_demoageid_get(unit,
                  imacindex  ,
                e);

        if (rv) {
            cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_demoageid_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for demoageid */
int soc_sbx_t3p1_demoageid_shell_set(int unit, int argc, char **argv);
int soc_sbx_t3p1_demoageid_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_demoageid_t e0;
    soc_sbx_t3p1_demoageid_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_DEMOAGEID_ID];
    int imacindex;
    void *indexpointers[1];
    indexpointers[0] = &imacindex;


    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_demoageid_t_init(e);

    rv = soc_sbx_t3p1_demoageid_get(unit,
                  imacindex  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
            cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->age_id,
                                        ed->fields[0].range, 0, argc, argv);
                    break;

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity[callee_ptr_arith] */
        soc_sbx_t3p1_ocm_update_overlaps(unit, SOC_SBX_T3P1_DEMOAGEID_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_demoageid_set(unit,
                  imacindex  ,
                e);

    if (rv) {
        cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/*
 * Shell entry print implementation
 */
int soc_sbx_t3p1_entries_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_t3p1_entries_shell_print(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_T3P1_LAG_ID:
        rv = soc_sbx_t3p1_lag_shell_print(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_VLAN_ID:
        rv = soc_sbx_t3p1_vlan_shell_print(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_IRT_ID:
        rv = soc_sbx_t3p1_irt_shell_print(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_OAM_BUBBLE_ID:
        rv = soc_sbx_t3p1_oam_bubble_shell_print(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_DEMOAGE_ID:
        rv = soc_sbx_t3p1_demoage_shell_print(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_DEMOAGEID_ID:
        rv = soc_sbx_t3p1_demoageid_shell_print(unit, argc, argv); 
        break;
        
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
int soc_sbx_t3p1_entries_shell_set(int unit, int eid, int argc, char **argv);
int soc_sbx_t3p1_entries_shell_set(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_T3P1_LAG_ID:
        rv = soc_sbx_t3p1_lag_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_VLAN_ID:
        rv = soc_sbx_t3p1_vlan_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_IRT_ID:
        rv = soc_sbx_t3p1_irt_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_OAM_BUBBLE_ID:
        rv = soc_sbx_t3p1_oam_bubble_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_DEMOAGE_ID:
        rv = soc_sbx_t3p1_demoage_shell_set(unit, argc, argv); 
        break;
        
    case SOC_SBX_T3P1_DEMOAGEID_ID:
        rv = soc_sbx_t3p1_demoageid_shell_set(unit, argc, argv); 
        break;
        
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}


/* entry diag shell delete implementation for ifp */


int
soc_sbx_t3p1_memory_shell_print(int unit,
         int mid, int argc, char **argv)
{
    int rv, i;
    uint32 addr, v, range;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_bank_t *tb = NULL; 
    soc_sbx_t3p1_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int sidx, eidx;
    uint32 segment;

    if (argc < 2) {
        cli_out("missing parameters\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_t3p1_read(argv[0], 128 , &segment);
    if (rv) {
        cli_out("illegal segment %s\n", argv[0]);
        return SOC_E_PARAM;
    }
    rv = soc_sbx_t3p1_read(argv[1], 1 << 23, &addr);
    if (rv) {
        cli_out("illegal address %s\n", argv[1]);
        return SOC_E_PARAM;
    }

    range = 1;
    if (argc > 2) {
        rv = soc_sbx_t3p1_read(argv[2], 1 << 23, &range);
        if (rv) {
            cli_out("illegal range %s\n", argv[1]);
            return SOC_E_PARAM;
        }
    }

    rv = soc_sbx_t3p1_table_bank_get(tm, md->ocmport, segment, (int) addr, &tb);
    if (rv) {
        cli_out("Segment(%d) Not mapped or Address 0x%x Out Of Range\n", segment, addr);
        return rv;
    }

    if (range > tb->limit - tb->base) {
        cli_out("Range %d beyond segment limits\n", range);
        return SOC_E_PARAM;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    sidx = addr;
    eidx = addr + ((range << 6) / tb->width);

    rv = soc_sbx_caladan3_ocm_port_mem_read(unit, tb->memory, tb->segment, 
                   sidx, eidx, (uint32 *)tm->entrydmabuf);
    if (SOC_SUCCESS(rv)) 
        soc_sbx_caladan3_cmic_endian(tm->entrydmabuf, mwidth/8);
    if (rv) {
        cli_out("memory read from %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    for (i = 0; i < 2*range; i++) {
      if (!(i & 1)) {
        cli_out("%s[0x%x]=",  tm->memories[mid].name, addr+(i>>1));
      }

      v = tm->entrydmabuf[i * 4 + 3]
          | (tm->entrydmabuf[i * 4 + 2] << 8)
          | (tm->entrydmabuf[i * 4 + 1] << 16)
          | (tm->entrydmabuf[i * 4 + 0] << 24); 

      soc_sbx_t3p1_print(-1, v);
      cli_out(" ");
      if ((i & 1)) {
        cli_out("\n");
      }
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}
/* Diag shell set memory contents */
int
soc_sbx_t3p1_memory_shell_set(int unit, 
         int mid, int argc, char **argv)
{
    int rv, i;
    uint32 v, addr, range;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_bank_t *tb = NULL; 
    soc_sbx_t3p1_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int sidx = 0;
    int eidx = 0;
    uint32 segment;

    if (argc < 4) {
        cli_out("missing parameters\n");
        return SOC_E_PARAM;
    }

    rv = soc_sbx_t3p1_read(argv[0], 128 , &segment);
    if (rv) {
        cli_out("illegal segment %s\n", argv[0]);
        return SOC_E_PARAM;
    }
    argc--;
    argv++;

    rv = soc_sbx_t3p1_read(argv[0], 1 << 23, &addr);
    if (rv) {
        cli_out("illegal address %s\n", argv[1]);
        return SOC_E_PARAM;
    }
    argc--;
    argv++;

    range = 1;
    rv = soc_sbx_t3p1_read(argv[0], 1 << 23, &range);

    if (rv) {
        cli_out("illegal range %s\n", argv[1]);
        return SOC_E_PARAM;
    }

    argc--;
    argv++;

    rv = soc_sbx_t3p1_table_bank_get(tm, md->ocmport, segment, (int) addr, &tb);
    if (rv) {
        cli_out("Segment(%d) Not mapped or Address 0x%x out of range\n", segment, addr);
        return rv;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    for (i = 0; i < 2*range; i++) {
        if (!argc) {
            cli_out("missing value\n");
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }

        rv = soc_sbx_t3p1_read(argv[0], -1, &v);
 
        if (rv) {
            cli_out("illegal value '%s'\n", argv[i + 1]);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }

        tm->entrydmabuf[i * 4 + 3] = v;
        tm->entrydmabuf[i * 4 + 2] = v >> 8;
        tm->entrydmabuf[i * 4 + 1] = v >> 16;
        tm->entrydmabuf[i * 4 + 0] = v >> 24; 

        argc--;
        argv++;
    }

    sidx = addr;
    eidx = addr + ((range << 6) / tb->width);

    soc_sbx_caladan3_cmic_endian(tm->entrydmabuf, mwidth/8);
    rv = soc_sbx_caladan3_ocm_port_mem_write(unit, tb->memory, tb->segment, 
                   sidx, eidx, (uint32 *)tm->entrydmabuf);
    if (rv) {
        cli_out("memory write to %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_t3p1_ocm_associated_table_info_dump(int unit, 
                                                     soc_sbx_t3p1_table_id_t table_id,
                                                     int table_bank_id, int detail)
 {
     int index;
     int entry;
     soc_sbx_t3p1_state_t *fe =
         (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
     soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
     soc_sbx_t3p1_entry_desc_t *ed;
     soc_sbx_t3p1_table_desc_t *tablePtr;

     /* The Entry Ids and Table Ids correspond one for one throughout 
      * all of t3p1_defs.[c|h] code. If that EVER changes this function will
      * require a conversion routine to covert between the two ID number spaces!
      */
     if (table_id > SOC_SBX_T3P1_TABLE_MAX_ID) {
         return 1;
     }
     ed = &tm->entries[table_id];

     tablePtr = &tm->tables[table_id];

     if (!ed->name) {
        return 1;
     }

     if (!tablePtr->name) {
         return 1;
     }

     if (!detail) {
         cli_out("%12s  %2d    %2d         %-24s:%2d  %2d\n",
                 tablePtr->name, table_id, table_bank_id,
                 soc_sbx_ocm_port_num_to_name(
                 tm->tables[table_id].banks[table_bank_id].memory),
                 tm->tables[table_id].banks[table_bank_id].memory,
                 tm->tables[table_id].banks[table_bank_id].segment);
         return 0;
     }
     cli_out("\n======\n");
     cli_out("Table [%s]  Id [%d]  Bank [%d] --> OCM Port[%s:%d]   Segment[%d]\n", 
             tablePtr->name, table_id, table_bank_id, 
             soc_sbx_ocm_port_num_to_name(tm->tables[table_id].banks[table_bank_id].memory),
             tm->tables[table_id].banks[table_bank_id].memory,
             tm->tables[table_id].banks[table_bank_id].segment);

     cli_out("\nTable INDEX:");

     for (index = 0; index < ed->nindexes; index++) {
     cli_out("%s%s[%d:%d]",
             (index? ",  ":"\n    < "), 
             ed->indexes[index].name, 
             ed->indexes[index].pos, 
             ed->indexes[index].pos + (ed->indexes[index].width - 1) );
     }
     cli_out(" >\n");

     cli_out("\nTable FIELD(s):");
     for (entry = 0; entry < ed->nfields; entry++) {
         cli_out("%s%s[%d:%d]",
                 (entry? "":"\n    { "),  
                 ed->fields[entry].name, 
                 ed->fields[entry].pos, 
                 ed->fields[entry].pos + (ed->fields[entry].width - 1));

         if (!((entry+1)%4) && entry != ed->nfields - 1) {
             cli_out(",\n      ");
         } else {
             if (entry == ed->nfields - 1) {
                 cli_out(" }\n");
             } else {
                 cli_out(",  ");
             }
         }
     }

     cli_out("\nTable BANK Info:\n");

     cli_out("\n    Sz[%d](unused by OCM)   Limit[%d]  Base[%d]  Width[%d]",
             tm->tables[table_id].banks[table_bank_id].size,
             tm->tables[table_id].banks[table_bank_id].limit,
             tm->tables[table_id].banks[table_bank_id].base,
             tm->tables[table_id].banks[table_bank_id].width);

     cli_out("\n==================================================================");
     cli_out("\n\n");

     return 0;
 }

STATIC 
char* soc_sbx_t3p1_ocm_port_to_lrp_port(int unit, sbx_caladan3_ocm_port_e_t mem) 
{
    int i;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    for (i=0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) { 
        if (tm->memories[i].ocmport == mem) { 
            break; 
        }
    }
    return ((i < SOC_SBX_T3P1_MEMORY_MAX_ID) ? tm->memories[i].name : "not found");
}    

int soc_sbx_t3p1_memory_map_shell_print(int unit, char *name);
int soc_sbx_t3p1_memory_map_shell_print(int unit, char *name)
{
    int i, j, base0, size0, slen;
    int fw = 20;
    char *s;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_t3p1_table_desc_t *td = NULL;
    soc_sbx_t3p1_memory_bank_desc_t *mb;

    if (name) {
        for (i = 0; i < SOC_SBX_T3P1_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            if (!sal_strcasecmp(td->name, name)) {
                cli_out("\nMemory map for table %s\n", name);
                cli_out("Bank   LRPPort CPUPort  Segment Width    Base       Size\n");
                cli_out("-----------------------------------------"
                        "---------------\n");
                for (j = 0; j < td->nbanks; j++) {
                    cli_out("%-6d%-11s%-8d%-8d%-7d0x%08x 0x%06x\n",
                            j, soc_sbx_t3p1_ocm_port_to_lrp_port(unit, td->banks[j].memory),
                            td->banks[j].memory,
                            td->banks[j].segment,
                            td->banks[j].width,
                            td->banks[j].base, td->banks[j].limit - td->banks[j].base);
                }
                cli_out("\n");
                return SOC_E_NONE;
            }
        }
        return SOC_E_PARAM;
    } else {
        for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
            if (tm->memories[i].nbanks) {
                cli_out("\nMemory map for %s", tm->memories[i].name);
                if (tm->memories[i].dma) {
                    cli_out(" (cpu port %d)", tm->memories[i].ocmport);
                }
                cli_out("\n%-*s%s\n",
                        fw, "Element", "Segment    Width    Base      Size");
                cli_out("------------------------------------------"
                        "------------------------\n");               
                for (j = 0; j < tm->memories[i].nbanks; j++) {
                    mb = &tm->memories[i].banks[j];
                    soc_sbx_t3p1_memory_bank_params_get(&base0, &size0, mb, tm);
                    
                    switch (mb->type) {
                    case SOC_SBX_T3P1_TABLE_BANK_TYPE:
                        td = &tm->tables[mb->number];
                        cli_out("%s", td->name);
                        slen = sal_strlen(td->name);
                        if (td->nbanks > 1) {
                            cli_out("%c", '0' + mb->bank);
                            slen++;
                        }
                        cli_out("%*s", fw - slen, "");
                        break;
                    case SOC_SBX_T3P1_COUNTER_BANK_TYPE:
                        s = "counter bank";
                        slen = sal_strlen(s);
                        cli_out("%s %-2d", s, mb->number);
                        cli_out("%*s", fw - slen - 3, "");
                        break;
                    case SOC_SBX_T3P1_POLICER_BANK_TYPE:
                        s = "policer bank";
                        slen = sal_strlen(s);
                        cli_out("%s %-2d", s, mb->number);
                        cli_out("%*s", fw - slen - 3, "");
                    }

                    if (td != NULL) {
                      cli_out("%3d%10d    0x%06x 0x%06x\n",
                              td->banks[mb->bank].segment, 
                              td->banks[mb->bank].width, 
                              base0, size0);
                    } else {
                      cli_out("\n");
                    }
                }
            }
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell constant print driver implementation
 */
int soc_sbx_t3p1_shell_print_constants(int unit, int argc, char **argv)
{
    int i;
    int bank_id = 0;
    int table_id = 0;
    int detail = 0;
    int  ocmmemdump = 0;    
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

   if (!sal_strcasecmp(argv[0], "ocmmemdetail")) {
       detail = 1;
       ocmmemdump = 1;

       if (argc > 2) {
           cli_out("extra arguments to %s command\n",
                   "ocmmemmap");
       }
   }

   if (!sal_strcasecmp(argv[0], "ocmmemmap")) {
       detail = 0;
       ocmmemdump = 1;
 
       if (argc > 2) {
           cli_out("extra arguments to %s command\n",
                   "ocmmemmap");
       }
   }

   if (ocmmemdump) {
       cli_out("\n===================================================\n");
       cli_out("OCM Memory Info");
       cli_out("\n===================================================\n\n");        

       if (!detail) {
           cli_out("Table: Name   Id    Bank  --->  OCM Port                          Seg\n"); 
           cli_out("======================================================================\n");
       }

       for (table_id = 0; table_id < SOC_SBX_T3P1_TABLE_MAX_ID; table_id++) {
           if (!tm->tables[table_id].name) {
               continue;
           }
           for (bank_id = 0; bank_id < tm->tables[table_id].nbanks; bank_id++) {
               soc_sbx_t3p1_ocm_associated_table_info_dump(unit, 
                                                               table_id, bank_id, detail);
           }
       }
       return SOC_E_NONE;
   }

    for (i = 0; i < SOC_SBX_T3P1_CONSTANT_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0],"all")) {
          soc_sbx_t3p1_constant_shell_print(unit, i);
        } else if (!sal_strcasecmp(argv[0], tm->constants[i].name)) {
          return soc_sbx_t3p1_constant_shell_print(unit, i);
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell global print driver implementation
 */
int soc_sbx_t3p1_shell_print_globals(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
          return soc_sbx_t3p1_global_shell_print(unit, i);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell mem print driver implementation
 */
int soc_sbx_t3p1_shell_print_memories(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_t3p1_memory_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_t3p1_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_entries_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    if (!sal_strcasecmp(argv[0], "memmap")) {
        if (argc > 2) {
            cli_out("extra arguments to %s command\n",
                    "memmap");
        }
        return soc_sbx_t3p1_memory_map_shell_print(unit,
                         argc > 1 ? argv[1] : NULL);
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell global set driver implementation
 */
int soc_sbx_t3p1_shell_set_globals(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
            return soc_sbx_t3p1_global_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell memory set driver implementation
 */
int soc_sbx_t3p1_shell_set_memories(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_t3p1_memory_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_t3p1_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_entries_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
/*
 * Shell entry delete implementation
 */
int soc_sbx_t3p1_entries_shell_delete(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_t3p1_entries_shell_delete(int unit, 
         int eid, int argc, char **argv)
{
    return SOC_E_NOT_FOUND;
}
 
int soc_sbx_t3p1_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_T3P1_ENTRY_MAX_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_entries_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/* Shell get command usage string */
char soc_sbx_t3p1_mem_get_usage[] =
"t3p1memget <memory> <segment> <addr> [<range>]   \n"
"     supported memories are:                     \n"
"         lrp_port0 lrp_port1 lrp_port2 lrp_port3 \n"
"         lrp_port4 lrp_port5 lrp_port6 lrp_port7 \n"
"         lrp_port8 lrp_port9                     \n"
;

/* Shell set command usage string */
char soc_sbx_t3p1_mem_set_usage[] =
"t3p1memset <memory>  <segment> <addr> <range> <32'h value> <32'h value> ... \n"
"     supported memories are:                     \n"
"         lrp_port0 lrp_port1 lrp_port2 lrp_port3 \n"
"         lrp_port4 lrp_port5 lrp_port6 lrp_port7 \n"
"         lrp_port8 lrp_port9                     \n"
;

/* Shell get command usage string */
char soc_sbx_t3p1_get_usage[] =
"t3p1get [<table> idx0=<i0> ...|\n"
"          |memmap [table]]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        lag               \n"
"                         lagi=<lagi> \n" 
"        vlan               \n"
"                         vlan=<vlan> \n" 
"        irt               \n"
"                         irule=<irule> \n" 
"        oam_bubble               \n"
"                         oamepi=<oamepi> \n" 
"        demoage               \n"
"                         macindex=<macindex> \n" 
"        demoageid               \n"
"                         macindex=<macindex> \n" 
#endif
;
/* Shell set command usage string */
char soc_sbx_t3p1_set_usage[] =
"t3p1set [<table> idx0=<i0> ...[field0=<f0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        lag               \n"
"                         lagi=<lagi> \n" 
"                         [ \n"
"                         qid=<qid> \n" 
"                         oi=<oi> \n" 
"                         ] \n"
"        vlan               \n"
"                         vlan=<vlan> \n" 
"                         [ \n"
"                         qid=<qid> \n" 
"                         oi=<oi> \n" 
"                         ] \n"
"        irt               \n"
"                         irule=<irule> \n" 
"                         [ \n"
"                         vlan=<vlan> \n" 
"                         ftidx=<ftidx> \n" 
"                         mirror=<mirror> \n" 
"                         usevlan=<usevlan> \n" 
"                         useftidx=<useftidx> \n" 
"                         copy=<copy> \n" 
"                         dp=<dp> \n" 
"                         cos=<cos> \n" 
"                         fcos=<fcos> \n" 
"                         usedp=<usedp> \n" 
"                         usecos=<usecos> \n" 
"                         policer=<policer> \n" 
"                         typedpolice=<typedpolice> \n" 
"                         mefcos=<mefcos> \n" 
"                         mef=<mef> \n" 
"                         ] \n"
"        oam_bubble               \n"
"                         oamepi=<oamepi> \n" 
"                         [ \n"
"                         bubble_mode=<bubble_mode> \n" 
"                         je=<je> \n" 
"                         i=<i> \n" 
"                         bubble_stream=<bubble_stream> \n" 
"                         t=<t> \n" 
"                         interval_index=<interval_index> \n" 
"                         reserved=<reserved> \n" 
"                         count=<count> \n" 
"                         timeout=<timeout> \n" 
"                         ] \n"
"        demoage               \n"
"                         macindex=<macindex> \n" 
"                         [ \n"
"                         age=<age> \n" 
"                         age_valid=<age_valid> \n" 
"                         ] \n"
"        demoageid               \n"
"                         macindex=<macindex> \n" 
"                         [ \n"
"                         age_id=<age_id> \n" 
"                         ] \n"
#endif
;

/* Shell delete command usage string */
char soc_sbx_t3p1_delete_usage[] =
"t3p1delete <table> idx0=<i0> ...\n"
"        ifp             rule=<rule> \n"
;



#endif
