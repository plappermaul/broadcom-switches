/**
 * $Id: ppe_diags_c.stg,v 1.27 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * g3p1_ppe_diags.c: Guadalupe2k V1.3 microcode PPE diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_defs.h>
#include <soc/sbx/g3p1/g3p1_ppe_diags.h>

static uint32 makePpeMask(int offset, int width) {
    int i;
    uint32 bit = (1 << offset);
    uint32 mask = 0;

    for (i = 0;i < width;i++) {
        mask |= bit;
        bit = bit << 1;
    }

    return mask;
}

/*
 * Utility method
 */
int soc_sbx_g3p1_ppe_update_overlaps(int unit, int table, uint32 *e, char *name, int value) {
  int fidx;
  int i;
  soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
  soc_sbx_g3p1_entry_desc_t *ed =  &tm->entries[table];

  int p1;
  int p2;
  int word;
  uint32 mask;

    fidx = soc_sbx_g3p1_field_find(ed, name);
    if (fidx < 0) {
        cli_out("unexpected field name '%s'\n", name);
        return SOC_E_PARAM;
    }

    word = ed->fields[fidx].pos/32;

    for (i = 0;i < ed->nfields;i++) {
        if (i != fidx) {
            if ((ed->fields[i].pos <= (ed->fields[fidx].pos + ed->fields[fidx].width - 1)) && 
                ((ed->fields[i].pos + ed->fields[i].width - 1) >= ed->fields[fidx].pos)) {
                
                if (ed->fields[i].pos < ed->fields[fidx].pos)
                    p1 = ed->fields[fidx].pos;
                else 
                    p1 = ed->fields[i].pos;

                if ((ed->fields[i].pos + ed->fields[i].width) < (ed->fields[fidx].pos + ed->fields[fidx].width))
                    p2 = ed->fields[i].pos + ed->fields[i].width - p1;
                else
                    p2 = ed->fields[fidx].pos + ed->fields[fidx].width - p1;

                p1 = p1 - (word * 32);

                mask = makePpeMask(p1, p2);
                e[i] = ((!mask) & e[i])  | (mask & value);
                               cli_out("Field:%s (value:%d) overlaps with:%s offset:%d width:%d (p1:%d p2:%d m:0x%08x w:%d v:%d)\n",
                                        name,
                                        value,
                                        ed->fields[i].name,
                                        ed->fields[i].pos,
                                        ed->fields[i].width, p1, p2, mask, word, e[i]);
            }
        }
    }
    return 0;
}


/* entry print accessor implementation for p2e */
static void soc_sbx_g3p1_p2e_print(int unit, soc_sbx_g3p1_p2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_P2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->portid; w = 6;  break;
        case 1: v = e->state_num; w = 9;  break;
        case 2: v = e->lsmmatch; w = 8;  break;
        case 3: v = e->ipv4mc; w = 6;  break;
        case 4: v = e->pbb; w = 3;  break;
        case 5: v = e->twintpid; w = 8;  break;
        case 6: v = e->tpid; w = 4;  break;
        case 7: v = e->oamloop; w = 7;  break;
        case 8: v = e->provider; w = 8;  break;
        case 9: v = e->customer; w = 8;  break;
        case 10: v = e->hdrtype; w = 7;  break;
        case 11: v = e->timestamp; w = 9;  break;
        case 12: v = e->aggr_hash; w = 9;  break;
        case 13: v = e->mpls_hdrcompr; w = 13;  break;
        case 14: v = e->port; w = 4;  break;
        case 15: v = e->nativevid; w = 9;  break;
        case 16: v = e->defcfi; w = 6;  break;
        case 17: v = e->defpri; w = 6;  break;
        case 18: v = e->defstrip; w = 8;  break;
        case 19: v = e->pstrip; w = 6;  break;
        case 20: v = e->mim; w = 3;  break;
        case 21: v = e->mplstp; w = 6;  break;
        case 22: v = e->untaggedstrip; w = 13;  break;
        case 23: v = e->droptagged; w = 10;  break;
        case 24: v = e->dropuntagged; w = 12;  break;
        case 25: v = e->tc_1588; w = 7;  break;
        case 26: v = e->rep_data; w = 8;  break;
        case 27: v = e->ppe_variable; w = 12;  break;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for p2e */
static int soc_sbx_g3p1_p2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_p2e_t e0;
    soc_sbx_g3p1_p2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_P2E_ID];
    int port; 
    void *indexpointers[1];
    indexpointers[0] = &port;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_p2e_get(unit,
                    port  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_p2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e */
static int soc_sbx_g3p1_p2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_p2e_t e0;
    soc_sbx_g3p1_p2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_P2E_ID];
    int port; 
    void *indexpointers[1];
    indexpointers[0] = &port;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_p2e_t_init(e);

    rv = soc_sbx_g3p1_p2e_get(unit,
                    port  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->portid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->state_num,
                            ed->fields[1].range, 0, argc, argv);
        break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->lsmmatch,
                            ed->fields[2].range, 0, argc, argv);
        break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->ipv4mc,
                            ed->fields[3].range, 0, argc, argv);
        break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->pbb,
                            ed->fields[4].range, 0, argc, argv);
        break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->twintpid,
                            ed->fields[5].range, 0, argc, argv);
        break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->tpid,
                            ed->fields[6].range, 0, argc, argv);
        break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->oamloop,
                            ed->fields[7].range, 0, argc, argv);
        break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->provider,
                            ed->fields[8].range, 0, argc, argv);
        break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->customer,
                            ed->fields[9].range, 0, argc, argv);
        break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->hdrtype,
                            ed->fields[10].range, 0, argc, argv);
        break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->timestamp,
                            ed->fields[11].range, 0, argc, argv);
        break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->aggr_hash,
                            ed->fields[12].range, 0, argc, argv);
        break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->mpls_hdrcompr,
                            ed->fields[13].range, 0, argc, argv);
        break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->port,
                            ed->fields[14].range, 0, argc, argv);
        break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->nativevid,
                            ed->fields[15].range, 0, argc, argv);
        break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->defcfi,
                            ed->fields[16].range, 0, argc, argv);
        break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->defpri,
                            ed->fields[17].range, 0, argc, argv);
        break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->defstrip,
                            ed->fields[18].range, 0, argc, argv);
        break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->pstrip,
                            ed->fields[19].range, 0, argc, argv);
        break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->mim,
                            ed->fields[20].range, 0, argc, argv);
        break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->mplstp,
                            ed->fields[21].range, 0, argc, argv);
        break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->untaggedstrip,
                            ed->fields[22].range, 0, argc, argv);
        break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->droptagged,
                            ed->fields[23].range, 0, argc, argv);
        break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->dropuntagged,
                            ed->fields[24].range, 0, argc, argv);
        break;
        case 25: rv = soc_sbx_g3p1_value_read(&e->tc_1588,
                            ed->fields[25].range, 0, argc, argv);
        break;
        case 26: rv = soc_sbx_g3p1_value_read(&e->rep_data,
                            ed->fields[26].range, 0, argc, argv);
        break;
        case 27: rv = soc_sbx_g3p1_value_read(&e->ppe_variable,
                            ed->fields[27].range, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_P2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_p2e_set(unit,
                    port  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for ep2e */
static void soc_sbx_g3p1_ep2e_print(int unit, soc_sbx_g3p1_ep2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_EP2E_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->portid; w = 6;  break;
        case 1: v = e->state_num; w = 9;  break;
        case 2: v = e->lsmmatch; w = 8;  break;
        case 3: v = e->ipv4mc; w = 6;  break;
        case 4: v = e->pbb; w = 3;  break;
        case 5: v = e->twintpid; w = 8;  break;
        case 6: v = e->tpid; w = 4;  break;
        case 7: v = e->oamloop; w = 7;  break;
        case 8: v = e->provider; w = 8;  break;
        case 9: v = e->customer; w = 8;  break;
        case 10: v = e->hdrtype; w = 7;  break;
        case 11: v = e->timestamp; w = 9;  break;
        case 12: v = e->aggr_hash; w = 9;  break;
        case 13: v = e->mim; w = 3;  break;
        case 14: v = e->mpls_hdrcompr; w = 13;  break;
        case 15: v = e->port; w = 4;  break;
        case 16: v = e->pid; w = 3;  break;
        case 17: v = e->stpid0; w = 6;  break;
        case 18: v = e->stpid1; w = 6;  break;
        case 19: v = e->cep; w = 3;  break;
        case 20: v = e->keeperh; w = 7;  break;
        case 21: v = e->mirroridx; w = 9;  break;
        case 22: v = e->tc_1588; w = 7;  break;
        case 23: v = e->rep_data; w = 8;  break;
        case 24: v = e->ppe_variable; w = 12;  break;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for ep2e */
static int soc_sbx_g3p1_ep2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ep2e_t e0;
    soc_sbx_g3p1_ep2e_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_EP2E_ID];
    int port; 
    void *indexpointers[1];
    indexpointers[0] = &port;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_ep2e_get(unit,
                    port  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_ep2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e */
static int soc_sbx_g3p1_ep2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_ep2e_t e0;
    soc_sbx_g3p1_ep2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_EP2E_ID];
    int port; 
    void *indexpointers[1];
    indexpointers[0] = &port;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_ep2e_t_init(e);

    rv = soc_sbx_g3p1_ep2e_get(unit,
                    port  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->portid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->state_num,
                            ed->fields[1].range, 0, argc, argv);
        break;
        case 2: rv = soc_sbx_g3p1_value_read(&e->lsmmatch,
                            ed->fields[2].range, 0, argc, argv);
        break;
        case 3: rv = soc_sbx_g3p1_value_read(&e->ipv4mc,
                            ed->fields[3].range, 0, argc, argv);
        break;
        case 4: rv = soc_sbx_g3p1_value_read(&e->pbb,
                            ed->fields[4].range, 0, argc, argv);
        break;
        case 5: rv = soc_sbx_g3p1_value_read(&e->twintpid,
                            ed->fields[5].range, 0, argc, argv);
        break;
        case 6: rv = soc_sbx_g3p1_value_read(&e->tpid,
                            ed->fields[6].range, 0, argc, argv);
        break;
        case 7: rv = soc_sbx_g3p1_value_read(&e->oamloop,
                            ed->fields[7].range, 0, argc, argv);
        break;
        case 8: rv = soc_sbx_g3p1_value_read(&e->provider,
                            ed->fields[8].range, 0, argc, argv);
        break;
        case 9: rv = soc_sbx_g3p1_value_read(&e->customer,
                            ed->fields[9].range, 0, argc, argv);
        break;
        case 10: rv = soc_sbx_g3p1_value_read(&e->hdrtype,
                            ed->fields[10].range, 0, argc, argv);
        break;
        case 11: rv = soc_sbx_g3p1_value_read(&e->timestamp,
                            ed->fields[11].range, 0, argc, argv);
        break;
        case 12: rv = soc_sbx_g3p1_value_read(&e->aggr_hash,
                            ed->fields[12].range, 0, argc, argv);
        break;
        case 13: rv = soc_sbx_g3p1_value_read(&e->mim,
                            ed->fields[13].range, 0, argc, argv);
        break;
        case 14: rv = soc_sbx_g3p1_value_read(&e->mpls_hdrcompr,
                            ed->fields[14].range, 0, argc, argv);
        break;
        case 15: rv = soc_sbx_g3p1_value_read(&e->port,
                            ed->fields[15].range, 0, argc, argv);
        break;
        case 16: rv = soc_sbx_g3p1_value_read(&e->pid,
                            ed->fields[16].range, 0, argc, argv);
        break;
        case 17: rv = soc_sbx_g3p1_value_read(&e->stpid0,
                            ed->fields[17].range, 0, argc, argv);
        break;
        case 18: rv = soc_sbx_g3p1_value_read(&e->stpid1,
                            ed->fields[18].range, 0, argc, argv);
        break;
        case 19: rv = soc_sbx_g3p1_value_read(&e->cep,
                            ed->fields[19].range, 0, argc, argv);
        break;
        case 20: rv = soc_sbx_g3p1_value_read(&e->keeperh,
                            ed->fields[20].range, 0, argc, argv);
        break;
        case 21: rv = soc_sbx_g3p1_value_read(&e->mirroridx,
                            ed->fields[21].range, 0, argc, argv);
        break;
        case 22: rv = soc_sbx_g3p1_value_read(&e->tc_1588,
                            ed->fields[22].range, 0, argc, argv);
        break;
        case 23: rv = soc_sbx_g3p1_value_read(&e->rep_data,
                            ed->fields[23].range, 0, argc, argv);
        break;
        case 24: rv = soc_sbx_g3p1_value_read(&e->ppe_variable,
                            ed->fields[24].range, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_EP2E_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_ep2e_set(unit,
                    port  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for tpid */
static void soc_sbx_g3p1_tpid_print(int unit, soc_sbx_g3p1_tpid_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_TPID_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->tpid; w = 4;  break;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for tpid */
static int soc_sbx_g3p1_tpid_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_tpid_t e0;
    soc_sbx_g3p1_tpid_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_TPID_ID];
    int tpidi; 
    void *indexpointers[1];
    indexpointers[0] = &tpidi;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_tpid_get(unit,
                    tpidi  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_tpid_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for tpid */
static int soc_sbx_g3p1_tpid_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_tpid_t e0;
    soc_sbx_g3p1_tpid_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_TPID_ID];
    int tpidi; 
    void *indexpointers[1];
    indexpointers[0] = &tpidi;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_tpid_t_init(e);

    rv = soc_sbx_g3p1_tpid_get(unit,
                    tpidi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->tpid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_TPID_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_tpid_set(unit,
                    tpidi  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for oam_rx */
static void soc_sbx_g3p1_oam_rx_print(int unit, soc_sbx_g3p1_oam_rx_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_RX_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->valid; w = 5;  break;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_rx */
static int soc_sbx_g3p1_oam_rx_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_rx_t e0;
    soc_sbx_g3p1_oam_rx_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_RX_ID];
    int rulenum; 
    void *indexpointers[1];
    indexpointers[0] = &rulenum;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_rx_get(unit,
                    rulenum  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_rx_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_rx */
static int soc_sbx_g3p1_oam_rx_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_rx_t e0;
    soc_sbx_g3p1_oam_rx_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_RX_ID];
    int rulenum; 
    void *indexpointers[1];
    indexpointers[0] = &rulenum;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_rx_t_init(e);

    rv = soc_sbx_g3p1_oam_rx_get(unit,
                    rulenum  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->valid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_OAM_RX_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_rx_set(unit,
                    rulenum  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for oam_tx */
static void soc_sbx_g3p1_oam_tx_print(int unit, soc_sbx_g3p1_oam_tx_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_TX_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->valid; w = 5;  break;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for oam_tx */
static int soc_sbx_g3p1_oam_tx_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_tx_t e0;
    soc_sbx_g3p1_oam_tx_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_TX_ID];
    int rulenum; 
    void *indexpointers[1];
    indexpointers[0] = &rulenum;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_oam_tx_get(unit,
                    rulenum  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_oam_tx_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_tx */
static int soc_sbx_g3p1_oam_tx_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_oam_tx_t e0;
    soc_sbx_g3p1_oam_tx_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_OAM_TX_ID];
    int rulenum; 
    void *indexpointers[1];
    indexpointers[0] = &rulenum;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_oam_tx_t_init(e);

    rv = soc_sbx_g3p1_oam_tx_get(unit,
                    rulenum  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->valid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_OAM_TX_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_oam_tx_set(unit,
                    rulenum  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for lsmac */
static void soc_sbx_g3p1_lsmac_print(int unit, soc_sbx_g3p1_lsmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_LSMAC_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->portid; w = 6;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3;  goto bigfield;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for lsmac */
static int soc_sbx_g3p1_lsmac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lsmac_t e0;
    soc_sbx_g3p1_lsmac_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_LSMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_lsmac_get(unit,
                    lsi  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_lsmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lsmac */
static int soc_sbx_g3p1_lsmac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_lsmac_t e0;
    soc_sbx_g3p1_lsmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_LSMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_lsmac_t_init(e);

    rv = soc_sbx_g3p1_lsmac_get(unit,
                    lsi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->portid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->useport,
                            ed->fields[1].range, 0, argc, argv);
        break;
        case 2: rv = soc_sbx_g3p1_big_value_read(e->mac,
                            ed->fields[2].width, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_LSMAC_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_lsmac_set(unit,
                    lsi  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for l2cpmac */
static void soc_sbx_g3p1_l2cpmac_print(int unit, soc_sbx_g3p1_l2cpmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_L2CPMAC_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->portid; w = 6;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3;  goto bigfield;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for l2cpmac */
static int soc_sbx_g3p1_l2cpmac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpmac_t e0;
    soc_sbx_g3p1_l2cpmac_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_L2CPMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_l2cpmac_get(unit,
                    lsi  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_l2cpmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpmac */
static int soc_sbx_g3p1_l2cpmac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_l2cpmac_t e0;
    soc_sbx_g3p1_l2cpmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_L2CPMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_l2cpmac_t_init(e);

    rv = soc_sbx_g3p1_l2cpmac_get(unit,
                    lsi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->portid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->useport,
                            ed->fields[1].range, 0, argc, argv);
        break;
        case 2: rv = soc_sbx_g3p1_big_value_read(e->mac,
                            ed->fields[2].width, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_L2CPMAC_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_l2cpmac_set(unit,
                    lsi  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}


/* entry print accessor implementation for elsmac */
static void soc_sbx_g3p1_elsmac_print(int unit, soc_sbx_g3p1_elsmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    int j, digits;
    uint8 *s = NULL;
    soc_sbx_g3p1_field_desc_t *fd;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_ELSMAC_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch(i) {
        case 0: v = e->portid; w = 6;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3;  goto bigfield;
        default: goto bigfield;
        }


        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            cli_out("\n  ");
            col=2;
        }
        cli_out("%s=", fd->name);
        col += w + 1;
        /* coverity [dead_error_condition] */
        /* coverity [dead_error_line]      */
        for (j = 0;s != NULL && j < digits; j++) {
            cli_out("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for elsmac */
static int soc_sbx_g3p1_elsmac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_elsmac_t e0;
    soc_sbx_g3p1_elsmac_t *e = &e0;
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_ELSMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    {
        rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
               cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g3p1_elsmac_get(unit,
                    lsi  ,
                e);

        if (rv) {
               cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g3p1_indexes_print(indexpointers, ed);
        soc_sbx_g3p1_elsmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for elsmac */
static int soc_sbx_g3p1_elsmac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g3p1_elsmac_t e0;
    soc_sbx_g3p1_elsmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_ppe_table_manager_t *tm = fe->ppe_mgr;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PPE_ELSMAC_ID];
    int lsi; 
    void *indexpointers[1];
    indexpointers[0] = &lsi;  

    rv = soc_sbx_g3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g3p1_elsmac_t_init(e);

    rv = soc_sbx_g3p1_elsmac_get(unit,
                    lsi  ,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
       cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_g3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
               cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g3p1_value_read(&e->portid,
                            ed->fields[0].range, 0, argc, argv);
        break;
        case 1: rv = soc_sbx_g3p1_value_read(&e->useport,
                            ed->fields[1].range, 0, argc, argv);
        break;
        case 2: rv = soc_sbx_g3p1_big_value_read(e->mac,
                            ed->fields[2].width, 0, argc, argv);
        break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_g3p1_ppe_update_overlaps(unit, SOC_SBX_G3P1_PPE_ELSMAC_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g3p1_elsmac_set(unit,
                    lsi  ,
                e);
    if (rv) {
       cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

int
soc_sbx_g3p1_ppe_table_shell_print(int unit, int eid, int argc, char **argv)
{
    int rv = 0;
    switch (eid) {
    case SOC_SBX_G3P1_PPE_P2E_TABLE_ID:
        rv = soc_sbx_g3p1_p2e_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_EP2E_TABLE_ID:
        rv = soc_sbx_g3p1_ep2e_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_TPID_TABLE_ID:
        rv = soc_sbx_g3p1_tpid_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_OAM_RX_TABLE_ID:
        rv = soc_sbx_g3p1_oam_rx_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_OAM_TX_TABLE_ID:
        rv = soc_sbx_g3p1_oam_tx_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_LSMAC_TABLE_ID:
        rv = soc_sbx_g3p1_lsmac_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_L2CPMAC_TABLE_ID:
        rv = soc_sbx_g3p1_l2cpmac_shell_print(unit, argc, argv); 
        break;        
    case SOC_SBX_G3P1_PPE_ELSMAC_TABLE_ID:
        rv = soc_sbx_g3p1_elsmac_shell_print(unit, argc, argv); 
        break;        
    }

    return rv;
}    

/*
 * Shell entry set implementation
 */
int soc_sbx_g3p1_ppe_table_shell_set(int unit, int eid, int argc, char **argv)
{
    int rv = 0;
    switch (eid) {
    case SOC_SBX_G3P1_PPE_P2E_TABLE_ID:
        rv = soc_sbx_g3p1_p2e_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_EP2E_TABLE_ID:
        rv = soc_sbx_g3p1_ep2e_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_TPID_TABLE_ID:
        rv = soc_sbx_g3p1_tpid_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_OAM_RX_TABLE_ID:
        rv = soc_sbx_g3p1_oam_rx_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_OAM_TX_TABLE_ID:
        rv = soc_sbx_g3p1_oam_tx_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_LSMAC_TABLE_ID:
        rv = soc_sbx_g3p1_lsmac_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_L2CPMAC_TABLE_ID:
        rv = soc_sbx_g3p1_l2cpmac_shell_set(unit, argc, argv); 
        break;
    case SOC_SBX_G3P1_PPE_ELSMAC_TABLE_ID:
        rv = soc_sbx_g3p1_elsmac_shell_set(unit, argc, argv); 
        break;
    }
    return rv;
}

char soc_sbx_g3p1_ptable_get_usage[] =
"g3p1ptableget seg_id=0..7 offset=0x0..0xFFFFF\n";
char soc_sbx_g3p1_ptable_set_usage[] =
"g3p1ptableset seg_id=0..7 offset=0x0..0xFFFFF value=0x0..0xFF\n";
int soc_sbx_g3p1_ptable_shell_set(int unit, int argc, char **argv)
{
  while (argc > 0)
  {
    uint32 seg_id, offset;
    uint32 data;
    uint8 data2;
    if (soc_sbx_g3p1_value_read(&seg_id, 7, 0, argc, argv) < 0)
      return SOC_E_PARAM;
    else
      argc--, argv++;
    if (soc_sbx_g3p1_value_read(&offset, 0xFFFFF, 0, argc, argv) < 0)
      return SOC_E_PARAM;
    else
      argc--, argv++;
    if (soc_sbx_g3p1_value_read(&data, 0xFF, 0, argc, argv) < 0)
      return SOC_E_PARAM;
    else
      argc--, argv++;
    data2 = data;
    soc_sbx_g3p1_ppe_property_table_segment_set(unit, seg_id, offset, data2);
    soc_sbx_g3p1_ppe_property_table_segment_get(unit, seg_id, offset, &data2); /* Read back */
    cli_out("\tseg_id %d, offset 0x%x set to value 0x%x\n", seg_id, offset, data2);
  }
  return SOC_E_NONE;
}

int soc_sbx_g3p1_ptable_shell_print(int unit, int argc, char **argv)
{
  cli_out("PPE Property Table\n");
  cli_out("------------------\n");
  cli_out("\tmode: %d\n", soc_sbx_g3p1_ppe_ptable_cfg.mode);
  cli_out("\tCAM Port A: %d\n", soc_sbx_g3p1_ppe_ptable_cfg.portA);
  cli_out("\tCAM Port B: %d\n", soc_sbx_g3p1_ppe_ptable_cfg.portB);
  cli_out("\tCAM Port C: %d\n", soc_sbx_g3p1_ppe_ptable_cfg.portC);
  cli_out("\tCAM Port D: %d\n", soc_sbx_g3p1_ppe_ptable_cfg.portD);

  while (argc > 0)
  {
    uint32 seg_id, offset;
    uint8 data;
    if (soc_sbx_g3p1_value_read(&seg_id, 7, 0, argc, argv) < 0)
      return SOC_E_PARAM;
    else
      argc--, argv++;
    if (soc_sbx_g3p1_value_read(&offset, 0xFFFFF, 0, argc, argv) < 0)
      return SOC_E_PARAM;
    else
      argc--, argv++;
    soc_sbx_g3p1_ppe_property_table_segment_get(unit, seg_id, offset, &data); /* This routine already formats the returned data according to the mode setting */
    cli_out("\tseg_id %d, offset 0x%x: value = 0x%x\n", seg_id, offset, data);
  }
  return SOC_E_NONE;
}

/*
 * Diag shell print driver implementation
 */

int soc_sbx_g3p1_ppe_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_ppe_table_manager_t *tm;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->ppe_mgr;

    for (i = 0; i < SOC_SBX_G3P1_PPE_MAX_TABLE_ID; i++) {
        
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_ppe_table_shell_print(unit, i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_g3p1_ppe_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g3p1_ppe_table_manager_t *tm;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->ppe_mgr;

    for (i = 0; i < SOC_SBX_G3P1_PPE_MAX_TABLE_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g3p1_ppe_table_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/* Shell get command usage string */
char soc_sbx_g3p1_ppe_get_usage[] =
"g3p1ppeget [<table> idx0=<i0> ...|\n"
"          |memmap [table]]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         p2e                \n"
"                         port=<port> \n" 
"         ep2e                \n"
"                         port=<port> \n" 
"         tpid                \n"
"                         tpidi=<tpidi> \n" 
"         oam_rx                \n"
"                         rulenum=<rulenum> \n" 
"         oam_tx                \n"
"                         rulenum=<rulenum> \n" 
"         lsmac                \n"
"                         lsi=<lsi> \n" 
"         l2cpmac                \n"
"                         lsi=<lsi> \n" 
"         elsmac                \n"
"                         lsi=<lsi> \n" 
#endif
;
/* Shell set command usage string */
char soc_sbx_g3p1_ppe_set_usage[] =
"g3p1ppeset [<table> idx0=<i0> ...[field0=<f0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"        p2e               \n"
"                         port=< port > \n"  
"                         [ \n"
"                         portid=< portid > \n"  
"                         state_num=< state_num > \n"  
"                         lsmmatch=< lsmmatch > \n"  
"                         ipv4mc=< ipv4mc > \n"  
"                         pbb=< pbb > \n"  
"                         twintpid=< twintpid > \n"  
"                         tpid=< tpid > \n"  
"                         oamloop=< oamloop > \n"  
"                         provider=< provider > \n"  
"                         customer=< customer > \n"  
"                         hdrtype=< hdrtype > \n"  
"                         timestamp=< timestamp > \n"  
"                         aggr_hash=< aggr_hash > \n"  
"                         mpls_hdrcompr=< mpls_hdrcompr > \n"  
"                         port=< port > \n"  
"                         nativevid=< nativevid > \n"  
"                         defcfi=< defcfi > \n"  
"                         defpri=< defpri > \n"  
"                         defstrip=< defstrip > \n"  
"                         pstrip=< pstrip > \n"  
"                         mim=< mim > \n"  
"                         mplstp=< mplstp > \n"  
"                         untaggedstrip=< untaggedstrip > \n"  
"                         droptagged=< droptagged > \n"  
"                         dropuntagged=< dropuntagged > \n"  
"                         tc_1588=< tc_1588 > \n"  
"                         rep_data=< rep_data > \n"  
"                         ppe_variable=< ppe_variable > \n"  
"                         ] \n"
"        ep2e               \n"
"                         port=< port > \n"  
"                         [ \n"
"                         portid=< portid > \n"  
"                         state_num=< state_num > \n"  
"                         lsmmatch=< lsmmatch > \n"  
"                         ipv4mc=< ipv4mc > \n"  
"                         pbb=< pbb > \n"  
"                         twintpid=< twintpid > \n"  
"                         tpid=< tpid > \n"  
"                         oamloop=< oamloop > \n"  
"                         provider=< provider > \n"  
"                         customer=< customer > \n"  
"                         hdrtype=< hdrtype > \n"  
"                         timestamp=< timestamp > \n"  
"                         aggr_hash=< aggr_hash > \n"  
"                         mim=< mim > \n"  
"                         mpls_hdrcompr=< mpls_hdrcompr > \n"  
"                         port=< port > \n"  
"                         pid=< pid > \n"  
"                         stpid0=< stpid0 > \n"  
"                         stpid1=< stpid1 > \n"  
"                         cep=< cep > \n"  
"                         keeperh=< keeperh > \n"  
"                         mirroridx=< mirroridx > \n"  
"                         tc_1588=< tc_1588 > \n"  
"                         rep_data=< rep_data > \n"  
"                         ppe_variable=< ppe_variable > \n"  
"                         ] \n"
"        tpid               \n"
"                         tpidi=< tpidi > \n"  
"                         [ \n"
"                         tpid=< tpid > \n"  
"                         ] \n"
"        oam_rx               \n"
"                         rulenum=< rulenum > \n"  
"                         [ \n"
"                         valid=< valid > \n"  
"                         ] \n"
"        oam_tx               \n"
"                         rulenum=< rulenum > \n"  
"                         [ \n"
"                         valid=< valid > \n"  
"                         ] \n"
"        lsmac               \n"
"                         lsi=< lsi > \n"  
"                         [ \n"
"                         portid=< portid > \n"  
"                         useport=< useport > \n"  
"                         mac=< mac > \n"  
"                         ] \n"
"        l2cpmac               \n"
"                         lsi=< lsi > \n"  
"                         [ \n"
"                         portid=< portid > \n"  
"                         useport=< useport > \n"  
"                         mac=< mac > \n"  
"                         ] \n"
"        elsmac               \n"
"                         lsi=< lsi > \n"  
"                         [ \n"
"                         portid=< portid > \n"  
"                         useport=< useport > \n"  
"                         mac=< mac > \n"  
"                         ] \n"
#endif
;

#endif
