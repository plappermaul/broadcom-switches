
/**
 * 
 *
 * $Id: tmu_diags_c.stg,v 1.17 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * t3p1_tmu_diags.c: Guadalupe2k V1.3 microcode diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_T3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/t3p1/t3p1_int.h>
#include <soc/sbx/t3p1/t3p1_defs.h>
#include <soc/sbx/t3p1/t3p1_tmu.h>
#include <soc/sbx/t3p1/t3p1_diags.h>
#include <soc/sbx/t3p1/t3p1_tmu_diags.h>

/* entry print accessor implementation for mac */
void soc_sbx_t3p1_mac_print(int unit, soc_sbx_t3p1_mac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ageid; w = 5;  break;
        case 1: v = e->smac_hit; w = 8;  break;
        case 2: v = e->sdrop; w = 5;  break;
        case 3: v = e->dontage; w = 7;  break;
        case 4: v = e->sreserved; w = 9;  break;
        case 5: v = e->pending; w = 7;  break;
        case 6: v = e->poe; w = 3;  break;
        case 7: v = e->dmac_hit; w = 8;  break;
        case 8: v = e->dcopy; w = 5;  break;
        case 9: v = e->ddrop; w = 5;  break;
        case 10: v = e->dreserved; w = 9;  break;
        case 11: v = e->ftidx; w = 5;  break;                
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for mac */
static int soc_sbx_t3p1_mac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_mac_t e0;
    soc_sbx_t3p1_mac_t *e = &e0;
    int rv;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];

    soc_sbx_t3p1_6_byte_t imac;
    int ivsi;
    

    void *indexpointers[2];
    
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;       
    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_mac_get(unit,  imac ,  ivsi  , e);

        if (rv) {
        	cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_mac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mac */
static int soc_sbx_t3p1_mac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_mac_t e0;
    soc_sbx_t3p1_mac_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];

    soc_sbx_t3p1_6_byte_t imac;
    int ivsi;

    void *indexpointers[2];
    
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_mac_t_init(e);

    rv = soc_sbx_t3p1_mac_get(unit,  imac ,  ivsi  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
    	cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
        	cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->ageid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_t3p1_value_read(&e->smac_hit,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_t3p1_value_read(&e->sdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_t3p1_value_read(&e->dontage,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_t3p1_value_read(&e->sreserved,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_t3p1_value_read(&e->pending,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_t3p1_value_read(&e->poe,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_t3p1_value_read(&e->dmac_hit,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_t3p1_value_read(&e->dcopy,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_t3p1_value_read(&e->ddrop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_t3p1_value_read(&e->dreserved,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_t3p1_value_read(&e->ftidx,
                                ed->fields[11].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_t3p1_update_overlaps(unit, SOC_SBX_T3P1_TMU_MAC_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_mac_set(unit,  imac ,  ivsi  , e);
    if (rv) {
    	cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for age2mac */
void soc_sbx_t3p1_age2mac_print(int unit, soc_sbx_t3p1_age2mac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->reserved1; w = 9;  break;
        case 1: v = e->smac2; w = 5;  break;
        case 2: v = e->vsi; w = 3;  break;
        case 3: v = e->smac1; w = 5;  break;                
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for age2mac */
static int soc_sbx_t3p1_age2mac_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_age2mac_t e0;
    soc_sbx_t3p1_age2mac_t *e = &e0;
    int rv;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];

    int iageid;
    

    void *indexpointers[1];
    
    indexpointers[0] = &iageid;       
    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_age2mac_get(unit,  iageid  , e);

        if (rv) {
        	cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_age2mac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for age2mac */
static int soc_sbx_t3p1_age2mac_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_age2mac_t e0;
    soc_sbx_t3p1_age2mac_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];

    int iageid;

    void *indexpointers[1];
    
    indexpointers[0] = &iageid;

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_age2mac_t_init(e);

    rv = soc_sbx_t3p1_age2mac_get(unit,  iageid  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
    	cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
        	cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->reserved1,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_t3p1_value_read(&e->smac2,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_t3p1_value_read(&e->vsi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_t3p1_value_read(&e->smac1,
                                ed->fields[3].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_t3p1_update_overlaps(unit, SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_age2mac_set(unit,  iageid  , e);
    if (rv) {
    	cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pvv2e */
void soc_sbx_t3p1_pvv2e_print(int unit, soc_sbx_t3p1_pvv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pvv2e_idx; w = 9;  break;                
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for pvv2e */
static int soc_sbx_t3p1_pvv2e_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_pvv2e_t e0;
    soc_sbx_t3p1_pvv2e_t *e = &e0;
    int rv;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];

    int ivrf;
    int iport;
    int iovid;
    int iivid;
    int inetmask_num_bits;    

    void *indexpointers[5];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &iport;
    indexpointers[2] = &iovid;
    indexpointers[3] = &iivid;
    indexpointers[4] = &inetmask_num_bits;       
    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_pvv2e_get(unit,  ivrf ,  iport ,  iovid ,  iivid , inetmask_num_bits , e);

        if (rv) {
        	cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_pvv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pvv2e */
static int soc_sbx_t3p1_pvv2e_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_pvv2e_t e0;
    soc_sbx_t3p1_pvv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];

    int ivrf;
    int iport;
    int iovid;
    int iivid;
    int inetmask_num_bits;
    void *indexpointers[5];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &iport;
    indexpointers[2] = &iovid;
    indexpointers[3] = &iivid;
    indexpointers[4] = &inetmask_num_bits;

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_pvv2e_t_init(e);

    rv = soc_sbx_t3p1_pvv2e_get(unit,  ivrf ,  iport ,  iovid ,  iivid , inetmask_num_bits , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
    	cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
        	cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->pvv2e_idx,
                                ed->fields[0].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_t3p1_update_overlaps(unit, SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_pvv2e_set(unit,  ivrf ,  iport ,  iovid ,  iivid , inetmask_num_bits , e);
    if (rv) {
    	cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emlfilter */
void soc_sbx_t3p1_emlfilter_print(int unit, soc_sbx_t3p1_emlfilter_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->reserved_0; w = 10;  break;
        case 1: v = e->reserved_1; w = 10;  break;
        case 2: v = e->reserved_2; w = 10;  break;
        case 3: v = e->reserved_3; w = 10;  break;                
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for emlfilter */
static int soc_sbx_t3p1_emlfilter_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_emlfilter_t e0;
    soc_sbx_t3p1_emlfilter_t *e = &e0;
    int rv;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];

    int iemlindex;
    

    void *indexpointers[1];
    
    indexpointers[0] = &iemlindex;       
    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_emlfilter_get(unit,  iemlindex  , e);

        if (rv) {
        	cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_emlfilter_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emlfilter */
static int soc_sbx_t3p1_emlfilter_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_emlfilter_t e0;
    soc_sbx_t3p1_emlfilter_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];

    int iemlindex;

    void *indexpointers[1];
    
    indexpointers[0] = &iemlindex;

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_emlfilter_t_init(e);

    rv = soc_sbx_t3p1_emlfilter_get(unit,  iemlindex  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
    	cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
        	cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->reserved_0,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_t3p1_value_read(&e->reserved_1,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_t3p1_value_read(&e->reserved_2,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_t3p1_value_read(&e->reserved_3,
                                ed->fields[3].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_t3p1_update_overlaps(unit, SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_emlfilter_set(unit,  iemlindex  , e);
    if (rv) {
    	cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for sample_dm1 */
void soc_sbx_t3p1_sample_dm1_print(int unit, soc_sbx_t3p1_sample_dm1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_t3p1_field_desc_t *fd;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];

    cli_out("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->w0; w = 2;  break;
        case 1: v = e->w1; w = 2;  break;
        case 2: v = e->w2; w = 2;  break;
        case 3: v = e->w3; w = 2;  break;                
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                cli_out("\n  ");
                col=2;
            }
            cli_out("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_t3p1_print(fd->range, v);
            col += w;
            cli_out(" ");
            col++;
        }
    }
    cli_out("\n");
}

/* entry diag shell print implementation for sample_dm1 */
static int soc_sbx_t3p1_sample_dm1_shell_print(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_sample_dm1_t e0;
    soc_sbx_t3p1_sample_dm1_t *e = &e0;
    int rv;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;

    soc_sbx_t3p1_entry_desc_t *ed = &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];

    int iindex_1;
    int iindex_2;
    

    void *indexpointers[2];
    
    indexpointers[0] = &iindex_1;
    indexpointers[1] = &iindex_2;       
    {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_t3p1_sample_dm1_get(unit,  iindex_1 ,  iindex_2  , e);

        if (rv) {
        	cli_out("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_t3p1_indexes_print(indexpointers, ed);
        soc_sbx_t3p1_sample_dm1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for sample_dm1 */
static int soc_sbx_t3p1_sample_dm1_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_t3p1_sample_dm1_t e0;
    soc_sbx_t3p1_sample_dm1_t *e = &e0;
    int rv, fidx;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID];

    int iindex_1;
    int iindex_2;

    void *indexpointers[2];
    
    indexpointers[0] = &iindex_1;
    indexpointers[1] = &iindex_2;

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_t3p1_sample_dm1_t_init(e);

    rv = soc_sbx_t3p1_sample_dm1_get(unit,  iindex_1 ,  iindex_2  , e);

    if (rv && rv != SOC_E_NOT_FOUND) {
    	cli_out("get of %s failed\n", ed->name);
        return rv;
    }

    while (argc) {
        fidx = soc_sbx_t3p1_field_find(ed, argv[0]);
        if (fidx < 0) {
        	cli_out("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_t3p1_value_read(&e->w0,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_t3p1_value_read(&e->w1,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_t3p1_value_read(&e->w2,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_t3p1_value_read(&e->w3,
                                ed->fields[3].range, 0, argc, argv);
                 break;        

        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        /* coverity [callee_ptr_arith] */
        soc_sbx_t3p1_update_overlaps(unit, SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID, (uint32*)e, argv[0], ((uint32*)e)[fidx]);

        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_t3p1_sample_dm1_set(unit,  iindex_1 ,  iindex_2  , e);
    if (rv) {
    	cli_out("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for mac */
static int soc_sbx_t3p1_mac_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_MAC_TABLE_ID];
    soc_sbx_t3p1_6_byte_t imac, nimac = {0,0,0,0,0,0};
    int ivsi=0, nivsi=0;
    void *indexpointers[2];
    indexpointers[0] = &imac;
    indexpointers[1] = &ivsi;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_t3p1_mac_first(unit,  imac ,  &ivsi  );
        if (rv == SOC_E_NOT_FOUND) {
        	cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
        	cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            int i;
            for (i=0; i<6; i++) { imac[i] = nimac[i]; }
   
            ivsi = nivsi;            
            
            rv = soc_sbx_t3p1_mac_next(unit,  imac ,  ivsi  ,  nimac ,  &nivsi  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_t3p1_mac_delete(unit,  imac ,  ivsi  );
        if (rv0) {
        	cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for age2mac */
static int soc_sbx_t3p1_age2mac_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID];
    int iageid=0, niageid=0;
    void *indexpointers[1];
    indexpointers[0] = &iageid;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_t3p1_age2mac_first(unit,  &iageid  );
        if (rv == SOC_E_NOT_FOUND) {
        	cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
        	cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            iageid = niageid;            
            
            rv = soc_sbx_t3p1_age2mac_next(unit,  iageid  ,  &niageid  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_t3p1_age2mac_delete(unit,  iageid  );
        if (rv0) {
        	cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}
/* entry diag shell delete implementation for pvv2e */
static int soc_sbx_t3p1_pvv2e_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID];
    int ivrf=0, nivrf=0;
    int iport=0, niport=0;
    int iovid=0, niovid=0;
    int iivid=0, niivid=0;
    int inetmask_num_bits;  
    void *indexpointers[5];
    
    indexpointers[0] = &ivrf;
    indexpointers[1] = &iport;
    indexpointers[2] = &iovid;
    indexpointers[3] = &iivid;
    indexpointers[4] = &inetmask_num_bits;
   
            ivrf = nivrf;
   
            iport = niport;
   
            iovid = niovid;
   
            iivid = niivid;  

    rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
      return SOC_E_PARAM;
    }

    if (rv != argc) {
      cli_out("'%s' is not a valid index for %s\n",
              argv[rv], ed->name);
      return SOC_E_PARAM;
    }

    rv0 = soc_sbx_t3p1_pvv2e_delete(unit,  ivrf ,  iport ,  iovid ,  iivid  , inetmask_num_bits);
    if (rv0) {
      cli_out("delete of %s failed\n", ed->name);
      return rv0;
    }
    return SOC_E_NONE;
}
/* entry diag shell delete implementation for emlfilter */
static int soc_sbx_t3p1_emlfilter_shell_delete(int unit, int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
    soc_sbx_t3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID];
    int iemlindex=0, niemlindex=0;
    void *indexpointers[1];
    indexpointers[0] = &iemlindex;
    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            cli_out("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_t3p1_emlfilter_first(unit,  &iemlindex  );
        if (rv == SOC_E_NOT_FOUND) {
        	cli_out("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
        	cli_out("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_t3p1_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
        	cli_out("'%s' is not a valid index for %s\n",
                        argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
   
            iemlindex = niemlindex;            
            
            rv = soc_sbx_t3p1_emlfilter_next(unit,  iemlindex  ,  &niemlindex  );
            if (rv && rv != SOC_E_NOT_FOUND) {
                cli_out("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_t3p1_emlfilter_delete(unit,  iemlindex  );
        if (rv0) {
        	cli_out("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

int soc_sbx_t3p1_tmu_table_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_t3p1_tmu_table_shell_print(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_T3P1_TMU_MAC_TABLE_ID:
        rv = soc_sbx_t3p1_mac_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID:
        rv = soc_sbx_t3p1_age2mac_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID:
        rv = soc_sbx_t3p1_pvv2e_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID:
        rv = soc_sbx_t3p1_emlfilter_shell_print(unit, argc, argv); 
        break;
    case SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID:
        rv = soc_sbx_t3p1_sample_dm1_shell_print(unit, argc, argv); 
        break;    
    default: rv = SOC_E_NOT_FOUND;
    }
    
    return rv;
}    

/*
 * Shell entry set implementation
 */
static int soc_sbx_t3p1_tmu_table_shell_set(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
        case SOC_SBX_T3P1_TMU_MAC_TABLE_ID:
            rv = soc_sbx_t3p1_mac_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID:
            rv = soc_sbx_t3p1_age2mac_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID:
            rv = soc_sbx_t3p1_pvv2e_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID:
            rv = soc_sbx_t3p1_emlfilter_shell_set(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_SAMPLE_DM1_TABLE_ID:
            rv = soc_sbx_t3p1_sample_dm1_shell_set(unit, argc, argv); 
            break;
    default: rv = SOC_E_NOT_FOUND;
    
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
static int soc_sbx_t3p1_tmu_table_shell_delete(int unit, int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
        case SOC_SBX_T3P1_TMU_MAC_TABLE_ID:
            rv = soc_sbx_t3p1_mac_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_AGE2MAC_TABLE_ID:
            rv = soc_sbx_t3p1_age2mac_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_EMLFILTER_TABLE_ID:
            rv = soc_sbx_t3p1_emlfilter_shell_delete(unit, argc, argv); 
            break;
        case SOC_SBX_T3P1_TMU_PVV2E_TABLE_ID:
            rv = soc_sbx_t3p1_pvv2e_shell_delete(unit, argc, argv); 
            break;
    default: rv = SOC_E_NOT_FOUND;
    
    }
    return rv;
}


static uint32 makeMask(int offset, int width) {
    int i;
    uint32 bit = (1 << offset);
    uint32 mask = 0;

    for (i = 0;i < width;i++) {
        mask |= bit;
        bit = bit << 1;
    }

    return mask;
}

/*
 * Utility method
 */
int soc_sbx_t3p1_update_overlaps(int unit, int table, uint32 *e, char *name, int value) {
  int fidx;
  int i;
  soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  soc_sbx_t3p1_tmu_table_manager_t *tm = fe->tmu_mgr;
  soc_sbx_t3p1_entry_desc_t *ed =  &tm->entries[table];
  int p1;
  int p2;
  int word;
  uint32 mask;

    fidx = soc_sbx_t3p1_field_find(ed, name);
    if (fidx < 0) {
    	cli_out("unexpected field name '%s'\n", name);
        return SOC_E_PARAM;
    }

    word = ed->fields[fidx].pos/32;

    for (i = 0;i < ed->nfields;i++) {
        if (i != fidx) {
            if ((ed->fields[i].pos <= (ed->fields[fidx].pos + ed->fields[fidx].width - 1)) && 
                ((ed->fields[i].pos + ed->fields[i].width - 1) >= ed->fields[fidx].pos)) {

                if (ed->fields[i].pos < ed->fields[fidx].pos)
                    p1 = ed->fields[fidx].pos;
                else 
                    p1 = ed->fields[i].pos;

                if ((ed->fields[i].pos + ed->fields[i].width) < (ed->fields[fidx].pos + ed->fields[fidx].width))
                    p2 = ed->fields[i].pos + ed->fields[i].width - p1;
                else
                    p2 = ed->fields[fidx].pos + ed->fields[fidx].width - p1;

                p1 = p1 - (word * 32);

                mask = makeMask(p1, p2);
                e[i] = ((!mask) & e[i])  | (mask & value);
 /*              
                cli_out("Field:%s (value:%d) overlaps with:%s offset:%d width:%d (p1:%d p2:%d m:0x%08x w:%d v:%d)\n",
                        name,
                        value,
                        ed->fields[i].name,
                        ed->fields[i].pos,
                        ed->fields[i].width, p1, p2, mask, word, e[i]);
*/
            }
        }
    }
    return 0;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_t3p1_tmu_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_tmu_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_T3P1_TMU_MAX_TABLE_ID; i++) {
        
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_tmu_table_shell_print(unit, i, argc - 1, &argv[1]);
        }
    }

    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_t3p1_tmu_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_tmu_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_T3P1_TMU_MAX_TABLE_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_tmu_table_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
int soc_sbx_t3p1_tmu_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_t3p1_tmu_table_manager_t *tm;

    soc_sbx_t3p1_state_t *fe =
        (soc_sbx_t3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    if (!fe) {
        return SOC_E_INIT;
    }
    tm = fe->tmu_mgr;

    for (i = 0; i < SOC_SBX_T3P1_TMU_MAX_TABLE_ID; i++) {
        if (tm->entries[i].name && !sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_t3p1_tmu_table_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

char soc_sbx_t3p1_tmu_get_usage[] = 
"t3p1tmuget [<table> idx0=<i0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>    \n" 
"         age2mac            ageid=<ageid>    \n" 
"         pvv2e            vrf=<vrf>  port=<port>  ovid=<ovid>  ivid=<ivid>  <netmask=number of bits in netmask>  \n" 
"         emlfilter            emlindex=<emlindex>    \n" 
"         sample_dm1            index_1=<index_1>  index_2=<index_2>    \n" 
#endif
;

char soc_sbx_t3p1_tmu_set_usage[] =
"t3p1tmuset [<table> idx0=<i0> ...[field0=<f0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>     \n"
 
"                         [ ageid=<ageid> ]        \n" 
"                         [ smac_hit=<smac_hit> ]        \n" 
"                         [ sdrop=<sdrop> ]        \n" 
"                         [ dontage=<dontage> ]        \n" 
"                         [ sreserved=<sreserved> ]        \n" 
"                         [ pending=<pending> ]        \n" 
"                         [ poe=<poe> ]        \n" 
"                         [ dmac_hit=<dmac_hit> ]        \n" 
"                         [ dcopy=<dcopy> ]        \n" 
"                         [ ddrop=<ddrop> ]        \n" 
"                         [ dreserved=<dreserved> ]        \n" 
"                         [ ftidx=<ftidx> ]        \n"  
"         age2mac            ageid=<ageid>     \n"
 
"                         [ reserved1=<reserved1> ]        \n" 
"                         [ smac2=<smac2> ]        \n" 
"                         [ vsi=<vsi> ]        \n" 
"                         [ smac1=<smac1> ]        \n"  
"         pvv2e            vrf=<vrf>  port=<port>  ovid=<ovid>  ivid=<ivid>     <netmask=number of bits in netmask>\n"
 
"                         [ pvv2e_idx=<pvv2e_idx> ]        \n"  
"         emlfilter            emlindex=<emlindex>     \n"
 
"                         [ reserved_0=<reserved_0> ]        \n" 
"                         [ reserved_1=<reserved_1> ]        \n" 
"                         [ reserved_2=<reserved_2> ]        \n" 
"                         [ reserved_3=<reserved_3> ]        \n"  
"         sample_dm1            index_1=<index_1>  index_2=<index_2>     \n"
 
"                         [ w0=<w0> ]        \n" 
"                         [ w1=<w1> ]        \n" 
"                         [ w2=<w2> ]        \n" 
"                         [ w3=<w3> ]        \n"  
#endif
;

char soc_sbx_t3p1_tmu_delete_usage[] = 
"t3p1tmudelete [<table> idx0=<i0> ...]\n"
#ifndef COMPILER_STRING_CONST_LIMIT
"         mac            mac=<mac>  vsi=<vsi>    \n" 
"         age2mac            ageid=<ageid>    \n" 
"         pvv2e            vrf=<vrf>  port=<port>  ovid=<ovid>  ivid=<ivid>    \n" 
"         emlfilter            emlindex=<emlindex>    \n" 
#endif
;


#endif
