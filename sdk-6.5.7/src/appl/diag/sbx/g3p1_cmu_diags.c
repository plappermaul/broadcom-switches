
/**
 * 
 *
 * $Id: cmu_diags_c.stg,v 1.12 Broadcom SDK $    
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 *
 * g3p1_cmu_diags.c: Guadalupe2k V1.3 microcode diagnostics routines 
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT)
#include <shared/bsl.h>

#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_defs.h>
#include <soc/sbx/g3p1/g3p1_cmu.h>
#include <soc/sbx/g3p1/g3p1_diags.h>
#include <soc/sbx/g3p1/g3p1_cmu_diags.h>
#include <appl/diag/system.h>

#include <ctype.h>

    
void soc_sbx_g3p1_pdctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_pdctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_pdctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_pdctr_print: soc_sbx_g3p1_pdctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("pdctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_pdctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_pdctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_pdctr_reset: soc_sbx_g3p1_pdctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_rtctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_rtctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_rtctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_rtctr_print: soc_sbx_g3p1_rtctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("rtctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_rtctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_rtctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_rtctr_reset: soc_sbx_g3p1_rtctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_ertctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_ertctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_ertctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_ertctr_print: soc_sbx_g3p1_ertctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("ertctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_ertctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_ertctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_ertctr_reset: soc_sbx_g3p1_ertctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_excctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_excctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_excctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_excctr_print: soc_sbx_g3p1_excctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("excctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_excctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_excctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_excctr_reset: soc_sbx_g3p1_excctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_ingctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_ingctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_ingctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_ingctr_print: soc_sbx_g3p1_ingctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("ingctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_ingctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_ingctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_ingctr_reset: soc_sbx_g3p1_ingctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_egrctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_egrctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_egrctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_egrctr_print: soc_sbx_g3p1_egrctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("egrctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_egrctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_egrctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_egrctr_reset: soc_sbx_g3p1_egrctr_clear failure");
        return;
    }
}

void soc_sbx_g3p1_sample_simple32ctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_simple32_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_simple32_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
    	 cli_out("soc_sbx_g3p1_sample_simple32ctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_sample_simple32ctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
    	 cli_out("soc_sbx_g3p1_sample_simple32ctr_print: soc_sbx_g3p1_sample_simple32ctr_read failure");
        sal_free(counter_values);
        return;
    }
      cli_out("sample_simple32ctr\n");
    for (i=0; i<num_counters; i++) {
    	char buf_val[32];
    	format_uint64_decimal(buf_val, counter_values[i].accumulator, 0);
    	cli_out("\t%d: [Accumulator: %s]\n", start_counter+i, buf_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_sample_simple32ctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_sample_simple32ctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_sample_simple32ctr_reset: soc_sbx_g3p1_sample_simple32ctr_clear failure");
        return;
    }
}

void soc_sbx_g3p1_sample_simple64ctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_simple64_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_simple64_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
    	 cli_out("soc_sbx_g3p1_sample_simple64ctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_sample_simple64ctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
    	 cli_out("soc_sbx_g3p1_sample_simple64ctr_print: soc_sbx_g3p1_sample_simple64ctr_read failure");
        sal_free(counter_values);
        return;
    }
      cli_out("sample_simple64ctr\n");
    for (i=0; i<num_counters; i++) {
    	char buf_val[32];
    	format_uint64_decimal(buf_val, counter_values[i].accumulator, 0);
    	cli_out("\t%d: [Accumulator: %s]\n", start_counter+i, buf_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_sample_simple64ctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_sample_simple64ctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_sample_simple64ctr_reset: soc_sbx_g3p1_sample_simple64ctr_clear failure");
        return;
    }
}

    
void soc_sbx_g3p1_sample_turbo32ctr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_turbo32_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_turbo32_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
        cli_out("soc_sbx_g3p1_sample_turbo32ctr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_sample_turbo32ctr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_sample_turbo32ctr_print: soc_sbx_g3p1_sample_turbo32ctr_read failure");
        sal_free(counter_values);
        return;
    }
    cli_out("sample_turbo32ctr\n");
    for (i=0; i<num_counters; i++) {
        char buf1_val[32];
        char buf2_val[32];
        format_uint64_decimal(buf1_val, counter_values[i].packets, 0);
        format_uint64_decimal(buf2_val, counter_values[i].bytes, 0);
        cli_out("\t%d: [Packets: %s Bytes: %s]\n", start_counter+i, buf1_val, buf2_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_sample_turbo32ctr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_sample_turbo32ctr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_sample_turbo32ctr_reset: soc_sbx_g3p1_sample_turbo32ctr_clear failure");
        return;
    }
}

void soc_sbx_g3p1_sample_cmurangectr_print(int unit, uint32 start_counter, uint32 num_counters) {
    int rv, i;
    soc_sbx_g3p1_range_count_t *counter_values;

    counter_values = sal_alloc(num_counters * sizeof(soc_sbx_g3p1_range_count_t), "asm3_cmu_diags");
    if (counter_values == NULL) {
    	 cli_out("soc_sbx_g3p1_sample_cmurangectr_print: Could not sal_alloc for %d counters", num_counters);
        return;
    }

    rv = soc_sbx_g3p1_sample_cmurangectr_read(unit, start_counter, num_counters, FALSE, counter_values);
    if (rv != SOC_E_NONE) {
    	 cli_out("soc_sbx_g3p1_sample_cmurangectr_print: soc_sbx_g3p1_sample_cmurangectr_read failure");
        sal_free(counter_values);
        return;
    }
      cli_out("sample_cmurangectr\n");
    for (i=0; i<num_counters; i++) {
    	char buf_val[32];
    	format_uint64_decimal(buf_val, counter_values[i].min_max, 0);
    	cli_out("\t%d: [MinMax: %s]\n", start_counter+i, buf_val);
    }
    cli_out("\n");
    sal_free(counter_values);
}

void soc_sbx_g3p1_sample_cmurangectr_reset(int unit) {
    int rv;

    rv = soc_sbx_g3p1_sample_cmurangectr_clear(unit);
    if (rv != SOC_E_NONE) {
        cli_out("soc_sbx_g3p1_sample_cmurangectr_reset: soc_sbx_g3p1_sample_cmurangectr_clear failure");
        return;
    }
}


static int parse_num_in_str(char *str) {
    char *sptr;
    sptr = str;
    while ((*sptr != (char)0) && (!isdigit((int)*sptr))) {
        sptr++;
    }

    return _shr_ctoi(sptr);
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_g3p1_cmu_shell_print(int unit, int argc, char **argv)
{    
    int start_counter = 0;
    int num_counters = 0;

    if (!sal_strcasecmp(argv[0], "pdctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_pdctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_pdctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "rtctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_rtctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_rtctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "ertctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_ertctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_ertctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "excctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_excctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_excctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "ingctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_ingctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_ingctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "egrctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_egrctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_egrctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_simple32ctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_sample_simple32ctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_sample_simple32ctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_simple64ctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_sample_simple64ctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_sample_simple64ctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_turbo32ctr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_sample_turbo32ctr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_sample_turbo32ctr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_cmurangectr")) {
        if (argc < 2)
            return SOC_E_PARAM;

        start_counter = parse_num_in_str(argv[1]);
        if (argc == 3) {
            num_counters = parse_num_in_str(argv[2]);
        }
        else {
            num_counters = 50 - num_counters;
        }
        cli_out("soc_sbx_g3p1_sample_cmurangectr_print(%d, %d)\n", start_counter, num_counters);
        soc_sbx_g3p1_sample_cmurangectr_print(unit, start_counter, num_counters);
        return SOC_E_NONE;
    }

    return SOC_E_PARAM;
}


/*
 * Diag shell set driver implementation
 */
int soc_sbx_g3p1_cmu_shell_reset(int unit, int argc, char **argv)
{
    if (!sal_strcasecmp(argv[0], "pdctr")) {
        soc_sbx_g3p1_pdctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "rtctr")) {
        soc_sbx_g3p1_rtctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "ertctr")) {
        soc_sbx_g3p1_ertctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "excctr")) {
        soc_sbx_g3p1_excctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "ingctr")) {
        soc_sbx_g3p1_ingctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "egrctr")) {
        soc_sbx_g3p1_egrctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_simple32ctr")) {
        soc_sbx_g3p1_sample_simple32ctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_simple64ctr")) {
        soc_sbx_g3p1_sample_simple64ctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_turbo32ctr")) {
        soc_sbx_g3p1_sample_turbo32ctr_reset(unit);
        return SOC_E_NONE;
    }
    if (!sal_strcasecmp(argv[0], "sample_cmurangectr")) {
        soc_sbx_g3p1_sample_cmurangectr_reset(unit);
        return SOC_E_NONE;
    }


    return SOC_E_PARAM;
}


char soc_sbx_g3p1_cmu_get_usage[] = 
"g3p1cmuget <counter group> [from=<i0> num=<i1>...]\n"
"         counter group : pdctr rtctr ertctr excctr ingctr egrctr sample_simple32ctr sample_simple64ctr sample_turbo32ctr sample_cmurangectr   \n"                                               
;

char soc_sbx_g3p1_cmu_reset_usage[] = 
"g3p1cmureset <counter group> \n"
"         counter group : pdctr rtctr ertctr excctr ingctr egrctr sample_simple32ctr sample_simple64ctr sample_turbo32ctr sample_cmurangectr   \n"    
;

#endif
