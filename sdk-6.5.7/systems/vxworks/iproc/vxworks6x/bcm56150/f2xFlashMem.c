/* f2xFlashMem.c - Intel28 and AMD29-style flash driver library */

/*
 * Copyright (c) 2000-2005,2007-2008,2010-2014 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */
 
/*
modification history
--------------------
02x,08may14,tjf improved "OPTIONAL BLK_DEV CREATE ROUTINES" documentation
02w,26sep13,tjf fixed f2xRegionCreate() bug introduced with v02p - this bug
                  prevented writes to flash not having a write-to-buffer command
02v,25jan13,tjf added f2xGroupFileSet() API
02u,15jun12,tjf improved f2xCfiXxx() code and various documentation
02t,28mar12,tjf updated copyright
02s,15feb12,tjf added strategy for unknown bus width during f2xCfiXxx() calls
02r,31jan12,tjf squelched compiler warnings, tried to make every tool happy
02q,12sep11,tjf enhanced Intel28 block unlock to handle undocumented behavior
02p,22jul11,tjf added support for larger write-to-buffer commands
02o,19jul11,tjf added f2xBootromXxx() API
02n,08jul11,tjf added f2xCfiXxx() API
02m,06jan11,tjf removed warnings given by VxWorks 6.9 gnu compiler
02l,25jan11,tjf enhanced the DESCRIPTION
02k,05dev10,tjf added BLK_DEV layer, and region block cache support
02j,30nov10,tjf replaced "double" references with custom (for 5.5) UINT64
02i,09mar10,tjf changed f28RegionProgram() and f2xRegionWBProgram() to command
                  the starting word address instead of offset 0.
02h,04jun08,tjf removed warnings given by T2.2.2 gnu compiler
02g,31jul07,tjf removed EOS string termination in sysNvRamSet() (thanks AndyD!)
02f,18jan07,tjf removed warnings generated by the VxWorks 6.3 diab compiler
02e,24jan05,tjf fixed bug related calls to f2xGroupRegionInfoGet() with 0 nbytes
02d,23dec04,tjf fixed bug related to tickGet() wrap where erase/program
                  routines can falsely timeout and abort with ERROR.  The bug
                  occurs if an erase/program operation runs F2X_TIMEOUT seconds
                  or less before tickGet() wraps to zero.  The frequency of
                  exposure is every 828 days after startup for a 60Hz sysClk.
02c,23dec04,tjf changed some call argument from '(F2X_RID)pRDesc' to 'id' - nit
02b,14dec04,tjf changed f2xRegionSet() to read flash with f2xRegionGet()
02a,02dec04,tjf changed f2xRegionWidthRead/Write() API for non-standard designs
                  and "macroized" internals of f2xRegionWidthRead()
01h,16jan04,tjf "macroized" PPC sync command for diab compilation
01g,10oct03,tjf added write to buffer support for AMD MirrorBit flash
01f,02jan03,tjf changed sysNvRamXxx() routines to be kosher with the BSP VTS
01e,07dec02,tjf added INCLUDE_F2X_FORCE_WIDTH_READ switch to support H/W that
                  can only perform region-width-sized reads
01d,16aug02,tjf added write to buffer support for Intel StrataFlash
01c,17may02,tjf added F2X_SYS_NV_RAM_OFFSET
01b,23jan01,tjf removed f2xRegionCreate() chipBlockSize power of 2 requirement
01a,19oct00,tjf written by Ted Friedl, Wind River PS, Madison, WI
*/

/*
DESCRIPTION
The f2xFlashMem module, which consists of f2xFlashMem.c and
f2xFlashMem.h, provides routines useful for programming most sane and
some insane implementations of NOR flash supporting Intel-style
(now Numonyx) and AMD-style (now Spansion) programming.  It has support
for TFFS socket/MTD modules, and has optional sysNvRamSet/Get(),
sysFlashErase/Size/Set/Get(), and BLK_DEV creation APIs.

This library supports multiple areas of NOR flash.  The flash may be
8, 16 and 32-bits in width, interleaved and non-interleaved, across an
8, 16, 32 or 64-bit bus, paged and non-paged, with uniform and multiple
erasable block sizes.  This library can also logically split a contiguous
area of flash memory, or logically join two or more noncontiguous areas
of dissimilar flash parts or busses.

Prior to version v02n, f2xFlashMem depended on the developer to identify
the underlying structure of the flash through calls to f2xRegionCreate(),
f2xGroupCreate() and f2xGroupAdd().  Since version v02n, f2xFlashMem
may be used on traditional implementations of 8 and 16-bit NOR flash 
and initialized with a single call to f2xCfiGroupsCreate().

TERMINOLOGY
Throughout this description and source code, a few terms are used in
an extremely narrow way.  Those terms are listed below:

.CS
Term            Definition
----------------------------------------------------------------------
chip            A single NOR flash part

chip block      An erasable unit of a chip.  Using AMD/Spansion
                terminology, this is a "sector."  Intel/Numonyx's term
                is a "block." Chip block sizes can vary within a single
                chip depending on their offset.  Most are 8, 16, 32,
                64, or 128 kilobytes in size.

chip width      The data width of a chip.  For chips with multiple width
                capabilities, the chip width refers to the width mode
                the chip is in.

block           An erasable unit of the set of chips that spans a data
                bus.  For interleaved chips, a block consists of the
                chip blocks that share the same address.  For the
                non-interleaved case, a block and chip block is
                equivalent.

region          A contiguous area of NOR flash memory that begins and
                ends on block boundaries, has a single block size and
                does not span more than one chip set (interleaved case)
                or chip (non-interleaved case).  A region is created
                with the f2xRegionCreate() call.

paging          A hardware method used to access a large amount of
                memory in a smaller and fixed address space.

page            An address space used for paging.  A region, by definition,
                cannot span more than one page.

group           A logically joined set of one or more regions.  A group
                is created with the f2xGroupCreate() call.  A region
                is added to an existing group with f2xGroupAdd().
----------------------------------------------------------------------
.CE

CREATING REGIONS AND GROUPS
Before creating groups from which to read and write, regions must
be created.  For this the developer must have some understanding of
the underlying flash.  Some questions that must be answered before
start are:

.CS
  Q1: What is the base address of flash?
  Q2: Is the flash programmed Intel-style or AMD-style?
  Q3: Are the flash parts interleaved (i.e., multiple chips across the bus)?
  Q4: How many data bits wide is each flash part?
  Q5: What is the size (in bytes) of the flash chips?
  Q6: Do the flash chips have a uniform block size?
  Q6a: If so, what is the block size?
  Q6b: If not, what are the different block sizes and at what offsets?
  Q7: Does the flash support the write-to-buffer command?
  Q8: Does the customer want to logically partition the flash? How so?
  Q9: Are any of the flash blocks locked?
  Q10: If the flash is AMD/Spansion, are these 8-bit-only parts?
  Q11: Is the flash physically partitioned internally?
  Q12: Is paging involved?
  Q13: Are there any special read or write requirements?
.CE

In most cases, the must-have answers are A1-A8, and usually A9-A13 can
be assumed to be "No" until discovered otherwise.  A lot of this
information is obtained via the board users manual, board schematics,
and specific flash data sheet.  Almost always, it is best to read the
flash part numbers directly from the board instead of relying on the
schematics whose part numberare often incomplete or incorrect.

If flash is physically partitioned into independent areas, will be
logically partitioned, or the flash has non-uniform block sizes,
multiple calls to f2xRegionCreate() are usually required.  In cases
where the flash has no physical partitioning (~98% of the time), the
calls are typically "chained" together using the region ID 
(type F2X_RID) of the previous call.  Here's an example:

.CS
    {
    F2X_RID rid;
    char *  baseAdrs = (char *)FLASH_BASE_ADRS;
 
    rid = f2xRegionCreate(baseAdrs, FLASH_BUS_WIDTH,
                          FLASH_REGION0_SIZE, FLASH_CHIP_WIDTH,
                          FLASH_REGION0_CHIP_BLOCK_SIZE,
                          FLASH_REGION_WIDTH, F28_TYPE | F2X_WB32_TYPE,
                          NULL, NULL, NONE);

    sysTffsGid = f2xGroupCreate(rid);

    baseAdrs += FLASH_REGION0_SIZE;

    rid = f2xRegionCreate(baseAdrs, FLASH_BUS_WIDTH,
                          FLASH_REGION1_SIZE, FLASH_CHIP_WIDTH,
                          FLASH_REGION1_CHIP_BLOCK_SIZE,
                          FLASH_BUS_WIDTH, F28_TYPE | F2X_WB32_TYPE,
                          rid, NULL, NONE);

    f2xGroupAdd(sysTffsGid, rid);

    baseAdrs += FLASH_REGION1_SIZE;

    rid = f2xRegionCreate(baseAdrs, FLASH_BUS_WIDTH,
                          FLASH_REGION2_SIZE, FLASH_CHIP_WIDTH,
                          FLASH_REGION2_CHIP_BLOCK_SIZE,
                          FLASH_BUS_WIDTH, F28_TYPE | F2X_WB32_TYPE,
                          rid, NULL, NONE);

    sysNvRamAdd(rid);
    }
.CE
 
Chaining in this way ensures the regions share the same mutex
semaphore so that the programming of one region blocks (i.e.,
disallows) the programming or reading of another.

In the example above, the flash was partitioned into 2 different
groups - one for TFFS and one for NVRAM.  It can be seen 
(by F28_TYPE | F2X_WB32_TYPE) that the flash requires
Intel-style commands and supports the write-to-buffer command.

The same thing can be accomplished using f2xCfiGroupsCreate() with
the following code:

.CS
    {
    F2X_GREQ greqArray[] =
        {
        {&sysTffsGid, 0, FLASH_REGION0_SIZE + FLASH_REGION1_SIZE},
        {&f2xSysNvRamGid, FLASH_REGION0_SIZE + FLASH_REGION1_SIZE,
         FLASH_REGION2_SIZE},
        };

    f2xCfiGroupsCreate ((char *)FLASH_BASE_ADRS, FLASH_BUS_WIDTH,
                        NELEMENTS(greqArray), greqArray, NULL, FALSE);
    }
.CE

In rare cases, the answers to Q9-Q13 will not all be "No."
Those cases are discussed here:

.CS
  I9: Locked blocks

      Some Intel flash parts power up locked.  In this case,
      unlocking the blocks during region/group creation is required.

  I10: 8-bit-only AMD/Spansion

      This is becoming rare and involves specifying the region
      <type> to be F29_8BIT_TYPE.  Do not use F29_8BIT_TYPE for a
      16-bit AMD/Spansion chip in 8-bit mode!

  I11: Internal partitioning

      Internal partitioning means two or more partitions of flash
      operate  independent of each other.  In this case, the
      f2xRegionCreate() calls for one partition do not need to be
      chained to the f2xRegionCreate() calls of another.

  I12: Paging

      This is very rare but if a board implements paging, functions
      must be created which change the page and are compatible with
      the <pageFunc> and <pageId> arguments of f2xRegionCreate().  

  I13: Special read or write requirements

      There may be hardware implementations which impose special
      requirements on flash reads and/or writes.  For cases where
      flash can only be read aligned, and in units corresponding to
      the size of the bus width, INCLUDE_F2X_FORCE_WIDTH_READ should
      be defined in config.h.

      Cases where the data path to the flash is miswired can often
      be fixed by creating routines for one or more of these macros,
      and defining them in config.h:

      F2X_UINT8_READ(), F2X_UINT16_READ(), F2X_UINT32_READ(),
      F2X_UINT64READ(), F2X_UINT8_WRITE(), F2X_UINT16_WRITE(),
      F2X_UINT32_WRITE(), F2X_UINT64_WRITE().
.CE

OPTIONAL CFI ROUTINES
For traditional implementations of 8 or 16-bit flash (most), it may
be easier on the developer and may help the BSP to tolerate flash
part changes by calling f2xCfiGroupsCreate() to create the flash
groups.  The BSP designer can go even further and utilize future
flash space additions (e.g., a larger part is substituted) by first
calling f2xCfiSize() before calling f2xCfiGroupsCreate() to decide
how to group the flash.  f2xCfiShow() can be called as a diagnostic
to display the composition of the flash.  The f2xCfiXxx() routines
are enabled by defining INCLUDE_F2X_CFI_ROUTINES.
 
OPTIONAL NVRAM ROUTINES
VxWorks requires that a BSP implement sysNvRamSet() and sysNvRamGet()
routines.  These routines can be provided by this library, and using
flash, by defining INCLUDE_F2X_SYS_FLASH_ROUTINES in config.h.
When INCLUDE_F2X_SYS_FLASH_ROUTINES is defined, at least one flash
region must be assigned to the NVRAM with a call to sysNvRamAdd() as
shown in the code example above.  If regions are created implicitly
by f2xCfiGroupsCreate(), the NVRAM group ID should be written directly
to the global variable f2xSysNvRamGid.

OPTIONAL SYS_FLASH ROUTINES
Many legacy BSPs implement sysFlashSet() and sysFlashGet() routines
for reading and writing flash.  A set of similar routines are
enabled by defining INCLUDE_F2X_SYS_FLASH_ROUTINES in config.h.
When INCLUDE_F2X_SYS_FLASH_ROUTINES is defined, at least one flash
region must be assigned to the sysFlashXxx() routines with a call
to sysFlashAdd().  If regions are created implicitly by
f2xCfiGroupsCreate(), the sysFlashXxx() group ID should be written
directly to the global variable f2xSysFlashGid.

In addition to sysFlashSet/Get/Add(), when INCLUDE_F2X_SYS_FLASH_ROUTINES
is defined, the routine sysFlashSize() is available to provide the
size of the sysFlashXxx() group, and sysFlashErase() is available to
erase the group entirely.

The sysFlashXxx() routines are considered "legacy."  No enhancements
to the sysFlashXxx() API is planned, or should be planned.

OPTIONAL BOOTROM ROUTINES
As a convenience, the routine f2xBootromSet() is available for writing
a new bootrom binary image to flash.  This routine is enabled by
defining INCLUDE_F2X_BOOTROM_ROUTINES in config.h.  When
INCLUDE_F2X_BOOTROM_ROUTINES is defined, at least one flash region must
be assigned to f2xBootromSet() with a call to f2xBootromAdd().  If regions
are created implicitly by f2xCfiGroupsCreate(), the group ID for the bootrom
code should be written directly to the global variable f2xBootromGid.

OPTIONAL BLK_DEV CREATE ROUTINES
The routine f2xBlkDevCreate() is included when INCLUDE_F2X_BLK_DEV_ROUTINES
is defined in config.h.  f2xBlkDevCreate() allows the user to creates
a BLK_DEV (VxWorks block device) from a flash group.  This is useful
for later versions of VxWorks 6.x where a rawFS volume may be used to
copy a new bootrom or kernel from the network to flash, using copy()
(or cp()), either from a running bootrom or from the VxWorks kernel.

With VxWorks 6.8, for example, a kernel can be booted from flash using
a (legacy) make-made bootrom by adding defines for INCLUDE_RAWFS
and INCLUDE_XBD_BLK_DEV to config.h, and adding this code to a custom
usrConfig.c (shown in diff format):

.CS
       /@ BOOTAPP starts just before USER_APPL, will not return @/
   
   #ifdef INCLUDE_BOOT_APP
  +{
  +    IMPORT F2X_GID sysRawFlashGid;
  +    BLK_DEV * pBlkDev;
  +
  +    pBlkDev = f2xBlkDevCreate (sysRawFlashGidGid, 0);
  +    xbdBlkDevCreate (pBlkDev, "/kernel");
  +}
   #ifdef INCLUDE_BOOT_EXC_HANDLER
       bootAppExcInit();
   #endif
.CE

where sysRawFlashGid is created in sysHwInit2() and #include "f2xFlashMem.h"
is added to the top of usrConfig.c.

The way of supporting a vxprj or workbench-built bootApp or kernel is to
add a configlette file and component data file to the BSP.  For example:

f2xFlashVol.c:

.CS
  void f2xVolMount()
      {
      IMPORT F2X_GID sysRawFlashGid;
      BLK_DEV * pBlkDev;

      pBlkDev = f2xBlkDevCreate (sysRawFlashGid, 0);
      xbdBlkDevCreate (pBlkDev, F2X_VOL_NAME);
      }
.CE

20f2x.cdf:

.CS
  Parameter F2X_VOL_NAME {
      NAME         Raw Flash Volume Name
      TYPE         char *
      _CFG_PARAMS  INCLUDE_F2X_VOL_MOUNT
      DEFAULT      "/kernel"
      }

  Component INCLUDE_F2X_VOL_MOUNT {
      NAME         Mount Raw Flash Volume
      SYNOPSIS     Flash volume useful for copying kernel to & booting from
      CONFIGLETTES f2xFlashVol.c
      HDR_FILES    f2xFlashMem.h xbdBlkDev.h
      INIT_RTN     f2xVolMount();
      REQUIRES     INCLUDE_RAWFS INCLUDE_XBD_BLK_DEV
      _INIT_ORDER  usrIosExtraInit
      INIT_AFTER   rawFsInit
      _CHILDREN    FOLDER_PERIPHERALS
      }
.CE

With this, and by adding the component INCLUDE_BOOT_FILESYSTEMS to the
bootApp and INCLUDE_F2X_VOL_MOUNT to both the bootApp and kernel, it is
possible to copy the kernel to flash and boot it directly from the flash
as shown here:

.CS
  Instantiating /tffs0 as rawFs,  device = 0x10001


  Instantiating /kernel:0 as rawFs,  device = 0x30001

  Press any key to stop auto-boot...
   1


  [VxWorks Boot]:
  [VxWorks Boot]: devs
  drv name
    0 /null
    1 /tyCo/0
    1 /tyCo/1
    4 /tffs0
    6 dragon:
    4 /kernel:0
  [VxWorks Boot]: cp dragon:/work/fsl_p2020_ds/default/vxWorks /kernel:0
  copying file dragon:/work/fsl_p2020_ds/default/vxWorks -> /kernel:0
  [VxWorks Boot]: @

  boot device          : fs
  unit number          : 0
  processor number     : 0
  host name            : dragon
  file name            : /kernel:0
  inet on ethernet (e) : 192.168.1.11:ffffff00
  host inet (h)        : 192.168.1.102
  user (u)             : vxworks
  ftp password (pw)    : target
  flags (f)            : 0xa
  target name (tn)     : P2020_2
  other (o)            : motetsec0

  Loading /kernel:0...1722096 + 304 + 188 + 419708
  Starting at 0x100000...


  Adding 7397 symbols for standalone.


                  VxWorks

  Copyright 1984-2009  Wind River Systems, Inc.

               CPU: Freescale P2020E - Security Engine
      Runtime Name: VxWorks
   Runtime Version: 6.8
       BSP version: 2.0/1
           Created: Dec  5 2010, 22:45:57
  ED&R Policy Mode: Deployed
     WDB Comm Type: WDB_COMM_END
               WDB: Ready.


  ->
.CE

WRITE CACHE
The routines f2xGroupCachedSet() and f2xGroupCacheFlush()
were added with f2xBlkDevCreate() to efficiently handle the many
small and sequential writes that come down from the copy() command.
The cache is also used by f2xGroupSet() to reduce the amount of
flash reading and heap activity the function previously required.
The cache implementation was optimized for these specific
purposes and is therefore quite simple.

The "cache", or "block cache" consists of a region-block-sized
area of RAM for each region.  This memory is used by f2xGroupSet()
and f2xGroupCachedSet() and is bypassed completely by f2xGroupGet()
and f2xGroupProgram().

f2xGroupProgram() stops writing and returns ERROR on any region
where it would hit a dirty block cache.  It also invalidates
any non-dirty block cache it hits.

f2xGroupGet() flushes any dirty block cache it hits.  

TRUE FLASH FILE SYSTEM CAVEATS
Two companion modules, f2xFlashMtd.c and f2xFlash-sysTffs.c,
which is typically renamed to sysTffs.c, combine to use this
library with TFFS.  

TFFS at times bypasses the MTD read routine, which may be
catastrophic if the flash is being shared with another purpose
(say, NVRAM) and a non-TFFS write occurs during the bypassed TFFS
read.  Such a condition can be avoided with proper region chaining
and, as a side-effect, by defining INCLUDE_F2X_FORCE_WIDTH_READ
in config.h.  Defining INCLUDE_F2X_FORCE_WIDTH_READ reduces the 
performance of TFFS, so it should only be used if non-TFFS writes
cannot be properly-timed or avoided.

TFFS also expects a volume to have a uniform block size.  A
uniform block size can is simulated at the group level from
regions with differing block sizes, if those regions are 
combined in the right way.  See the description for
f2xGroupBlockSize() for details about how to combine regions
such that their group size is a positive value.

TYPICAL INSTALLATION
The following is a step-by-step example of replacing the existing
flash implementation of the VxWorks 6.8 fsl_p2020_ds BSP with
the f2xFlash module suite:

.CS
  1. Remove the files flashMem.c, nvRamToFlash.c, sysMtd.c and
     sysTffs.c.

  2. Add the files f2xFlashMem.c, f2xFlashMem.h, f2xFlashMtd.c and
     f2xFlash-sysTffs.c.  Rename the file f2xFlash-sysTffs.c to
     sysTffs.c.

  3. Add this line to config.h to support the NVRAM and programming
     the bootrom:

     #define INCLUDE_F2X_SYS_NV_RAM_ROUTINES
     #define INCLUDE_F2X_BOOTROM_ROUTINES

  4. Add this line to the includes of sysLib.c:

     #include "f2xFlashMem.h"

  5. Add these lines to the global variables of sysLib.c:

     #ifdef INCLUDE_FLASH
     F2X_GID sysTffsGid;
     #endif /@ INCLUDE_FLASH @/

  6. Change this source in sysLib.c from this:

     #ifdef INCLUDE_FLASH
     #   include "flashMem.c"
     #   include "nvRamToFlash.c"
     #else  /@ INCLUDE_FLASH @/
     #   include <mem/nullNvRam.c>
     #endif  /@ INCLUDE_FLASH @/

     to this:

     #ifdef INCLUDE_FLASH
     #   include "f2xFlashMem.c"
     #ifdef INCLUDE_TFFS
     #   include "f2xFlashMtd.c"
     #endif /@ INCLUDE_TFFS @/
     #else  /@ INCLUDE_FLASH @/
     #   include <mem/nullNvRam.c>
     #endif  /@ INCLUDE_FLASH @/

  7. Add this code to sysHwInit2() of sysLib.c:

     #ifdef INCLUDE_FLASH
         {
         F2X_RID    rid;
         char *     baseAdrs;
         int        regionSize;

         /@ partition flash into groups, maintaining the legacy partitioning,
          @ ignoring wasted space and space designated for U-boot
          @/

         baseAdrs = (char *)FLASH_BASE_ADRS;
         regionSize = 0x04000000;  /@ 64MB used for TFFS (legacy) @/
 
         rid = f2xRegionCreate (baseAdrs, S29GL_FLASH_WIDTH * 1, regionSize,
                                S29GL_FLASH_WIDTH, S29GL_SECTOR_SIZE, 
                                S29GL_FLASH_WIDTH * 1,
                                F29_16BIT_TYPE | F2X_WB32_TYPE, NULL, NULL, 0);

         sysTffsGid = f2xGroupCreate(rid);

         baseAdrs = (char *)NV_RAM_ADRS;
         regionSize = NV_RAM_SIZE;
 
         rid = f2xRegionCreate (baseAdrs, S29GL_FLASH_WIDTH * 1, regionSize,
                                S29GL_FLASH_WIDTH, S29GL_SECTOR_SIZE, 
                                S29GL_FLASH_WIDTH * 1,
                                F29_16BIT_TYPE | F2X_WB32_TYPE, rid, NULL, 0);

         sysNvRamAdd(rid);

         baseAdrs = (char *)ROM_BASE_ADRS;
         regionSize = ROM_SIZE;
 
         rid = f2xRegionCreate (baseAdrs, S29GL_FLASH_WIDTH * 1, regionSize,
                                S29GL_FLASH_WIDTH, S29GL_SECTOR_SIZE, 
                                S29GL_FLASH_WIDTH * 1,
                                F29_16BIT_TYPE | F2X_WB32_TYPE, rid, NULL, 0);


         f2xBootromAdd(rid);
         }
     #endif /@ INCLUDE_FLASH @/

  8. Customize sysTffsInit() in sysTffs.c to this:

     LOCAL void sysTffsInit (void)
         {
         IMPORT F2X_GID sysTffsGid;

         f2xRegister(sysTffsGid);
         }
.CE

Of course, adding DOSFS or HRFS involves including components such as
INCLUDE_TFFS, INCLUDE_DOSFS, INCLUDE_HRFS, INCLUDE_DISK_UTIL among 
others.

INITIALIZING A TFFS/DOSFS DEVICE
The typical steps for initializing a TFFS/DOSFS device on VxWorks 6.5
and earlier {{verification needed, true on 5.x, 6.4}}, assuming
the group sysTffsGid corresponds to TFFS volume 0:

.CS
  -> tffsRawio 0, 3, 0, f2xGroupSize(sysTffsGid)/f2xGroupBlockSize(sysTffsGid)
  -> tffsDevFormat 0, 0
  -> usrTffsConfig 0, 0, "/tffs"
.CE

The with VxWorks 6.5 and earlier, the volume is checked during
usrTffsConfig() and it is formatted with DOSFS if it is found not to
contain a valid file system.  Here a TFFS volume should never be
formatted with dosFsVolFormat().

The typical steps for initializing a TFFS/DOSFS device on VxWorks 6.6
and later {{verification needed, true on 6.8, 6.9}} are shown,
assuming the group sysTffsGid corresponds to TFFS volume 0:

.CS
  -> tffsRawio 0, 3, 0, f2xGroupSize(sysTffsGid)/f2xGroupBlockSize(sysTffsGid)
  -> tffsDevFormat 0, 0
  -> usrTffsConfig 0, 0, "/tffs"
  -> dosFsVolFormat "/tffs"
.CE

The with VxWorks 6.6 and later, the volume is checked during 
usrTffsConfig() and it is instantiated as a RAWFS volume if no known
file system is found.  When the volume is formatted with DOSFS, it
is re-instantiated as a DOSFS volume.

INITIALIZING A TFFS/HRFS DEVICE
The typical steps for initializing a TFFS/DOSFS device are shown,
assuming the group sysTffsGid corresponds to TFFS volume 0:

.CS
  -> tffsRawio 0, 3, 0, f2xGroupSize(sysTffsGid)/f2xGroupBlockSize(sysTffsGid)
  -> tffsDevFormat 0, 0
  -> flFileSysSectorStart = 1
  -> pBlkDev = tffsDevCreate (0, 0)
  -> tffsDevOptionsSet(pBlkDev)
  -> xbdBlkDevCreateSync(pBlkDev, "/tffs")
  -> hrfsDiskFormat "/tffs"
.CE

NOTES FROM THE AUTHOR
The f2xFlash module suite is a balance of utility, simplicity and
legacy.  Changes to the main branch which compromise any of these
attributes are rarely made.

POSSIBLE FUTURE ENHANCEMENTS
- None as of 22jul11.
*/

/* includes */

#include "vxWorks.h"
#include "sysLib.h"
#include "taskLib.h"
#include "memLib.h"
#include "semLib.h"
#include "tickLib.h"
#include "string.h"
#include "blkIo.h"
#include "ioLib.h"
#include "lstLib.h"
#include "cacheLib.h"
#include "stdioLib.h"
#include "f2xFlashMem.h"

/* defines */

#ifdef INCLUDE_F2X_UINT64_LEGACY
#define UINT64                 double
#else /* INCLUDE_F2X_UINT64_LEGACY */
#define UINT64                 unsigned long long
#endif /* INCLUDE_F2X_UINT64_LEGACY */

#ifndef F2X_MAX_REGIONS
#define F2X_MAX_REGIONS        16
#endif /* F2X_MAX_REGIONS */

#ifndef F2X_MAX_GROUPS
#define F2X_MAX_GROUPS         16
#endif /* F2X_MAX_GROUPS */

/* WARNING: The F2X_UINTxx_READ() macros are at times bypassed unless
 *          INCLUDE_F2X_FORCE_WIDTH_READ is defined.
 */

#ifndef F2X_UINT8_READ
#define F2X_UINT8_READ(id, pSrc, pDst, isData) \
                               {*(UINT8 *)(pDst) = *(volatile UINT8 *)(pSrc);}
#endif /* F2X_UINT8_READ */

#ifndef F2X_UINT16_READ
#define F2X_UINT16_READ(id, pSrc, pDst, isData) \
                               {*(UINT16 *)(pDst) = *(volatile UINT16 *)(pSrc);}
#endif /* F2X_UINT16_READ */

#ifndef F2X_UINT32_READ
#define F2X_UINT32_READ(id, pSrc, pDst, isData) \
                               {*(UINT32 *)(pDst) = *(volatile UINT32 *)(pSrc);}
#endif /* F2X_UINT32_READ */

#ifndef F2X_UINT64_READ
#define F2X_UINT64_READ(id, pSrc, pDst, isData) \
                               {*(UINT64 *)(pDst) = *(volatile UINT64 *)(pSrc);}
#endif /* F2X_UINT64_WRITE */

#ifndef F2X_UINT8_WRITE
#define F2X_UINT8_WRITE(id, pSrc, pDst, isData) \
                               {*(volatile UINT8 *)(pDst) = *(UINT8 *)(pSrc);}
#endif /* F2X_UINT8_WRITE */

#ifndef F2X_UINT16_WRITE
#define F2X_UINT16_WRITE(id, pSrc, pDst, isData) \
                               {*(volatile UINT16 *)(pDst) = *(UINT16 *)(pSrc);}
#endif /* F2X_UINT16_WRITE */

#ifndef F2X_UINT32_WRITE
#define F2X_UINT32_WRITE(id, pSrc, pDst, isData) \
                               {*(volatile UINT32 *)(pDst) = *(UINT32 *)(pSrc);}
#endif /* F2X_UINT32_WRITE */

#ifndef F2X_UINT64_WRITE
#define F2X_UINT64_WRITE(id, pSrc, pDst, isData) \
                               {*(volatile UINT64 *)(pDst) = *(UINT64 *)(pSrc);}
#endif /* F2X_UINT64_WRITE */

#define F2X_ALIGN(x,align)     ((unsigned)(x) - ((unsigned)(x) % (align)))

#ifndef F2X_SYS_NV_RAM_OFFSET
#define F2X_SYS_NV_RAM_OFFSET  0
#endif /* F2X_SYS_NV_RAM_OFFSET */

#ifndef NV_RAM_SIZE
#define NV_RAM_SIZE            255
#endif /* NV_RAM_SIZE */

#define F2X_CFI_PATTERN_1Q     {'Q','R','Y'}
#define F2X_CFI_PATTERN_2Q     {'Q','Q','R','R','Y','Y'}
#define F2X_CFI_PATTERN_4Q     {'Q','Q','Q','Q','R','R','R','R', \
                                'Y','Y','Y','Y'}
#define F2X_CFI_PATTERN_8Q     {'Q','Q','Q','Q','Q','Q','Q','Q', \
                                'R','R','R','R','R','R','R','R', \
                                'Y','Y','Y','Y','Y','Y','Y','Y'}
#define F2X_CFI_PATTERN_16Q    {'Q','Q','Q','Q','Q','Q','Q','Q', \
                                'Q','Q','Q','Q','Q','Q','Q','Q', \
                                'R','R','R','R','R','R','R','R', \
                                'R','R','R','R','R','R','R','R', \
                                'Y','Y','Y','Y','Y','Y','Y','Y', \
                                'Y','Y','Y','Y','Y','Y','Y','Y'}
#define F2X_CFI_CMD(x)         {(char)(x),(char)(x),(char)(x),(char)(x), \
                                (char)(x),(char)(x),(char)(x),(char)(x)}

#ifdef _WRS_GNU_VAR_MACROS
#define F2X_PRINTF(args...)    {if (verbose) printf (args);}
#else /* _WRS_GNU_VAR_MACROS */
#define F2X_PRINTF(...)        {if (verbose) printf (__VA_ARGS__);}
#endif /* _WRS_GNU_VAR_MACROS */

/* typedefs */

typedef struct                 /* F2X_GDESC */
    {
    F2X_RID   ridArray[F2X_MAX_REGIONS];    /* regions of the group */
    int       ridArrayCount;                /* number of regions in the group */
    int       groupSize;                    /* total size of group in bytes */
    int       pseudoBlockSize;              /* see f2xGroupBlockSize() */
    SEMAPHORE semaphore;                    /* group-level semaphore */
    SEM_ID    semId;                        /* pointer to semaphore above */
    } F2X_GDESC;

typedef struct                 /* F2X_BLK_DEV */
    {
    BLK_DEV   bd;                           /* BLK_DEV structure, must be 1st */
    F2X_GID   id;                           /* group ID of the device */
    } F2X_BLK_DEV;

typedef struct                 /* F2X_RREC */
    {
    NODE      node;                         /* list structure, must be 1st */
    int       offset;                       /* region start offset */
    int       regionSize;                   /* region size */
    int       blockSize;                    /* region block size */
    F2X_RID   rid;                          /* region ID for this region */
    } F2X_RREC;

/* globals */

#ifdef INCLUDE_F2X_SYS_FLASH_ROUTINES
F2X_GID f2xSysFlashGid = (F2X_GID)NULL;
#endif /* INCLUDE_F2X_SYS_FLASH_ROUTINES */
#ifdef INCLUDE_F2X_SYS_NV_RAM_ROUTINES
F2X_GID f2xSysNvRamGid = (F2X_GID)NULL;
#endif /* INCLUDE_F2X_SYS_NV_RAM_ROUTINES */
#ifdef INCLUDE_F2X_BOOTROM_ROUTINES
F2X_GID f2xBootromGid = (F2X_GID)NULL;
#endif /* INCLUDE_F2X_BOOTROM_ROUTINES */
#ifdef INCLUDE_F2X_CFI_ROUTINES
int f2xCfiErrorLine = 0;    /* debug tool */
#endif /* INCLUDE_F2X_CFI_ROUTINES */

/* locals */

LOCAL F2X_RDESC f2xRDescArray [F2X_MAX_REGIONS];
LOCAL int       f2xRDescArrayCount = 0;
LOCAL F2X_GDESC f2xGDescArray [F2X_MAX_GROUPS];
LOCAL int       f2xGDescArrayCount = 0;
LOCAL char      f2xErasedArray [F2X_MAX_REGION_WIDTH];

/* region-level routines ---------------------------------------------------- */

/*******************************************************************************
*
* f2xRegionWidthRead - read flash region
*
* This routine reads the entire width of a flash region into a buffer.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: N/A.
*
* NOMANUAL
*/

void f2xRegionWidthRead
    (
    F2X_RID id,
    char *  pDst,
    int     offset,
    BOOL    isData
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pSrc = pRDesc->baseAdrs + offset;
    UINT64      buf;    /* aligned buffer */
    char *      pBuf = (char *)&buf;

    /* perform the aligned read into the aligned buffer */

    switch (pRDesc->regionWidth)
        {
        case 1:
            F2X_UINT8_READ(id, pSrc, pBuf, isData);
            break;
        case 2:
            F2X_UINT16_READ(id, pSrc, pBuf, isData);
            break;
        case 4:
            F2X_UINT32_READ(id, pSrc, pBuf, isData);
            break;
        case 8:
            F2X_UINT64_READ(id, pSrc, pBuf, isData);
            break;
        default:
            break;
        }

    /* copy aligned buffer into possibly unaligned buffer */

    bcopy (pBuf, pDst, pRDesc->regionWidth);
    }

/*******************************************************************************
*
* f2xRegionWidthWrite - write flash region
*
* This routine writes a buffer over the entire width of a flash region.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: N/A.
*
* NOMANUAL
*/

void f2xRegionWidthWrite
    (
    F2X_RID id,
    char *  pSrc,
    int     offset,
    BOOL    isData
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pDst = pRDesc->baseAdrs + offset;
    int         numWrites = pRDesc->regionWidth / pRDesc->writeWidth;
    int         writeIndex;
    UINT64      buf;    /* aligned buffer */
    char *      pBuf = (char *)&buf;

    /* copy possibly unaligned buffer into aligned buffer */

    bcopy (pSrc, pBuf, pRDesc->regionWidth);

    /* perform the aligned write from the aligned buffer */

    for (writeIndex = 0; writeIndex < numWrites; writeIndex++)
        {
        switch (pRDesc->writeWidth)
            {
            case 1:
                F2X_UINT8_WRITE(id, pBuf, pDst, isData);
                break;
            case 2:
                F2X_UINT16_WRITE(id, pBuf, pDst, isData);
                break;
            case 4:
                F2X_UINT32_WRITE(id, pBuf, pDst, isData);
                break;
            case 8:
                F2X_UINT64_WRITE(id, pBuf, pDst, isData);
                break;
            default:
                break;
            }
        pBuf += pRDesc->writeWidth;
        pDst += pRDesc->writeWidth;
        }

    CACHE_PIPE_FLUSH();
    }

/*******************************************************************************
*
* f2xRegionCmdCreate - create flash command
*
* This routine creates a flash command buffer.  This routine is also
* used to create byte/command counts in f2xRegionWBProgram().
*
* RETURNS: N/A
*/

LOCAL void f2xRegionCmdCreate
    (
    F2X_RID id,
    char *  pDst,
    int     cmd
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    int         chipIndex;

    for (chipIndex = 0; chipIndex < numChips; chipIndex++)
        {
        switch (pRDesc->chipWidth)
            {
            case 1:
                *(UINT8 *)pDst = (UINT8)cmd;
                break;
            case 2:
                *(UINT16 *)pDst = (UINT16)cmd;
                break;
            case 4:
                *(UINT32 *)pDst = (UINT32)cmd;
                break;
            default:
                break;
            }
        pDst += pRDesc->chipWidth;
        }
    }

/*******************************************************************************
*
* f2xRegionBlockSize - get flash region block size
* 
* This routine returns the size of a flash region block in bytes.
*
* RETURNS: Size of flash region block in bytes.
*/

LOCAL int f2xRegionBlockSize
    (
    F2X_RID id
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    int         blockSize;

    blockSize = pRDesc->chipBlockSize * (pRDesc->regionWidth /
                                         pRDesc->chipWidth);

    return (blockSize);
    }

/*******************************************************************************
*
* f28RegionIsBusy - checks if Intel28-style flash region is busy
*
* This routine checks if the Intel28-style flash region is busy.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: TRUE if any flash chip in the region is busy, else FALSE.
*/

LOCAL BOOL f28RegionIsBusy
    (
    F2X_RID id
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char        statusArray[F2X_MAX_REGION_WIDTH];
    char *      pChip = statusArray;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    char        statusByte;
    int         chipIndex;

    f2xRegionWidthRead (id, statusArray, 0, FALSE);

    for (chipIndex = 0; chipIndex < numChips; chipIndex++)
        {
        switch (pRDesc->chipWidth)
            {
            case 1:
                statusByte = (char)*(UINT8 *)pChip;
                break;
            case 2:
                statusByte = (char)*(UINT16 *)pChip;
                break;
            case 4:
            default:
                statusByte = (char)*(UINT32 *)pChip;
                break;
            }

        if ((statusByte & F28_STAT_WSMS) == 0)
            return (TRUE);

        pChip += pRDesc->chipWidth;
        }

    return (FALSE);
    }

/*******************************************************************************
*
* f28RegionStatusGet - get status of Intel28-style flash region
*
* This routine returns the status bytes of all Intel28-style
* chips or'ed into one byte.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: The or'ed status byte.
*/

LOCAL char f28RegionStatusGet
    (
    F2X_RID id
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char        statusArray[F2X_MAX_REGION_WIDTH];
    char *      pChip = statusArray;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    char        statusByte = 0;
    int         chipIndex;

    f2xRegionWidthRead (id, statusArray, 0, FALSE);

    for (chipIndex = 0; chipIndex < numChips; chipIndex++)
        {
        switch (pRDesc->chipWidth)
            {
            case 1:
                statusByte |= (char)*(UINT8 *)pChip;
                break;
            case 2:
                statusByte |= (char)*(UINT16 *)pChip;
                break;
            case 4:
                statusByte |= (char)*(UINT32 *)pChip;
                break;
            default:
                break;
            }
        pChip += pRDesc->chipWidth;
        }

    return (statusByte);
    }

/*******************************************************************************
*
* f28RegionProgram - program Intel28-style flash region
*
* This routine programs erased Intel28-style flash in multiples
* of the flash region width.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if programming failed.
*/

LOCAL STATUS f28RegionProgram
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    ULONG       tickSave;
    ULONG       timeoutTicks;

    while (nbytes > 0)
        {
        /* send the command */

        f2xRegionWidthWrite (id, pRDesc->cmdProgram, offset, FALSE);

        /* write the word */

        f2xRegionWidthWrite (id, pSrc, offset, TRUE);
     
        /* wait for write to complete */

        tickSave = tickGet();
        timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
        while (f28RegionIsBusy(id))
            {
            if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
                {
                status = ERROR;
                goto f28RegionProgramExit;
                }
            }

        pSrc += pRDesc->regionWidth;
        nbytes -= pRDesc->regionWidth;
        offset += pRDesc->regionWidth;
        }

    /* check status of the write */
        
    if ((f28RegionStatusGet (id) & 
        (F28_STAT_PS | F28_STAT_PSS | F28_STAT_BLS)) != 0)
        status = ERROR;

f28RegionProgramExit:

    f2xRegionWidthWrite (id, pRDesc->cmdClearStatus, 0, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdReadArray, 0, FALSE);

    return (status);
    }

/*******************************************************************************
*
* f28RegionWBProgram - "write to buffer"-program Intel28-style flash region
*
* This routine uses the Write to Buffer command to program erased
* Intel28-style flash.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if programming failed.
*/

LOCAL STATUS f28RegionWBProgram
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    ULONG       tickSave;
    ULONG       timeoutTicks;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    char        pWriteBufferCount[F2X_MAX_REGION_WIDTH];
    int         alignedOffset;
    int         bytesToProgram;
    int         bytesToProgramLast = 0;
    int         startOffset;

    while (nbytes > 0)
        {
        /* Write to Buffer commands run faster when the offset is naturally
         * aligned.  We make it so here.
         */

        alignedOffset = F2X_ALIGN (offset, pRDesc->regionWBSize);

        bytesToProgram = min(nbytes, 
                             pRDesc->regionWBSize - (offset - alignedOffset));

        /* send the command */

        f2xRegionWidthWrite (id, pRDesc->cmdWriteBuffer, offset, FALSE);

        /* According to the Write to Buffer command flow chart, we should
         * check the XSR register here and repeat the Write to Buffer command
         * if busy.  This is problematic when multiple chips span a word
         * because they will come ready at different times, and the next
         * Write to Buffer command will be interpretted as a count to those
         * who are ready.  We instead terminate every Write to Buffer command
         * so we can assume the write buffer(s) are always ready.
         */

        if (bytesToProgram != bytesToProgramLast)
            {
            /* create the chip byte/word count (bus) word */

            f2xRegionCmdCreate (id, pWriteBufferCount,
                                bytesToProgram/numChips/pRDesc->chipWidth - 1);

            bytesToProgramLast = bytesToProgram;
            }

        /* write the byte count */

        f2xRegionWidthWrite (id, pWriteBufferCount, offset, FALSE);

        /* write the data */

        startOffset = offset;
        nbytes -= bytesToProgram;
        while (bytesToProgram > 0)
            {
            f2xRegionWidthWrite (id, pSrc, offset, TRUE);
     
            pSrc += pRDesc->regionWidth;
            bytesToProgram -= pRDesc->regionWidth;
            offset += pRDesc->regionWidth;
            }

        /* write the confirmation */

        f2xRegionWidthWrite (id, pRDesc->cmdConfirm, startOffset, FALSE);

        /* wait for write to complete */

        tickSave = tickGet();
        timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
        while (f28RegionIsBusy(id))
            {
            if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
                {
                status = ERROR;
                goto f28RegionWBProgramExit;
                }
            }

        /* check status of the write */
        
        if ((f28RegionStatusGet (id) & 
            (F28_STAT_PS | F28_STAT_PSS | F28_STAT_BLS)) != 0)
            {
            status = ERROR;
            goto f28RegionWBProgramExit;
            }
        }

f28RegionWBProgramExit:

    f2xRegionWidthWrite (id, pRDesc->cmdClearStatus, 0, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdReadArray, 0, FALSE);

    return (status);
    }

/*******************************************************************************
*
* f28RegionBlockErase - erase block of Intel28-style flash region
*
* This routine erases one block of Intel28-style flash specified
* by <offset>.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if erase failed.
*/

LOCAL STATUS f28RegionBlockErase
    (
    F2X_RID id,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    ULONG       tickSave;
    ULONG       timeoutTicks;

    /* send the commands */

    f2xRegionWidthWrite (id, pRDesc->cmdBlockErase, 0, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdConfirm, offset, FALSE);

    /* wait for erase to complete */

    tickSave = tickGet();
    timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
    while (f28RegionIsBusy(id))
        {
        taskDelay(1);
        if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
            {
            status = ERROR;
            goto f28RegionBlockEraseExit;
            }
        }

    /* check status of the erase */
        
    if ((f28RegionStatusGet (id) & 
         (F28_STAT_ESS | F28_STAT_ES | F28_STAT_VPPS | F28_STAT_BLS)) != 0)
        status = ERROR;

f28RegionBlockEraseExit:

    f2xRegionWidthWrite (id, pRDesc->cmdClearStatus, 0, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdReadArray, 0, FALSE);

    return (status);
    }

/*******************************************************************************
*
* f29RegionStatusGet - get status of AMD29-style flash region
*
* This routine returns the status of the AMD29-style flash region.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: F29_STATUS_BUSY if any chip is busy, or F29_STATUS_ERROR
* if no chip is busy and at least one is in error, or F29_STATUS_OK
* if no chip is busy and none are in error.
*/

LOCAL F29_STATUS f29RegionStatusGet
    (
    F2X_RID id,
    char *  pData,
    int     offset
    )
    {
    F29_STATUS  f29Status = F29_STATUS_OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char        statusArray[F2X_MAX_REGION_WIDTH];
    char *      pChip = statusArray;
    char        xDataArray[F2X_MAX_REGION_WIDTH];
    char *      pXData = xDataArray;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    char        statusByte = 0;
    char        dataByte = 0;
    int         chipIndex;

    f2xRegionWidthRead (id, statusArray, offset, FALSE);

    /* transform the data similar to the status read above */

    switch (pRDesc->regionWidth)
        {
        case 1:
            F2X_UINT8_READ(id, pData, xDataArray, FALSE);
            break;
        case 2:
            F2X_UINT16_READ(id, pData, xDataArray, FALSE);
            break;
        case 4:
            F2X_UINT32_READ(id, pData, xDataArray, FALSE);
            break;
        case 8:
            F2X_UINT64_READ(id, pData, xDataArray, FALSE);
            break;
        default:
            break;
        }

    for (chipIndex = 0; chipIndex < numChips; chipIndex++)
        {
        switch (pRDesc->chipWidth)
            {
            case 1:
                dataByte = (char)*(UINT8 *)pXData;
                statusByte = (char)*(UINT8 *)pChip;
                break;
            case 2:
                dataByte = (char)*(UINT16 *)pXData;
                statusByte = (char)*(UINT16 *)pChip;
                break;
            case 4:
                dataByte = (char)*(UINT32 *)pXData;
                statusByte = (char)*(UINT32 *)pChip;
                break;
            default:
                break;
            }

        /* data polling algorithm */

        if ((dataByte & F29_STAT_DQ7) != (statusByte & F29_STAT_DQ7))
            {
            if ((statusByte & F29_STAT_DQ5) == 0)
                {
                /* a chip is busy, return */

                f29Status = F29_STATUS_BUSY;

                return (f29Status);
                }
            else
                {
                /* authenticate the error */

                f2xRegionWidthRead (id, statusArray, offset, FALSE);

                switch (pRDesc->chipWidth)
                    {
                    case 1:
                        statusByte = (char)*(UINT8 *)pChip;
                        break;
                    case 2:
                        statusByte = (char)*(UINT16 *)pChip;
                        break;
                    case 4:
                        statusByte = (char)*(UINT32 *)pChip;
                        break;
                    default:
                        break;
                    }

                if ((dataByte & F29_STAT_DQ7) != (statusByte & F29_STAT_DQ7))
                    {
                    f29Status = F29_STATUS_ERROR;

                    /* continue and make sure no others are busy */
                    }
                }
            }

        pXData += pRDesc->chipWidth;
        pChip += pRDesc->chipWidth;
        }

    return (f29Status);
    }

/*******************************************************************************
*
* f29RegionProgram - program AMD29-style flash region
*
* This routine programs erased AMD29-style flash in multiples
* of the flash region width.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if programming failed.
*/

LOCAL STATUS f29RegionProgram
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    F29_STATUS  f29Status;
    ULONG       tickSave;
    ULONG       timeoutTicks;

    while (nbytes > 0)
        {
        /* send the commands */

        f2xRegionWidthWrite (id, pRDesc->cmdUnlock1, pRDesc->offUnlock1, FALSE);
        f2xRegionWidthWrite (id, pRDesc->cmdUnlock2, pRDesc->offUnlock2, FALSE);
        f2xRegionWidthWrite (id, pRDesc->cmdProgram, pRDesc->offProgram, FALSE);

        /* write the word */

        f2xRegionWidthWrite (id, pSrc, offset, TRUE);
     
        /* wait for write to complete */

        tickSave = tickGet();
        timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
        while ((f29Status = f29RegionStatusGet(id, pSrc, offset)) ==
                F29_STATUS_BUSY)
            {
            if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
                {
                f2xRegionWidthWrite (id, pRDesc->cmdReset,
                                     pRDesc->offReset, FALSE);
                return (ERROR);
                }
            }

        /* check status of the write */

        if (f29Status != F29_STATUS_OK)
            {
            f2xRegionWidthWrite (id, pRDesc->cmdReset, pRDesc->offReset, FALSE);
            return (ERROR);
            }
 
        pSrc += pRDesc->regionWidth;
        nbytes -= pRDesc->regionWidth;
        offset += pRDesc->regionWidth;
        }

    return (OK);
    }

/*******************************************************************************
*
* f29RegionWBProgram - "write to buffer"-program AMD29-style flash region
*
* This routine uses the Write to Buffer command to program erased
* AMD29-style flash.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if programming failed.
*/

LOCAL STATUS f29RegionWBProgram
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    F29_STATUS  f29Status;
    ULONG       tickSave;
    ULONG       timeoutTicks;
    int         numChips = pRDesc->regionWidth / pRDesc->chipWidth;
    char        pWriteBufferCount[F2X_MAX_REGION_WIDTH];
    int         alignedOffset;
    int         bytesToProgram;
    int         blockOffset;

    while (nbytes > 0)
        {
        /* Write to Buffer commands run faster when the offset is naturally
         * aligned.  We make it so here.
         */

        alignedOffset = F2X_ALIGN (offset, pRDesc->regionWBSize);

        bytesToProgram = min(nbytes, 
                             pRDesc->regionWBSize - (offset - alignedOffset));

        blockOffset = F2X_ALIGN (offset, f2xRegionBlockSize(id));

        /* send the commands */

        f2xRegionWidthWrite (id, pRDesc->cmdUnlock1, pRDesc->offUnlock1, FALSE);
        f2xRegionWidthWrite (id, pRDesc->cmdUnlock2, pRDesc->offUnlock2, FALSE);
        f2xRegionWidthWrite (id, pRDesc->cmdWriteBuffer, blockOffset, FALSE);

        /* create the chip byte/word count (bus) word */

        f2xRegionCmdCreate (id, pWriteBufferCount,
                            bytesToProgram/numChips/pRDesc->chipWidth - 1);

        /* write the byte count */

        f2xRegionWidthWrite (id, pWriteBufferCount, blockOffset, FALSE);

        /* write the data */

        nbytes -= bytesToProgram;
        while (bytesToProgram > 0)
            {
            f2xRegionWidthWrite (id, pSrc, offset, TRUE);
     
            pSrc += pRDesc->regionWidth;
            bytesToProgram -= pRDesc->regionWidth;
            offset += pRDesc->regionWidth;
            }

        /* write the "program buffer" command */

        f2xRegionWidthWrite (id, pRDesc->cmdProgramBuffer, blockOffset, FALSE);

        /* wait for write to complete */

        tickSave = tickGet();
        timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
        while ((f29Status = f29RegionStatusGet(id, pSrc - pRDesc->regionWidth, 
                                               offset - pRDesc->regionWidth)) ==
                F29_STATUS_BUSY)
            {
            if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
                {
                f2xRegionWidthWrite (id, pRDesc->cmdReset,
                                     pRDesc->offReset, FALSE);
                return (ERROR);
                }
            }

        /* check status of the write */

        if (f29Status != F29_STATUS_OK)
            {
            f2xRegionWidthWrite (id, pRDesc->cmdReset, pRDesc->offReset, FALSE);
            return (ERROR);
            }

        }

    return (OK);
    }

/*******************************************************************************
*
* f29RegionBlockErase - erase block of AMD29-style flash region
*
* This routine erases one block of Intel28-style flash specified
* by <offset>.
*
* WARNING: For the sake of speed, this routine leaves alignment
* checking, range checking, mutual exclusion protection and page
* selection (if any) to higher-order routines.
*
* RETURNS: OK, or ERROR if erase failed.
*/

LOCAL STATUS f29RegionBlockErase
    (
    F2X_RID id,
    int     offset
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pSrc = f2xErasedArray;
    F29_STATUS  f29Status;
    ULONG       tickSave;
    ULONG       timeoutTicks;

    /* send the commands */

    f2xRegionWidthWrite (id, pRDesc->cmdUnlock1, pRDesc->offUnlock1, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdUnlock2, pRDesc->offUnlock2, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdBlockErase,
                         pRDesc->offBlockErase, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdUnlock1, pRDesc->offUnlock1, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdUnlock2, pRDesc->offUnlock2, FALSE);
    f2xRegionWidthWrite (id, pRDesc->cmdConfirm, offset, FALSE);

    /* wait for erase to complete */

    tickSave = tickGet();
    timeoutTicks = sysClkRateGet() * F2X_TIMEOUT;
    while ((f29Status = f29RegionStatusGet(id, pSrc, offset)) ==
           F29_STATUS_BUSY)
        {
        taskDelay(1);
        if ((tickGet() - tickSave) > (ULONG)timeoutTicks)
            {
            f2xRegionWidthWrite (id, pRDesc->cmdReset, pRDesc->offReset, FALSE);
            return (ERROR);
            }
        }

    /* check status of the erase */
        
    if (f29Status != F29_STATUS_OK)
        {
        f2xRegionWidthWrite (id, pRDesc->cmdReset, pRDesc->offReset, FALSE);
        return (ERROR);
        }

    return (OK);
    }

/*******************************************************************************
*
* f2xRegionProgram - program flash region
*
* This routine programs erased flash at any offset and any number
* of bytes within the region.
*
* WARNING: For the sake of speed, this routine leaves range
* checking to higher-order routines.
*
* RETURNS: OK, or ERROR if programming failed.
*/

LOCAL STATUS f2xRegionProgram
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    int         alignedOffset = F2X_ALIGN (offset, pRDesc->regionWidth);
    int         bytesToProgram;
    int         bytesToCopyHead;
    int         bytesToCopyTail;
    char        pWord[F2X_MAX_REGION_WIDTH];

    semTake (pRDesc->semId, WAIT_FOREVER);

    /* check for collision with block cache */

    if ((pRDesc->cacheRegionOffset != NONE) &&
        ((offset + nbytes) > pRDesc->cacheRegionOffset) &&
        ((pRDesc->cacheRegionOffset + f2xRegionBlockSize(id)) > offset))
        {
        /* refuse to program under a dirty block cache */

        if (pRDesc->cacheIsDirty)
            {
            status = ERROR;
            goto f2xRegionProgramExit;
            }

        /* Invalidate the block cache.  This is done specifically for calls
         * from f2xGroupProgram().  It is undone by f2xRegionCacheFlush()
         * and f2xRegionSet() as needed.
         */

        pRDesc->cacheRegionOffset = NONE;
        }

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

    /* program partial word start */

    bytesToCopyHead = offset - alignedOffset;
    if (bytesToCopyHead != 0)
        {
        bytesToProgram = min(nbytes, pRDesc->regionWidth - bytesToCopyHead);
        bytesToCopyTail = pRDesc->regionWidth - bytesToCopyHead -
                          bytesToProgram;

#ifdef INCLUDE_F2X_FORCE_WIDTH_READ
        f2xRegionWidthRead (id, pWord, alignedOffset, TRUE);
        bcopy (pSrc, pWord + bytesToCopyHead, bytesToProgram);
#else /* INCLUDE_F2X_FORCE_WIDTH_READ */
        /* This code is being kept for legacy purposes.  In time it will be
         * removed and the code above will be used exclusively - it is simpler.
         */
        bcopy (pRDesc->baseAdrs + alignedOffset, pWord, bytesToCopyHead);
        bcopy (pSrc, pWord + bytesToCopyHead, bytesToProgram);
        bcopy (pRDesc->baseAdrs + alignedOffset + bytesToCopyHead + 
               bytesToProgram, pWord + bytesToCopyHead + bytesToProgram,
               bytesToCopyTail);
#endif /* INCLUDE_F2X_FORCE_WIDTH_READ */

        status = (pRDesc->programRtn)(id, pWord, pRDesc->regionWidth,
                                      alignedOffset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionProgramExit;
            }

        pSrc += bytesToProgram;
        nbytes -= bytesToProgram;
        offset += bytesToProgram;
        }

    if (nbytes == 0)
        goto f2xRegionProgramExit;

    /* program whole word middle */

    bytesToProgram = min((unsigned)nbytes,
                         F2X_ALIGN(offset + nbytes, pRDesc->regionWidth) -
                         offset);

    if (bytesToProgram != 0)
        {
        status = (pRDesc->programRtn)(id, pSrc, bytesToProgram, offset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionProgramExit;
            }

        pSrc += bytesToProgram;
        nbytes -= bytesToProgram;
        offset += bytesToProgram;
        }
        
    /* program partial word end */

    bytesToProgram = nbytes;
    if (bytesToProgram != 0)
        {
        bytesToCopyTail = pRDesc->regionWidth - bytesToProgram;

#ifdef INCLUDE_F2X_FORCE_WIDTH_READ
        f2xRegionWidthRead (id, pWord, offset, TRUE);
        bcopy (pSrc, pWord, bytesToProgram);
#else /* INCLUDE_F2X_FORCE_WIDTH_READ */
        /* This code is being kept for legacy purposes.  In time it will be
         * removed and the code above will be used exclusively - it is simpler.
         */
        bcopy (pSrc, pWord, bytesToProgram);
        bcopy (pRDesc->baseAdrs + offset + bytesToProgram,
               pWord + bytesToProgram, bytesToCopyTail);
#endif /* INCLUDE_F2X_FORCE_WIDTH_READ */

        status = (pRDesc->programRtn)(id, pWord, pRDesc->regionWidth, offset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionProgramExit;
            }
        }

f2xRegionProgramExit:
    semGive (pRDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xRegionBlockErase - erase block of flash region
*
* This routine erases one block of a flash region.
*
* WARNING: For the sake of speed, this routine leaves range
* checking to higher-order routines.
*
* RETURNS: OK, or ERROR if erase failed.
*/

LOCAL STATUS f2xRegionBlockErase
    (
    F2X_RID id,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;

    offset = F2X_ALIGN (offset, f2xRegionBlockSize(id));

    semTake (pRDesc->semId, WAIT_FOREVER);

    /* invalidate block cache if this block matches */

    if (pRDesc->cacheRegionOffset == offset)
        {
        pRDesc->cacheRegionOffset = NONE;
        pRDesc->cacheIsDirty = FALSE;
        }

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

    status = (pRDesc->blockEraseRtn)(id, offset);

    semGive (pRDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xRegionCacheFlush - write the region block cache to flash
*
* This routine erases the block corresponding to the region block cache
* and programs it with the contents of the cache.
*
* RETURNS: OK, or ERROR erase or program failed.
*/

LOCAL STATUS f2xRegionCacheFlush
    (
    F2X_RID id
    )
    {
    STATUS      status;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pCache = pRDesc->pCache;
    int         offset = pRDesc->cacheRegionOffset;

    semTake (pRDesc->semId, WAIT_FOREVER);

    if (!pRDesc->cacheIsDirty)
        {
        status = OK;
        goto f2xRegionCacheFlushExit;
        }

    if (!pRDesc->cacheRegionIsErased)
        {
        /* temporarily erase the block corresponding to the cache */

        status = f2xRegionBlockErase (id, offset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionCacheFlushExit;
            }
        }

    /* set isDirty to FALSE so program happens */

    pRDesc->cacheIsDirty = FALSE;

    /* write the cache block to flash */

    status = f2xRegionProgram (id, pCache, f2xRegionBlockSize(id), offset);

    if (status != OK)
        {
        status = ERROR;
        goto f2xRegionCacheFlushExit;
        }

    /* undo what the above calls did to the block cache status */

    pRDesc->cacheRegionOffset = offset;

f2xRegionCacheFlushExit:
    semGive (pRDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xRegionGet - get the contents of flash region
*
* This routine copies the contents of a flash region into a
* specified buffer.
*
* WARNING: For the sake of speed, this routine leaves range
* checking to higher-order routines.
*
* RETURNS: OK, or ERROR parameters are invalid.
*/

LOCAL STATUS f2xRegionGet
    (
    F2X_RID id,
    char *  pDst,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
#ifdef INCLUDE_F2X_FORCE_WIDTH_READ
    int         alignedOffset = F2X_ALIGN (offset, pRDesc->regionWidth);
    int         bytesToRead;
    int         bytesToSkipHead;
    int         bytesToSkipTail;
    char        pWord[F2X_MAX_REGION_WIDTH];
#else /* INCLUDE_F2X_FORCE_WIDTH_READ */
    char *      pSrc = pRDesc->baseAdrs + offset;
#endif /* INCLUDE_F2X_FORCE_WIDTH_READ */

    semTake (pRDesc->semId, WAIT_FOREVER);

    /* check for collision with a dirty block cache */

    if ((pRDesc->cacheRegionOffset != NONE) && (pRDesc->cacheIsDirty) &&
        ((offset + nbytes) > pRDesc->cacheRegionOffset) &&
        ((pRDesc->cacheRegionOffset + f2xRegionBlockSize(id)) > offset))
        {
        status = f2xRegionCacheFlush(id);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionGetExit;
            }
        }

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

#ifdef INCLUDE_F2X_FORCE_WIDTH_READ
    /* read partial word start */

    bytesToSkipHead = offset - alignedOffset;
    if (bytesToSkipHead != 0)
        {
        bytesToRead = min(nbytes, pRDesc->regionWidth - bytesToSkipHead);

        f2xRegionWidthRead (id, pWord, alignedOffset, TRUE);
        bcopy (pWord + bytesToSkipHead, pDst, bytesToRead);

        pDst += bytesToRead;
        nbytes -= bytesToRead;
        offset += bytesToRead;
        }

    if (nbytes == 0)
        goto f2xRegionGetExit;

    /* read whole word middle */

    while (nbytes >= pRDesc->regionWidth)
        {
        f2xRegionWidthRead (id, pDst, offset, TRUE);

        pDst += pRDesc->regionWidth;
        nbytes -= pRDesc->regionWidth;
        offset += pRDesc->regionWidth;
        }

    /* read partial word end */

    bytesToRead = nbytes;
    if (bytesToRead != 0)
        {
        bytesToSkipTail = pRDesc->regionWidth - bytesToRead;

        f2xRegionWidthRead (id, pWord, offset, TRUE);
        bcopy (pWord, pDst, bytesToRead);
        }

#else /* INCLUDE_F2X_FORCE_WIDTH_READ */

    bcopy (pSrc, pDst, nbytes);

#endif /* INCLUDE_F2X_FORCE_WIDTH_READ */

f2xRegionGetExit:
    semGive (pRDesc->semId);

    return (OK);
    }

/*******************************************************************************
*
* f2xRegionCachedSet - write to flash region with cache
*
* This routine copies a specified buffer into a flash region with
* the benefit of a copy-back cache.
*
* WARNING: For the sake of speed, this routine leaves range
* checking to higher-order routines.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/

LOCAL STATUS f2xRegionCachedSet
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pCache = pRDesc->pCache;
    char *      pBuf;
    int         blockOffset;
    int         bytesToSet;
    int         bytesToCheck;
    int         cacheRegionOffset;

    semTake (pRDesc->semId, WAIT_FOREVER);

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

    while (nbytes > 0)
        {
        cacheRegionOffset = F2X_ALIGN (offset, f2xRegionBlockSize(id));

        if (cacheRegionOffset != pRDesc->cacheRegionOffset)
            {
            if (pRDesc->cacheIsDirty)
                {
                status = f2xRegionCacheFlush(id);

                if (status != OK)
                    {
                    status = ERROR;
                    goto f2xRegionCachedSetExit;
                    }
                }

            /* read new flash block into cache buffer */

            f2xRegionGet (id, pCache, f2xRegionBlockSize(id),
                          cacheRegionOffset);

            pRDesc->cacheRegionOffset = cacheRegionOffset;

            /* record if underlying block needs erasing */
        
            bytesToCheck = f2xRegionBlockSize(id);
            pRDesc->cacheRegionIsErased = TRUE;
            pBuf = pCache;
            while (bytesToCheck > 0)
               {
               if (*(UINT32 *)pBuf != (UINT32)0xffffffff)
                   {
                   pRDesc->cacheRegionIsErased = FALSE;
                   break;
                   }

               pBuf += sizeof (UINT32);;
               bytesToCheck -= sizeof (UINT32);
               }
            }

        blockOffset = offset - cacheRegionOffset;
        bytesToSet = min(nbytes, f2xRegionBlockSize(id) - blockOffset);

        /* copy source over the block image */

        bcopy (pSrc, pCache + blockOffset, bytesToSet);
        pRDesc->cacheIsDirty = TRUE;

        pSrc += bytesToSet;
        nbytes -= bytesToSet;
        offset += bytesToSet;
        }

f2xRegionCachedSetExit:
    semGive (pRDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xRegionSet - write to flash region
*
* This routine copies a specified buffer into a flash region.
*
* WARNING: For the sake of speed, this routine leaves range
* checking to higher-order routines.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/

LOCAL STATUS f2xRegionSet
    (
    F2X_RID id,
    char *  pSrc,
    int     nbytes,
    int     offset
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    char *      pCache = pRDesc->pCache;
    char *      pBuf;
    int         blockOffset;
    int         bytesToSet;
    int         bytesToCheck;
    int         cacheRegionOffset;
    BOOL        needsErase;
    BOOL        cacheIsDirty;

    semTake (pRDesc->semId, WAIT_FOREVER);

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

    while (nbytes > 0)
        {
        cacheRegionOffset = F2X_ALIGN (offset, f2xRegionBlockSize(id));

        if (cacheRegionOffset != pRDesc->cacheRegionOffset)
            {
            if (pRDesc->cacheIsDirty)
                {
                status = f2xRegionCacheFlush(id);

                if (status != OK)
                    {
                    status = ERROR;
                    goto f2xRegionSetExit;
                    }
                }

            /* read new flash block into cache buffer */

            f2xRegionGet (id, pCache, f2xRegionBlockSize(id),
                          cacheRegionOffset);

            pRDesc->cacheRegionOffset = cacheRegionOffset;
            }

        pRDesc->cacheRegionIsErased = FALSE;

        blockOffset = offset - cacheRegionOffset;
        bytesToSet = min(nbytes, f2xRegionBlockSize(id) - blockOffset);
        bytesToCheck = bytesToSet;

        /* see if block needs to be erased */
        
        needsErase = FALSE;
        pBuf = pCache + blockOffset;
        while (bytesToCheck > 0)
           {
           if (*pBuf != (char)0xff)
               {
               needsErase = TRUE;
               break;
               }

           pBuf++;
           bytesToCheck--;
           }

        /* copy source over the block image */

        bcopy (pSrc, pCache + blockOffset, bytesToSet);

        if (needsErase)
            {
            /* erase and write the modified block */

            status = f2xRegionBlockErase (id, offset);

            if (status != OK)
                {
                status = ERROR;
                goto f2xRegionSetExit;
                }

            status = f2xRegionProgram (id, pCache, f2xRegionBlockSize(id),
                                       cacheRegionOffset);
            }
        else
            {
            /* save dirty state, and set to FALSE so program happens */

            cacheIsDirty = pRDesc->cacheIsDirty;
            pRDesc->cacheIsDirty = FALSE;

            /* write only the necessary parts */

            status = f2xRegionProgram (id, pCache + blockOffset, bytesToSet,
                                       offset);

            /* restore state */

            pRDesc->cacheIsDirty = cacheIsDirty;
            }

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionSetExit;
            }

        /* undo what the above calls did to the block cache status */

        pRDesc->cacheRegionOffset = offset;
        
        pSrc += bytesToSet;
        nbytes -= bytesToSet;
        offset += bytesToSet;
        }

f2xRegionSetExit:
    semGive (pRDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xRegionErase - erase flash region
*
* This routine erases a flash region.
*
* RETURNS: OK, or ERROR if erase failed.
*/

LOCAL STATUS f2xRegionErase
    (
    F2X_RID id
    )
    {
    STATUS      status = OK;
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;
    int         offset;

    semTake (pRDesc->semId, WAIT_FOREVER);

    if (pRDesc->pageFunc != (VOIDFUNCPTR)NULL)
        {
        /* turn the page */

        (pRDesc->pageFunc)(pRDesc->pageId);
        }

    for (offset = 0; offset < pRDesc->regionSize;
         offset += f2xRegionBlockSize(id))
        {
        status = f2xRegionBlockErase (id, offset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xRegionBlockEraseExit;
            }
        }

f2xRegionBlockEraseExit:
    semGive (pRDesc->semId);
     
    return (status);
    }

/*******************************************************************************
*
* f2xRegionSize - get size of flash region
*
* This routine returns the size of a flash region in bytes.
*
* RETURNS: Size of flash region in bytes.
*/

LOCAL int f2xRegionSize
    (
    F2X_RID id
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)id;

    return (pRDesc->regionSize);
    }

/*******************************************************************************
*
* f2xRegionIsPowerOf2 - checks if argument is power of 2
*
* This routine checks that the argument is a power of 2.
*
* RETURNS: TRUE if <arg> is a power of 2, else FALSE.
*/

LOCAL BOOL f2xRegionIsPowerOf2
    (
    int arg
    )
    {
    if (arg <= 0)
        return (FALSE);

    while ((arg & 1) == 0)
        arg >>= 1;

    return ((arg & ~1) == 0);
    }

/*******************************************************************************
*
* f2xRegionCreate - create flash region
*
* This routine records the parameters of a flash region and
* puts the region in a ready state.
*
* ARGUMENT DETAILS:
* <baseAdrs>:
* Base address of the flash region.
*
* <regionWidth>:
* Data bus width of the flash region in bytes.  This is the
* equivalent to the number of interleaved chips multiplied by the
* byte width of each (i.e., <chipWidth>, see below).
*
* <regionSize>:
* Entire size of the flash region in bytes.  The address
* <baseAdrs> + <regionSize> - 1 should be the last byte of
* the region.  To properly reset a region, a region should
* not span inter-chip or intra-chip banks.
*
* <chipWidth>:
* The width of a single flash chip in bytes.  This is usually
* 1 or 2.
*
* <chipBlockSize>:
* The erasable unit in bytes of a flash chip for this
* region.  Using AMD terminology, this is the "sector size."
* Using Intel terminology, this  is the "block size."
*
* <writeWidth>:
* The width in bytes the CPU should use to write to the flash
* region.  In almost all cases, this is the same as <regionWidth>.
* In rare cases (e.g., writes that traverse a Motorola Falcon chip
* set), this is half, a quarter or an eighth of <regionWidth>.
*
* <type>:
* The type of the flash chips.  This should be F28_TYPE for
* Intel28-style flash; F29_8BIT_TYPE for 8-bit only AMD29-style flash;
* F29_16BIT_TYPE for 8/16-bit and 16-bit only AMD29-style flash; and
* F29_32BIT_TYPE for 8/16/32-bit, 16/32-bit and 32-bit only AMD29-style
* flash.  If the flash supports a "write to buffer" command 
* (as do Intel StrataFlash and AMD MirrorBit flash), write performance
* may be enhanced by or-ing the type value above with F2X_WBxx_TYPE.
* See f2xFlashMem.h for details.
*
* <dependRid>:
* The region ID (F2X_RID) of a dependent flash region.  In most
* cases this should be the region ID of any previously defined
* region that shares the same flash chip (or chips) or shares the
* same page (see next argument).  If the region has no dependents
* or this is the first call to f2xRegionCreate() for a dependent
* region, <dependRid> should be NULL.  This information is used
* to share mutual exclusion mechanisms (semaphores) between
* dependent regions and is particularly important when two dependent
* regions belong to different flash groups.
*
* <pageFunc>:
* A user-supplied function used when paging that places the region
* at <baseAdrs>. For most hardware configurations, i.e., those where
* the entire flash region is entirely memory mapped, <pageFunc> is
* NULL.
*
* <pageId>:
* An argument for <pageFunc> (above).  This is additional 
* information that may be used to identify one page from another.
* If <pageFunc> NULL, <pageId> should be NONE.
*
* RETURNS: An ID for the region, or NULL if parameters are invalid
* or F2X_MAX_REGION regions already exist.
*/

F2X_RID f2xRegionCreate
    (
    char *      baseAdrs,       /* base address of flash region */
    int         regionWidth,    /* width of flash region in bytes */
    int         regionSize,     /* entire size of flash region in bytes */
    int         chipWidth,      /* width of single flash part in bytes */
    int         chipBlockSize,  /* block size of a single flash chip in bytes */
    int         writeWidth,     /* width of a flash region write in bytes */
    int         type,           /* f2x_xxx_TYPE - see f2xFlashMem.h */
    F2X_RID     dependRid,      /* dependent region ID (or NULL) */
    VOIDFUNCPTR pageFunc,       /* user-supplied page function (or NULL) */
    int         pageId          /* argument for page function (or NONE) */
    )
    {
    F2X_RDESC * pRDesc;
    char *      pCache;
    int         typeWithMask = type & F2X_TYPE_MASK;
    int         f2xBlockSize;
    int         shift;

    /* interrogate user input */

    if ((f2xRegionIsPowerOf2 (regionWidth) && 
         f2xRegionIsPowerOf2 (chipWidth) &&
         f2xRegionIsPowerOf2 (writeWidth)) == FALSE)
        return ((F2X_RID)NULL);

    if (((regionWidth == 1) || (regionWidth == 2) ||
         (regionWidth == 4) || (regionWidth == 8)) == FALSE)
        return ((F2X_RID)NULL);

    if (((chipWidth == 1) || (chipWidth == 2) ||
         (chipWidth == 4)) == FALSE)
        return ((F2X_RID)NULL);

    if ((regionWidth % chipWidth) != 0)
        return ((F2X_RID)NULL);

    if ((regionWidth % writeWidth) != 0)
        return ((F2X_RID)NULL);

    if (writeWidth < chipWidth)
        return ((F2X_RID)NULL);
   
    f2xBlockSize = chipBlockSize * (regionWidth / chipWidth);

    if ((regionSize % f2xBlockSize) != 0)
        return ((F2X_RID)NULL);

    if ((typeWithMask != F28_TYPE) && (typeWithMask != F28_WB32_TYPE) &&
        (typeWithMask != F29_8BIT_TYPE) && (typeWithMask != F29_16BIT_TYPE) &&
        (typeWithMask != F29_32BIT_TYPE))
        return ((F2X_RID)NULL);

    if (((type & F2X_WB_TYPE_MASK) != 0) &&
        ((F2X_WB_SIZE(type) > 0x10000) ||
         ((chipWidth == 1) && (F2X_WB_SIZE(type) > 0x100))))
        return ((F2X_RID)NULL);

    switch (typeWithMask)
        {
        case F29_32BIT_TYPE:
            if (chipWidth == 4) break;
        case F29_16BIT_TYPE:
            if (chipWidth == 2) break;
        case F29_8BIT_TYPE:
            if (chipWidth == 1) break;
            return ((F2X_RID)NULL);
            break;
        default:
            break;
        }

    /* initialize "erased" array (this might happen more that once) */

    bfill (f2xErasedArray, sizeof (f2xErasedArray), 0xff);

    /* make sure we have enough descriptors */

    if ((unsigned)f2xRDescArrayCount >= NELEMENTS(f2xRDescArray))
        return ((F2X_RID)NULL);

    /* get some memory for the block cache */

    pCache = (char *)malloc (chipBlockSize * (regionWidth / chipWidth));

    if (pCache == NULL)
        return ((F2X_RID)NULL);

    /* get next descriptor */

    pRDesc = &f2xRDescArray [f2xRDescArrayCount];

    /* increment array element count */

    f2xRDescArrayCount++;

    /* save user input to descriptor */

    pRDesc->baseAdrs = baseAdrs;
    pRDesc->regionWidth = regionWidth;
    pRDesc->regionSize = regionSize;
    pRDesc->chipWidth = chipWidth;
    pRDesc->chipBlockSize = chipBlockSize;
    pRDesc->writeWidth = writeWidth;
    pRDesc->type = type;
    pRDesc->regionWBSize = (type & F2X_WB_TYPE_MASK) == 0 ? 0 :
                           F2X_WB_SIZE(type) * (regionWidth / chipWidth);
    pRDesc->pageFunc = pageFunc;
    pRDesc->pageId = pageId;

    /* form commands in descriptor */

    switch (typeWithMask)
        {
        case F28_TYPE:
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdClearStatus,
                                F28_CMD_CLEAR_STATUS);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdReadArray,
                                F28_CMD_READ_ARRAY);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdBlockErase,
                                F28_CMD_BLOCK_ERASE);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdConfirm,
                                F28_CMD_CONFIRM);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdProgram,
                                F28_CMD_PROGRAM);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdWriteBuffer,
                                F28_CMD_WRITE_BUFFER);
            break;
        case F29_8BIT_TYPE:
        case F29_16BIT_TYPE:
        case F29_32BIT_TYPE:
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdReset,
                                F29_CMD_RESET);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdUnlock1,
                                F29_CMD_UNLOCK1);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdUnlock2,
                                F29_CMD_UNLOCK2);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdProgramBuffer,
                                F29_CMD_PROGRAM_BUFFER);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdBlockErase,
                                F29_CMD_BLOCK_ERASE);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdConfirm,
                                F29_CMD_ERASE_CONFIRM);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdProgram,
                                F29_CMD_PROGRAM);
            f2xRegionCmdCreate ((F2X_RID)pRDesc, pRDesc->cmdWriteBuffer,
                                F29_CMD_WRITE_BUFFER);

            switch (typeWithMask)
                {
                case F29_8BIT_TYPE:
                    shift = 1 >> chipWidth;  /* i.e., 0 */
                    break;
                case F29_16BIT_TYPE:
                    shift = 2 >> chipWidth;
                    break;
                case F29_32BIT_TYPE:
                default:
                    shift = 4 >> chipWidth;
                    break;
                }

            pRDesc->offReset = (F29_OFF_RESET << shift) * regionWidth;
            pRDesc->offUnlock1 = (F29_OFF_UNLOCK1 << shift) * regionWidth;
            pRDesc->offUnlock2 = (F29_OFF_UNLOCK2 << shift) * regionWidth;
            pRDesc->offBlockErase = (F29_OFF_BLOCK_ERASE << shift) * 
                                    regionWidth;
            pRDesc->offProgram = (F29_OFF_PROGRAM << shift) * regionWidth;
            
            break;
        default:
            break;
        }

    /* set up the block cache */

    pRDesc->pCache = pCache;
    pRDesc->cacheRegionOffset = NONE;    /* invalid/empty */
    pRDesc->cacheIsDirty = FALSE;

    /* record the programming and block erase methods */

    if ((pRDesc->type & F2X_TYPE_MASK) == F28_TYPE)
        {
        if (pRDesc->regionWBSize == 0)
            pRDesc->programRtn = f28RegionProgram;
        else
            pRDesc->programRtn = f28RegionWBProgram;
        pRDesc->blockEraseRtn = f28RegionBlockErase;
        }
    else
        {
        if (pRDesc->regionWBSize == 0)
            pRDesc->programRtn = f29RegionProgram;
        else
            pRDesc->programRtn = f29RegionWBProgram;
        pRDesc->blockEraseRtn = f29RegionBlockErase;
        }

    /* initialize or copy semaphores */

    if (dependRid == (F2X_RID)NULL)
        {
        /* initialize region-level semaphore */

        semMInit (&pRDesc->semaphore, SEM_DELETE_SAFE);
     
        /* point to it */
        
        pRDesc->semId = (SEM_ID)&pRDesc->semaphore;
        }
    else
        {
        /* share semaphore with dependent region */
        
        pRDesc->semId = ((F2X_RDESC *)dependRid)->semId;
        }

    /* initialize state of region */

    switch (typeWithMask)
        {
        case F28_TYPE:
            f2xRegionWidthWrite ((F2X_RID)pRDesc, pRDesc->cmdClearStatus,
                                 0, FALSE);
            f2xRegionWidthWrite ((F2X_RID)pRDesc, pRDesc->cmdReadArray,
                                 0, FALSE);
            break;
        case F29_8BIT_TYPE:
        case F29_16BIT_TYPE:
        case F29_32BIT_TYPE:
            f2xRegionWidthWrite ((F2X_RID)pRDesc, pRDesc->cmdReset,
                                 pRDesc->offReset, FALSE);
            break;
        default:
            break;
        }

    return ((F2X_RID)pRDesc);
    }

/* group-level routines ----------------------------------------------------- */

/*******************************************************************************
*
* f2xGroupRegionInfoGet - get region index and region offset
*
* Given the number of bytes and offset into a flash group, this
* routine returns the region index in <*pRegionIndex> and region
* offset in <*pRegionOffset>.
*
* RETURNS: OK, or ERROR if <nbytes> and <offset> are out of range.
*/

LOCAL STATUS f2xGroupRegionInfoGet
    (
    F2X_GID id,
    int     nbytes,
    int     offset,
    int *   pRegionIndex,
    int *   pRegionOffset
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    int         regionIndex;

    /* check bounds */

    if ((nbytes < 0) || (offset < 0))
        return (ERROR);
 
    if ((nbytes + offset) > pGDesc->groupSize)
        return (ERROR);

    /* find the starting region */

    for (regionIndex = 0; regionIndex < pGDesc->ridArrayCount; regionIndex++)
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

        if (offset < f2xRegionSize (pRDesc))
            {
            /* we have our starting region and offset */
            break;
            }

        offset -= f2xRegionSize ((F2X_RID)pRDesc);
        }

    *pRegionIndex = regionIndex;
    *pRegionOffset = offset;

    return (OK);
    }

/*******************************************************************************
*
* f2xGroupAct - perform action on flash group
*
* This routine calls the routine specified by <routine> to
* program, set or get flash at any offset and any number
* of bytes within the group.
*
* RETURNS: OK, or ERROR if copy failed.
*/

LOCAL STATUS f2xGroupAct
    (
    F2X_GID id,        /* group ID */
    char *  pBuf,      /* source or destination buffer */
    int     nbytes,    /* number of bytes to copy */
    int     offset,    /* byte offset into flash group */
    FUNCPTR routine    /* ptr to f2xRegionProgram/Set/Get() */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    STATUS      status;
    int         regionIndex;
    int         regionOffset;
    int         bytesToAct;

    status = f2xGroupRegionInfoGet (id, nbytes, offset, &regionIndex,
                                    &regionOffset);

    if (status != OK)
        return (ERROR);

    semTake (pGDesc->semId, WAIT_FOREVER);

    while (nbytes > 0)
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

        bytesToAct = min(nbytes, f2xRegionSize (pRDesc) - regionOffset);

        status = (routine)((F2X_RID)pRDesc, pBuf, bytesToAct, regionOffset);

        if (status != OK)
            {
            status = ERROR;
            goto f2xGroupActExit;
            }

        regionIndex += 1;
        pBuf += bytesToAct;
        nbytes -= bytesToAct;
        regionOffset = 0;
        }

f2xGroupActExit:
    semGive (pGDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xGroupMap - TODO
*
* RETURNS: Memory mapped address.
*/

char * f2xGroupMap
    (
    F2X_GID id,       /* group ID */
    int     offset    /* byte offset into group */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    STATUS      status;
    int         regionIndex;
    int         regionOffset;
    char        ch;
    
    status = f2xGroupRegionInfoGet (id, 1, offset, &regionIndex, &regionOffset);

    if (status != OK)
        return ((char *)NULL);

    pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

    /* turn the page if necessary */
    
    f2xRegionGet ((F2X_RID)pRDesc, &ch, 0, regionOffset);

    return (pRDesc->baseAdrs + regionOffset);
    }

/*******************************************************************************
*
* f2xGroupProgram - program flash group
*
* This routine programs erased flash at any offset and any number
* of bytes within the group.
*
* RETURNS: OK, or ERROR if programming failed.
*/

STATUS f2xGroupProgram
    (
    F2X_GID id,        /* group ID */
    char *  pSrc,      /* source buffer */
    int     nbytes,    /* number of bytes to program */
    int     offset     /* byte offset into flash group */
    )
    {
    STATUS      status;

    status = f2xGroupAct (id, pSrc, nbytes, offset, f2xRegionProgram);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* f2xGroupBlockSize - get flash group block size
* 
* This routine returns the size of a flash group block in bytes.
*
* The flash group block size is the largest region block size in
* the group if and only if its boundaries fall on region block 
* boundaries, and the group size is an integer multiple of it,
* else the flash group block size is considered "dependent on
* region" and is 0.
*
* RETURNS: Size of flash group block in bytes, or 0 if flash
* group block size depends on flash region.
*/

int f2xGroupBlockSize
    (
    F2X_GID id    /* group ID */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;

    return (pGDesc->pseudoBlockSize);
    }

/*******************************************************************************
*
* f2xGroupBlockErase - erase a block of flash group
*
* This routine erases one block of the flash group.  If
* f2xGroupBlockSize() is zero for the group, the size of the block
* erased depends on the region specified by <offset>.
*
* RETURNS: OK, or ERROR if erase failed.
*/

STATUS f2xGroupBlockErase
    (
    F2X_GID id,       /* group ID */
    int     offset    /* byte offset into group */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    STATUS      status;
    int         regionIndex;
    int         regionOffset;
    int         bytesToErase;

    status = f2xGroupRegionInfoGet (id, 1, offset, &regionIndex, &regionOffset);

    if (status != OK)
        return (ERROR);

    semTake (pGDesc->semId, WAIT_FOREVER);

    if (pGDesc->pseudoBlockSize > 0)
        {
        offset = F2X_ALIGN (offset, pGDesc->pseudoBlockSize);

        bytesToErase = pGDesc->pseudoBlockSize;

        while (bytesToErase > 0)
            {
            f2xGroupRegionInfoGet (id, 1, offset, &regionIndex, &regionOffset);

            pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

            status = f2xRegionBlockErase ((F2X_RID)pRDesc, regionOffset);

            if (status != OK)
                {
                status = ERROR;
                break;
                }

            offset += f2xRegionBlockSize ((F2X_RID)pRDesc);
            bytesToErase -= f2xRegionBlockSize ((F2X_RID)pRDesc);
            }
        }
    else
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

        regionOffset = F2X_ALIGN (regionOffset,
                                   f2xRegionBlockSize ((F2X_RID)pRDesc));

        status = f2xRegionBlockErase ((F2X_RID)pRDesc, regionOffset);

        if (status != OK)
            status = ERROR;
        }

    semGive (pGDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xGroupCachedSet - write to flash group with cache
*
* This routine copies a specified buffer into a flash group with
* the benefit of a copy-back cache.
*
* This function improves overall performance compared to f2xGroupSet()
* when writing small amounts (i.e., much less than the region block size)
* in a sequential manner while overwriting existing flash data.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/
 
STATUS f2xGroupCachedSet
    (
    F2X_GID id,        /* group ID */
    char *  pSrc,      /* source buffer */
    int     nbytes,    /* number of bytes to copy */
    int     offset     /* byte offset into group */
    )
    {
    STATUS      status;

    status = f2xGroupAct (id, pSrc, nbytes, offset, f2xRegionCachedSet);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* f2xGroupSet - write to flash group
*
* This routine copies a specified buffer into a flash group.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/
 
STATUS f2xGroupSet
    (
    F2X_GID id,        /* group ID */
    char *  pSrc,      /* source buffer */
    int     nbytes,    /* number of bytes to copy */
    int     offset     /* byte offset into group */
    )
    {
    STATUS      status;

    status = f2xGroupAct (id, pSrc, nbytes, offset, f2xRegionSet);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* f2xGroupGet - get the contents of flash group
*
* This routine copies the contents of a flash group into a
* specified buffer.
*
* RETURNS: OK, or ERROR parameters are invalid.
*/
 
STATUS f2xGroupGet
    (
    F2X_GID id,        /* group ID */
    char *  pDst,      /* destination buffer */
    int     nbytes,    /* number of bytes to copy */
    int     offset     /* byte offset into group */
    )
    {
    STATUS      status;

    status = f2xGroupAct (id, pDst, nbytes, offset, f2xRegionGet);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* f2xGroupErase - erase flash group
*
* This routine erases a flash group.
*
* RETURNS: OK, or ERROR if erase failed.
*/
 
STATUS f2xGroupErase
    (
    F2X_GID id    /* group ID */
    )
    {
    STATUS      status = OK;
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    int         regionIndex;

    semTake (pGDesc->semId, WAIT_FOREVER);

    for (regionIndex = 0; regionIndex < pGDesc->ridArrayCount; regionIndex++)
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

        status = f2xRegionErase ((F2X_RID)pRDesc);

        if (status != OK)
            {
            status = ERROR;
            goto f2xGroupEraseExit;
            }
        }

f2xGroupEraseExit:
    semGive (pGDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xGroupCacheFlush - flush caches in a flash group
*
* This routine flushes the caches in a flash group.
*
* RETURNS: OK, or ERROR if cache flush failed.
*/
 
STATUS f2xGroupCacheFlush
    (
    F2X_GID id    /* group ID */
    )
    {
    STATUS      status = OK;
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;
    F2X_RDESC * pRDesc;
    int         regionIndex;

    semTake (pGDesc->semId, WAIT_FOREVER);

    for (regionIndex = 0; regionIndex < pGDesc->ridArrayCount; regionIndex++)
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

        status = f2xRegionCacheFlush ((F2X_RID)pRDesc);

        if (status != OK)
            {
            status = ERROR;
            goto f2xGroupCacheFlushExit;
            }
        }

f2xGroupCacheFlushExit:
    semGive (pGDesc->semId);

    return (status);
    }

/*******************************************************************************
*
* f2xGroupSize - get the size of flash group
*
* This routine returns the size of the flash group in bytes.
*
* RETURNS: Size of flash in bytes.
*/
 
int f2xGroupSize
    (
    F2X_GID id    /* group ID */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)id;

    return (pGDesc->groupSize);
    }

/******************************************************************************
*
* f2xGroupFileSet - write a file to flash group
*
* This routine writes a file to a flash group. This function is intended
* to be used at the command line. It therefore provides user feedback
* to stdout.
*
* RETURNS: OK, or ERROR if there was an issue opening the file or
* programming the flash, or a lack of resources.
*/

STATUS f2xGroupFileSet
    (
    F2X_GID id,          /* group ID */
    char *  fileName,    /* name of file */
    int     offset       /* byte offset into group */
    )
    {
    char * funcName = "f2xGroupFileSet";
    char * argUsage = "<id>, ""<filename>"", [<offset>]";
    STATUS status = ERROR;
    int    nbytes;
    char * pBuf;
    int    fd;
    int    i;

#ifdef INCLUDE_F2X_BOOTROM_ROUTINES
    if (id == f2xBootromGid)
        {
        /* customize stdout for f2xBootromSet() */

        funcName = "f2xBootromSet";
        argUsage = """<filename>"", [<offset>]";
        }
#endif /* INCLUDE_F2X_BOOTROM_ROUTINES */

    /* take care/time to ensure the user input is valid */

    for (i = 0; i < NELEMENTS(f2xGDescArray); i++)
        {
        if ((id == (F2X_GID)&f2xGDescArray[i]) && (f2xGroupSize(id) > 0))
            break;
        }

    if ((i >= NELEMENTS(f2xGDescArray)) || (fileName == NULL) ||
        (offset < 0) || (offset >= f2xGroupSize(id)))
        {
        printf ("usage: %s %s\n", funcName, argUsage);
        goto f2xGroupFileSetExit0;
        }

    fd = open (fileName, O_RDONLY, 0);

    if (fd == ERROR)
        {
        printf ("%s: cannot open %s\n", funcName, fileName);
        goto f2xGroupFileSetExit0;
        }

    /* malloc and request (read) one more byte than the available flash
     * space to to determine if the file is too big
     */

    pBuf = malloc (f2xGroupSize(id) - offset + 1);

    if (pBuf == NULL)
        {
        printf ("%s: out of memory\n", funcName);
        goto f2xGroupFileSetExit1;
        }

    nbytes = read (fd, pBuf, f2xGroupSize(id) - offset + 1);

    if (nbytes < 0)
        {
        printf ("%s: error reading %s\n", funcName, fileName);
        goto f2xGroupFileSetExit2;
        }

    if (nbytes > (f2xGroupSize(id) - offset))
        {
        printf ("%s: %s is too large\n", funcName, fileName);
        goto f2xGroupFileSetExit2;
        }

    printf ("Programming the flash... ");

    status = f2xGroupSet(id, pBuf, nbytes, offset);

    if (status == OK)
        printf ("done\n");
    else
        printf ("PROGRAMMING ERROR\n");

f2xGroupFileSetExit2:
    free (pBuf);
f2xGroupFileSetExit1:
    close (fd);
f2xGroupFileSetExit0:

    return (status);
    }

/*******************************************************************************
*
* f2xGroupCreate - create a flash group
*
* This routine creates a flash group from the flash region
* specified by <rid>.
*
* RETURNS: An ID for the group, or NULL if F2X_MAX_GROUP groups
* already exist.
*/

F2X_GID f2xGroupCreate
    (
    F2X_RID rid    /* region ID */
    )
    {
    F2X_RDESC * pRDesc = (F2X_RDESC *)rid;
    F2X_GDESC * pGDesc;

    /* make sure we have enough descriptors */

    if ((unsigned)f2xGDescArrayCount >= NELEMENTS(f2xGDescArray))
        return ((F2X_GID)NULL);

    /* get next descriptor */

    pGDesc = &f2xGDescArray [f2xGDescArrayCount];

    /* increment array element count */

    f2xGDescArrayCount++;

    /* initialize group descriptor */

    pGDesc->ridArray[0] = rid;
    pGDesc->ridArrayCount = 1;
    pGDesc->groupSize = f2xRegionSize ((F2X_RID)pRDesc);
    pGDesc->pseudoBlockSize = f2xRegionBlockSize ((F2X_RID)pRDesc);

    /* initialize group-level semaphore */

    semMInit (&pGDesc->semaphore, SEM_DELETE_SAFE);
   
    /* point to it */
       
    pGDesc->semId = (SEM_ID)&pGDesc->semaphore;

    return (pGDesc);
    }

/*******************************************************************************
*
* f2xGroupAdd - add a region to a flash group
*
* This routine adds a flash region logically after all of the
* existing regions in a flash group.
*
* RETURNS: OK, or ERROR if F2X_MAX_REGIONS regions already exist
* in the group.
*/

STATUS f2xGroupAdd
    (
    F2X_GID gid,    /* existing group ID */
    F2X_RID rid     /* region ID to add */
    )
    {
    F2X_GDESC * pGDesc = (F2X_GDESC *)gid;
    F2X_RDESC * pRDesc = (F2X_RDESC *)rid;
    int         regionOffset = 0;
    int         regionIndex;
    int         pseudoBlockSize;
    int         offset;

    /* make sure we have enough region IDs */

    if ((unsigned)pGDesc->ridArrayCount >= NELEMENTS(pGDesc->ridArray))
        return (ERROR);

    /* update group descriptor */

    pGDesc->ridArray[pGDesc->ridArrayCount] = rid;
    pGDesc->ridArrayCount++;
    pGDesc->groupSize += f2xRegionSize ((F2X_RID)pRDesc);

    /* Determine the flash group block size.  The flash group block size is
     * the largest region block size in the group if and only if its
     * boundaries fall on region block boundaries, and the group size is
     * an integer multiple of it, else the flash group block size is
     * considered "dependent on region" and is 0.
     */

    /* find the largest region block size - the potential group block size */

    pseudoBlockSize = 0;
    for (regionIndex = 0; regionIndex < pGDesc->ridArrayCount; regionIndex++)
        {
        pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];
        pseudoBlockSize = max(pseudoBlockSize,
                              f2xRegionBlockSize ((F2X_RID)pRDesc));
        }

    /* test that its and integer multiple of the group size */

    if ((pGDesc->groupSize % pseudoBlockSize) == 0)
        {
        /* test that pseudo block boundaries fall on region block boundaries */

        for (offset = 0; offset < pGDesc->groupSize; offset += pseudoBlockSize)
            {
            f2xGroupRegionInfoGet ((F2X_GID)pGDesc, 1, offset,
                                   &regionIndex, &regionOffset);

            pRDesc = (F2X_RDESC *)pGDesc->ridArray[regionIndex];

            if ((regionOffset % f2xRegionBlockSize ((F2X_RID)pRDesc)) != 0)
                {
                pseudoBlockSize = 0;
                break;
                }
            }
        }
    else
        pseudoBlockSize = 0;
 
    pGDesc->pseudoBlockSize = pseudoBlockSize;

    return (OK);
    }

/* optional sysFlashXxx() routines ------------------------------------------ */

#ifdef INCLUDE_F2X_SYS_FLASH_ROUTINES

/*******************************************************************************
*
* sysFlashSet - write to flash
*
* This routine copies a specified buffer into the sysFlashXxx()
* flash group.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/
 
STATUS sysFlashSet
    (
    char * pSrc,      /* source buffer */
    int    nbytes,    /* number of bytes to copy */
    int    offset     /* byte offset into flash (group) */
    )
    {
    STATUS status;

    if (f2xSysFlashGid == (F2X_GID)NULL)
        return (ERROR);

    status = f2xGroupSet (f2xSysFlashGid, pSrc, nbytes, offset);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* sysFlashGet - get the contents of flash
*
* This routine copies the contents of the sysFlashXxx() flash group
* into a specified buffer.
*
* RETURNS: OK, or ERROR parameters are invalid.
*/
 
STATUS sysFlashGet
    (
    char * pDst,      /* destination buffer */
    int    nbytes,    /* number of bytes to copy */
    int    offset     /* byte offset into flash (group) */
    )
    {
    STATUS status;

    if (f2xSysFlashGid == (F2X_GID)NULL)
        return (ERROR);

    status = f2xGroupGet (f2xSysFlashGid, pDst, nbytes, offset);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* sysFlashErase - erase flash
*
* This routine erases the sysFlashXxx() flash group.
*
* RETURNS: OK, or ERROR if erase failed.
*/
 
STATUS sysFlashErase (void)

    {
    STATUS status;

    if (f2xSysFlashGid == (F2X_GID)NULL)
        return (ERROR);

    status = f2xGroupErase (f2xSysFlashGid);

    if (status != OK)
        status = ERROR;

    return (status);
    }

/*******************************************************************************
*
* sysFlashSize - get the size of flash
*
* This routine returns the size of the sysFlashXxx() flash group in bytes.
*
* RETURNS: Size of flash in bytes.
*/
 
int sysFlashSize (void)
    {
    if (f2xSysFlashGid == (F2X_GID)NULL)
        return (ERROR);

    return (f2xGroupSize (f2xSysFlashGid));
    }

/****************************************************************************** *
*
* sysFlashAdd - add a region to the sysFlashXxx() group
*
* This routine adds a flash region after all of the existing
* regions in a flash group.
*
* RETURNS: OK, or ERROR if F2X_MAX_REGIONS regions already exist
* in the sysFlashXxx() group.
*/

STATUS sysFlashAdd
    (
    F2X_RID rid    /* region ID to add */
    )
    {
    STATUS status;

    if (f2xSysFlashGid == (F2X_GID)NULL)
        {
        f2xSysFlashGid = f2xGroupCreate (rid);

        if (f2xSysFlashGid == (F2X_GID)NULL)
            return (ERROR);
        }
    else
        {
        status = f2xGroupAdd (f2xSysFlashGid, rid);

        if (status != OK)
            return (ERROR);
        }

    return (OK);
    }

#endif /* INCLUDE_F2X_SYS_FLASH_ROUTINES */

/* optional sysNvRamXxx() routines ------------------------------------------ */

#ifdef INCLUDE_F2X_SYS_NV_RAM_ROUTINES

/*******************************************************************************
*
* sysNvRamSet - write to flash
*
* This routine copies a specified buffer into the sysNvRamXxx()
* flash group.
*
* RETURNS: OK, or ERROR parameters are invalid or set failed.
*/
 
STATUS sysNvRamSet
    (
    char * pSrc,      /* source buffer */
    int    nbytes,    /* number of bytes to copy */
    int    offset     /* byte offset into flash (group) */
    )
    {
    STATUS status;

    if (f2xSysNvRamGid == (F2X_GID)NULL)
        return (ERROR);

    if ((nbytes + offset) > NV_RAM_SIZE)
        return (ERROR);

    offset += F2X_SYS_NV_RAM_OFFSET;

    status = f2xGroupSet (f2xSysNvRamGid, pSrc, nbytes, offset);

    if (status != OK)
        return (ERROR);

    return (status);
    }

/*******************************************************************************
*
* sysNvRamGet - get the contents of flash
*
* This routine copies the contents of the sysNvRamXxx() flash group
* into a specified buffer.
*
* RETURNS: OK, or ERROR parameters are invalid.
*/
 
STATUS sysNvRamGet
    (
    char * pDst,      /* destination buffer */
    int    nbytes,    /* number of bytes to copy */
    int    offset     /* byte offset into flash (group) */
    )
    {
    STATUS status;

    if (f2xSysNvRamGid == (F2X_GID)NULL)
        return (ERROR);

    if ((nbytes + offset) > NV_RAM_SIZE)
        return (ERROR);

    offset += F2X_SYS_NV_RAM_OFFSET;

    status = f2xGroupGet (f2xSysNvRamGid, pDst, nbytes, offset);

    if (status != OK)
        return (ERROR);

    pDst[nbytes] = EOS;

    return (OK);
    }

/******************************************************************************
*
* sysNvRamAdd - add a region to the sysNvRamXxx() group
*
* This routine adds a flash region after all of the existing
* regions in a flash group.
*
* RETURNS: OK, or ERROR if F2X_MAX_REGIONS regions already exist
* in the sysNvRamXxx() group.
*/

STATUS sysNvRamAdd
    (
    F2X_RID rid    /* region ID to add */
    )
    {
    STATUS status;

    if (f2xSysNvRamGid == (F2X_GID)NULL)
        {
        f2xSysNvRamGid = f2xGroupCreate (rid);

        if (f2xSysNvRamGid == (F2X_GID)NULL)
            return (ERROR);
        }
    else
        {
        status = f2xGroupAdd (f2xSysNvRamGid, rid);

        if (status != OK)
            return (ERROR);
        }

    return (OK);
    }

#endif /* INCLUDE_F2X_SYS_NV_RAM_ROUTINES */

/* optional f2xBootromXxx() routines ---------------------------------------- */

#ifdef INCLUDE_F2X_BOOTROM_ROUTINES

/******************************************************************************
*
* f2xBootromSet - write a file to flash
*
* This routine writes a binary file to the boot location in flash.
*
* WARNING!!!
* If this function is improperly implemented or you create a bad bootrom
* image, you could render your target useless.  Only use this routine in
* lab environments, and only if you have a backup JTAG programmer or
* equivalent.
*
* INTERNAL
* BSP best practices dictates that ROM_BASE_ADRS is the address where
* the bootrom binary is copied (not necessarily the base of flash) and
* ROM_SIZE is the size allotted to the bootrom binary starting from
* ROM_BASE_ADRS (not necessarily the size of flash).  If you follow this
* rule, and f2xBootromGid offset 0 corresponds to ROM_BASE_ADRS, this
* routine should work correctly.
*
* RETURNS: OK, or ERROR if there was an issue opening the file or
* programming the flash, or a lack of resources.
*/

STATUS f2xBootromSet
    (
    char * fileName,    /* name of binary image */
    int    offset       /* byte offset into bootrom group */
    )
    {
    STATUS status;

    status = f2xGroupFileSet (f2xBootromGid, fileName, offset);

    return (status);
    }

/******************************************************************************
*
* f2xBootromAdd - add a region to the f2xBootromXxx() group
*
* This routine adds a flash region after all of the existing
* regions in a flash group.
*
* RETURNS: OK, or ERROR if F2X_MAX_REGIONS regions already exist
* in the f2xBootromXxx() group.
*/

STATUS f2xBootromAdd
    (
    F2X_RID rid    /* region ID to add */
    )
    {
    STATUS status;

    if (f2xBootromGid == (F2X_GID)NULL)
        {
        f2xBootromGid = f2xGroupCreate (rid);

        if (f2xBootromGid == (F2X_GID)NULL)
            return (ERROR);
        }
    else
        {
        status = f2xGroupAdd (f2xBootromGid, rid);

        if (status != OK)
            return (ERROR);
        }

    return (OK);
    }

#endif /* INCLUDE_F2X_BOOTROM_ROUTINES */

/* optional f2xBlkDevXxx() routines ----------------------------------------- */

#ifdef INCLUDE_F2X_BLK_DEV_ROUTINES

/*******************************************************************************
*
* f2xBlkRd - read one or more BLK_DEV blocks
*
* This routine reads one or more blocks from the specified volume, starting
* with the specified BLK_DEV block number.
*
* RETURNS: OK, or ERROR if arguments are invalid.
*/

LOCAL STATUS f2xBlkRd
    (
    F2X_BLK_DEV * pF2xBlkDev,    /* device desriptor */
    uint_t        startBlk,      /* starting block number */
    uint_t        numBlks,       /* number of blocks to copy */
    char *        pDst           /* destination buffer */
    )
    { 
    STATUS status;
    int    bytesPerBlk = (int)pF2xBlkDev->bd.bd_bytesPerBlk;

    status = f2xGroupGet (pF2xBlkDev->id, pDst, bytesPerBlk * numBlks,
                          bytesPerBlk * startBlk);
    return (status);
    }

/*******************************************************************************
*
* f2xBlkWrt - write one or more BLK_DEV blocks
*
* This routine writes one or more blocks from the specified volume, starting
* with the specified BLK_DEV block number.
*
* RETURNS: OK, or ERROR if arguments are invalid.
*/

LOCAL STATUS f2xBlkWrt
    (
    F2X_BLK_DEV * pF2xBlkDev,    /* device desriptor */
    uint_t        startBlk,      /* starting block number */
    uint_t        numBlks,       /* number of blocks to copy */
    char *        pSrc           /* source buffer */
    )
    { 
    STATUS status;
    int    bytesPerBlk = (int)pF2xBlkDev->bd.bd_bytesPerBlk;

    status = f2xGroupCachedSet (pF2xBlkDev->id, pSrc, bytesPerBlk * numBlks,
                                bytesPerBlk * startBlk);
    return (status);
    }

/*******************************************************************************
*
* f2xBlkIoctl - BLK_DEV ioctl
*
* This routine flushes the region block caches when commaned with FIOSYNC.
*
* RETURNS: OK, or ENOTSUP if command isn't supported.
*/

LOCAL int f2xBlkIoctl
    (
    F2X_BLK_DEV * pF2xBlkDev,    /* device desriptor */
    int           cmd,           /* command  */
    void *        arg            /* argument */
    )
    { 
    int status;

    if (cmd == FIOSYNC)
        status = f2xGroupCacheFlush (pF2xBlkDev->id);
    else
        status = ENOTSUP;

    return (status);
    }

/*******************************************************************************
*
* f2xBlkDevCreate - create an f2xFlashMem block device
*
* This routine creates a simple block device using the f2xFlashMem API.
*
* RETURNS: A pointer to a block device structure (BLK_DEV) or NULL if out
* of memory or if arguments are invalid.
*/

BLK_DEV * f2xBlkDevCreate
    (
    F2X_GID id,            /* existing group ID */
    int     bytesPerBlk    /* desired block device block size, or 0 */
    )
    {
    F2X_BLK_DEV * pF2xBlkDev;
    BLK_DEV * pBlkDev;

    if ((id == NULL) || (bytesPerBlk < 0))
        return (NULL);

    if (bytesPerBlk == 0)
        bytesPerBlk = 1024;    /* optimized for copy() */

    pF2xBlkDev = (F2X_BLK_DEV *) malloc (sizeof (F2X_BLK_DEV));

    if (pF2xBlkDev == NULL)
        return (NULL);

    pBlkDev = &pF2xBlkDev->bd;

    pBlkDev->bd_blkRd = f2xBlkRd;
    pBlkDev->bd_blkWrt = f2xBlkWrt;
    pBlkDev->bd_ioctl = f2xBlkIoctl;
    pBlkDev->bd_reset = NULL;
    pBlkDev->bd_statusChk = NULL;
    pBlkDev->bd_removable = FALSE;
    pBlkDev->bd_nBlocks = f2xGroupSize(id) / bytesPerBlk;
    pBlkDev->bd_bytesPerBlk = bytesPerBlk;
    pBlkDev->bd_blksPerTrack = bytesPerBlk;
    pBlkDev->bd_nHeads = 1;
    pBlkDev->bd_retry = 1;
    pBlkDev->bd_mode = O_RDWR;
    pBlkDev->bd_readyChanged = TRUE;

    pF2xBlkDev->id = id;

    return ((BLK_DEV *)pF2xBlkDev);
    }

#endif /* INCLUDE_F2X_BLK_DEV_ROUTINES */

/* optional f2xCfiXxx() routines ----------------------------------------- */

#ifdef INCLUDE_F2X_CFI_ROUTINES

/* locals */

LOCAL char     f2xCfiPattern11[3] = F2X_CFI_PATTERN_1Q;
LOCAL char     f2xCfiPattern11_16[6] = F2X_CFI_PATTERN_2Q;
LOCAL char     f2xCfiPattern21[6] = F2X_CFI_PATTERN_2Q;
LOCAL char     f2xCfiPattern21_16[12] = F2X_CFI_PATTERN_4Q;
LOCAL short    f2xCfiPattern22[3] = F2X_CFI_PATTERN_1Q;
LOCAL char     f2xCfiPattern41[12] = F2X_CFI_PATTERN_4Q;
LOCAL char     f2xCfiPattern41_16[24] = F2X_CFI_PATTERN_8Q;
LOCAL short    f2xCfiPattern42[6] = F2X_CFI_PATTERN_2Q;
LOCAL char     f2xCfiPattern81[24] = F2X_CFI_PATTERN_8Q;
LOCAL char     f2xCfiPattern81_16[48] = F2X_CFI_PATTERN_16Q;
LOCAL short    f2xCfiPattern82[12] = F2X_CFI_PATTERN_4Q;

LOCAL char     f28CfiCmdReadArray[F2X_MAX_REGION_WIDTH] = 
                   F2X_CFI_CMD(F28_CMD_READ_ARRAY);
LOCAL char     f28CfiCmdBlockLockSetup[F2X_MAX_REGION_WIDTH] = 
                   F2X_CFI_CMD(F28_CMD_BLK_LOCK_SETUP);
LOCAL char     f28CfiCmdBlockLockClear[F2X_MAX_REGION_WIDTH] = 
                   F2X_CFI_CMD(F28_CMD_BLK_LOCK_CLEAR);
LOCAL char     f29CfiCmdReset[F2X_MAX_REGION_WIDTH] =
                   F2X_CFI_CMD(F29_CMD_RESET);
LOCAL char     f29CfiCmdUnlock1[F2X_MAX_REGION_WIDTH] =
                   F2X_CFI_CMD(F29_CMD_UNLOCK1);
LOCAL char     f29CfiCmdUnlock2[F2X_MAX_REGION_WIDTH] =
                   F2X_CFI_CMD(F29_CMD_UNLOCK2);
LOCAL char     f2xCfiCmdCfiQuery[F2X_MAX_REGION_WIDTH] =
                   F2X_CFI_CMD(F2X_CMD_CFI_QUERY);
LOCAL char     f2xCfiCmdReadDeviceId[F2X_MAX_REGION_WIDTH] =
                   F2X_CFI_CMD(F2X_CMD_READ_DEVICE_ID);

LOCAL LIST     f2xCfiRRecList;
LOCAL char     f2xCfiFlashData[512];
LOCAL F2X_RREC f2xCfiRRecArray[F2X_MAX_REGIONS * 2];
LOCAL int      f2xCfiRRecArrayCount;

/*******************************************************************************
*
* f2xCfiWidthCopy - copy flash region
*
* This routine copies data to or from flash in one <width>-sized
* transfer.
*
* RETURNS: N/A.
*/

LOCAL void f2xCfiWidthCopy
    (
    char * pSrc,    /* source address */
    char * pDst,    /* destination address */
    int    width    /* width of single transfer */
    )
    {
    switch (width)
        {
        case 1:
            *(volatile UINT8 *)pDst = *(UINT8 *)pSrc;
            break;
        case 2:
            *(volatile UINT16 *)pDst = *(UINT16 *)pSrc;
            break;
        case 4:
            *(volatile UINT32 *)pDst = *(UINT32 *)pSrc;
            break;
        case 8:
            *(volatile UINT64 *)pDst = *(UINT64 *)pSrc;
            break;
        default:
            break;
        }

    CACHE_PIPE_FLUSH();
    }

/*******************************************************************************
*
* f2xCfiRead - read CFI data
*
* This routine reads CFI data specified by the arguments.
*
* RETURNS: Value of CFI data.
*/

LOCAL UINT32 f2xCfiRead
    (
    char * baseAdrs,     /* base address of flash */
    int    chipWidth,    /* width of single flash part in bytes */
    int    shift,        /* shift factor for CFI data offset */
    int    offset,       /* base offset to CFI data */
    int    length        /* length of CFI data */
    )
    {
    UINT16  buf;    /* aligned buffer */
    UINT8 * pBuf = (UINT8 *)&buf;
    UINT32  val;

    f2xCfiWidthCopy (baseAdrs + (offset << shift), (char *)pBuf, chipWidth);

    if (chipWidth == 1)
        val = (UINT32)*pBuf;
    else
        val = (UINT32)*(UINT16 *)pBuf & 0xff;

    if (length == 1)
        return (val);

    f2xCfiWidthCopy (baseAdrs + ((offset + 1) << shift), (char *)pBuf,
                     chipWidth);

    if (chipWidth == 1)
        val |= (UINT32)*pBuf << 8;
    else
        val |= ((UINT32)*(UINT16 *)pBuf & 0xff) << 8;

    if (length == 2)
        return (val);

    f2xCfiWidthCopy (baseAdrs + ((offset + 2) << shift), (char *)pBuf,
                     chipWidth);

    if (chipWidth == 1)
        val |= (UINT32)*pBuf << 16;
    else
        val |= ((UINT32)*(UINT16 *)pBuf & 0xff) << 16;

    f2xCfiWidthCopy (baseAdrs + ((offset + 3) << shift), (char *)pBuf,
                     chipWidth);

    if (chipWidth == 1)
        val |= (UINT32)*pBuf << 24;
    else
        val |= ((UINT32)*(UINT16 *)pBuf & 0xff) << 24;

    return (val);
    }

/*******************************************************************************
*
* f2xCfiRRecSplit - split a region record
*
* This routine splits a region record at <offset> bytes.  This causes
* the region pointed to by <pRRec> to be reduced in size, and a new
* region record to be added to the ordered f2xCfiRRecList.
*
* RETURNS: OK, or ERROR if region could not be split.
*/

LOCAL STATUS f2xCfiRRecSplit
    (
    F2X_RREC * pRRec,     /* region record to split */
    int        offset,    /* offset of split */
    int        index,     /* greqArray[] index for working F2X_GREQ */
    BOOL       verbose    /* TRUE for verbose mode */
    )
    {
    F2X_RREC * pRRecNew;
    int        regionSize = offset - pRRec->offset;

    if ((regionSize % pRRec->blockSize) != 0)
        {
        F2X_PRINTF ("Invalid <greqArray[]> element at index %d. Not on block boundary.\n",
                    index);
        return (ERROR);
        }

    if (f2xCfiRRecArrayCount >= NELEMENTS(f2xCfiRRecArray))
        {
        F2X_PRINTF ("Resource issue, increase F2X_MAX_REGIONS.\n");
        return (ERROR);
        }

    /* split this region record into two in our ordered list */

    pRRecNew = &f2xCfiRRecArray[f2xCfiRRecArrayCount];
    f2xCfiRRecArrayCount++;
    pRRecNew->offset = offset;
    pRRecNew->regionSize = pRRec->regionSize - regionSize;
    pRRecNew->blockSize = pRRec->blockSize;
    pRRecNew->rid = NULL;
    lstInsert (&f2xCfiRRecList, (NODE *)pRRec, (NODE *)pRRecNew);

    pRRec->regionSize = regionSize;

    return (OK);
    }

/*******************************************************************************
*
* f2xCfiGroupsCreate - create flash groups
*
* This routine probes the flash to determine the quantity and 
* type of flash and then tries to establish flash groups using
* the user-defined <numGReq> and <greqArray[]>.  It is also used
* by f2xCfiSize() to determine the total size of the flash, and by
* f2xCfiShow() to display the common flash interface information.
*
* ARGUMENT DETAILS:
* <baseAdrs>:
* Base address of the flash.
*
* <busWidth>:
* Data bus width of the flash in bytes.  This is the equivalent to
* the number of interleaved chips multiplied by the byte width of
* each.  In cases where the bus width is unknown, the routine
* f2xCfiSize() may be called with ascending bus widths (i.e., 1, 2,
* 4, 8).  The first bus width to return a size is the correct width.
*
* <numGReq>:
* Number of valid elements in the greqArray[].  When 0, this routine
* only queries the flash.
*
* <greqArray[]>:
* Group request array.  Before calling this routine, the user
* populates an array of F2X_GREQ elements which specify the desired
* offset and groupSize for each flash group.  After a successful
* call, the gid of each F2X_GREQ element contains the F2X_GID of
* the flash group.
*
* Note that requested flash groups may overlap, but they must start
* and end on a block boundary and may not extend beyond the total
* size of flash.
*
* <pSize>:
* Storage location to write the total flash size.  When NULL,
* the total flash size is not written.
*
* <verbose>:
* TRUE for verbose mode.  Note that verbose mode must not be used
* before the I/O subsystem is initialized, e.g., during sysHwInit2().
*
* WARNING:
* To remove any dependency on the heap (or a large stack), this routine
* is not reentrant.  It also runs independent of any existing group/region
* program synchronization.  This routine should therefore only be run by
* one task at a time, and should not be run on flash which is already
* grouped.
*
* WARNING #2:
* For this routine to work, the hardware must be configured such
* that commands can be written to the flash device(s).  This means
* any hardware write protection must be disabled.
*
* WARNING #3:
* This routine was written to be as simple as possible while handling
* the majority of past, current, future and unknown flash, and flash
* designs.  It it known to return invalid results for certain kinds
* of flash.  Some examples are:
* .CS
* o Chips with multiple dies, such as the Intel 40F4400P30.
* o AMD-style top boot block chips which do not support the AMD/Spansion
    "Sector and WP# Pin Protection Scheme" extended information byte
    (P+0xf), such as the Am29LV160DT.
* .CE 
*
* RETURNS: OK, and a greqArray[] with valid group IDs, or ERROR if
* parameters are invalid.
*/ 
STATUS f2xCfiGroupsCreate
    (
    char *       baseAdrs,      /* base address of flash */
    int          busWidth,      /* flash bus width */
    int          numGReq,       /* number of requested groups */
    F2X_GREQ     greqArray[],   /* group request array */
    int *        pSize,         /* location to write total flash size or NULL */
    BOOL         verbose        /* TRUE for verbose mode */
    )
    {
    STATUS      status;
    F2X_RREC *  pRRec;
    F2X_RID     rid = NULL;
    F2X_GREQ *  pGReq;
    char *      blockAdrs;
    UINT16      commandSet;
    UINT16      intCode;
    UINT32      val32;
    UINT16      val16;
    UINT8       val8;
    BOOL        is16;
    BOOL        isReversed = FALSE;
    BOOL        unlockRegions = FALSE;
    char        pVal[2];
    int         chipBlockSize;
    int         chipBlockSize0;
    int         deviceSize;
    int         chipWidth;
    int         numBlocks;
    int         numRegions;
    int         totalSize;
    int         cfiFound;
    int         offset;
    int         shift;
    int         type;
    int         i; 
    int         j;

    /* check arguments */

    if (((busWidth == 1) || (busWidth == 2) ||
         (busWidth == 4) || (busWidth == 8)) == FALSE)
        {
        F2X_PRINTF ("Invalid <busWidth> %d.\n", busWidth);
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if (numGReq < 0)
        {
        F2X_PRINTF ("Invalid <numGReq> %d.\n", numGReq);
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if ((numGReq > 0) && (greqArray == NULL))
        {
        F2X_PRINTF ("Argument <greqArray[]> is NULL.\n");
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if (numGReq > (F2X_MAX_GROUPS - f2xGDescArrayCount))
        {
        F2X_PRINTF ("Not enough resources, increase F2X_MAX_GROUPS.\n");
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if (numGReq > 0)
        {
        for (i = 0; i < numGReq; i++)
            {
            if (greqArray[i].pGid == NULL)
                {
                F2X_PRINTF ("Argument <greqArray[%d].pGid> is NULL.\n", i);
                f2xCfiErrorLine = __LINE__;
                return (ERROR);
                }
            }

        /* initialize variables that keep track of regions */

        lstInit (&f2xCfiRRecList);
        f2xCfiRRecArrayCount = 0;
        }

    /* ensure flash is in read mode */

    f2xCfiWidthCopy (f29CfiCmdReset, baseAdrs, busWidth);
    f2xCfiWidthCopy (f28CfiCmdReadArray, baseAdrs, busWidth);

    /* read beginning of flash into memory for later comparison */

    bcopy (baseAdrs, f2xCfiFlashData, sizeof (f2xCfiFlashData));
    
    /* put the flash into query mode if we can */

    shift = ((busWidth == 1) ? 0 :
             (busWidth == 2) ? 1 :
             (busWidth == 4) ? 2 : 3 );
    
    offset = F29_OFF_CFI_QUERY << shift;

    f2xCfiWidthCopy (f2xCfiCmdCfiQuery, baseAdrs + offset, busWidth);

    if (bcmp (baseAdrs, f2xCfiFlashData, sizeof(f2xCfiFlashData)) == 0)
        {
        offset <<= 1;

        f2xCfiWidthCopy(f2xCfiCmdCfiQuery, baseAdrs + offset, busWidth);
        }

    /* check for query information */
    
    cfiFound = 0;
    chipWidth = 1;
    is16 = TRUE;

    switch (busWidth)
        {
        case 1:
            /* check for 8-bit flash */

            if (bcmp (f2xCfiPattern11, baseAdrs + 0x10,
                sizeof (f2xCfiPattern11)) == 0)
                {
                is16 = FALSE;
                cfiFound++;
                }

            /* check for 16-bit flash in 8-bit mode */

            if (bcmp (f2xCfiPattern11_16, baseAdrs + 0x20,
                sizeof (f2xCfiPattern11_16)) == 0)
                {
                shift++;
                cfiFound++;
                }
            break;
        case 2:
            /* check for 8-bit flash */

            if (bcmp (f2xCfiPattern21, baseAdrs + 0x20,
                sizeof (f2xCfiPattern21)) == 0)
                {
                is16 = FALSE;
                cfiFound++;
                }

            /* check for 16-bit flash in 8-bit mode */

            if (bcmp (f2xCfiPattern21_16, baseAdrs + 0x40,
                sizeof (f2xCfiPattern21_16)) == 0)
                {
                shift++;
                cfiFound++;
                }

            /* check for 16-bit flash in 16-bit mode */

            if (bcmp ((char *)f2xCfiPattern22, baseAdrs + 0x20,
                sizeof (f2xCfiPattern22)) == 0)
                {
                chipWidth = 2;
                cfiFound++;
                }
            break;
        case 4:
            /* check for 8-bit flash */

            if (bcmp (f2xCfiPattern41, baseAdrs + 0x40,
                sizeof (f2xCfiPattern41)) == 0)
                {
                is16 = FALSE;
                cfiFound++;
                }

            /* check for 16-bit flash in 8-bit mode */

            if (bcmp (f2xCfiPattern41_16, baseAdrs + 0x80,
                sizeof (f2xCfiPattern41_16)) == 0)
                {
                shift++;
                cfiFound++;
                }

            /* check for 16-bit flash in 16-bit mode */

            if (bcmp ((char *)f2xCfiPattern42, baseAdrs + 0x40,
                sizeof (f2xCfiPattern42)) == 0)
                {
                chipWidth = 2;
                cfiFound++;
                }
            break;
        case 8:
            /* check for 8-bit flash */

            if (bcmp (f2xCfiPattern81, baseAdrs + 0x80,
                sizeof (f2xCfiPattern81)) == 0)
                {
                is16 = FALSE;
                cfiFound++;
                }

            /* check for 16-bit flash in 8-bit mode */

            if (bcmp (f2xCfiPattern81_16, baseAdrs + 0x100,
                sizeof (f2xCfiPattern81_16)) == 0)
                {
                shift++;
                cfiFound++;
                }

            /* check for 16-bit flash in 16-bit mode */

            if (bcmp ((char *)f2xCfiPattern82, baseAdrs + 0x80,
                sizeof (f2xCfiPattern82)) == 0)
                {
                chipWidth = 2;
                cfiFound++;
                }
            break;
        default:
            F2X_PRINTF ("Programming error.\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            break;
        }
    
    if (cfiFound == 0)
        {
        F2X_PRINTF ("No CFI query identification string found.\n");
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if (cfiFound > 1)
        {
        F2X_PRINTF ("CFI query identification string is ambiguous.\n");
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    /* get command set */

    commandSet = (UINT16)f2xCfiRead (baseAdrs, chipWidth, shift, 0x13, 2);

    switch (commandSet)
        {
        case 1:
            type = F28_TYPE;
            break;
        case 2:
            type = is16 ? F29_16BIT_TYPE : F29_8BIT_TYPE;
            break;
        default:
            F2X_PRINTF ("Unknown primary command set 0x%04x.\n.", commandSet);
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            break;
        }

    /* check interface code description */

    intCode = (UINT16)f2xCfiRead (baseAdrs, chipWidth, shift, 0x28, 2);

    if (((intCode == 0) && is16) || ((intCode == 1) && (chipWidth != 2)))
        {
        F2X_PRINTF ("Inconsistent interface code description 0x%04x.\n",
                    intCode);
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    if (intCode > 2)
        {
        F2X_PRINTF ("Unsupported interface code description 0x%04x.\n",
                    intCode);
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    /* check to see if we can use write to buffer commands */

    val16 = (UINT16)f2xCfiRead (baseAdrs, chipWidth, shift, 0x2a, 2);

    if (val16 > 0)
        {
        /* limit the WB size to what we and the flash support */

        if ((chipWidth == 1) && (val16 > 8))
            type |= F2X_WB256_TYPE;
        else if (val16 > 16)
            type |= F2X_WB64KB_TYPE;
        else
            type |= F2X_WB_TYPE(val16);
        }
    
    /* extract manufacturer/device ID information */

    if ((type & F2X_TYPE_MASK) == F28_TYPE)
        {
        f2xCfiWidthCopy (f28CfiCmdReadArray, baseAdrs, busWidth);
        f2xCfiWidthCopy (f2xCfiCmdReadDeviceId, baseAdrs, busWidth);
        }
    else
        {
        f2xCfiWidthCopy (f29CfiCmdReset, baseAdrs, busWidth);
        offset = F29_OFF_UNLOCK1 << shift;
        f2xCfiWidthCopy (f29CfiCmdUnlock1, baseAdrs + offset, busWidth);
        offset = F29_OFF_UNLOCK2 << shift;
        f2xCfiWidthCopy (f29CfiCmdUnlock2, baseAdrs + offset, busWidth);
        offset = F29_OFF_READ_DEVICE_ID << shift;
        f2xCfiWidthCopy (f2xCfiCmdReadDeviceId, baseAdrs + offset, busWidth);
        }

    F2X_PRINTF ("Manufacturer ID:     ");

    f2xCfiWidthCopy (baseAdrs + (0x00 << shift), pVal, chipWidth);

    if (chipWidth == 1)
        F2X_PRINTF ("0x%02x\n", *(UINT8 *)pVal)
    else
        F2X_PRINTF ("0x%04x\n", *(UINT16 *)pVal)

    F2X_PRINTF ("Device ID:           ");

    f2xCfiWidthCopy (baseAdrs + (0x01 << shift), pVal, chipWidth);

    if (chipWidth == 1)
        F2X_PRINTF ("0x%02x", *(UINT8 *)pVal)
    else
        F2X_PRINTF ("0x%04x", *(UINT16 *)pVal)

    if ((type & F2X_TYPE_MASK) == F28_TYPE)
        {
        F2X_PRINTF ("\n");

        f2xCfiWidthCopy (f28CfiCmdReadArray, baseAdrs, busWidth);
        }
    else
        {
        f2xCfiWidthCopy (baseAdrs + (0x0e << shift), pVal, chipWidth);
 
        if (chipWidth == 1)
            F2X_PRINTF ("-%02x", *(UINT8 *)pVal)
        else
            F2X_PRINTF ("-%04x", *(UINT16 *)pVal)

        f2xCfiWidthCopy (baseAdrs + (0x0f << shift), pVal, chipWidth);
 
        if (chipWidth == 1)
            F2X_PRINTF ("-%02x\n", *(UINT8 *)pVal)
        else
            F2X_PRINTF ("-%04x\n", *(UINT16 *)pVal)

        f2xCfiWidthCopy (f29CfiCmdReset, baseAdrs, busWidth);
        }

    /* return to query mode */

    if ((type & F2X_TYPE_MASK) == F28_TYPE)
        offset = 0;
    else
        offset = F29_OFF_CFI_QUERY << shift;

    f2xCfiWidthCopy (f2xCfiCmdCfiQuery, baseAdrs + offset, busWidth);

    F2X_PRINTF ("Type:                ");

    switch (type & F2X_TYPE_MASK)
        {
        case F28_TYPE:
            F2X_PRINTF ("F28_TYPE");
            break;
        case F29_8BIT_TYPE:
            F2X_PRINTF ("F29_8BIT_TYPE");
            break;
        case F29_16BIT_TYPE:
            F2X_PRINTF ("F29_16BIT_TYPE");
            break;
        default:
            F2X_PRINTF ("ERROR\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            break;
        }
    if ((type & F2X_WB_TYPE_MASK) == 0)
        F2X_PRINTF ("\n")
    else
        {
        F2X_PRINTF (" | F2X_WB");
        if (F2X_WB_SIZE(type) < F2X_WB_SIZE(F2X_WB1KB_TYPE))
            F2X_PRINTF ("%d", F2X_WB_SIZE(type))
        else
            F2X_PRINTF ("%dKB", F2X_WB_SIZE(type)/0x400)
        F2X_PRINTF ("_TYPE\n");
        }

    F2X_PRINTF ("Interface Code:      ");
    switch (intCode)
        {
        case 0:
            F2X_PRINTF ("x8-only interface\n");
            break;
        case 1:
            F2X_PRINTF ("x16-only interface\n");
            break;
        case 2:
            F2X_PRINTF ("x8 or x16 interface via BYTE#\n");
            break;
        default:
            F2X_PRINTF ("ERROR\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            break;
        }

    deviceSize = 1 << f2xCfiRead (baseAdrs, chipWidth, shift, 0x27, 1);

    F2X_PRINTF ("Bus Width:           %d bytes\n", busWidth);
    F2X_PRINTF ("Chip Width:          %d bytes\n", chipWidth);
    F2X_PRINTF ("Device Size:         0x%x bytes, %d megabits\n",
                deviceSize, deviceSize >> 17);

    numRegions = (int)f2xCfiRead (baseAdrs, chipWidth, shift, 0x2c, 1);

    F2X_PRINTF ("Erase Block Regions: %d\n", numRegions);

    /* this is not a loop ("while" used to avoid excessive nesting) */

    while (((type & F2X_TYPE_MASK) != F28_TYPE) && (numRegions > 1))
        {
        /* This is a boot block AMD29-style flash.  Most if not all
         * AMD29-style devices list the CFI "Erase Block Region Information"
         * starting with the boot block.  This representation must be
         * reversed for top boot block devices to properly record the
         * regions.  Check and set isReversed for this situation.
         *
         * WARNING: Early AMD devices like the Am29LV160D may not support
         * the "Sector and WP# Pin Protection Scheme" CFI extended
         * information byte (P+0xf). This algorithm incorrectly groups
         * top boot block devices without this byte!
         */

        /* check for Primary Algorithm extended table address */

        val16 = (UINT16)f2xCfiRead (baseAdrs, chipWidth, shift, 0x15, 2);

        if (val16 == 0)
            break;

        /* check for top boot block device */

        val8 = (UINT8)f2xCfiRead (baseAdrs, chipWidth, shift,
                                  (int)val16 + 0xf, 1);
        if (val8 != 0x03)
            break;

        /* check that the first blocks listed are smaller than the last */

        val32 = (UINT32)f2xCfiRead (baseAdrs, chipWidth, shift,
                                    0x2d + (0 * 4), 4);
        chipBlockSize0 = (val32 >> 16) << 8;
        
        val32 = (UINT32)f2xCfiRead (baseAdrs, chipWidth, shift,
                                    0x2d + ((numRegions - 1) * 4), 4);
        chipBlockSize = (val32 >> 16) << 8;

        if (chipBlockSize0 > chipBlockSize)
            break;

        isReversed = TRUE;
        break;
        }

    /* list the erasable block regions */

    offset = 0;
    for (i = 0; i < numRegions; i++)
        {
        val32 = (UINT32)f2xCfiRead (baseAdrs, chipWidth, shift,
                                    0x2d + ((isReversed ? 
                                             (numRegions - i - 1) : i) * 4), 4);
        chipBlockSize = (val32 >> 16) << 8;
        numBlocks = (val32 & 0xffff) + 1;

        F2X_PRINTF ("  %08x:          0x%x blocks of 0x%x bytes\n",
                    offset, numBlocks, chipBlockSize);

        if (numGReq > 0)
            {
            if (f2xCfiRRecArrayCount >= NELEMENTS(f2xCfiRRecArray))
                {
                F2X_PRINTF ("Resource issue, increase F2X_MAX_REGIONS.\n");
                f2xCfiErrorLine = __LINE__;
                return (ERROR);
                }

            /* record this region and add it to our ordered list */

            pRRec = &f2xCfiRRecArray[f2xCfiRRecArrayCount];
            f2xCfiRRecArrayCount++;
            pRRec->offset = offset * (busWidth/chipWidth);
            pRRec->blockSize = chipBlockSize * (busWidth/chipWidth);
            pRRec->regionSize = pRRec->blockSize * numBlocks;
            pRRec->rid = NULL;
            lstAdd (&f2xCfiRRecList, (NODE *)pRRec);
            }

        offset += numBlocks * chipBlockSize;
        }

    if (deviceSize != offset)
        {
        F2X_PRINTF ("Device size does not match erase block region information\n");
        f2xCfiErrorLine = __LINE__;
        return (ERROR);
        }

    totalSize = deviceSize * (busWidth/chipWidth);

    F2X_PRINTF ("Total Size:          0x%x bytes\n", totalSize);

    if (pSize != NULL)
        *pSize = totalSize;

    /* this is not a loop ("while" used to avoid excessive nesting) */

    while ((type & F2X_TYPE_MASK) == F28_TYPE)
        {
        /* Some Intel-style flash power up with the blocks locked.
         * f2xFlashMem assumes blocks are not locked in this way.
         * Determine if an unlock procedure is necessary during region
         * creation.
         */

        /* check for Primary Algorithm extended table address */

        val16 = (UINT16)f2xCfiRead (baseAdrs, chipWidth, shift, 0x15, 2);

        if (val16 == 0)
            break;

        /* check if this flash supports protection bits */

        val32 = f2xCfiRead (baseAdrs, chipWidth, shift, (int)val16 + 0x5, 4);

        if ((val32 & (1 << 6)) == 0)
            break;

        unlockRegions = TRUE;
        break;
        }

    /* return to read mode */

    if ((type & F2X_TYPE_MASK) == F28_TYPE)
        f2xCfiWidthCopy (f28CfiCmdReadArray, baseAdrs, busWidth);
    else
        f2xCfiWidthCopy (f29CfiCmdReset, baseAdrs, busWidth);

    /* == if numGReq is zero, we are done == */

    if (numGReq == 0)
        return (OK);

    /* check group request array for simple problems */

    pGReq = greqArray;
    for (i = 0; i < numGReq; i++)
        {
        if ((pGReq->offset < 0) || (pGReq->groupSize < 0) ||
            ((pGReq->offset + pGReq->groupSize) > totalSize))
            {
            F2X_PRINTF ("Invalid <greqArray[]> element at index %d.\n", i);
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        pGReq++;
        }

    /* split region records if necessary based on group request alignment */

    pGReq = greqArray;
    for (i = 0; i < numGReq; i++)
        {
        /* go to the region record with this start offset */

        offset = pGReq->offset;

        pRRec = (F2X_RREC *)lstFirst (&f2xCfiRRecList);

        while ((pRRec != NULL) && 
               (offset >= (pRRec->offset + pRRec->regionSize)))
             pRRec = (F2X_RREC *)lstNext ((NODE *)pRRec);

        if (pRRec == NULL)
            {
            F2X_PRINTF ("Programming error.\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        /* if start offset is within the region, split the region record */

        if ((offset != pRRec->offset) && 
            (f2xCfiRRecSplit (pRRec, offset, i, verbose) != OK))
            {
            F2X_PRINTF ("Programming error.\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        /* go to the region record with this end offset */

        offset = pGReq->offset + pGReq->groupSize;

        while ((pRRec != NULL) && 
               (offset > (pRRec->offset + pRRec->regionSize)))
             pRRec = (F2X_RREC *)lstNext ((NODE *)pRRec);

        if (pRRec == NULL)
            {
            F2X_PRINTF ("Programming error.\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        /* if end offset is within the region, split the region record */

        if ((offset != (pRRec->offset + pRRec->regionSize)) &&
            (f2xCfiRRecSplit (pRRec, offset, i, verbose) != OK))
            {
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        pGReq++;
        }

    /* create the groups */

    F2X_PRINTF ("Creating Groups...\n");

    pGReq = greqArray;
    rid = NULL;
    for (i = 0; i < numGReq; i++)
        {
        *pGReq->pGid = NULL;

        /* go to the region record with this start offset */

        offset = pGReq->offset;

        pRRec = (F2X_RREC *)lstFirst (&f2xCfiRRecList);

        while ((pRRec != NULL) && (offset != pRRec->offset))
             pRRec = (F2X_RREC *)lstNext ((NODE *)pRRec);

        if (pRRec == NULL)
            {
            F2X_PRINTF ("Programming error.\n");
            f2xCfiErrorLine = __LINE__;
            return (ERROR);
            }

        /* create regions as necessary and add to a group */

        offset = pGReq->offset + pGReq->groupSize;

        while ((pRRec != NULL) && 
               (offset >= (pRRec->offset + pRRec->regionSize)))
            {
            if (pRRec->rid == NULL)
                {
                rid = f2xRegionCreate (baseAdrs + pRRec->offset, busWidth,
                                       pRRec->regionSize, chipWidth,
                                       pRRec->blockSize / (busWidth/chipWidth),
                                       busWidth, type, rid, NULL, 0);
                if (rid == NULL)
                    {
                    F2X_PRINTF ("Resource issue, increase F2X_MAX_REGIONS.\n");
                    f2xCfiErrorLine = __LINE__;
                    return (ERROR);
                    }

                pRRec->rid = rid;

                if (unlockRegions)
                    {
                    /* unlock potentially locked blocks */

                    numBlocks = pRRec->regionSize / pRRec->blockSize;

                    blockAdrs = baseAdrs + pRRec->offset;
                    for (j = 0; j < numBlocks; j++)
                        {
                        f2xCfiWidthCopy (f28CfiCmdBlockLockSetup,
                                         blockAdrs, busWidth);
                        f2xCfiWidthCopy (f28CfiCmdBlockLockClear,
                                         blockAdrs, busWidth);

                        /* Some flash, as in the Numonyx 28F128P30, do not
                         * follow their own documentation regarding unlocking
                         * blocks, instead they ignore the read array command
                         * until they are no longer busy unlocking.  Waiting
                         * for each unlock to complete takes too long, so we
                         * only wait the last time to ensure our flash isn't
                         * left in status mode.
                         */
                        
                        if (j == (numBlocks - 1))
                            while (f28RegionIsBusy (rid));

                        f2xCfiWidthCopy (f28CfiCmdReadArray,
                                         blockAdrs, busWidth);
                        blockAdrs += pRRec->blockSize;
                        }
                    }
                }

            if (*pGReq->pGid == NULL)
                {
                *pGReq->pGid = f2xGroupCreate (pRRec->rid);

                if (*pGReq->pGid == NULL)
                    {
                    F2X_PRINTF ("Resource issue, increase F2X_MAX_GROUPS.\n");
                    f2xCfiErrorLine = __LINE__;
                    return (ERROR);
                    }
                }
            else
                {
                status = f2xGroupAdd (*pGReq->pGid, pRRec->rid);

                if (status != OK)
                    {
                    F2X_PRINTF ("Resource issue, increase F2X_MAX_REGIONS.\n");
                    f2xCfiErrorLine = __LINE__;
                    return (ERROR);
                    }
                }

             pRRec = (F2X_RREC *)lstNext ((NODE *)pRRec);
             }

        F2X_PRINTF ("  %p:          %p-%p\n",
                    *pGReq->pGid, baseAdrs + pGReq->offset,
                    baseAdrs + offset - 1);
        pGReq++;
        }

    return (OK);
    }

/*******************************************************************************
*
* f2xCfiSize - total size of the flash
*
* This routine returns the total size of the flash.
*
* If the bus width is unknown, call this routine with ascending
* bus widths (i.e., 1, 2, 4, 8).  The first bus width to return
* a size is the correct width.
*
* WARNING:
* This routine calls f2xGroupsCreate() so it is not reentrant, and
* should not be called for already-grouped flash.
*
* RETURNS: Total size of flash or ERROR if flash could not be queried.
*/

int f2xCfiSize
    (
    char * baseAdrs,   /* base address of flash */
    int    busWidth    /* flash bus width */
    )
    {
    STATUS status;
    int    size;

    /* check arguments */

    if (((busWidth == 1) || (busWidth == 2) ||
         (busWidth == 4) || (busWidth == 8)) == FALSE)
        return (ERROR);

    status = f2xCfiGroupsCreate (baseAdrs, busWidth, 0, NULL, &size, FALSE );

    return (status != OK ? ERROR : size);
    }

/*******************************************************************************
*
* f2xCfiShow - display common flash interface information
*
* This routine diplays the CFI information for a single or set
* of flash chips at <baseAdrs> with a bus width of <busWidth>.
*
* If the bus width is unknown, call this routine with ascending
* bus widths (i.e., 1, 2, 4, 8).  The first bus width to return
* OK is the correct width.
*
* WARNING:
* This routine calls f2xGroupsCreate() so it is not reentrant, and
* should not be called for already-grouped flash.
*
* RETURNS: OK, or ERROR if info could not be fully shown.
*/

STATUS f2xCfiShow
    (
    char * baseAdrs,   /* base address of flash */
    int    busWidth    /* flash bus width */
    )
    {
    STATUS status;

    /* check arguments */

    if (((busWidth == 1) || (busWidth == 2) ||
         (busWidth == 4) || (busWidth == 8)) == FALSE)
        {
        printf ("usage: f2xCfiShow <baseAdrs>, <busWidth>\n");
        return (ERROR);
        }

    status = f2xCfiGroupsCreate (baseAdrs, busWidth, 0, NULL, NULL, TRUE);

    return (status);
    }
#endif /* INCLUDE_F2X_CFI_ROUTINES */
