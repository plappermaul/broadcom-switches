#!/usr/bin/perl -w
#
# cint2c.pl
# Script to convert logs generated by the API logger into a executable CINT
#
# This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
# 
# Copyright 2007-2021 Broadcom Inc. All rights reserved.


# ! /tools/oss/packages/x86_64-rhel5/perl/5.8.8/bin/perl -w

#use Data::Dumper;

$\ = "\n";
$, = "\n";
$/ = "\n";

my $usage = "\

    Usage:

        cint2c.pl -i <c-like-input> -o <cint-output> -g <globals-output> [-z <yes|no>] [-r <yes|no>]

        -i
          <c-like-input>: typically a file generated by the API Logger either via
                          the inline or offline logging mechanism, or through the
                          \"logger show\" command, or through \"logger decode\"
                          command. This option is mandatory.

        -o
          <cint-output> : output generated by converting <c-like-input> to C
                          This option is mandatory

        -g
        <globals-output>: file containing any global values referred from
                          <cint-output>. This option is mandatory.

        [-z [yes|no]]   : all u?int64 variables are substituted with ZERO. This
                          helps to reduce the number of globals that are
                          generated during conversion process, especially when
                          the logs contain a lot of \"stat_get\" calls. This
                          option is optional, and disabled by default

        [-r [yes|no]]   : retain contents of the original line in the output.
                          When this option is turned on, each line of output is
                          concatenation of the converted C code followed by the
                          original input line as a comment. This helps when
                          verifying manually if the conversion was done
                          correctly. This option is optional, and is enabled by
                          default

";


my %opts;

#
# For any system where getopt is not available, the following routine provides
# a custom implementation for it. Most unix servers should have getopt so
# usually a user would pass has_getopt = 1
#
sub getopts ($$) {
    my $has_getopt = shift;
    my $parsed_opts = shift;

    if ($has_getopt) {

        my $getopt_cmd = "getopt -n cint2c.pl -o i:o:g:z:r: -- @ARGV";
        open GOFH, "$getopt_cmd |" or die "unable to spawn getopt command: \"$getopt_cmd\"";
        my $getopt = <GOFH>;
        close GOFH;

        if ($? != 0) {
            print STDERR "cint2c.pl: Getopt return an error.\n";
            print STDERR $usage;
            exit(-1);
        }

        # Process the getopt output now
        # remove any trailing newline
        chomp $getopt;

        # fetch options and non-option parameters
        my ($opts,$nonopts) = split /--/, $getopt;

        #remove leading and trailing whitespace
        $opts =~ s/^\s+//;
        $opts =~ s/\s+$//;
        $nonopts =~ s/^\s+//;
        $nonopts =~ s/\s+$//;

        # we don't know what to do with non-options, will carp and ignore
        print STDERR "Unknown options ignored: $nonopts\n" unless ($nonopts =~ /^\s*$/);

        # process the options now. Clear any leading and trailing whitespace
        my @opts = split / /, $opts;

        my $expect_opt = 1;
        my $cur_opt = undef;
        while (my $el = shift @opts) {
            if ($expect_opt) {
                $cur_opt = $el;
                $parsed_opts->{$cur_opt} = "";
                $expect_opt = 0;
            } else {
                $el =~ s/^'//;
                $parsed_opts->{$cur_opt} .= $el;
                if ($el =~ /'$/) {
                    $expect_opt = 1;
                    $cur_opt = undef;
                }
            }
        }

        foreach my $opt (keys %opts) {
            $parsed_opts->{$opt} =~ s/'//g;
        }
    } else {

        #
        # Custom implementation of getopt
        #
        my $expect_opt = 1;
        my $cur_opt = undef;
        while (my $arg = shift @ARGV) {
            if ($expect_opt) {
                if ($arg =~ /^-[iogzr]$/) {
                    $cur_opt = $arg;
                    $parsed_opts->{$cur_opt} = "";
                    $expect_opt = 0;
                } else {
                    print STDERR "cint2c.pl: unknown option $arg";
                    print STDERR $usage;
                    exit(-1);
                }
            } else {
                if (not defined $cur_opt) {
                    print STDERR "cint2c.pl: unexpected argument $arg";
                    print STDERR $usage;
                    exit(-1);
                }
                $parsed_opts->{$cur_opt} .= $arg;
                $expect_opt = 1;
                $cur_opt = undef;
            }
        }
    }
}

# Busybox does not provide the getopt command. Therefore pass has_getopt=0
getopts(0,\%opts);

unless (defined $opts{-i} and $opts{-i} ne "" and
        defined $opts{-o} and $opts{-o} ne "" and
        defined $opts{-g} and $opts{-g} ne "") {

    print STDERR "cint2c.pl: -i,-o,-g must be provided.";
    #print Dumper(\%opts);
    print STDERR $usage;
    exit(-1);
}

my $zero_64b_nums = 0;
if (defined $opts{-z}) {

    $zero_64b_nums = $opts{-z};

    if ($zero_64b_nums =~ /^(Y|y|YES|Yes|yes)$/) {

        $zero_64b_nums = 1;

    } elsif ($zero_64b_nums =~ /^(N|n|NO|No|no)$/) {

        $zero_64b_nums = 0;

    } else {

        print STDERR "cint2c.pl: unknown option -z $zero_64b_nums";
        print STDERR $usage;
        exit(-1);
    }
}

my $retain = 1;
if (defined $opts{-r}) {

    $retain = $opts{-r};

    if ($retain =~ /^(Y|y|YES|Yes|yes)$/) {

        $retain = 1;

    } elsif ($retain =~ /^(N|n|NO|No|no)$/) {

        $retain = 0;

    } else {
        print STDERR "cint2c.pl: unknown option -r $retain";
        print STDERR $usage;
        exit(-1);
    }
}

open IFH, "<$opts{-i}" or die "Could not open \"$opts{-i}\" for reading";
open OFH, ">$opts{-o}" or die "Could not open \"$opts{-o}\" for writing";
open GFH, ">$opts{-g}" or die "Could not open \"$opts{-g}\" for writing";

my $void_ptr_name = "G_void_ptr";

#
# bcm_rx_reasons_t holds various punt reasons. It is implemented as a bitfield
# and printed as a list of strings, one for each set bit, using a special
# format'er. For example, when bits 1,2 are set in the bitfield it is printed
# as
#
#     bcm_rx_reasons_t reasons = Arp Bpdu
#
# instead of just some output that shows that bits 1,2 are set in this
# bitfield.
#
# Need a way to map those strings back to a bcmRxReason* enum which may be used
# to set the corresponding bit using BCM_RX_REASON_SET.
#
# The following list of strings (hash keys) and associated enums (hash values)
# are found by merging the lists _SHR_RX_REASON_NAMES_INITIALIZER in
# include/shared/rx.h, _shr_rx_reason_t in include/shared/rx.h, and
# bcm_rx_reason_t in include/bcm/rx.h.
#
# The first two lists map 1:1 to each other, whereas the third one cherry picks
# values from the second list. Therefore, there are items in the first two
# lists with no corresponding item in the third list. In such cases, the
# absolute value of such items (bit index) are being copied here for the
# reverse mapping.

my %bcmRxReason = (
    "Invalid"                   =>       "bcmRxReasonInvalid",
    "Arp"                       =>       "bcmRxReasonArp",
    "Bpdu"                      =>       "bcmRxReasonBpdu",
    "Broadcast"                 =>       "bcmRxReasonBroadcast",
    "ClassBasedMove"            =>       "bcmRxReasonClassBasedMove",
    "ClassTagPackets"           =>       "bcmRxReasonClassTagPackets",
    "Control"                   =>       "bcmRxReasonControl",
    "CpuLearn"                  =>       "bcmRxReasonCpuLearn",
    "DestLookupFail"            =>       "bcmRxReasonDestLookupFail",
    "Dhcp"                      =>       "bcmRxReasonDhcp",
    "DosAttack"                 =>       "bcmRxReasonDosAttack",
    "E2eHolIbp"                 =>       "bcmRxReasonE2eHolIbp",
    "EncapHiGigError"           =>       "bcmRxReasonEncapHigigError",
    "FilterMatch"               =>       "bcmRxReasonFilterMatch",
    "GreChecksum"               =>       "bcmRxReasonGreChecksum",
    "GreSourceRoute"            =>       "bcmRxReasonGreSourceRoute",
    "HigigControl"              =>       "bcmRxReasonHigigControl",
    "HigigHdrError"             =>       "bcmRxReasonHigigHdrError",
    "IcmpRedirect"              =>       "bcmRxReasonIcmpRedirect",
    "Igmp"                      =>       "bcmRxReasonIgmp",
    "IngressFilter"             =>       "bcmRxReasonIngressFilter",
    "Ip"                        =>       "bcmRxReasonIp",
    "IpfixRateViolation"        =>       "bcmRxReasonIpfixRateViolation",
    "IpMcastMiss"               =>       "bcmRxReasonIpMcastMiss",
    "IpOptionVersion"           =>       "bcmRxReasonIpOptionVersion",
    "Ipmc"                      =>       "bcmRxReasonIpmc",
    "IpmcRsvd"                  =>       "bcmRxReasonIpmcReserved",
    "L2Cpu"                     =>       "bcmRxReasonL2Cpu",
    "L2DestMiss"                =>       "bcmRxReasonL2DestMiss",
    "L2LearnLimit"              =>       "bcmRxReasonL2LearnLimit",
    "L2Move"                    =>       "bcmRxReasonL2Move",
    "L2MtuFail"                 =>       "bcmRxReasonL2MtuFail",
    "L2NonUnicastMiss"          =>       "bcmRxReasonL2NonUnicastMiss",
    "L2SourceMiss"              =>       "bcmRxReasonL2SourceMiss",
    "L3AddrBindFail"            =>       "bcmRxReasonL3AddrBindFail",
    "L3DestMiss"                =>       "bcmRxReasonL3DestMiss",
    "L3HeaderError"             =>       "bcmRxReasonL3HeaderError",
    "L3MtuFail"                 =>       "bcmRxReasonL3MtuFail",
    "L3Slowpath"                =>       "bcmRxReasonL3Slowpath",
    "L3SourceMiss"              =>       "bcmRxReasonL3SourceMiss",
    "L3SourceMove"              =>       "bcmRxReasonL3SourceMove",
    "MartianAddr"               =>       "bcmRxReasonMartianAddr",
    "McastIdxError"             =>       "bcmRxReasonMcastIdxError",
    "McastMiss"                 =>       "bcmRxReasonMcastMiss",
    "MimServiceError"           =>       "bcmRxReasonMimServiceError",
    "MplsCtrlWordError"         =>       "bcmRxReasonMplsCtrlWordError",
    "MplsError"                 =>       "bcmRxReasonMplsError",
    "MplsInvalidAction"         =>       "bcmRxReasonMplsInvalidAction",
    "MplsInvalidPayload"        =>       "bcmRxReasonMplsInvalidPayload",
    "MplsLabelMiss"             =>       "bcmRxReasonMplsLabelMiss",
    "MplsSequenceNumber"        =>       "bcmRxReasonMplsSequenceNumber",
    "MplsTtl"                   =>       "bcmRxReasonMplsTtl",
    "Multicast"                 =>       "bcmRxReasonMulticast",
    "Nhop"                      =>       "bcmRxReasonNhop",
    "OamError"                  =>       "bcmRxReasonOAMError",
    "OamSlowPath"               =>       "bcmRxReasonOAMSlowpath",
    "OamLMDM"                   =>       "bcmRxReasonOAMLMDM",
    "ParityError"               =>       "bcmRxReasonParityError",
    "Protocol"                  =>       "bcmRxReasonProtocol",
    "SampleDest"                =>       "bcmRxReasonSampleDest",
    "SampleSource"              =>       "bcmRxReasonSampleSource",
    "SharedVlanMismatch"        =>       "bcmRxReasonSharedVlanMismatch",
    "SourceRoute"               =>       "bcmRxReasonSourceRoute",
    "TimeStamp"                 =>       "bcmRxReasonTimeStamp",
    "Ttl"                       =>       "bcmRxReasonTtl",
    "Ttl1"                      =>       "bcmRxReasonTtl1",
    "TunnelError"               =>       "bcmRxReasonTunnelError",
    "UdpChecksum"               =>       "bcmRxReasonUdpChecksum",
    "UnknownVlan"               =>       "bcmRxReasonUnknownVlan",
    "UrpfFail"                  =>       "bcmRxReasonUrpfFail",
    "VcLabelMiss"               =>       "bcmRxReasonVcLabelMiss",
    "VlanFilterMatch"           =>       "bcmRxReasonVlanFilterMatch",
    "WlanClientError"           =>       "bcmRxReasonWlanClientError",
    "WlanSlowPath"              =>       "bcmRxReasonWlanSlowpath",
    "WlanDot1xDrop"             =>       "bcmRxReasonWlanDot1xDrop",
    "ExceptionFlood"            =>       "75", #"_SHR_RX_EXCEPTION_FLOOD",
    "Timesync"                  =>       "bcmRxReasonTimeSync",
    "EavData"                   =>       "bcmRxReasonEAVData",
    "SamePortBridge"            =>       "bcmRxReasonSamePortBridge",
    "SplitHorizon"              =>       "bcmRxReasonSplitHorizon",
    "L4Error"                   =>       "bcmRxReasonL4Error",
    "Stp"                       =>       "bcmRxReasonStp",
    "EgressFilterRedirect"      =>       "82", #"_SHR_RX_EGRESS_FILTER_REDIRECT",
    "FilterRedirect"            =>       "83", #"_SHR_RX_FILTER_REDIRECT",
    "Loopback"                  =>       "84", #"_SHR_RX_LOOPBACK",
    "VlanTranslate"             =>       "bcmRxReasonVlanTranslate",
    "Mmrp"                      =>       "bcmRxReasonMmrp",
    "Srp"                       =>       "bcmRxReasonSrp",
    "TunnelControl"             =>       "bcmRxReasonTunnelControl",
    "L2Marked"                  =>       "bcmRxReasonL2Marked",
    "WlanSlowpathKeepalive"     =>       "bcmRxReasonWlanSlowpathKeepalive",
    "Station"                   =>       "bcmRxReasonStation",
    "Niv"                       =>       "bcmRxReasonNiv",
    "NivPrioDrop"               =>       "bcmRxReasonNivPrioDrop",
    "NivInterfaceMiss"          =>       "bcmRxReasonNivInterfaceMiss",
    "NivRpfFail"                =>       "bcmRxReasonNivRpfFail",
    "NivTagInvalid"             =>       "bcmRxReasonNivTagInvalid",
    "NivTagDrop"                =>       "bcmRxReasonNivTagDrop",
    "NivUntagDrop"              =>       "bcmRxReasonNivUntagDrop",
    "Trill"                     =>       "bcmRxReasonTrill",
    "TrillInvalid"              =>       "bcmRxReasonTrillInvalid",
    "TrillMiss"                 =>       "bcmRxReasonTrillMiss",
    "TrillRpfFail"              =>       "bcmRxReasonTrillRpfFail",
    "TrillSlowpath"             =>       "bcmRxReasonTrillSlowpath",
    "TrillCoreIsIs"             =>       "bcmRxReasonTrillCoreIsIs",
    "TrillTtl"                  =>       "bcmRxReasonTrillTtl",
    "BfdSlowpath"               =>       "bcmRxReasonBfdSlowpath",
    "Bfd"                       =>       "107", #"_SHR_RX_BFD",
    "Mirror"                    =>       "bcmRxReasonMirror",
    "RegexAction"               =>       "bcmRxReasonRegexAction",
    "RegexMatch"                =>       "bcmRxReasonRegexMatch",
    "FailoverDrop"              =>       "bcmRxReasonFailoverDrop",
    "WlanTunnelError"           =>       "bcmRxReasonWlanTunnelError",
    "CongestionCnmProxy"        =>       "bcmRxReasonCongestionCnmProxy",
    "CongestionCnmProxyError"   =>       "bcmRxReasonCongestionCnmProxyError",
    "CongestionCnm"             =>       "bcmRxReasonCongestionCnm",
    "MplsUnknownAch"            =>       "bcmRxReasonMplsUnknownAch",
    "MplsLookupsExceeded"       =>       "bcmRxReasonMplsLookupsExceeded",
    "MplsReservedEntropyLabel"  =>       "bcmRxReasonMplsReservedEntropyLabel",
    "MplsIllegalReservedLabel"  =>       "bcmRxReasonMplsIllegalReservedLabel",
    "MplsRouterAlertLabel"      =>       "bcmRxReasonMplsRouterAlertLabel",
    "NivPrune"                  =>       "bcmRxReasonNivPrune",
    "VirtualPortPrune"          =>       "bcmRxReasonVirtualPortPrune",
    "NonUnicastDrop"            =>       "bcmRxReasonNonUnicastDrop",
    "TrillPacketPortMismatch"   =>       "bcmRxReasonTrillPacketPortMismatch",
    "WlanClientMove"            =>       "bcmRxReasonWlanClientMove",
    "WlanSourcePortMiss"        =>       "bcmRxReasonWlanSourcePortMiss",
    "WlanClientSourceMiss"      =>       "bcmRxReasonWlanClientSourceMiss",
    "WlanClientDestMiss"        =>       "bcmRxReasonWlanClientDestMiss",
    "WlanMtu"                   =>       "bcmRxReasonWlanMtu",
    "TrillName"                 =>       "bcmRxReasonTrillName",
    "L2GreSipMiss"              =>       "bcmRxReasonL2GreSipMiss",
    "L2GreVpnIdMiss"            =>       "bcmRxReasonL2GreVpnIdMiss",
    "TimesyncUnknownVersion"    =>       "bcmRxReasonTimesyncUnknownVersion",
    "BfdError"                  =>       "bcmRxReasonBfd",
    "BfdUnknownVersion"         =>       "bcmRxReasonBfdUnknownVersion",
    "BfdInvalidVersion"         =>       "bcmRxReasonBfdInvalidVersion",
    "BfdLookupFailure"          =>       "bcmRxReasonBfdLookupFailure",
    "BfdInvalidPacket"          =>       "bcmRxReasonBfdInvalidPacket",
    "VxlanSipMiss"              =>       "bcmRxReasonVxlanSipMiss",
    "VxlanVpnIdMiss"            =>       "bcmRxReasonVxlanVpnIdMiss",
    "FcoeZoneCheckFail"         =>       "bcmRxReasonFcoeZoneCheckFail",
    "IpmcInterfaceMismatch"     =>       "bcmRxReasonIpmcInterfaceMismatch",
    "Nat"                       =>       "bcmRxReasonNat",
    "TcpUdpNatMiss"             =>       "bcmRxReasonTcpUdpNatMiss",
    "IcmpNatMiss"               =>       "bcmRxReasonIcmpNatMiss",
    "NatFragment"               =>       "bcmRxReasonNatFragment",
    "NatMiss"                   =>       "bcmRxReasonNatMiss",
    "UnknownSubtentingPort"     =>       "bcmRxReasonUnknownSubtendingPort",
    "LLTagAbsentDrop"           =>       "149", #"_SHR_RX_LLTAG_ABSENT_DROP",
    "LLTagpresenDrop"           =>       "150", #"_SHR_RX_LLTAG_PRESENT_DROP",
    "OAMCCMslowpath"            =>       "bcmRxReasonOAMCCMSlowpath",
    "OAMIncompleteOpcode"       =>       "152", #"_SHR_RX_OAM_INCOMPLETE_OPCODE",
    "OAMCCMpacket"              =>       "bcmRxReasonBHHOAM",
    "Reserved0"                 =>       "bcmRxReasonReserved0",
    "OAMMplsLmDM"               =>       "bcmRxReasonOAMMplsLmDm",
    "SAT"                       =>       "bcmRxReasonSat",
    "SampleSourceFlex"          =>       "bcmRxReasonSampleSourceFlex",
    "FlexSflow"                 =>       "bcmRxReasonFlexSflow",
    "VxltMiss"                  =>       "bcmRxReasonVxltMiss",
    "TunnelDecapEcnError"       =>       "bcmRxReasonTunnelDecapEcnError",
    "TunnelObjectValidationFail"=>       "bcmRxReasonTunnelObjectValidationFail",
    "L3Cpu"                     =>       "bcmRxReasonL3Cpu",
    "TunnelAdaptLookupMiss"     =>       "bcmRxReasonTunnelAdaptLookupMiss",
    "PacketFlowSelectMiss"      =>       "bcmRxReasonPacketFlowSelectMiss",
    "ProtectionDataDrop"        =>       "bcmRxReasonProtectionDataDrop",
    "PacketFlowSelect"          =>       "bcmRxReasonPacketFlowSelect",
    "OtherLookupMiss"           =>       "bcmRxReasonOtherLookupMiss",
    "InvalidTpid"               =>       "bcmRxReasonInvalidTpid",
    "MplsControlPacket"         =>       "bcmRxReasonMplsControlPacket",
    "TunnelTtlError"            =>       "bcmRxReasonTunnelTtlError",
    "L2HeaderError"             =>       "bcmRxReasonL2HeaderError",
    "OtherLookupHit"            =>       "bcmRxReasonOtherLookupHit",
    "L2SrcLookupMiss"           =>       "bcmRxReasonL2SrcLookupMiss",
    "L2SrcLookupHit"            =>       "bcmRxReasonL2SrcLookupHit",
    "L2DstLookupMiss"           =>       "bcmRxReasonL2DstLookupMiss",
    "L2DstLookupHit"            =>       "bcmRxReasonL2DstLookupHit",
    "L3SrcRouteLookupMiss"      =>       "bcmRxReasonL3SrcRouteLookupMiss",
    "L3SrcHostLookupMiss"       =>       "bcmRxReasonL3SrcHostLookupMiss",
    "L3SrcRouteLookupHit"       =>       "bcmRxReasonL3SrcRouteLookupHit",
    "L3SrcHostLookupHit"        =>       "bcmRxReasonL3SrcHostLookupHit",
    "L3DstRouteLookupMiss"      =>       "bcmRxReasonL3DstRouteLookupMiss",
    "L3DstHostLookupMiss"       =>       "bcmRxReasonL3DstHostLookupMiss",
    "L3DstRouteLookupHit"       =>       "bcmRxReasonL3DstRouteLookupHit",
    "L3DstHostLookupHit"        =>       "bcmRxReasonL3DstHostLookupHit",
    "MplsLookup1Miss"           =>       "bcmRxReasonVlanTranslate1Lookup1Miss",
    "MplsLookup2Miss"           =>       "bcmRxReasonVlanTranslate1Lookup2Miss",
    "L3TunnelLookupMiss"        =>       "bcmRxReasonMplsLookup1Miss",
    "VlanTranslate1Lookup1Miss" =>       "bcmRxReasonMplsLookup2Miss",
    "VlanTranslate1Lookup2Miss" =>       "bcmRxReasonL3TunnelLookupMiss",
    "VlanTranslate2Lookup1Miss" =>       "bcmRxReasonVlanTranslate2Lookup1Miss",
    "VlanTranslate2Lookup2Miss" =>       "bcmRxReasonVlanTranslate2Lookup2Miss",
    "L2StuFail"                 =>       "bcmRxReasonL2StuFail",
    "SrCounterExceeded"         =>       "bcmRxReasonSrCounterExceeded",
    "SrCopyToCpuBit0"           =>       "bcmRxReasonSrCopyToCpuBit0",
    "SrCopyToCpuBit1"           =>       "bcmRxReasonSrCopyToCpuBit1",
    "SrCopyToCpuBit2"           =>       "bcmRxReasonSrCopyToCpuBit2",
    "SrCopyToCpuBit3"           =>       "bcmRxReasonSrCopyToCpuBit3",
    "SrCopyToCpuBit4"           =>       "bcmRxReasonSrCopyToCpuBit4",
    "SrCopyToCpuBit5"           =>       "bcmRxReasonSrCopyToCpuBit5",
    "L3HeaderMismatch"          =>       "bcmRxReasonL3HeaderMismatch",
    "DlbMonitor"                =>       "bcmRxReasonDLBMonitor",
    "EtrapMonitor"              =>       "bcmRxReasonETrapMonitor",
    "IntTurnAround"             =>       "bcmRxReasonIntTurnAround",
    "IntHopLimit"               =>       "bcmRxReasonIntHopLimit",
    "ProtectionStatusDown"      =>       "bcmRxReasonProtStatDown",
);

#
# Utility function to format input and output lines into a single line
#
sub outputf ($$$$$)
{
    my ($fh, $indent, $outln, $inln, $infostr) = (shift, shift, shift, shift, shift);

    if ($retain) {
        printf($fh "%-80s /* %-100s */\n", $indent . $outln, "$inln --> $infostr");
    } else {
        printf($fh "%s\n", $indent . $outln);
    }
    #printf("%s\nINP:%s\nOUT:%s%s\n\n", $infostr, $inln, $indent, $outln);
}


#
# Theory of Operation
#
#     The API logger generates C-like output. Each C-like logging entry has the
#     pattern:
#
#     ['if (0)'] '{'
#
#          outputs of type (1) below
#
#          outputs of type (2) below
#
#          one line of type (3) below
#
#     '}'
#
#     The 'if (0)' is added to logging entries generated from the second call
#     to the logger from an API. NOTE, this may be eliminated in the future.
#
#     The three output types are as follows:
#
#     (1) API inputs are printed using the equivalent of the cint command
#     "cint> print <variable>;". Pointers are dereferenced and are also printed
#     using the same approach. Finally, the call_ctxt structure is also
#     printed.
#
#     (2) Once all API inputs have been printed, additional lines are written
#     which fix up the pointers - i.e. pointer variables are assigned to
#     adddress-of the variables printed after dereferencing them. These lines
#     are valid C statements.
#
#     (3) Finally a line is added invoking the API with the inputs printed
#     above.  This line is also a valid C statement.
#
#     Note that (2), and (3) are both written by the logger code such that they
#     are already valid C statements and do not require additional processing
#     here.  They are retained as-is in the output.
#
#     Function cint_variable_print() which is the implementation of the "print"
#     command in the CINT interpreter, writes all variables in the following
#     pattern.
#
#            <variable-type> <name> = <value>
#
#     If <variable-type> is an array or a structure, <value> spans over
#     multiple lines surrounded by curly braces '{' and '}'. Each member is
#     recursively printed in the following lines in the same format as above,
#     i.e. arrays or structures are printed as follows:
#
#            <variable-type> <name> = '{'
#                <member-1-type> <member-1-name> = <member-1-value>
#                <member-2-type> <member-2-name> = <member-2-value>
#                               .
#                               .
#                <member-n-type> <member-n-name> = <member-n-value>
#            '}'
#
#     Of course, <member-x-type> may also be a structure or an array.
#
#     Therefore, almost all the code below is focussed on converting these
#     inputs from (1) into executable CINT statements. Everything else is
#     simply retained without any additional processing.
#
#     Given the format of the input data it is possible to process each line
#     independently. This simplifies the implementation significantly because
#     each line
#
#            <variable-type> <name> = <value>
#
#     may simply be converted to either, if it is not part of struct of array
#
#            <name> = <value>;
#
#       OR
#
#     if it was part of a structure or array simply as
#
#            <value>,
#
#
# SPECIAL HANDLING FOR CERTAIN DATATYPES
#
#     Certain datatypes, listed below, require special handling because lines
#
#            <variable-type> <name> = <value>
#
#     cannot be converted to
#
#            <name> = <value>;
#
#     and still be valid CINT statements. For example:-
#
#     bcm_pbmp_t
#
#            bcm_pbmp_t pbmp = { 1 2 3 4 }
#
#     cannot be converted to
#
#            pbmp = { 1 2 3 4 };
#
#     because this is not a valid statement in CINT. Similarly,
#
#     uint64
#
#            uint64 u64 = {0x01234567 0x89ABCDEF}
#
#     cannot be converted to
#
#            u64 = {0x01234567 0x89ABCDEF};
#
#     This presents a problem with the otherwise line-by-line processing that
#     results in one line of output for each line of input.
#
#     Luckily, in the CINT interpreter variables may be assigned to another
#     variable of the same type, including bc_pbmp_t and u?int64. Instead of
#     uplifting the CINT interpreter to accept assignment of these data types,
#     we elect to work around the issue. In the examples above the following
#     code may be generated to have pbmp and u64 receive the same values as in
#     the input logs.
#
#            bcm_pbmp_t another_pbmp;
#            BCM_PBMP_CLEAR(another_pbmp);
#            BCM_PBMP_PORT_ADD(another_pbmp,1);
#            BCM_PBMP_PORT_ADD(another_pbmp,2);
#            BCM_PBMP_PORT_ADD(another_pbmp,3);
#            BCM_PBMP_PORT_ADD(another_pbmp,4);
#            pbmp = another_pbmp;
#
#            uint64 another64;
#            COMPILER_64_SET(another64, 0x01234567, 0x89ABCDEF);
#            u64 = another64;
#
#     Therefore, we detect variables of these two types, create other variables
#     with the same value, and assign those variables to the ones found in the
#     logs.
#
#     The output is quite similar to as shown in the examples above, except
#     that the "another" variables are declared and initialized as globals in a
#     separate file provided via input -g. These are referred from the CINT
#     output file.
#
#     While creating PBMP globals the script looks for already created globals
#     with the same value (i.e. same set of ports as required) in order to
#     minimize the total number of globals that need to be created. This
#     optimization is not done for 64bit numbers because they are expected to
#     be statistics and reusing variable names is unlikely to benefit a human
#     reader of the final CINT script, unlike in case of PBMPs.
#
#
# CHAR POINTERS
#
#     One additional special case is that of char* pointers. Unlike any other
#     pointer type, these pointers if not-NULL are dereferenced and the pointed
#     string is printed within quotes after the pointer itself. E.g.
#
#            char* api = 0xabcd1234 "bcm_vlan_port_create"
#
#     This can be converted to
#
#            api = "bcm_vlan_port_create";
#
#     There is special handling for this case also.
#
# SUMMARY
#
#     In summary, following line-by-line converter code matches each input line
#     against a set of regular expressions; each regular expression matches a
#     variant of "<variable-type> <variable-name> = <variable-value>"; and
#     finally outputs a single line to the output file for every input line.
#
#     Once all input lines have been processed, it outputs all the collected
#     bcm_pbmp_t and u?int64 constants into a separate output file meant to
#     hold these as global variables.
#
#     If a new variable-type is discovered that escapes the set of regexps
#     below, then a new handler for such type will need to be added here.
#
#     Concatenation of the globals file and the output file should result in a
#     standaone executable CINT, where all APIs are called in the same order,
#     and where each API receives exactly the same inputs, as were seen during
#     log generation.
#


my $in_struct_or_arr = 0;
my $braces = 0;

my $PBMP_COUNT = 0;
my $PBMP = [];

my $UINT64_COUNT = 0;
my $UINT64 = [];

my $RX_REASONS_COUNT = 0;
my $RX_REASONS = [];

my @arrays;

#
# While the input file is not EOF, process it one line at a time.
#

while (<IFH>) {

    chomp;

    my $ln = $_;
    # holds the number of spaces (indentation) before any other output
    my $indent = "";

    # prefix and suffix are empty strings when not in array context. When in
    # array context, i.e. when processing array elements, prefix holds required
    # number of open curly braces { for the first element, and corresponding
    # number of spaces for all other elements. prefix is appended to indent.
    # Similarly suffix holds the required number of close curly braces for the
    # last element, or the empty string.

    my $prefix = "";
    my $suffix = "";

    # reduce all single-line comments to the empty string ("") so that we do
    # not end up matching on comments and generate output based on that.

    $ln =~ s/\/\*.*\*\///g;

    # All whitespace at the beginning of a line is its indentation. This
    # indentation is added to the output line from any of the matches below.

    if ($ln =~ /^(\s+)/) {
        $indent = $1;
    }

    # practically every first line of the output of cint_variable_print should
    # match this. Use this to determine array maths, required for
    # multi-dimensional arrays.

    # (1) SHR_BITDCL[1][9] _dest_array = {
    # (2) SHR_BITDCL _dest_array[0][0] = 1990921929 (0x76ab0ec9)
    # (3) SHR_BITDCL _dest_array[0][1] = 1990921929 (0x76ab0ec9)
    # (3) SHR_BITDCL _dest_array[0][8] = 1990921929 (0x76ab0ec9)
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=/) {


        # (1) $type: SHR_BITDCL[1][9] $name: _dest_array
        # (2) $type: SHR_BITDCL       $name: _dest_array[0][0]
        # (3) $type: SHR_BITDCL       $name: _dest_array[0][1]
        # (4) $type: SHR_BITDCL       $name: _dest_array[0][8]
        my ($type, $name) = ($1, $2);

        # (1) true
        # (2) false
        # (3) false
        # (4) false
        my $is_array_or_struct = ($ln =~ /\{\s*$/);

        # (1) passes this check, (2)(3)(4) fail
        if ($is_array_or_struct and $type =~ s/(\[[[:digit:]\[\]]+\])$//) {

            # (1) $arrbounds = [1][9]
            my $arrbounds = $1;

            my ($num_dimensions, @dimensions, @indices);

            # (1) $name: _dest_array[1][9]
            $name .= $arrbounds;

            while ($arrbounds =~ m/\[([[:digit:]]+)\]/g) {
                $num_dimensions++;
                push @dimensions, $1;
                push @indices, -1;
            }
            # (1) $num_dimensions = 2
            # (1) @dimensions = ( 1, 9 )
            # (1) @indices = (-1, -1)

            # a new array was found, push it to top of list
            unshift @arrays, {
                NAME => $name,
                NUM_DIMENSIONS => $num_dimensions,
                DIMENSIONS => \@dimensions,
                INDICES => \@indices,
            };

            #die "type is array, but line does not end in {: $ln" unless ($ln =~ m/\=\s+\{\s*$/g);

        # (2)(3)(4) pass this check
        } elsif ($name =~ m/(\[[[:digit:]\[\]]+\])$/) {

            # (2) $arrindices: [0][0]
            # (3) $arrindices: [0][1]
            # (4) $arrindices: [0][8]
            my $arrindices = $1;
            my ($num_indices, @indices);

            while ($arrindices =~ m/\[([[:digit:]]+)\]/g) {
                $num_indices++;
                push @indices, $1;
            }
            # (2) $num_indices: 2 @indices: (0,0)
            # (3) $num_indices: 2 @indices: (0,1)
            # (4) $num_indices: 2 @indices: (0,8)

            # to be found here, we must be already in a struct or array.
            die "unexpected array member: $ln" if (not $in_struct_or_arr or scalar @arrays == 0);

            my $arr = $arrays[0];

            #print Dumper($arr);

            #die "num indices != current array dimensions: $ln" unless ($num_indices == $arr->{NUM_DIMENSIONS});

            for (my $i = 0; $i < $num_indices; $i++) {
                die "array out of bounds: index $i: $ln" if ($indices[$i] >= $arr->{DIMENSIONS}->[$i]);
                my $stored_indices = $arr->{INDICES};
                die "unexpected index: index $i: $ln" if (($indices[$i] != $stored_indices->[$i]) and ($indices[$i] != ($stored_indices->[$i] + 1)));

                # a new entry begins when the associated index changes
                # and an open curly brace should be prefixed. This applies for
                # all dimensions except one for which the curly brace is
                # supplied by cint_variable_print.

                if ($indices[$i] != $stored_indices->[$i]) {
                    $stored_indices->[$i] = $indices[$i];
                    $prefix .= "{ " if ($i < ($num_indices-1));
                } else {
                    $prefix .= "  " if ($i < ($num_indices-1));
                }
            }

            # (2) $prefix: "{ "
            # (3) $prefix: "  "
            # (4) $prefix: "  "

            for (my $i = $num_indices -1; $i >= 0; $i--) {

                # loop will break here for (2) and (3) because second subscript
                # is less than dimension -1, i.e. not the last index

                last if ($indices[$i] < ($arr->{DIMENSIONS}->[$i]-1));

                # the first array dimension is already enclosed in close curly
                # brace by cint_variable_print. All other dimensions must be
                # closed by us.

                $suffix .= " }," if ($i < ($num_indices-1));

                # if the first array dimension also reached the final index,
                # then this array is completely processed. Pop it from the
                # list of open arrays.

                shift @arrays if ($i == 0);
            }

            # (2) $suffix: ""
            # (3) $suffix: ""
            # (4) $suffix: " },"
            # (4) array completed, and was popped
        }


        # we will be here for all lines. An open brace marks start of an array
        # or struct. Mark that, and keep runnnig counter for open-braces for
        # nested definitions. This counter is decremented when a stand-alone
        # close-brace is found (below)

        if ($ln =~ m/=\s+\{\s*$/) {
            my $infostr = "array or struct";

            $braces++;

            if ($in_struct_or_arr) {
                outputf(\*OFH, $indent, "{", $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "$type $name = {", $ln, $infostr);
                $in_struct_or_arr = 1;
            }

            next;
        }
    }

    # close braces \}
    if ($ln =~ /^\s*\}\s*$/) {
        my $infostr = "close brace";

        if ($in_struct_or_arr) {
            $braces--;
            if ($braces) {
                outputf(\*OFH, $indent, "}," . $suffix, $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "};", $ln, $infostr);
                $in_struct_or_arr = 0;
            }
            next;
        }
    }


    # prepend the computed prefix if any to the indentation

    $indent .= $prefix;

    # bcm_pbmp_t ports = { 1 2 201 }
    if ($ln =~ /^\s*bcm_pbmp_t\s+([[:alnum:]_\[\]]+)\s+=\s+{([[:space:][:digit:]]*)}\s*$/) {
        my ($name, $ports) = ($1, $2);
        my $infostr = "pbmp";

        $ports =~ s/^ //g;
        my @ports = sort { $a <=> $b } split / /, $ports;
        my $empty_pbmp = (0 == scalar @ports);

        my $existing_pbmp;
        for (my $ii = 0; scalar @ports and ($ii < scalar @$PBMP); $ii++) {
            my $ii_ports = $PBMP->[$ii];
            next if (scalar @$ii_ports != scalar @ports);
            my $equal = 1;
            for (my $jj = 0; $jj < scalar @ports; $jj++) {
                $equal = 0 if ($ii_ports->[$jj] != $ports[$jj]);
            }
            $infostr .= " (existing)", $existing_pbmp = $ii, last if ($equal);
        }

        if (not defined $existing_pbmp and not $empty_pbmp) {
            push @$PBMP, \@ports;
            $existing_pbmp = $PBMP_COUNT;
            $PBMP_COUNT++;
        }

        if ($in_struct_or_arr) {

            if ($empty_pbmp) {
                outputf(\*OFH, $indent, "EMPTY_PBMP," . $suffix, $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "PBMP_$existing_pbmp," . $suffix, $ln, $infostr);
            }
            next;
        }

        if ($empty_pbmp) {
            outputf(\*OFH, $indent, "bcm_pbmp_t $name = EMPTY_PBMP;", $ln, $infostr);
        } else {
            outputf(\*OFH, $indent, "bcm_pbmp_t $name = PBMP_$existing_pbmp;", $ln, $infostr);
            #outputf(\*OFH, $indent, "bcm_pbmp_t $name;\n", $ln, $infostr);
            #foreach my $port (@ports) {
            #    printf(OFH "%-80s\n", $indent . "BCM_PBMP_PORT_ADD($name, $port);");
            #}
        }

        next;
    }

    # uint64 value = {0x00000000 0x00000000}
    if ($ln =~ /^\s*(u?int64)\s+([[:alnum:]_\[\]]+)\s+=\s+{(0x[[:xdigit:]]+)\s+(0x[[:xdigit:]]+)}\s*$/) {
        my ($type, $name, $hi, $lo) = ($1, $2, $3, $4);
        my $is_zero = ((hex($hi) == 0) && (hex($lo) == 0));
        my $is_unsigned = ($type =~ /^u/);
        my $infostr = "u?int64";
        my $zero_64_name = ($is_unsigned ? "U" : "") . "INT64_ZERO";
        my $var_64_name  = ($is_unsigned ? "U" : "") . "INT64_$UINT64_COUNT";

        if ($in_struct_or_arr) {
            if ($is_zero || $zero_64b_nums) {
                outputf(\*OFH, $indent, "$zero_64_name," . $suffix, $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "$var_64_name," . $suffix, $ln, $infostr);
                push @$UINT64, { 'hi' => $hi, 'lo' => $lo, 'unsigned' => $is_unsigned };
                $UINT64_COUNT++;
            }
            next;
        }

        if ($is_zero) {
            outputf(\*OFH, $indent, "$type $name = $zero_64_name;", $ln, $infostr);
        } else {
            outputf(\*OFH, $indent, "$type $name;", $ln, $infostr);
            if ($is_unsigned) {
                outputf(\*OFH, $indent, "    COMPILER_64_SET(&$name, $hi, $lo);", $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "    $void_ptr_name = &$name;", $ln, $infostr);
                outputf(\*OFH, $indent, "    COMPILER_64_SET($void_ptr_name, $hi, $lo);", $ln, $infostr);
            }
        }

        next;
    }

    # bcm_rx_reasons_t reasons = Arp Bpdu
    if ($ln =~ /^\s*(bcm_rx_reasons_t)\s+([[:alnum:]_\[\]]+)\s+=\s+([[:alnum:][:space:]]+)\s*$/) {
        my ($type, $name, $reasons) = ($1, $2, $3);
        my $infostr = "bcm_rx_reasons";
        my $is_none = ($reasons eq 'None');
        my $none_reasons_name = "RX_REASONS_NONE";
        my $var_reasons_name = "RX_REASONS_$RX_REASONS_COUNT";

        if ($in_struct_or_arr) {
            if ($is_none) {
                outputf(\*OFH, $indent, "$none_reasons_name," . $suffix, $ln, $infostr);
            } else {
                outputf(\*OFH, $indent, "$var_reasons_name," . $suffix, $ln, $infostr);
                push @RX_REASONS, $reasons;
                $RX_REASONS_COUNT++;
            }
            next;
        }

        if ($is_none) {
            outputf(\*OFH, $indent, "$type $name = $none_reasons_name;", $ln, $infostr);
        } else {
            outputf(\*OFH, $indent, "$type $name;", $ln, $infostr);
            outputf(\*OFH, $indent, "    BCM_RX_REASON_CLEAR_ALL(&$name);", $ln, $infostr);
            foreach my $reason (split /\s+/, $reasons) {
                outputf(\*OFH, $indent, "    BCM_RX_REASON_SET(&$name, $bcmRxReason{$reason});", $ln, $infostr);
            }
        }

        next;
    }

    # char* api = 0xabcd1234 "bcm_vlan_port_create"
    if ($ln =~ /^\s*(char\*)\s+([[:alnum:]_\[\]]+)\s+=\s+(0x[[:xdigit:]]+|NULL)\s+(\".*\")\s*$/) {
        my ($type, $name, $val, $val2) = ($1, $2, $3, $4);
        my $infostr = "char* pointer";

        $val2 = $val if ($val eq "NULL");

        if ($in_struct_or_arr) {
            outputf(\*OFH, $indent, "$val2," . $suffix, $ln, $infostr);
            next;
        }

        outputf(\*OFH, $indent, "$type $name = $val2;", $ln, $infostr);
        next;
    }

    # bcm_field_stage_t stage = bcmFieldStageIngressPMF1 (11)
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=\s+([-[:alnum:]_]+)\s+\((-?[[:digit:]]+|0x[[:xdigit:]]+)\)( '.')?\s*$/) {
        my ($type, $name, $val, $val2) = ($1, $2, $3, $4);
        my $infostr = "enum or int or char";

        #$val = $val2 if ($val < 0);

        if ($in_struct_or_arr) {
            outputf(\*OFH, $indent, "$val," . $suffix, $ln, $infostr);
            next;
        }

        if ($type =~ s/(\[[[:digit:]]+\])$//) {
            $name .= $1;
        }
        outputf(\*OFH, $indent, "$type $name = $val;", $ln, $infostr);
        next;
    }

    # bcm_field_qualify_t qual_id = <invalid enum> (2181)
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=\s+<invalid enum>\s+\((-?[[:digit:]]+|0x[[:xdigit:]]+)\)\s*$/) {
        my ($type, $name, $val) = ($1, $2, $3);
        my $infostr = "invalid enum";

        #$val = $val2 if ($val < 0);

        if ($in_struct_or_arr) {
           outputf(\*OFH, $indent, "$val," . $suffix, $ln, $infostr);
           next;
        }

        if ($type =~ s/(\[[[:digit:]]+\])$//) {
           $name .= $1;
        }

        outputf(\*OFH, $indent, "$type $name = $val;", $ln, $infostr);
        next;
    }

    # uint8[6] l3a_nexthop_mac = 84:05:53:3A:AF:34
    # uint8[16] l3a_ip6_net = cb9c:d386:0ed1:c5bb:2b2d:bcbb:4d2e:d9bd
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=\s+([[:xdigit:]:]+)\s*$/) {
        my ($type, $name, $val) = ($1, $2, $3);
        my $infostr = "mac or ipv6";

        $val =~ s/://g;
        $val =~ s/([[:xdigit:]]{2})/0x$1,/g;
        $val = "{ " . $val . " }";

        if ($in_struct_or_arr) {
            outputf(\*OFH, $indent, "$val," . $suffix, $ln, $infostr);
            next;
        }

        if ($type =~ s/(\[[[:digit:]]+\])$//) {
            $name .= $1;
        }

        outputf(\*OFH, $indent, "$type $name = $val;", $ln, $infostr);
        next;
    }

    # ip address
    # uint32 l3a_subnet = 192.168.0.1
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=\s+([[:digit:].]+)\s*$/) {
        my ($type, $name, $val) = ($1, $2, $3);
        my $infostr = "ip address";

        $val = "0x" . join('', map(unpack("H*", pack("C", $_)), split(/\./, $val)));

        if ($in_struct_or_arr) {
            outputf(\*OFH, $indent, "$val," . $suffix, $ln, $infostr);
            next;
        }

        if ($type =~ s/(\[[[:digit:]]+\])$//) {
            $name .= $1;
        }

        outputf(\*OFH, $indent, "$type $name = $val;", $ln, $infostr);
        next;
    }

    # int *ptr = 0x100
    if ($ln =~ /^\s*([[:alnum:][:space:]_\[\]\*]+)\s+([[:alnum:]_\[\]]+)\s+=\s+([[:alnum:]_]+|[[:digit:]]+|0x[[:xdigit:]]+)\s*$/) {
        my ($type, $name, $val) = ($1, $2, $3);
        my $infostr = "pointer";

        if ($in_struct_or_arr) {
            outputf(\*OFH, $indent, "(void*)$val," . $suffix, $ln, $infostr);
            next;
        }

        if ($type =~ s/(\[[[:digit:]]+\])$//) {
            $name .= $1;
        }

        outputf(\*OFH, $indent, "$type $name = (void*)$val;", $ln, $infostr);
        next;
    }

    # Remove the if (0) checks
    if ($ln =~ /^\s+if \(0\) \{\s*$/) {
        my $infostr = "remove if(0)";

        my $newln = $ln;
        $newln =~ s/if \(0\) //;
        outputf(\*OFH, "", $newln, $ln, $infostr);
        next;
    }

    my $infostr = "used as-is";
    outputf(\*OFH, "", "$ln", $ln, $infostr);

}

# inputfile reached EOF


# Write the bcm_pbmp_t and uint64 type values to the global file. First write
# the variables holding ZERO u?int64 values and the one holding the empty pbmp.

print GFH "
    void *$void_ptr_name;

    uint64 UINT64_ZERO;
        COMPILER_64_ZERO(&UINT64_ZERO);

    int64  INT64_ZERO;
        $void_ptr_name = &INT64_ZERO;
        COMPILER_64_ZERO($void_ptr_name);

    bcm_pbmp_t EMPTY_PBMP;
        BCM_PBMP_CLEAR(EMPTY_PBMP);

    bcm_pbmp_t ALL_PBMP;
        BCM_PBMP_CLEAR(ALL_PBMP);
        {
            int pp;
            for (pp = 0; pp <= BCM_PBMP_PORT_MAX; pp++) {
                BCM_PBMP_PORT_ADD(ALL_PBMP, pp);
            }
        }

    bcm_rx_reasons_t RX_REASONS_NONE;
        BCM_RX_REASON_CLEAR_ALL(&RX_REASONS_NONE);
";


# Write variables for pbmp constants found while processing the input file
$indent = ' ' x 4;

$PBMP_COUNT = 0;
foreach my $ports (@$PBMP) {
    my $name = "PBMP_$PBMP_COUNT";
    printf(GFH "%sbcm_pbmp_t $name;\n", $indent);
    printf(GFH "%s    BCM_PBMP_CLEAR($name);\n", $indent);
    foreach my $port (@$ports) {
        printf(GFH "%s    BCM_PBMP_PORT_ADD($name, $port);\n", $indent);
    }
    printf(GFH "\n");
    $PBMP_COUNT++;
}

# Write variables for u?int64 constants found while processing the input file

$UINT64_COUNT = 0;
foreach my $uint64 (@$UINT64) {

    my $is_unsigned = $uint64->{'unsigned'};
    my $type = ($is_unsigned ? "u" : "") . "int64";
    my $name = ($is_unsigned ? "U" : "") . "INT64_$UINT64_COUNT";

    printf(GFH "%s$type $name;\n", $indent);
    if ($is_unsigned) {
        printf(GFH "%s    COMPILER_64_SET(&$name, %s, %s);\n", $indent, $uint64->{'hi'}, $uint64->{'lo'});
    } else {
        printf(GFH "%s    $void_ptr_name = &$name;\n", $indent);
        printf(GFH "%s    COMPILER_64_SET($void_ptr_name, %s, %s);\n", $indent, $uint64->{'hi'}, $uint64->{'lo'});
    }
    printf(GFH "\n");

    $UINT64_COUNT++;
}

# Write variables for bcm_rx_reasons_t constants found while processing the
# input file

$RX_REASONS_COUNT = 0;
foreach my $reasons (@RX_REASONS) {
    my $name = "RX_REASONS_$RX_REASONS_COUNT";
    printf(GFH "%sbcm_rx_reasons_t $name;\n", $indent);
    printf(GFH "%s    BCM_RX_REASON_CLEAR_ALL(&$name);\n", $indent);
    foreach my $reason (split /\s+/, $reasons) {
        printf(GFH "%s    BCM_RX_REASON_SET(&$name, $bcmRxReason{$reason});\n", $indent);
    }
    $RX_REASONS_COUNT++;
}

# Close all file handles

close IFH;
close OFH;
close GFH;

exit(0);
