/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: INTERNAL/regs/xgs/generate-chip.pl
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcmdrd/bcmdrd_types.h>
#include <bcmdrd/bcmdrd_chip.h>
#include <bcmdrd/bcmdrd_field.h>
#include <bcmdrd/chip/bcm56990_a0_defs.h>
#include <bcmdrd/chip/bcm56990_a0_sig.h>

/* Block types */
const char *bcm56990_a0_drd_blktype_names[] = {
    "null",
    "avs",
    "cdport",
    "cmic",
    "epipe",
    "flex_ctr",
    "ipipe",
    "iproc",
    "lbport",
    "mgmt_obm",
    "mmu_eb",
    "mmu_glb",
    "mmu_itm",
    "pfc_collector",
    "port_if",
    "ser",
    "top",
    "xlport"
};

/* Block structures */
bcmdrd_block_t bcm56990_a0_drd_blocks[] =
{
    { BLKTYPE_CDPORT,                   16,   {{0x0000001e}} },
    { BLKTYPE_CDPORT,                   17,   {{0x000001e0}} },
    { BLKTYPE_CDPORT,                   18,   {{0x00001e00}} },
    { BLKTYPE_CDPORT,                   19,   {{0x0001e000}} },
    { BLKTYPE_CDPORT,                   20,   {{0x001e0000}} },
    { BLKTYPE_CDPORT,                   21,   {{0x01e00000}} },
    { BLKTYPE_CDPORT,                   22,   {{0x1e000000}} },
    { BLKTYPE_CDPORT,                   23,   {{0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   24,   {{0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   25,   {{0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   26,   {{0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   27,   {{0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   28,   {{0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   29,   {{0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   30,   {{0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   31,   {{0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   32,   {{0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   33,   {{0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   34,   {{0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   35,   {{0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   36,   {{0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   37,   {{0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   38,   {{0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   39,   {{0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   40,   {{0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   41,   {{0x00000000, 0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   42,   {{0x00000000, 0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   43,   {{0x00000000, 0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   44,   {{0x00000000, 0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   45,   {{0x00000000, 0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   46,   {{0x00000000, 0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   47,   {{0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   48,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   49,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   50,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   51,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   52,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   53,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   54,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   55,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   56,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   57,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   58,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   59,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   60,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   61,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   62,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   63,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   64,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   65,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   66,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   67,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   68,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   69,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   70,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   71,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   72,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_CDPORT,                   73,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001e0}} },
    { BLKTYPE_CDPORT,                   74,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001e00}} },
    { BLKTYPE_CDPORT,                   75,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001e000}} },
    { BLKTYPE_CDPORT,                   76,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x001e0000}} },
    { BLKTYPE_CDPORT,                   77,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01e00000}} },
    { BLKTYPE_CDPORT,                   78,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1e000000}} },
    { BLKTYPE_CDPORT,                   79,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   80,   {{0x00000000}} },
    { BLKTYPE_CDPORT,                   81,   {{0x00000000}} },
    { BLKTYPE_CDPORT,                   82,   {{0x00000000}} },
    { BLKTYPE_CDPORT,                   83,   {{0x00000000}} },
    { BLKTYPE_LBPORT,                   91,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008}} },
    { BLKTYPE_LBPORT,                   92,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010}} },
    { BLKTYPE_LBPORT,                   93,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000020}} },
    { BLKTYPE_LBPORT,                   94,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000040}} },
    { BLKTYPE_LBPORT,                   95,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000080}} },
    { BLKTYPE_LBPORT,                   96,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100}} },
    { BLKTYPE_LBPORT,                   97,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000200}} },
    { BLKTYPE_LBPORT,                   98,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400}} },
    { BLKTYPE_XLPORT,                   12,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006}} },
    { BLKTYPE_IPIPE,                     1,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}} },
    { BLKTYPE_EPIPE,                     2,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}} },
    { BLKTYPE_MMU_ITM,                   3,   {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}} },
    { BLKTYPE_MMU_EB,                    4,   {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}} },
    { BLKTYPE_MMU_GLB,                   5,   {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}} },
    { BLKTYPE_TOP,                       8,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} },
    { BLKTYPE_SER,                       9,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} },
    { BLKTYPE_IPROC,                    11,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} },
    { BLKTYPE_AVS,                      87,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} },
    { BLKTYPE_FLEX_CTR,                 88,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}} },
    { BLKTYPE_PORT_IF,                  89,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}} },
    { BLKTYPE_PFC_COLLECTOR,            90,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} },
    { BLKTYPE_MGMT_OBM,                 101,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}} }
};

const int bcm56990_a0_drd_blktype_start_idx[] = {
    0, 85, 0, 0, 78, 86, 77, 84, 68, 89, 80, 81, 79, 88, 87, 83, 82, 76
};

/* Symbol table */
#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
extern bcmdrd_symbols_t bcm56990_a0_drd_symbols;
#endif

/* Declare function first to prevent compiler warnings */
extern uint32_t
bcm56990_a0_drd_blockport_addr(int block, int lane, uint32_t offset,
                               uint32_t idx);

uint32_t
bcm56990_a0_drd_blockport_addr(int block, int lane, uint32_t offset,
                               uint32_t idx)
{
    uint32_t addr;

    if (lane < 0) {
        /* Default block/port calculation for memories */
        addr = offset;
        addr += idx;
    } else {
        /* Default block/port calculation for registers */
        if (block == 12 && lane == 1) {
            lane = 2;
        }
        addr = (offset | lane);
        /* XLPORT uses SBUS v4, and its block number is 12 */
        if (block == 12) {
            addr += (idx << 8);
        } else {
            addr += (idx << 10);
        }
    }
    return addr;
}

/* Declare function first to prevent compiler warnings */
extern int
bcm56990_a0_drd_addr_decode(const bcmdrd_symbol_t *symbol,
                            int block, uint32_t addr,
                            uint32_t *idx, uint32_t *lane);

int
bcm56990_a0_drd_addr_decode(const bcmdrd_symbol_t *symbol,
                            int block, uint32_t addr,
                            uint32_t *idx, uint32_t *lane)
{
    uint32_t diff = 0, port_num = 0;
    uint32_t addr_mask, offset_mask;
    uint32_t mask;

    /* Check for Stage ID and basetype. */
    mask = 0xff800000;
    if ((addr & mask) != (symbol->addr & mask)) {
        return -1;
    }

    /* Mask the Stage ID and basetype. */
    mask = ~mask;
    addr_mask = addr & mask;
    offset_mask = symbol->addr & mask;

    if (addr_mask < offset_mask) {
        return -1;
    }

    diff = addr_mask - offset_mask;
    if (symbol->flags & BCMDRD_SYMBOL_FLAG_REGISTER) {
        /* XLPORT uses SBUS v4, and its block number is 12 */
        if (block == 12) {
            port_num = diff & 0xff;
            if (port_num == 2) {
                 port_num = 1;
            }
            diff = diff >> 8;
        } else {
            port_num = diff & 0x3ff;
            diff = diff >> 10;
        }
    }
    if (idx) {
        *idx = diff;
    }
    if (lane) {
        *lane = port_num;
    }
    return 0;
}

/* Declare function first to prevent compiler warnings */
extern bcmdrd_port_num_domain_t
bcm56990_a0_drd_port_num_domain(bcmdrd_sid_t sid, int blktype);

bcmdrd_port_num_domain_t
bcm56990_a0_drd_port_num_domain(bcmdrd_sid_t sid, int blktype)
{
    switch (sid) {
    case MMU_CRB_DEVICE_PORT_TO_MMU_PORT_MAPPINGr:
        return BCMDRD_PND_LOGIC;
    default:
        break;
    }
    switch (blktype) {
    case BLKTYPE_IPIPE:
    case BLKTYPE_EPIPE:
    case BLKTYPE_FLEX_CTR:
    case BLKTYPE_PORT_IF:
    case BLKTYPE_MGMT_OBM:
        return BCMDRD_PND_LOGIC;
    case BLKTYPE_MMU_GLB:
    case BLKTYPE_MMU_ITM:
    case BLKTYPE_MMU_EB:
        return BCMDRD_PND_MMU;
    default:
        break;
    }
    return BCMDRD_PND_PHYS;
}

/* Declare function first to prevent compiler warnings */
extern int
bcm56990_a0_drd_blktype_from_porttype(bcmdrd_port_type_t ptype);

int
bcm56990_a0_drd_blktype_from_porttype(bcmdrd_port_type_t ptype)
{
    if (ptype == BCMDRD_PORT_TYPE_LB) {
        return BLKTYPE_LBPORT;
    }
    return -1;
}

/* Declare function first to prevent compiler warnings */
extern uint32_t
bcm56990_a0_drd_pipe_info(const bcmdrd_chip_info_t *cinfo,
                          bcmdrd_pipe_info_t *pi,
                          bcmdrd_pipe_info_type_t pi_type);

uint32_t
bcm56990_a0_drd_pipe_info(const bcmdrd_chip_info_t *cinfo,
                          bcmdrd_pipe_info_t *pi,
                          bcmdrd_pipe_info_type_t pi_type)
{
    /* Base types */
#define BT_IPORT            0
#define BT_EPORT            1
#define BT_IPIPE            2
#define BT_EPIPE            3
#define BT_CHIP             4
#define BT_ITM              5

#define BT_DECODE(_ofs) (((_ofs) >> 23) & 0x7)

    /* Access types */
#define AT_DUPLICATE        17
#define AT_SINGLE           28
#define AT_ADDR_SPLIT_DIST  18
#define AT_ADDR_SPLIT_SPLIT 20
#define AT_DATA_SPLIT       22
#define AT_DUPLICATE2       23
#define AT_UNIQUE           31

    /* Per-pipe memory section size */
#define SECT_SHFT_16K   14

#define MMUPORT_IN_PIPE(_m, _p) \
    (((_m) >= ((_p) * 32)) && ((_m) < (((_p) * 32) + 17)))

    /* Transparent information */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_AT_UNIQUE_GLOBAL) {
        return AT_DUPLICATE;
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_NUM_PIPE_INST) {
        if (pi == NULL) {
            /* Get the number of pipes for the device. */
            return 16;
        }
        /* Get the number of block-based pipes for the device. */
        switch (pi->blktype) {
        case BLKTYPE_IPIPE:
        case BLKTYPE_EPIPE:
        case BLKTYPE_FLEX_CTR:
            return 4;
        case BLKTYPE_MMU_EB:
        case BLKTYPE_PORT_IF:
            return 16;
        case BLKTYPE_MMU_ITM:
            return 2;
        default:
            return 1;
        }
    }

    if (pi == NULL) {
        return 0;
    }

    /* Return the pipe index for a given physical device port. */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PIPE_INDEX_FROM_PORT) {
        uint32_t pipe_idx = 0;

        if (pi->pnd == BCMDRD_PND_PHYS) {
            if (pi->port >= 1 && pi->port <= 256) {
                pipe_idx = (pi->port - 1) >> 4;
            } else if (pi->port == 0) {
                pipe_idx = 0;
            } else if (pi->port == 259) {
                pipe_idx = 1;
            } else if (pi->port == 258) {
                pipe_idx = 2;
            } else if (pi->port == 260) {
                pipe_idx = 3;
            } else if (pi->port == 267) {
                pipe_idx = 4;
            } else if (pi->port == 261) {
                pipe_idx = 5;
            } else if (pi->port == 268) {
                pipe_idx = 6;
            } else if (pi->port == 262) {
                pipe_idx = 7;
            } else if (pi->port == 257) {
                pipe_idx = 8;
            } else if (pi->port == 263) {
                pipe_idx = 9;
            } else if (pi->port == 269) {
                pipe_idx = 10;
            } else if (pi->port == 264) {
                pipe_idx = 11;
            } else if (pi->port == 270) {
                pipe_idx = 12;
            } else if (pi->port == 265) {
                pipe_idx = 13;
            } else if (pi->port == 271) {
                pipe_idx = 14;
            } else if (pi->port == 266) {
                pipe_idx = 15;
            }
        } else if (pi->pnd == BCMDRD_PND_LOGIC) {
            if (pi->port >= 0 && pi->port < 272) {
                pipe_idx = pi->port / 17;
            }
        } else if (pi->pnd == BCMDRD_PND_MMU) {
            if (pi->port >= 0 && pi->port <= 496) {
                pipe_idx = pi->port >> 5;
            }
        }
        return pipe_idx;
    }

    /* Get valid instance maps from device valid instance maps (pi->pipe_map) */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BLK_PIPE_MAP) {
        uint32_t blk_pipe, blk_pipe_map = 0;

        /*
         * IPEP Pipe mapping
         *
         * Chip    IPEP   ITM
         * ------------------
         * 0       0       0
         * 1       0       0
         * 2       0       0
         * 3       0       0
         * 4       1       1
         * 5       1       1
         * 6       1       1
         * 7       1       1
         * 8       2       1
         * 9       2       1
         * 10      2       1
         * 11      2       1
         * 12      3       0
         * 13      3       0
         * 14      3       0
         * 15      3       0
         */
        if (pi->blktype == BLKTYPE_IPIPE || pi->blktype == BLKTYPE_EPIPE ||
            pi->blktype == BLKTYPE_FLEX_CTR) {
            for (blk_pipe = 0; blk_pipe < 4; blk_pipe++) {
                if (pi->pipe_map & (0xf << (4 * blk_pipe))) {
                    blk_pipe_map |= (1 << blk_pipe);
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            if (pi->pipe_map & 0xf00f) {
                blk_pipe_map |= 0x1;
            }
            if (pi->pipe_map & 0xff0) {
                blk_pipe_map |= 0x2;
            }
        }
        return blk_pipe_map;
    }

    /* Information without base type */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PMASK) {
        /* Unique block instances */
        uint32_t inst_mask = 0;

        if (pi->acctype == AT_UNIQUE) {
            switch (pi->blktype) {
            case BLKTYPE_IPIPE:
            case BLKTYPE_EPIPE:
            case BLKTYPE_FLEX_CTR:
                inst_mask = 0xf;
                break;
            case BLKTYPE_MMU_EB:
            case BLKTYPE_PORT_IF:
                inst_mask = 0xffff;
                break;
            case BLKTYPE_MMU_ITM:
                inst_mask = 0x3;
                break;
            default:
                inst_mask = 0x1;
                break;
            }
        }
        return inst_mask;
    }

    /* Information with base type, without base index */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_LINST) {
        /* Basetype instances */
        uint32_t num_inst = 0;
        uint32_t base_type = BT_DECODE(pi->offset);

        switch (pi->blktype) {
        case BLKTYPE_MMU_GLB:
        case BLKTYPE_MMU_ITM:
        case BLKTYPE_MMU_EB:
            switch (base_type) {
            case BT_IPORT:
            case BT_EPORT:
                num_inst = 497;
                break;
            case BT_IPIPE:
            case BT_EPIPE:
                num_inst = 16;
                if (pi->acctype < 16) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_ITM:
                num_inst = 2;
                if (pi->acctype < 16) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_CHIP:
                num_inst = 1;
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return num_inst;
    } else if (pi_type == BCMDRD_PIPE_INFO_TYPE_SECT_SHFT) {
        uint32_t sect_shft = 0;
        uint32_t base_type = BT_DECODE(pi->offset);

        switch (pi->blktype) {
        case BLKTYPE_MMU_ITM:
            switch (base_type) {
            case BT_ITM:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            case BT_IPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            case BT_EPIPE:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_EB:
            switch (base_type) {
            case BT_ITM:
            case BT_IPIPE:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            case BT_EPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_GLB:
            switch (base_type) {
            case BT_ITM:
            case BT_IPIPE:
            case BT_EPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_16K;
                }
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return sect_shft;
    }

    /* Information with base type and base index */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASETYPE_PMASK ||
        pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
        /* Valid unique block instances for specific baseidx */
        uint32_t inst_mask = 0;
        uint32_t base_type = BT_DECODE(pi->offset);
        int baseidx = pi->baseidx;

        if (baseidx < 0) {
            return 0;
        }

        if (pi->blktype == BLKTYPE_MMU_EB) {
            if (base_type == BT_IPORT || base_type == BT_EPORT) {
                int idx;
                for (idx = 0; idx < 16; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        inst_mask = 0xffff;
                        break;
                    }
                }
            } else if (base_type == BT_IPIPE) {
                if (baseidx < 16) {
                    inst_mask = 0xffff;
                }
            } else if (base_type == BT_EPIPE) {
                if (baseidx < 16) {
                    inst_mask = (1 << baseidx);
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    inst_mask = 0xffff;
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            if (base_type == BT_IPORT || base_type == BT_EPORT) {
                int idx;

                for (idx = 0; idx < 16; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        inst_mask = 0x3;
                        break;
                    }
                }
            } else if (base_type == BT_IPIPE || base_type == BT_EPIPE) {
                if (baseidx < 16) {
                    inst_mask = 0x3;
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    inst_mask = (1 << baseidx);
                }
            }
        }

        if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
            /*
             * If access type is UNIQUE_PIPE_#, need to check
             * whether the pipe is in BASETYPE_PAMSK inst_mask.
             */
            if (inst_mask != 0 && pi->acctype < 16 &&
                ((1 << pi->acctype) & inst_mask) == 0) {
                return 1;
            }
            return 0;
        }
        return inst_mask;
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASETYPE_SINGLE_PMASK) {
        uint32_t base_type = BT_DECODE(pi->offset);
        int baseidx = pi->baseidx;

        if (baseidx < 0) {
            return 0;
        }

        if (pi->acctype != AT_SINGLE) {
            return 0;
        }
        if (pi->blktype == BLKTYPE_MMU_EB) {
            if (base_type == BT_EPORT) {
                int idx;

                for (idx = 0; idx < 16; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        return (1 << idx);
                    }
                }
            } else if (base_type == BT_EPIPE) {
                if (baseidx < 16) {
                    return (1 << baseidx);
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            if (base_type == BT_IPORT) {
                int idx;

                for (idx = 0; idx < 16; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        if (idx < 4 || idx > 11) {
                            return 1;
                        } else {
                            return 2;
                        }
                    }
                }
            } else if (base_type == BT_IPIPE) {
                if (baseidx < 4 || baseidx > 11) {
                    return 1;
                } else if (baseidx < 16){
                    return 2;
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    return (1 << baseidx);
                }
            }
        }
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_SUB_PIPE_MAP) {
        if (pi->pipe_inst >= 0 && pi->pipe_inst < 4 &&
            pi->sub_pipe_inst >= 0 && pi->sub_pipe_inst < 2) {
            return (0x3 << (pi->pipe_inst * 4 + pi->sub_pipe_inst * 2));
        }
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_MEMIDX_INVALID) {
        if (pi->acctype == AT_ADDR_SPLIT_SPLIT) {
            /* Indexed by logical port number  */
            if (!BCMDRD_PBMP_MEMBER(cinfo->valid_pbmps[BCMDRD_PND_LOGIC],
                                    pi->memidx)) {
                return 1;
            }
        } else if (pi->acctype == AT_ADDR_SPLIT_DIST) {
            if (pi->blktype == BLKTYPE_IPIPE || pi->blktype == BLKTYPE_EPIPE) {
                /* Per logical port maps to more than 1 entry */
                int ent_num = (pi->memidx_max + 1) / 272;
                if (!BCMDRD_PBMP_MEMBER(cinfo->valid_pbmps[BCMDRD_PND_LOGIC],
                                        pi->memidx / ent_num)) {
                    return 1;
                }
            } else if (pi->blktype == BLKTYPE_PORT_IF) {
                /* Indexed by physical port number */
                if (!BCMDRD_PBMP_MEMBER(cinfo->valid_pbmps[BCMDRD_PND_PHYS],
                                        pi->memidx)) {
                    return 1;
                }
            }
        }
        return 0;
    }

    return 0;
}

/* Index ranges for this chip */
static bcmdrd_numel_range_t _numel_ranges[] = {
    {  0,  0, {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}} }, /*  0 */
    {  0,  0, {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}} }, /*  1 */
    {  0,  0, {{0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff, 0x0000ffff}} }, /*  2 */
    {  0,  1, {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}} }  /*  3 */
};

/* Register array encodings for this chip */
static bcmdrd_numel_encoding_t _numel_encodings[] = {
    { { 5 } },
    { {  0, -1 } },
    { {  1, -1 } },
    { {  2, -1 } },
    { {  3, -1 } }
};

/* Variable register array info */
bcmdrd_numel_info_t bcm56990_a0_drd_numel_info = {
    _numel_ranges,
    _numel_encodings
};

/* Chip information structure */
bcmdrd_chip_info_t bcm56990_a0_drd_chip_info = {

    /* Register file digest. */
    BCM56990_A0_SIGNATURE,

    /* HMI protocol (typically S-bus address format version). */
    6,

    /* HMI block (typically CMIC block number). */
    CMIC_BLOCK,

    /* Other (non-HMI) block types */
    18,
    bcm56990_a0_drd_blktype_names,
    bcm56990_a0_drd_blktype_start_idx,

    /* Other (non-HMI) blocks */
    90,
    bcm56990_a0_drd_blocks,

    /* Valid ports for this chip */
    {
        /* Valid physical ports for this chip */
        {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000007ff}},
        /* Valid logical ports for this chip */
        {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000ffff}},
        /* Valid MMU ports for this chip */
        {{0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff, 0x0001ffff}}
    },

    /* Chip flags */
    0,

#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
    /* Use the static per-chip symbol tables */
    &bcm56990_a0_drd_symbols,
#endif

    /* Variable register array info */
    &bcm56990_a0_drd_numel_info,

    /* Chip profile */
    NULL,

    /* Address calculation override */
    bcm56990_a0_drd_blockport_addr,

    /* Address decoder override */
    bcm56990_a0_drd_addr_decode,

    /* Port number domain */
    bcm56990_a0_drd_port_num_domain,

    /* Get device-specific block type from generic port type */
    bcm56990_a0_drd_blktype_from_porttype,

    /* Pipe info */
    bcm56990_a0_drd_pipe_info

};
