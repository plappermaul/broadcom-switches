/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: INTERNAL/regs/xgs/generate-chip.pl
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcmdrd/bcmdrd_types.h>
#include <bcmdrd/bcmdrd_chip.h>
#include <bcmdrd/bcmdrd_field.h>
#include <bcmdrd/chip/bcm56880_a0_defs.h>
#include <bcmdrd/chip/bcm56880_a0_sig.h>

/* Block types */
const char *bcm56880_a0_drd_blktype_names[] = {
    "null",
    "avs",
    "cdport",
    "cev",
    "cmic",
    "epipe",
    "ipipe",
    "iproc",
    "lbport",
    "mmu_eb",
    "mmu_glb",
    "mmu_itm",
    "port_if",
    "ser",
    "top",
    "xlport"
};

/* Block structures */
bcmdrd_block_t bcm56880_a0_drd_blocks[] =
{
    { BLKTYPE_CDPORT,                   16,   {{0x000001fe}} },
    { BLKTYPE_CDPORT,                   17,   {{0x0001fe00}} },
    { BLKTYPE_CDPORT,                   18,   {{0x01fe0000}} },
    { BLKTYPE_CDPORT,                   19,   {{0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   20,   {{0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   21,   {{0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   22,   {{0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   23,   {{0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   24,   {{0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   25,   {{0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   26,   {{0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   27,   {{0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   28,   {{0x00000000, 0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   29,   {{0x00000000, 0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   30,   {{0x00000000, 0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   31,   {{0x00000000, 0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   32,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   33,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   34,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   35,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   36,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   37,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   38,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   39,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   40,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   41,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   42,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   43,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   44,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001fe}} },
    { BLKTYPE_CDPORT,                   45,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0001fe00}} },
    { BLKTYPE_CDPORT,                   46,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01fe0000}} },
    { BLKTYPE_CDPORT,                   47,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xfe000000, 0x00000001}} },
    { BLKTYPE_CDPORT,                   83,   {{0x00000000}} },
    { BLKTYPE_LBPORT,                   48,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000020}} },
    { BLKTYPE_LBPORT,                   49,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000040}} },
    { BLKTYPE_LBPORT,                   50,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000080}} },
    { BLKTYPE_LBPORT,                   51,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100}} },
    { BLKTYPE_XLPORT,                   12,   {{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000001e}} },
    { BLKTYPE_IPIPE,                     1,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}} },
    { BLKTYPE_EPIPE,                     2,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}} },
    { BLKTYPE_MMU_ITM,                   3,   {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}} },
    { BLKTYPE_MMU_EB,                    4,   {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}} },
    { BLKTYPE_MMU_GLB,                   5,   {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}} },
    { BLKTYPE_TOP,                       8,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}} },
    { BLKTYPE_SER,                       9,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}} },
    { BLKTYPE_IPROC,                    11,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}} },
    { BLKTYPE_AVS,                      87,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}} },
    { BLKTYPE_CEV,                      88,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}} },
    { BLKTYPE_PORT_IF,                  89,   {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}} }
};

const int bcm56880_a0_drd_blktype_start_idx[] = {
    0, 46, 0, 47, 0, 39, 38, 45, 33, 41, 42, 40, 48, 44, 43, 37
};

/* Symbol table */
#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
extern bcmdrd_symbols_t bcm56880_a0_drd_symbols;
#endif

/* Declare function first to prevent compiler warnings */
extern uint32_t
bcm56880_a0_drd_blockport_addr(int block, int lane, uint32_t offset,
                               uint32_t idx);

uint32_t
bcm56880_a0_drd_blockport_addr(int block, int lane, uint32_t offset,
                               uint32_t idx)
{
    uint32_t addr;

    if (lane < 0) {
        /* Default block/port calculation for memories */
        addr = offset;
        addr += idx;
    } else {
        if (block == 1 || block == 2 || block == 88 ) {
            /*
             * Transform to XFS format for IPIPE, EPIPE and CEV blocks.
             * No Indexed registers under XFS.
             */
            addr = ((offset << 1) & 0x7fffff) | lane;
            addr |= (((offset & 0x2000000) ^ 0x2000000) >> 2);
        } else {
            /* Default block/port calculation for registers */
            addr = (offset | lane);
            addr += (idx << 8);
        }
    }
    return addr;
}

/* Declare function first to prevent compiler warnings */
extern int
bcm56880_a0_drd_addr_decode(const bcmdrd_symbol_t *symbol,
                            int block, uint32_t addr,
                            uint32_t *idx, uint32_t *lane);

int
bcm56880_a0_drd_addr_decode(const bcmdrd_symbol_t *symbol,
                            int block, uint32_t addr,
                            uint32_t *idx, uint32_t *lane)
{
    uint32_t diff = 0, port_num = 0;
    uint32_t addr_mask, offset_mask;
    uint32_t mask;
    uint32_t xfs_addr;

    if (block == 1 || block == 2 || block == 88 ) {
        /* XFS format address for IPIPE, EPIPE and CEV blocks  */
        if (symbol->flags & BCMDRD_SYMBOL_FLAG_MEMORY) {
            /* Check for MEMSEL */
            if ((addr & 0xfff0000) != (symbol->addr & 0xfff0000)) {
                return -1;
            }
            addr_mask = addr & 0xffff;
            offset_mask = symbol->addr & 0xffff;
            if (addr_mask < offset_mask) {
                return -1;
            }
            diff = addr_mask - offset_mask;
        } else {
            xfs_addr = (symbol->addr << 1) & 0x7fffff;
            xfs_addr |= (((symbol->addr & 0x2000000) ^ 0x2000000) >> 2);
            /* Check for REGTYPE and REGSEL */
            mask = 0xfffe00;
            if ((addr & mask) != (xfs_addr & mask)) {
                return -1;
            }
            port_num = addr & 0x1ff;
            diff = 0;
        }
    } else {
        /* Check for Stage ID and basetype. */
        mask = 0xff800000;
        if ((addr & mask) != (symbol->addr & mask)) {
            return -1;
        }
        /* Mask the Stage ID and basetype. */
        mask = ~mask;
        addr_mask = addr & mask;
        offset_mask = symbol->addr & mask;
        if (addr_mask < offset_mask) {
            return -1;
        }
        diff = addr_mask - offset_mask;
        if (symbol->flags & BCMDRD_SYMBOL_FLAG_REGISTER) {
            port_num = diff & 0xff;
            diff = diff >> 8;
        }
    }
    if (idx) {
        *idx = diff;
    }
    if (lane) {
        *lane = port_num;
    }
    return 0;
}

/* Declare function first to prevent compiler warnings */
extern bcmdrd_port_num_domain_t
bcm56880_a0_drd_port_num_domain(bcmdrd_sid_t sid, int blktype);

bcmdrd_port_num_domain_t
bcm56880_a0_drd_port_num_domain(bcmdrd_sid_t sid, int blktype)
{
    switch (sid) {
    case MMU_CRB_DEVICE_PORT_TO_MMU_PORT_MAPPINGr:
    case MMU_RQE_REPL_PORT_AGG_MAPr:
        return BCMDRD_PND_LOGIC;
    default:
        break;
    }
    switch (blktype) {
    case BLKTYPE_IPIPE:
    case BLKTYPE_EPIPE:
    case BLKTYPE_PORT_IF:
        return BCMDRD_PND_LOGIC;
    case BLKTYPE_MMU_GLB:
    case BLKTYPE_MMU_ITM:
    case BLKTYPE_MMU_EB:
        return BCMDRD_PND_MMU;
    default:
        break;
    }
    return BCMDRD_PND_PHYS;
}

/* Declare function first to prevent compiler warnings */
extern int
bcm56880_a0_drd_blktype_from_porttype(bcmdrd_port_type_t ptype);

int
bcm56880_a0_drd_blktype_from_porttype(bcmdrd_port_type_t ptype)
{
    if (ptype == BCMDRD_PORT_TYPE_LB) {
        return BLKTYPE_LBPORT;
    }
    return -1;
}

/* Declare function first to prevent compiler warnings */
extern uint32_t
bcm56880_a0_drd_pipe_info(const bcmdrd_chip_info_t *cinfo,
                          bcmdrd_pipe_info_t *pi,
                          bcmdrd_pipe_info_type_t pi_type);

uint32_t
bcm56880_a0_drd_pipe_info(const bcmdrd_chip_info_t *cinfo,
                          bcmdrd_pipe_info_t *pi,
                          bcmdrd_pipe_info_type_t pi_type)
{
    /* Base types */
#define BT_IPORT                0
#define BT_EPORT                1
#define BT_IPIPE                2
#define BT_EPIPE                3
#define BT_CHIP                 4
#define BT_ITM                  5

#define BT_DECODE(_ofs) (((_ofs) >> 23) & 0x7)

    /* Access types */
#define AT_DUPLICATE            9
#define AT_ADDR_SPLIT_SPLIT     12
#define AT_SINGLE               20
#define AT_UNIQUE               31

    /* Per-pipe memory section size */
#define SECT_SHFT_32K           15

#define MMUPORT_IN_PIPE(_m, _p) \
    (((_m) >= ((_p) * 32)) && ((_m) < (((_p) * 32) + 20)))
#define MMUPORT_IN_PIPE0(_m) MMUPORT_IN_PIPE(_m, 0)
#define MMUPORT_IN_PIPE1(_m) MMUPORT_IN_PIPE(_m, 1)
#define MMUPORT_IN_PIPE2(_m) MMUPORT_IN_PIPE(_m, 2)
#define MMUPORT_IN_PIPE3(_m) MMUPORT_IN_PIPE(_m, 3)
#define MMUPORT_IN_PIPE4(_m) MMUPORT_IN_PIPE(_m, 4)
#define MMUPORT_IN_PIPE5(_m) MMUPORT_IN_PIPE(_m, 5)
#define MMUPORT_IN_PIPE6(_m) MMUPORT_IN_PIPE(_m, 6)
#define MMUPORT_IN_PIPE7(_m) MMUPORT_IN_PIPE(_m, 7)

    /* Transparent information */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_AT_UNIQUE_GLOBAL) {
        return AT_DUPLICATE;
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_NUM_PIPE_INST) {
        if (pi == NULL) {
            /* Get the number of pipes for the device. */
            return 8;
        }
        /* Get the number of block-based pipes for the device. */
        switch (pi->blktype) {
        case BLKTYPE_IPIPE:
        case BLKTYPE_EPIPE:
            return 4;
        case BLKTYPE_MMU_EB:
        case BLKTYPE_PORT_IF:
            return 8;
        case BLKTYPE_MMU_ITM:
            return 2;
        default:
            return 0;
        }
    }

    if (pi == NULL) {
        return 0;
    }

    /* Return the pipe index for a given physical device port. */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PIPE_INDEX_FROM_PORT) {
        uint32_t pipe_idx = 0;

        if (pi->pnd == BCMDRD_PND_PHYS) {
            if (pi->port >= 1 && pi->port <= 256) {
                pipe_idx = (pi->port - 1) >> 5;
            } else if (pi->port == 0) {
                pipe_idx = 0;
            } else if (pi->port >= 257 && pi->port <= 260) {
                pipe_idx = (pi->port - 257) * 2 + 1;
            } else if (pi->port >= 261 && pi->port <= 264) {
                pipe_idx = (pi->port - 261) * 2 + 1;
            }
        } else if (pi->pnd == BCMDRD_PND_LOGIC) {
            if (pi->port >= 0 && pi->port < 160) {
                pipe_idx = pi->port / 20;
            }
        } else if (pi->pnd == BCMDRD_PND_MMU) {
            if (pi->port >= 0 && pi->port <= 242) {
                pipe_idx = pi->port >> 5;
            }
        }
        return pipe_idx;
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BLK_PIPE_MAP) {
        uint32_t blk_pipe, blk_pipe_map = 0;

        /*
         * IPEP/ITM Pipe mapping
         *
         * Chip    IPEP    ITM
         * ---------------------
         * 0       0       0
         * 1       0       0
         * 2       1       1
         * 3       1       1
         * 4       2       1
         * 5       2       1
         * 6       3       0
         * 7       3       0
         */
        if (pi->blktype == BLKTYPE_IPIPE || pi->blktype == BLKTYPE_EPIPE) {
            for (blk_pipe = 0; blk_pipe < 4; blk_pipe++) {
                if (pi->pipe_map & (0x3 << (2 * blk_pipe))) {
                    blk_pipe_map |= (1 << blk_pipe);
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            if (pi->pipe_map & 0xc3) {
                blk_pipe_map |= 0x1;
            }
            if (pi->pipe_map & 0x3c) {
                blk_pipe_map |= 0x2;
            }
        }
        return blk_pipe_map;
    }

    /* Information without base type */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PMASK) {
        /* Unique block instances */
        uint32_t inst_mask = 0;

        if (pi->acctype == AT_UNIQUE) {
            switch (pi->blktype) {
            case BLKTYPE_IPIPE:
            case BLKTYPE_EPIPE:
                inst_mask = 0xf;
                break;
            case BLKTYPE_MMU_EB:
            case BLKTYPE_PORT_IF:
                inst_mask = 0xff;
                break;
            case BLKTYPE_MMU_ITM:
                inst_mask = 0x3;
                break;
            default:
                break;
            }
        }
        return inst_mask;
    }

    /* Information with base type, without base index */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_LINST) {
        /* Basetype instances */
        uint32_t num_inst = 0;
        uint32_t base_type = BT_DECODE(pi->offset);

        switch (pi->blktype) {
        case BLKTYPE_MMU_GLB:
        case BLKTYPE_MMU_ITM:
        case BLKTYPE_MMU_EB:
            switch (base_type) {
            case BT_IPORT:
            case BT_EPORT:
                num_inst = 244;
                break;
            case BT_IPIPE:
            case BT_EPIPE:
                num_inst = 8;
                if (pi->acctype < 8) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_ITM:
                num_inst = 2;
                if (pi->acctype < 8) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_CHIP:
                num_inst = 1;
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return num_inst;
    } else if (pi_type == BCMDRD_PIPE_INFO_TYPE_SECT_SHFT) {
        uint32_t sect_shft = 0;
        uint32_t base_type = BT_DECODE(pi->offset);

        switch (pi->blktype) {
        case BLKTYPE_MMU_ITM:
            switch (base_type) {
            case BT_ITM:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_IPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_EPIPE:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_EB:
            switch (base_type) {
            case BT_ITM:
            case BT_IPIPE:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_EPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_GLB:
            switch (base_type) {
            case BT_ITM:
            case BT_IPIPE:
            case BT_EPIPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return sect_shft;
    }

    /* Information with base type and base index */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASETYPE_PMASK ||
        pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
        /* Valid unique block instances for specific baseidx */
        uint32_t inst_mask = 0;
        uint32_t base_type = BT_DECODE(pi->offset);
        int baseidx = pi->baseidx;

        if (baseidx < 0) {
            return 0;
        }

        if (pi->blktype == BLKTYPE_MMU_EB) {
            if (base_type == BT_IPORT || base_type == BT_EPORT) {
                int idx;

                for (idx = 0; idx < 8; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        inst_mask = 0xff;
                        break;
                    }
                }
            } else if (base_type == BT_IPIPE || base_type == BT_EPIPE) {
                if (baseidx < 8) {
                    inst_mask = 0xff;
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    inst_mask = 0xff;
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            if (base_type == BT_IPORT || base_type == BT_EPORT) {
                int idx;

                for (idx = 0; idx < 8; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        inst_mask = 0x3;
                        break;
                    }
                }
            } else if (base_type == BT_IPIPE || base_type == BT_EPIPE) {
                if (baseidx < 8) {
                    inst_mask = 0x3;
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    inst_mask = (1 << baseidx);
                }
            }
        }

        if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
            /*
             * If access type is UNIQUE_PIPE_#, need to check
             * whether the pipe is in BASETYPE_PAMSK inst_mask.
             */
            if (inst_mask != 0 && pi->acctype < 8 &&
                ((1 << pi->acctype) & inst_mask) == 0) {
                return 1;
            }
            return 0;
        }
        return inst_mask;
    }
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASETYPE_SINGLE_PMASK) {
        uint32_t base_type = BT_DECODE(pi->offset);
        int baseidx = pi->baseidx;

        if (baseidx < 0) {
            return 0;
        }

        if (pi->acctype != AT_SINGLE) {
            return 0;
        }
        if (pi->blktype == BLKTYPE_MMU_EB) {
            if (base_type == BT_IPORT || base_type == BT_EPORT) {
                int idx;

                for (idx = 0; idx < 8; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        return (1 << idx);
                    }
                }
            } else if (base_type == BT_IPIPE || base_type == BT_EPIPE) {
                if (baseidx < 8) {
                    return (1 << baseidx);
                }
            }
        } else if (pi->blktype == BLKTYPE_MMU_ITM) {
            int inst = -1;

            if (base_type == BT_IPORT) {
                int idx;

                for (idx = 0; idx < 8; idx++) {
                    if (MMUPORT_IN_PIPE(baseidx, idx)) {
                        if (idx < 2 || idx > 5) {
                            inst = 0;
                        } else {
                            inst = 1;
                        }
                        break;
                    }
                }
            } else if (base_type == BT_IPIPE) {
                if (baseidx >= 2 && baseidx <= 5) {
                    inst = 1;
                } else if (baseidx < 8){
                    inst = 0;
                }
            } else if (base_type == BT_ITM) {
                if (baseidx < 2) {
                    inst = baseidx;
                }
            }

            if (inst >= 0) {
                return (1 << inst);
            }
        }
    }
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_MEMIDX_INVALID) {
        if (pi->acctype == AT_ADDR_SPLIT_SPLIT) {
            /* Indexed by logical port number  */
            if (!BCMDRD_PBMP_MEMBER(cinfo->valid_pbmps[BCMDRD_PND_LOGIC],
                                    pi->memidx)) {
                return 1;
            }
        }
        return 0;
    }

    return 0;
}

/* Index ranges for this chip */
static bcmdrd_numel_range_t _numel_ranges[] = {
    {  0,  0, {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}} }, /*  0 */
    {  0,  0, {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}} }, /*  1 */
    {  0,  0, {{0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff}} }, /*  2 */
    {  0,  8, {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}} }  /*  3 */
};

/* Register array encodings for this chip */
static bcmdrd_numel_encoding_t _numel_encodings[] = {
    { { 5 } },
    { {  0, -1 } },
    { {  1, -1 } },
    { {  2, -1 } },
    { {  3, -1 } }
};

/* Variable register array info */
bcmdrd_numel_info_t bcm56880_a0_drd_numel_info = {
    _numel_ranges,
    _numel_encodings
};

/* Chip information structure */
bcmdrd_chip_info_t bcm56880_a0_drd_chip_info = {

    /* Register file digest. */
    BCM56880_A0_SIGNATURE,

    /* HMI protocol (typically S-bus address format version). */
    4,

    /* HMI block (typically CMIC block number). */
    CMIC_BLOCK,

    /* Other (non-HMI) block types */
    16,
    bcm56880_a0_drd_blktype_names,
    bcm56880_a0_drd_blktype_start_idx,

    /* Other (non-HMI) blocks */
    49,
    bcm56880_a0_drd_blocks,

    /* Valid ports for this chip */
    {
        /* Valid physical ports for this chip */
        {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000001ff}},
        /* Valid logical ports for this chip */
        {{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}},
        /* Valid MMU ports for this chip */
        {{0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff, 0x000fffff}}
    },

    /* Chip flags */
    0,

#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
    /* Use the static per-chip symbol tables */
    &bcm56880_a0_drd_symbols,
#endif

    /* Variable register array info */
    &bcm56880_a0_drd_numel_info,

    /* Chip profile */
    NULL,

    /* Address calculation override */
    bcm56880_a0_drd_blockport_addr,

    /* Address decoder override */
    bcm56880_a0_drd_addr_decode,

    /* Port number domain */
    bcm56880_a0_drd_port_num_domain,

    /* Get device-specific block type from generic port type */
    bcm56880_a0_drd_blktype_from_porttype,

    /* Pipe info */
    bcm56880_a0_drd_pipe_info

};
