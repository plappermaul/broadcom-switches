#ifndef __BCMI_BLACKHAWK_XGXS_DEFS_H__
#define __BCMI_BLACKHAWK_XGXS_DEFS_H__
/*******************************************************************************
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_BLACKHAWK_XGXS.
 * This file provides all basic definitions required to program the BCMI_BLACKHAWK_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 */

#ifndef _DV_TB_
#include <phymod/acc/phymod_tsc_iblk.h>
#endif /* _DV_TB_ */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_PMD_CTL
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x0096
 * DEVAD:    1
 * DESC:     BASE-R PMD control register 150
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR linktrn training0 = Normal operation(self clearing)
 *     LINKTRN_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr (0x00010096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_PMD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_pmd_ctl[1];
	uint32_t _lnktrnit_base_r_pmd_ctl;
} BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_CLR(r) (r).lnktrnit_base_r_pmd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SET(r,d) (r).lnktrnit_base_r_pmd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_GET(r) (r).lnktrnit_base_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET(r) ((((r).lnktrnit_base_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET(r,f) (r).lnktrnit_base_r_pmd_ctl[0]=(((r).lnktrnit_base_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET(r) (((r).lnktrnit_base_r_pmd_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET(r,f) (r).lnktrnit_base_r_pmd_ctl[0]=(((r).lnktrnit_base_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_PMD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_pmd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr
#define LNKTRNIT_BASE_R_PMD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_t LNKTRNIT_BASE_R_PMD_CTLr_t;
#define LNKTRNIT_BASE_R_PMD_CTLr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_CLR
#define LNKTRNIT_BASE_R_PMD_CTLr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SET
#define LNKTRNIT_BASE_R_PMD_CTLr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET
#define READ_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITE_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_CTLr
#define MODIFY_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_CTLr
#define READLN_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITELN_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_PMD_STS
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x0097
 * DEVAD:    1
 * DESC:     BASE-R PMD status register 151
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     LINKTRN_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     LINKTRN_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     LINKTRN_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr (0x00010097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_PMD_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_pmd_sts[1];
	uint32_t _lnktrnit_base_r_pmd_sts;
} BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_CLR(r) (r).lnktrnit_base_r_pmd_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SET(r,d) (r).lnktrnit_base_r_pmd_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_GET(r) (r).lnktrnit_base_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET(r) (((r).lnktrnit_base_r_pmd_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_PMD_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_pmd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr
#define LNKTRNIT_BASE_R_PMD_STSr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_t LNKTRNIT_BASE_R_PMD_STSr_t;
#define LNKTRNIT_BASE_R_PMD_STSr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_CLR
#define LNKTRNIT_BASE_R_PMD_STSr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SET
#define LNKTRNIT_BASE_R_PMD_STSr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET
#define READ_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_PMD_STSr
#define WRITE_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_STSr
#define MODIFY_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_STSr
#define READLN_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_PMD_STSr
#define WRITELN_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_STSr
#define WRITEALL_LNKTRNIT_BASE_R_PMD_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_PMD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIR_BASE_R_LP_COEFF_UPD
 * BLOCKS:   LINKTRN_IEEE_RX
 * REGADDR:  0x0098
 * DEVAD:    1
 * DESC:     BASE-R LP coeff update register 152
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when linktrn training is disabled asindicated in the IEEE standardlinktrn supports link training for IEEE/OIF/FC standardsPlease see the apprpopiate standards for register bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr (0x00010098 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIR_BASE_R_LP_COEFF_UPD.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t lnktrnir_base_r_lp_coeff_upd[1];
	uint32_t _lnktrnir_base_r_lp_coeff_upd;
} BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR(r) (r).lnktrnir_base_r_lp_coeff_upd[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET(r,d) (r).lnktrnir_base_r_lp_coeff_upd[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET(r) (r).lnktrnir_base_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).lnktrnir_base_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).lnktrnir_base_r_lp_coeff_upd[0]=(((r).lnktrnir_base_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIR_BASE_R_LP_COEFF_UPD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnir_base_r_lp_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_t LNKTRNIR_BASE_R_LP_COEFF_UPDr_t;
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET
#define READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIR_BASE_R_LP_STS_REP
 * BLOCKS:   LINKTRN_IEEE_RX
 * REGADDR:  0x0099
 * DEVAD:    1
 * DESC:     BASE-R LP status report register 153
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partnerlinktrn supports link training for IEEE/OIF/FC standardsPlease see the apprpopiate standards for register bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr (0x00010099 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIR_BASE_R_LP_STS_REP.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_s {
	uint32_t v[1];
	uint32_t lnktrnir_base_r_lp_sts_rep[1];
	uint32_t _lnktrnir_base_r_lp_sts_rep;
} BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_CLR(r) (r).lnktrnir_base_r_lp_sts_rep[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SET(r,d) (r).lnktrnir_base_r_lp_sts_rep[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_GET(r) (r).lnktrnir_base_r_lp_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET(r) (((r).lnktrnir_base_r_lp_sts_rep[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).lnktrnir_base_r_lp_sts_rep[0]=(((r).lnktrnir_base_r_lp_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIR_BASE_R_LP_STS_REP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnir_base_r_lp_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr
#define LNKTRNIR_BASE_R_LP_STS_REPr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_t LNKTRNIR_BASE_R_LP_STS_REPr_t;
#define LNKTRNIR_BASE_R_LP_STS_REPr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_CLR
#define LNKTRNIR_BASE_R_LP_STS_REPr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SET
#define LNKTRNIR_BASE_R_LP_STS_REPr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_GET
#define LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET
#define LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET
#define READ_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITE_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIR_BASE_R_LP_STS_REPr
#define MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr
#define READLN_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_LD_COEFF_UPD
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x009a
 * DEVAD:    1
 * DESC:     BASE-R LD coeff update register 154
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local DeviceThis register is not writeablelinktrn supports link training for IEEE/OIF/FC standardsPlease see the apprpopiate standards for register bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr (0x0001009a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_LD_COEFF_UPD.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_ld_coeff_upd[1];
	uint32_t _lnktrnit_base_r_ld_coeff_upd;
} BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR(r) (r).lnktrnit_base_r_ld_coeff_upd[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET(r,d) (r).lnktrnit_base_r_ld_coeff_upd[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET(r) (r).lnktrnit_base_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).lnktrnit_base_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).lnktrnit_base_r_ld_coeff_upd[0]=(((r).lnktrnit_base_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_LD_COEFF_UPD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_ld_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_t LNKTRNIT_BASE_R_LD_COEFF_UPDr_t;
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET
#define READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_LD_STS_REP
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x009b
 * DEVAD:    1
 * DESC:     BASE-R LD status report register 155
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framemost recently recieived from the Link Partnerlinktrn supports link training for IEEE/OIF/FC standardsPlease see the apprpopiate standards for register bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr (0x0001009b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_LD_STS_REP.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_ld_sts_rep[1];
	uint32_t _lnktrnit_base_r_ld_sts_rep;
} BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_CLR(r) (r).lnktrnit_base_r_ld_sts_rep[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SET(r,d) (r).lnktrnit_base_r_ld_sts_rep[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_GET(r) (r).lnktrnit_base_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET(r) (((r).lnktrnit_base_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).lnktrnit_base_r_ld_sts_rep[0]=(((r).lnktrnit_base_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_LD_STS_REP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_ld_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr
#define LNKTRNIT_BASE_R_LD_STS_REPr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_t LNKTRNIT_BASE_R_LD_STS_REPr_t;
#define LNKTRNIT_BASE_R_LD_STS_REPr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_CLR
#define LNKTRNIT_BASE_R_LD_STS_REPr_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SET
#define LNKTRNIT_BASE_R_LD_STS_REPr_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_GET
#define LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET
#define LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET
#define READ_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_READ_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITE_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNIT_BASE_R_LD_STS_REPr
#define MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr
#define READLN_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ1
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd005
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_CAL_D4 signed 2's complement rxa slicer offset adjust for ES, p3 only
 *     RXA_SLICER_OFFSET_ADJ_CAL_D5 signed 2's complement rxa slicer offset adjust for ES, p4, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r (0x0001d005 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj1[1];
	uint32_t _dsc_rxa_slcr_offs_adj1;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_CLR(r) (r).dsc_rxa_slcr_offs_adj1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_SET(r,d) (r).dsc_rxa_slcr_offs_adj1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_GET(r) (r).dsc_rxa_slcr_offs_adj1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_GET(r) ((((r).dsc_rxa_slcr_offs_adj1[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_SET(r,f) (r).dsc_rxa_slcr_offs_adj1[0]=(((r).dsc_rxa_slcr_offs_adj1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_GET(r) (((r).dsc_rxa_slcr_offs_adj1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_SET(r,f) (r).dsc_rxa_slcr_offs_adj1[0]=(((r).dsc_rxa_slcr_offs_adj1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r,(_r._dsc_rxa_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r,(_r._dsc_rxa_slcr_offs_adj1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r,(_r._dsc_rxa_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r
#define DSC_RXA_SLCR_OFFS_ADJ1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_t DSC_RXA_SLCR_OFFS_ADJ1r_t;
#define DSC_RXA_SLCR_OFFS_ADJ1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_CLR
#define DSC_RXA_SLCR_OFFS_ADJ1r_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_SET
#define DSC_RXA_SLCR_OFFS_ADJ1r_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_GET
#define DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_GET
#define DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D5f_SET
#define DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_GET
#define DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r_RXA_SLICER_OFFSET_ADJ_CAL_D4f_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ1r
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ1r
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ1r
#define READLN_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ1r
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ1r
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ2
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd006
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_CAL_D2 signed 2's complement rxa slicer offset adjust for ES, m1, NS
 *     RXA_SLICER_OFFSET_ADJ_CAL_D3 signed 2's complement rxa slicer offset adjust for ES, p1 only
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r (0x0001d006 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj2[1];
	uint32_t _dsc_rxa_slcr_offs_adj2;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_CLR(r) (r).dsc_rxa_slcr_offs_adj2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_SET(r,d) (r).dsc_rxa_slcr_offs_adj2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_GET(r) (r).dsc_rxa_slcr_offs_adj2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_GET(r) ((((r).dsc_rxa_slcr_offs_adj2[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_SET(r,f) (r).dsc_rxa_slcr_offs_adj2[0]=(((r).dsc_rxa_slcr_offs_adj2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_GET(r) (((r).dsc_rxa_slcr_offs_adj2[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_SET(r,f) (r).dsc_rxa_slcr_offs_adj2[0]=(((r).dsc_rxa_slcr_offs_adj2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r,(_r._dsc_rxa_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r,(_r._dsc_rxa_slcr_offs_adj2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r,(_r._dsc_rxa_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r
#define DSC_RXA_SLCR_OFFS_ADJ2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_t DSC_RXA_SLCR_OFFS_ADJ2r_t;
#define DSC_RXA_SLCR_OFFS_ADJ2r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_CLR
#define DSC_RXA_SLCR_OFFS_ADJ2r_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_SET
#define DSC_RXA_SLCR_OFFS_ADJ2r_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_GET
#define DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_GET
#define DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D3f_SET
#define DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_GET
#define DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r_RXA_SLICER_OFFSET_ADJ_CAL_D2f_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ2r
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ2r
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ2r
#define READLN_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ2r
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ2r
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ3
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd007
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_3 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_CAL_D0 signed 2's complement rxa slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR
 *     RXA_SLICER_OFFSET_ADJ_CAL_D1 signed 2's complement rxa slicer offset adjust for ES, m3, NS
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r (0x0001d007 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj3[1];
	uint32_t _dsc_rxa_slcr_offs_adj3;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_CLR(r) (r).dsc_rxa_slcr_offs_adj3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_SET(r,d) (r).dsc_rxa_slcr_offs_adj3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_GET(r) (r).dsc_rxa_slcr_offs_adj3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_GET(r) ((((r).dsc_rxa_slcr_offs_adj3[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_SET(r,f) (r).dsc_rxa_slcr_offs_adj3[0]=(((r).dsc_rxa_slcr_offs_adj3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_GET(r) (((r).dsc_rxa_slcr_offs_adj3[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_SET(r,f) (r).dsc_rxa_slcr_offs_adj3[0]=(((r).dsc_rxa_slcr_offs_adj3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r,(_r._dsc_rxa_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r,(_r._dsc_rxa_slcr_offs_adj3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r,(_r._dsc_rxa_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r
#define DSC_RXA_SLCR_OFFS_ADJ3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_t DSC_RXA_SLCR_OFFS_ADJ3r_t;
#define DSC_RXA_SLCR_OFFS_ADJ3r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_CLR
#define DSC_RXA_SLCR_OFFS_ADJ3r_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_SET
#define DSC_RXA_SLCR_OFFS_ADJ3r_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_GET
#define DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_GET
#define DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D1f_SET
#define DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_GET
#define DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r_RXA_SLICER_OFFSET_ADJ_CAL_D0f_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ3r
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ3r
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ3r
#define READLN_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ3r
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ3r
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ4
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd008
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_4 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_CAL_P1 signed 2's complement rxa slicer offset adjust for ES, NS
 *     RXA_SLICER_OFFSET_ADJ_CAL_P2 signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r (0x0001d008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj4[1];
	uint32_t _dsc_rxa_slcr_offs_adj4;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_CLR(r) (r).dsc_rxa_slcr_offs_adj4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_SET(r,d) (r).dsc_rxa_slcr_offs_adj4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_GET(r) (r).dsc_rxa_slcr_offs_adj4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_GET(r) ((((r).dsc_rxa_slcr_offs_adj4[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_SET(r,f) (r).dsc_rxa_slcr_offs_adj4[0]=(((r).dsc_rxa_slcr_offs_adj4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_GET(r) (((r).dsc_rxa_slcr_offs_adj4[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_SET(r,f) (r).dsc_rxa_slcr_offs_adj4[0]=(((r).dsc_rxa_slcr_offs_adj4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r,(_r._dsc_rxa_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r,(_r._dsc_rxa_slcr_offs_adj4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r,(_r._dsc_rxa_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r
#define DSC_RXA_SLCR_OFFS_ADJ4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_t DSC_RXA_SLCR_OFFS_ADJ4r_t;
#define DSC_RXA_SLCR_OFFS_ADJ4r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_CLR
#define DSC_RXA_SLCR_OFFS_ADJ4r_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_SET
#define DSC_RXA_SLCR_OFFS_ADJ4r_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_GET
#define DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_GET
#define DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P2f_SET
#define DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_GET
#define DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r_RXA_SLICER_OFFSET_ADJ_CAL_P1f_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ4r
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ4r
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ4r
#define READLN_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ4r
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ4r
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ5
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd009
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_5 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_CAL_LMS signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 *     RXA_SLICER_OFFSET_ADJ_CAL_P0 signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r (0x0001d009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj5[1];
	uint32_t _dsc_rxa_slcr_offs_adj5;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_CLR(r) (r).dsc_rxa_slcr_offs_adj5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_SET(r,d) (r).dsc_rxa_slcr_offs_adj5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_GET(r) (r).dsc_rxa_slcr_offs_adj5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_GET(r) ((((r).dsc_rxa_slcr_offs_adj5[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_SET(r,f) (r).dsc_rxa_slcr_offs_adj5[0]=(((r).dsc_rxa_slcr_offs_adj5[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_GET(r) (((r).dsc_rxa_slcr_offs_adj5[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_SET(r,f) (r).dsc_rxa_slcr_offs_adj5[0]=(((r).dsc_rxa_slcr_offs_adj5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r,(_r._dsc_rxa_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r,(_r._dsc_rxa_slcr_offs_adj5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r,(_r._dsc_rxa_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r
#define DSC_RXA_SLCR_OFFS_ADJ5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_t DSC_RXA_SLCR_OFFS_ADJ5r_t;
#define DSC_RXA_SLCR_OFFS_ADJ5r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_CLR
#define DSC_RXA_SLCR_OFFS_ADJ5r_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_SET
#define DSC_RXA_SLCR_OFFS_ADJ5r_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_GET
#define DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_GET
#define DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_P0f_SET
#define DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_GET
#define DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r_RXA_SLICER_OFFSET_ADJ_CAL_LMSf_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ5r
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ5r
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ5r
#define READLN_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ5r
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ5r
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_SLCR_OFFS_ADJ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ1
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00a
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_CAL_D4 signed 2's complement rxb slicer offset adjust for ES, p3 only
 *     RXB_SLICER_OFFSET_ADJ_CAL_D5 signed 2's complement rxb slicer offset adjust for ES, p4, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r (0x0001d00a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj1[1];
	uint32_t _dsc_rxb_slcr_offs_adj1;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_CLR(r) (r).dsc_rxb_slcr_offs_adj1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_SET(r,d) (r).dsc_rxb_slcr_offs_adj1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_GET(r) (r).dsc_rxb_slcr_offs_adj1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_GET(r) ((((r).dsc_rxb_slcr_offs_adj1[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_SET(r,f) (r).dsc_rxb_slcr_offs_adj1[0]=(((r).dsc_rxb_slcr_offs_adj1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_GET(r) (((r).dsc_rxb_slcr_offs_adj1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_SET(r,f) (r).dsc_rxb_slcr_offs_adj1[0]=(((r).dsc_rxb_slcr_offs_adj1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r,(_r._dsc_rxb_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r,(_r._dsc_rxb_slcr_offs_adj1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r,(_r._dsc_rxb_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r
#define DSC_RXB_SLCR_OFFS_ADJ1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_t DSC_RXB_SLCR_OFFS_ADJ1r_t;
#define DSC_RXB_SLCR_OFFS_ADJ1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_CLR
#define DSC_RXB_SLCR_OFFS_ADJ1r_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_SET
#define DSC_RXB_SLCR_OFFS_ADJ1r_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_GET
#define DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_GET
#define DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D5f_SET
#define DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_GET
#define DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r_RXB_SLICER_OFFSET_ADJ_CAL_D4f_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ1r
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ1r
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ1r
#define READLN_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ1r
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ1r
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ2
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00b
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_CAL_D2 signed 2's complement rxb slicer offset adjust for ES, m1, NS
 *     RXB_SLICER_OFFSET_ADJ_CAL_D3 signed 2's complement rxb slicer offset adjust for ES, p1 only
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r (0x0001d00b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj2[1];
	uint32_t _dsc_rxb_slcr_offs_adj2;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_CLR(r) (r).dsc_rxb_slcr_offs_adj2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_SET(r,d) (r).dsc_rxb_slcr_offs_adj2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_GET(r) (r).dsc_rxb_slcr_offs_adj2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_GET(r) ((((r).dsc_rxb_slcr_offs_adj2[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_SET(r,f) (r).dsc_rxb_slcr_offs_adj2[0]=(((r).dsc_rxb_slcr_offs_adj2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_GET(r) (((r).dsc_rxb_slcr_offs_adj2[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_SET(r,f) (r).dsc_rxb_slcr_offs_adj2[0]=(((r).dsc_rxb_slcr_offs_adj2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r,(_r._dsc_rxb_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r,(_r._dsc_rxb_slcr_offs_adj2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r,(_r._dsc_rxb_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r
#define DSC_RXB_SLCR_OFFS_ADJ2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_t DSC_RXB_SLCR_OFFS_ADJ2r_t;
#define DSC_RXB_SLCR_OFFS_ADJ2r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_CLR
#define DSC_RXB_SLCR_OFFS_ADJ2r_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_SET
#define DSC_RXB_SLCR_OFFS_ADJ2r_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_GET
#define DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_GET
#define DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D3f_SET
#define DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_GET
#define DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r_RXB_SLICER_OFFSET_ADJ_CAL_D2f_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ2r
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ2r
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ2r
#define READLN_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ2r
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ2r
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ3
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00c
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_3 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_CAL_D0 signed 2's complement rxb slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR
 *     RXB_SLICER_OFFSET_ADJ_CAL_D1 signed 2's complement rxb slicer offset adjust for ES, m3, NS
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r (0x0001d00c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj3[1];
	uint32_t _dsc_rxb_slcr_offs_adj3;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_CLR(r) (r).dsc_rxb_slcr_offs_adj3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_SET(r,d) (r).dsc_rxb_slcr_offs_adj3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_GET(r) (r).dsc_rxb_slcr_offs_adj3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_GET(r) ((((r).dsc_rxb_slcr_offs_adj3[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_SET(r,f) (r).dsc_rxb_slcr_offs_adj3[0]=(((r).dsc_rxb_slcr_offs_adj3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_GET(r) (((r).dsc_rxb_slcr_offs_adj3[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_SET(r,f) (r).dsc_rxb_slcr_offs_adj3[0]=(((r).dsc_rxb_slcr_offs_adj3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r,(_r._dsc_rxb_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r,(_r._dsc_rxb_slcr_offs_adj3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r,(_r._dsc_rxb_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r
#define DSC_RXB_SLCR_OFFS_ADJ3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_t DSC_RXB_SLCR_OFFS_ADJ3r_t;
#define DSC_RXB_SLCR_OFFS_ADJ3r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_CLR
#define DSC_RXB_SLCR_OFFS_ADJ3r_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_SET
#define DSC_RXB_SLCR_OFFS_ADJ3r_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_GET
#define DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_GET
#define DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D1f_SET
#define DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_GET
#define DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r_RXB_SLICER_OFFSET_ADJ_CAL_D0f_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ3r
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ3r
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ3r
#define READLN_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ3r
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ3r
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ4
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00d
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_4 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_CAL_P1 signed 2's complement rxb slicer offset adjust for ES, NS
 *     RXB_SLICER_OFFSET_ADJ_CAL_P2 signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r (0x0001d00d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj4[1];
	uint32_t _dsc_rxb_slcr_offs_adj4;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_CLR(r) (r).dsc_rxb_slcr_offs_adj4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_SET(r,d) (r).dsc_rxb_slcr_offs_adj4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_GET(r) (r).dsc_rxb_slcr_offs_adj4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_GET(r) ((((r).dsc_rxb_slcr_offs_adj4[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_SET(r,f) (r).dsc_rxb_slcr_offs_adj4[0]=(((r).dsc_rxb_slcr_offs_adj4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_GET(r) (((r).dsc_rxb_slcr_offs_adj4[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_SET(r,f) (r).dsc_rxb_slcr_offs_adj4[0]=(((r).dsc_rxb_slcr_offs_adj4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r,(_r._dsc_rxb_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r,(_r._dsc_rxb_slcr_offs_adj4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r,(_r._dsc_rxb_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r
#define DSC_RXB_SLCR_OFFS_ADJ4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_t DSC_RXB_SLCR_OFFS_ADJ4r_t;
#define DSC_RXB_SLCR_OFFS_ADJ4r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_CLR
#define DSC_RXB_SLCR_OFFS_ADJ4r_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_SET
#define DSC_RXB_SLCR_OFFS_ADJ4r_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_GET
#define DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_GET
#define DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P2f_SET
#define DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_GET
#define DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r_RXB_SLICER_OFFSET_ADJ_CAL_P1f_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ4r
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ4r
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ4r
#define READLN_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ4r
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ4r
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ5
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00e
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_5 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_CAL_LMS signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 *     RXB_SLICER_OFFSET_ADJ_CAL_P0 signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r (0x0001d00e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj5[1];
	uint32_t _dsc_rxb_slcr_offs_adj5;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_CLR(r) (r).dsc_rxb_slcr_offs_adj5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_SET(r,d) (r).dsc_rxb_slcr_offs_adj5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_GET(r) (r).dsc_rxb_slcr_offs_adj5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_GET(r) ((((r).dsc_rxb_slcr_offs_adj5[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_SET(r,f) (r).dsc_rxb_slcr_offs_adj5[0]=(((r).dsc_rxb_slcr_offs_adj5[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_GET(r) (((r).dsc_rxb_slcr_offs_adj5[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_SET(r,f) (r).dsc_rxb_slcr_offs_adj5[0]=(((r).dsc_rxb_slcr_offs_adj5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r,(_r._dsc_rxb_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r,(_r._dsc_rxb_slcr_offs_adj5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r,(_r._dsc_rxb_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r
#define DSC_RXB_SLCR_OFFS_ADJ5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_t DSC_RXB_SLCR_OFFS_ADJ5r_t;
#define DSC_RXB_SLCR_OFFS_ADJ5r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_CLR
#define DSC_RXB_SLCR_OFFS_ADJ5r_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_SET
#define DSC_RXB_SLCR_OFFS_ADJ5r_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_GET
#define DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_GET
#define DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_P0f_SET
#define DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_GET
#define DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r_RXB_SLICER_OFFSET_ADJ_CAL_LMSf_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ5r
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ5r
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ5r
#define READLN_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ5r
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ5r
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_SLCR_OFFS_ADJ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP4_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd013
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr (0x0001d013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_AB.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_ab[1];
	uint32_t _dsc_rx_dfe_tap4_ab;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_CLR(r) (r).dsc_rx_dfe_tap4_ab[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_SET(r,d) (r).dsc_rx_dfe_tap4_ab[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_GET(r) (r).dsc_rx_dfe_tap4_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_ab[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_ab[0]=(((r).dsc_rx_dfe_tap4_ab[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_ab[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_ab[0]=(((r).dsc_rx_dfe_tap4_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_AB.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP4_ABr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap4_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr
#define DSC_RX_DFE_TAP4_ABr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_t DSC_RX_DFE_TAP4_ABr_t;
#define DSC_RX_DFE_TAP4_ABr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_CLR
#define DSC_RX_DFE_TAP4_ABr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_SET
#define DSC_RX_DFE_TAP4_ABr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_GET
#define DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP4_ABr
#define WRITE_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP4_ABr
#define MODIFY_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABr
#define READLN_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP4_ABr
#define WRITELN_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABr
#define WRITEALL_DSC_RX_DFE_TAP4_ABr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP4_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd014
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr (0x0001d014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_CD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_cd[1];
	uint32_t _dsc_rx_dfe_tap4_cd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_CLR(r) (r).dsc_rx_dfe_tap4_cd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_SET(r,d) (r).dsc_rx_dfe_tap4_cd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_GET(r) (r).dsc_rx_dfe_tap4_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_cd[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_cd[0]=(((r).dsc_rx_dfe_tap4_cd[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_cd[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_cd[0]=(((r).dsc_rx_dfe_tap4_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_CD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP4_CDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP4_CDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap4_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr
#define DSC_RX_DFE_TAP4_CDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_t DSC_RX_DFE_TAP4_CDr_t;
#define DSC_RX_DFE_TAP4_CDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_CLR
#define DSC_RX_DFE_TAP4_CDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_SET
#define DSC_RX_DFE_TAP4_CDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_GET
#define DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP4_CDr
#define WRITE_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP4_CDr
#define MODIFY_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP4_CDr
#define READLN_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP4_CDr
#define WRITELN_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP4_CDr
#define WRITEALL_DSC_RX_DFE_TAP4_CDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP4_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP4_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP5_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd015
 * DEVAD:    1
 * DESC:     rx_dfe_tap5_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr (0x0001d015 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP5_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap5_abcd[1];
	uint32_t _dsc_rx_dfe_tap5_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR(r) (r).dsc_rx_dfe_tap5_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap5_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET(r) (r).dsc_rx_dfe_tap5_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET(r) (((r).dsc_rx_dfe_tap5_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP5_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap5_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr
#define DSC_RX_DFE_TAP5_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_t DSC_RX_DFE_TAP5_ABCDr_t;
#define DSC_RX_DFE_TAP5_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR
#define DSC_RX_DFE_TAP5_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET
#define DSC_RX_DFE_TAP5_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET
#define READ_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr
#define WRITE_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr
#define MODIFY_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr
#define READLN_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr
#define WRITELN_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP5_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP5_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP6_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd016
 * DEVAD:    1
 * DESC:     rx_dfe_tap6_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr (0x0001d016 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP6_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap6_abcd[1];
	uint32_t _dsc_rx_dfe_tap6_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR(r) (r).dsc_rx_dfe_tap6_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap6_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET(r) (r).dsc_rx_dfe_tap6_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET(r) (((r).dsc_rx_dfe_tap6_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP6_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap6_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr
#define DSC_RX_DFE_TAP6_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_t DSC_RX_DFE_TAP6_ABCDr_t;
#define DSC_RX_DFE_TAP6_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR
#define DSC_RX_DFE_TAP6_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET
#define DSC_RX_DFE_TAP6_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET
#define READ_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr
#define WRITE_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr
#define MODIFY_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr
#define READLN_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr
#define WRITELN_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP6_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP6_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd017
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr (0x0001d017 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET(r) (((r).dsc_rx_dfe_tap7_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr
#define DSC_RX_DFE_TAP7_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_t DSC_RX_DFE_TAP7_ABCDr_t;
#define DSC_RX_DFE_TAP7_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR
#define DSC_RX_DFE_TAP7_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET
#define DSC_RX_DFE_TAP7_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET
#define READ_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr
#define READLN_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP8_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd018
 * DEVAD:    1
 * DESC:     rx_dfe_tap8_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr (0x0001d018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP8_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap8_abcd[1];
	uint32_t _dsc_rx_dfe_tap8_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR(r) (r).dsc_rx_dfe_tap8_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap8_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET(r) (r).dsc_rx_dfe_tap8_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET(r) (((r).dsc_rx_dfe_tap8_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP8_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap8_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr
#define DSC_RX_DFE_TAP8_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_t DSC_RX_DFE_TAP8_ABCDr_t;
#define DSC_RX_DFE_TAP8_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR
#define DSC_RX_DFE_TAP8_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET
#define DSC_RX_DFE_TAP8_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET
#define READ_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr
#define WRITE_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr
#define MODIFY_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr
#define READLN_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr
#define WRITELN_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP8_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP8_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd019
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr (0x0001d019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET(r) (((r).dsc_rx_dfe_tap9_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr
#define DSC_RX_DFE_TAP9_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_t DSC_RX_DFE_TAP9_ABCDr_t;
#define DSC_RX_DFE_TAP9_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR
#define DSC_RX_DFE_TAP9_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET
#define DSC_RX_DFE_TAP9_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET
#define READ_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr
#define READLN_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ1
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd01a
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_CAL_D4 signed 2's complement rxc slicer offset adjust for ES, p3 only
 *     RXC_SLICER_OFFSET_ADJ_CAL_D5 signed 2's complement rxc slicer offset adjust for ES, p4, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r (0x0001d01a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj1[1];
	uint32_t _dsc_rxc_slcr_offs_adj1;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_CLR(r) (r).dsc_rxc_slcr_offs_adj1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_SET(r,d) (r).dsc_rxc_slcr_offs_adj1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_GET(r) (r).dsc_rxc_slcr_offs_adj1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_GET(r) ((((r).dsc_rxc_slcr_offs_adj1[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_SET(r,f) (r).dsc_rxc_slcr_offs_adj1[0]=(((r).dsc_rxc_slcr_offs_adj1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_GET(r) (((r).dsc_rxc_slcr_offs_adj1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_SET(r,f) (r).dsc_rxc_slcr_offs_adj1[0]=(((r).dsc_rxc_slcr_offs_adj1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r,(_r._dsc_rxc_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r,(_r._dsc_rxc_slcr_offs_adj1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r,(_r._dsc_rxc_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r
#define DSC_RXC_SLCR_OFFS_ADJ1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_t DSC_RXC_SLCR_OFFS_ADJ1r_t;
#define DSC_RXC_SLCR_OFFS_ADJ1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_CLR
#define DSC_RXC_SLCR_OFFS_ADJ1r_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_SET
#define DSC_RXC_SLCR_OFFS_ADJ1r_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_GET
#define DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_GET
#define DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D5f_SET
#define DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_GET
#define DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r_RXC_SLICER_OFFSET_ADJ_CAL_D4f_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ1r
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ1r
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ1r
#define READLN_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ1r
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ1r
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ2
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd01b
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_CAL_D2 signed 2's complement rxc slicer offset adjust for ES, m1, NS
 *     RXC_SLICER_OFFSET_ADJ_CAL_D3 signed 2's complement rxc slicer offset adjust for ES, p1 only
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r (0x0001d01b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj2[1];
	uint32_t _dsc_rxc_slcr_offs_adj2;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_CLR(r) (r).dsc_rxc_slcr_offs_adj2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_SET(r,d) (r).dsc_rxc_slcr_offs_adj2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_GET(r) (r).dsc_rxc_slcr_offs_adj2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_GET(r) ((((r).dsc_rxc_slcr_offs_adj2[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_SET(r,f) (r).dsc_rxc_slcr_offs_adj2[0]=(((r).dsc_rxc_slcr_offs_adj2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_GET(r) (((r).dsc_rxc_slcr_offs_adj2[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_SET(r,f) (r).dsc_rxc_slcr_offs_adj2[0]=(((r).dsc_rxc_slcr_offs_adj2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r,(_r._dsc_rxc_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r,(_r._dsc_rxc_slcr_offs_adj2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r,(_r._dsc_rxc_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r
#define DSC_RXC_SLCR_OFFS_ADJ2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_t DSC_RXC_SLCR_OFFS_ADJ2r_t;
#define DSC_RXC_SLCR_OFFS_ADJ2r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_CLR
#define DSC_RXC_SLCR_OFFS_ADJ2r_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_SET
#define DSC_RXC_SLCR_OFFS_ADJ2r_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_GET
#define DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_GET
#define DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D3f_SET
#define DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_GET
#define DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r_RXC_SLICER_OFFSET_ADJ_CAL_D2f_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ2r
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ2r
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ2r
#define READLN_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ2r
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ2r
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ3
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd01c
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_3 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_CAL_D0 signed 2's complement rxc slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR
 *     RXC_SLICER_OFFSET_ADJ_CAL_D1 signed 2's complement rxc slicer offset adjust for ES, m3, NS
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r (0x0001d01c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj3[1];
	uint32_t _dsc_rxc_slcr_offs_adj3;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_CLR(r) (r).dsc_rxc_slcr_offs_adj3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_SET(r,d) (r).dsc_rxc_slcr_offs_adj3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_GET(r) (r).dsc_rxc_slcr_offs_adj3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_GET(r) ((((r).dsc_rxc_slcr_offs_adj3[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_SET(r,f) (r).dsc_rxc_slcr_offs_adj3[0]=(((r).dsc_rxc_slcr_offs_adj3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_GET(r) (((r).dsc_rxc_slcr_offs_adj3[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_SET(r,f) (r).dsc_rxc_slcr_offs_adj3[0]=(((r).dsc_rxc_slcr_offs_adj3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r,(_r._dsc_rxc_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r,(_r._dsc_rxc_slcr_offs_adj3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r,(_r._dsc_rxc_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r
#define DSC_RXC_SLCR_OFFS_ADJ3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_t DSC_RXC_SLCR_OFFS_ADJ3r_t;
#define DSC_RXC_SLCR_OFFS_ADJ3r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_CLR
#define DSC_RXC_SLCR_OFFS_ADJ3r_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_SET
#define DSC_RXC_SLCR_OFFS_ADJ3r_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_GET
#define DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_GET
#define DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D1f_SET
#define DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_GET
#define DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r_RXC_SLICER_OFFSET_ADJ_CAL_D0f_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ3r
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ3r
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ3r
#define READLN_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ3r
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ3r
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ4
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd01d
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_4 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_CAL_P1 signed 2's complement rxc slicer offset adjust for ES, NS
 *     RXC_SLICER_OFFSET_ADJ_CAL_P2 signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r (0x0001d01d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj4[1];
	uint32_t _dsc_rxc_slcr_offs_adj4;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_CLR(r) (r).dsc_rxc_slcr_offs_adj4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_SET(r,d) (r).dsc_rxc_slcr_offs_adj4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_GET(r) (r).dsc_rxc_slcr_offs_adj4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_GET(r) ((((r).dsc_rxc_slcr_offs_adj4[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_SET(r,f) (r).dsc_rxc_slcr_offs_adj4[0]=(((r).dsc_rxc_slcr_offs_adj4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_GET(r) (((r).dsc_rxc_slcr_offs_adj4[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_SET(r,f) (r).dsc_rxc_slcr_offs_adj4[0]=(((r).dsc_rxc_slcr_offs_adj4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r,(_r._dsc_rxc_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r,(_r._dsc_rxc_slcr_offs_adj4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r,(_r._dsc_rxc_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r
#define DSC_RXC_SLCR_OFFS_ADJ4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_t DSC_RXC_SLCR_OFFS_ADJ4r_t;
#define DSC_RXC_SLCR_OFFS_ADJ4r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_CLR
#define DSC_RXC_SLCR_OFFS_ADJ4r_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_SET
#define DSC_RXC_SLCR_OFFS_ADJ4r_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_GET
#define DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_GET
#define DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P2f_SET
#define DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_GET
#define DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r_RXC_SLICER_OFFSET_ADJ_CAL_P1f_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ4r
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ4r
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ4r
#define READLN_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ4r
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ4r
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ5
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd01e
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_5 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_CAL_LMS signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 *     RXC_SLICER_OFFSET_ADJ_CAL_P0 signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r (0x0001d01e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj5[1];
	uint32_t _dsc_rxc_slcr_offs_adj5;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_CLR(r) (r).dsc_rxc_slcr_offs_adj5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_SET(r,d) (r).dsc_rxc_slcr_offs_adj5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_GET(r) (r).dsc_rxc_slcr_offs_adj5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_GET(r) ((((r).dsc_rxc_slcr_offs_adj5[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_SET(r,f) (r).dsc_rxc_slcr_offs_adj5[0]=(((r).dsc_rxc_slcr_offs_adj5[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_GET(r) (((r).dsc_rxc_slcr_offs_adj5[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_SET(r,f) (r).dsc_rxc_slcr_offs_adj5[0]=(((r).dsc_rxc_slcr_offs_adj5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r,(_r._dsc_rxc_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r,(_r._dsc_rxc_slcr_offs_adj5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r,(_r._dsc_rxc_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r
#define DSC_RXC_SLCR_OFFS_ADJ5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_t DSC_RXC_SLCR_OFFS_ADJ5r_t;
#define DSC_RXC_SLCR_OFFS_ADJ5r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_CLR
#define DSC_RXC_SLCR_OFFS_ADJ5r_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_SET
#define DSC_RXC_SLCR_OFFS_ADJ5r_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_GET
#define DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_GET
#define DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_P0f_SET
#define DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_GET
#define DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r_RXC_SLICER_OFFSET_ADJ_CAL_LMSf_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ5r
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ5r
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ5r
#define READLN_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ5r
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ5r
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_SLCR_OFFS_ADJ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP10_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd020
 * DEVAD:    1
 * DESC:     rx_dfe_tap10_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr (0x0001d020 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP10_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap10_abcd[1];
	uint32_t _dsc_rx_dfe_tap10_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR(r) (r).dsc_rx_dfe_tap10_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap10_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET(r) (r).dsc_rx_dfe_tap10_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET(r) (((r).dsc_rx_dfe_tap10_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP10_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap10_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr
#define DSC_RX_DFE_TAP10_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_t DSC_RX_DFE_TAP10_ABCDr_t;
#define DSC_RX_DFE_TAP10_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR
#define DSC_RX_DFE_TAP10_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET
#define DSC_RX_DFE_TAP10_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET
#define READ_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr
#define WRITE_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr
#define MODIFY_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr
#define READLN_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr
#define WRITELN_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP10_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP10_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd021
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr (0x0001d021 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET(r) (((r).dsc_rx_dfe_tap11_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr
#define DSC_RX_DFE_TAP11_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_t DSC_RX_DFE_TAP11_ABCDr_t;
#define DSC_RX_DFE_TAP11_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR
#define DSC_RX_DFE_TAP11_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET
#define DSC_RX_DFE_TAP11_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET
#define READ_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr
#define READLN_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP12_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd022
 * DEVAD:    1
 * DESC:     rx_dfe_tap12_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr (0x0001d022 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP12_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap12_abcd[1];
	uint32_t _dsc_rx_dfe_tap12_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR(r) (r).dsc_rx_dfe_tap12_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap12_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET(r) (r).dsc_rx_dfe_tap12_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET(r) (((r).dsc_rx_dfe_tap12_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP12_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap12_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr
#define DSC_RX_DFE_TAP12_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_t DSC_RX_DFE_TAP12_ABCDr_t;
#define DSC_RX_DFE_TAP12_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR
#define DSC_RX_DFE_TAP12_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET
#define DSC_RX_DFE_TAP12_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET
#define READ_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr
#define WRITE_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr
#define MODIFY_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr
#define READLN_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr
#define WRITELN_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP12_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP12_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd023
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr (0x0001d023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET(r) (((r).dsc_rx_dfe_tap13_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr
#define DSC_RX_DFE_TAP13_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_t DSC_RX_DFE_TAP13_ABCDr_t;
#define DSC_RX_DFE_TAP13_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR
#define DSC_RX_DFE_TAP13_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET
#define DSC_RX_DFE_TAP13_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET
#define READ_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr
#define READLN_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP14_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd024
 * DEVAD:    1
 * DESC:     rx_dfe_tap14_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr (0x0001d024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP14_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap14_abcd[1];
	uint32_t _dsc_rx_dfe_tap14_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR(r) (r).dsc_rx_dfe_tap14_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap14_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET(r) (r).dsc_rx_dfe_tap14_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET(r) (((r).dsc_rx_dfe_tap14_abcd[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP14_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap14_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr
#define DSC_RX_DFE_TAP14_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_t DSC_RX_DFE_TAP14_ABCDr_t;
#define DSC_RX_DFE_TAP14_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR
#define DSC_RX_DFE_TAP14_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET
#define DSC_RX_DFE_TAP14_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET
#define READ_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr
#define WRITE_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr
#define MODIFY_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr
#define READLN_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr
#define WRITELN_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP14_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP14_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_8_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd025
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_8_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr (0x0001d025 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_8_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_8_mux_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET(r) (((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_8_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET
#define READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_10_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd026
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_10_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr (0x0001d026 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_10_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_10_mux_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET(r) (((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_10_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET
#define READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_12_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd027
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_12_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr (0x0001d027 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_12_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_12_mux_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET(r) (((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_12_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET
#define READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_14_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd028
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_14_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr (0x0001d028 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_14_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_14_mux_abcd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET(r) (((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_14_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET
#define READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LOAD_PRESETS
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd029
 * DEVAD:    1
 * DESC:     load_presets.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_AFE       Load presets for analog interface Registers
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr (0x0001d029 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LOAD_PRESETS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_s {
	uint32_t v[1];
	uint32_t dsc_load_presets[1];
	uint32_t _dsc_load_presets;
} BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_CLR(r) (r).dsc_load_presets[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_SET(r,d) (r).dsc_load_presets[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_GET(r) (r).dsc_load_presets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_PRESET_AFEf_GET(r) (((r).dsc_load_presets[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_PRESET_AFEf_SET(r,f) (r).dsc_load_presets[0]=(((r).dsc_load_presets[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_LOAD_PRESETS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LOAD_PRESETSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LOAD_PRESETSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LOAD_PRESETSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LOAD_PRESETSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_load_presets))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LOAD_PRESETSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_load_presets))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LOAD_PRESETSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_load_presets))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr
#define DSC_LOAD_PRESETSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_t DSC_LOAD_PRESETSr_t;
#define DSC_LOAD_PRESETSr_CLR BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_CLR
#define DSC_LOAD_PRESETSr_SET BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_SET
#define DSC_LOAD_PRESETSr_GET BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_GET
#define DSC_LOAD_PRESETSr_PRESET_AFEf_GET BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_PRESET_AFEf_GET
#define DSC_LOAD_PRESETSr_PRESET_AFEf_SET BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr_PRESET_AFEf_SET
#define READ_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_READ_DSC_LOAD_PRESETSr
#define WRITE_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_LOAD_PRESETSr
#define MODIFY_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LOAD_PRESETSr
#define READLN_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_READLN_DSC_LOAD_PRESETSr
#define WRITELN_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LOAD_PRESETSr
#define WRITEALL_DSC_LOAD_PRESETSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LOAD_PRESETSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LOAD_PRESETSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ1
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd02a
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_CAL_D4 signed 2's complement rxd slicer offset adjust for ES, p3 only
 *     RXD_SLICER_OFFSET_ADJ_CAL_D5 signed 2's complement rxd slicer offset adjust for ES, p4, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r (0x0001d02a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj1[1];
	uint32_t _dsc_rxd_slcr_offs_adj1;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_CLR(r) (r).dsc_rxd_slcr_offs_adj1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_SET(r,d) (r).dsc_rxd_slcr_offs_adj1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_GET(r) (r).dsc_rxd_slcr_offs_adj1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_GET(r) ((((r).dsc_rxd_slcr_offs_adj1[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_SET(r,f) (r).dsc_rxd_slcr_offs_adj1[0]=(((r).dsc_rxd_slcr_offs_adj1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_GET(r) (((r).dsc_rxd_slcr_offs_adj1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_SET(r,f) (r).dsc_rxd_slcr_offs_adj1[0]=(((r).dsc_rxd_slcr_offs_adj1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r,(_r._dsc_rxd_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r,(_r._dsc_rxd_slcr_offs_adj1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r,(_r._dsc_rxd_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r
#define DSC_RXD_SLCR_OFFS_ADJ1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_t DSC_RXD_SLCR_OFFS_ADJ1r_t;
#define DSC_RXD_SLCR_OFFS_ADJ1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_CLR
#define DSC_RXD_SLCR_OFFS_ADJ1r_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_SET
#define DSC_RXD_SLCR_OFFS_ADJ1r_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_GET
#define DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_GET
#define DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D5f_SET
#define DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_GET
#define DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r_RXD_SLICER_OFFSET_ADJ_CAL_D4f_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ1r
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ1r
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ1r
#define READLN_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ1r
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ1r
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ2
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd02b
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_CAL_D2 signed 2's complement rxd slicer offset adjust for ES, m1, NS
 *     RXD_SLICER_OFFSET_ADJ_CAL_D3 signed 2's complement rxd slicer offset adjust for ES, p1 only
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r (0x0001d02b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj2[1];
	uint32_t _dsc_rxd_slcr_offs_adj2;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_CLR(r) (r).dsc_rxd_slcr_offs_adj2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_SET(r,d) (r).dsc_rxd_slcr_offs_adj2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_GET(r) (r).dsc_rxd_slcr_offs_adj2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_GET(r) ((((r).dsc_rxd_slcr_offs_adj2[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_SET(r,f) (r).dsc_rxd_slcr_offs_adj2[0]=(((r).dsc_rxd_slcr_offs_adj2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_GET(r) (((r).dsc_rxd_slcr_offs_adj2[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_SET(r,f) (r).dsc_rxd_slcr_offs_adj2[0]=(((r).dsc_rxd_slcr_offs_adj2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r,(_r._dsc_rxd_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r,(_r._dsc_rxd_slcr_offs_adj2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r,(_r._dsc_rxd_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r
#define DSC_RXD_SLCR_OFFS_ADJ2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_t DSC_RXD_SLCR_OFFS_ADJ2r_t;
#define DSC_RXD_SLCR_OFFS_ADJ2r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_CLR
#define DSC_RXD_SLCR_OFFS_ADJ2r_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_SET
#define DSC_RXD_SLCR_OFFS_ADJ2r_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_GET
#define DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_GET
#define DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D3f_SET
#define DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_GET
#define DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r_RXD_SLICER_OFFSET_ADJ_CAL_D2f_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ2r
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ2r
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ2r
#define READLN_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ2r
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ2r
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ3
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd02c
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_3 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_CAL_D0 signed 2's complement rxd slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR
 *     RXD_SLICER_OFFSET_ADJ_CAL_D1 signed 2's complement rxd slicer offset adjust for ES, m3, NS
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r (0x0001d02c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj3[1];
	uint32_t _dsc_rxd_slcr_offs_adj3;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_CLR(r) (r).dsc_rxd_slcr_offs_adj3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_SET(r,d) (r).dsc_rxd_slcr_offs_adj3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_GET(r) (r).dsc_rxd_slcr_offs_adj3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_GET(r) ((((r).dsc_rxd_slcr_offs_adj3[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_SET(r,f) (r).dsc_rxd_slcr_offs_adj3[0]=(((r).dsc_rxd_slcr_offs_adj3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_GET(r) (((r).dsc_rxd_slcr_offs_adj3[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_SET(r,f) (r).dsc_rxd_slcr_offs_adj3[0]=(((r).dsc_rxd_slcr_offs_adj3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r,(_r._dsc_rxd_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r,(_r._dsc_rxd_slcr_offs_adj3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r,(_r._dsc_rxd_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r
#define DSC_RXD_SLCR_OFFS_ADJ3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_t DSC_RXD_SLCR_OFFS_ADJ3r_t;
#define DSC_RXD_SLCR_OFFS_ADJ3r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_CLR
#define DSC_RXD_SLCR_OFFS_ADJ3r_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_SET
#define DSC_RXD_SLCR_OFFS_ADJ3r_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_GET
#define DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_GET
#define DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D1f_SET
#define DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_GET
#define DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r_RXD_SLICER_OFFSET_ADJ_CAL_D0f_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ3r
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ3r
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ3r
#define READLN_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ3r
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ3r
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ4
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd02d
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_4 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_CAL_P1 signed 2's complement rxd slicer offset adjust for ES, NS
 *     RXD_SLICER_OFFSET_ADJ_CAL_P2 signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r (0x0001d02d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj4[1];
	uint32_t _dsc_rxd_slcr_offs_adj4;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_CLR(r) (r).dsc_rxd_slcr_offs_adj4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_SET(r,d) (r).dsc_rxd_slcr_offs_adj4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_GET(r) (r).dsc_rxd_slcr_offs_adj4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_GET(r) ((((r).dsc_rxd_slcr_offs_adj4[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_SET(r,f) (r).dsc_rxd_slcr_offs_adj4[0]=(((r).dsc_rxd_slcr_offs_adj4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_GET(r) (((r).dsc_rxd_slcr_offs_adj4[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_SET(r,f) (r).dsc_rxd_slcr_offs_adj4[0]=(((r).dsc_rxd_slcr_offs_adj4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r,(_r._dsc_rxd_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r,(_r._dsc_rxd_slcr_offs_adj4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r,(_r._dsc_rxd_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r
#define DSC_RXD_SLCR_OFFS_ADJ4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_t DSC_RXD_SLCR_OFFS_ADJ4r_t;
#define DSC_RXD_SLCR_OFFS_ADJ4r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_CLR
#define DSC_RXD_SLCR_OFFS_ADJ4r_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_SET
#define DSC_RXD_SLCR_OFFS_ADJ4r_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_GET
#define DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_GET
#define DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P2f_SET
#define DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_GET
#define DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r_RXD_SLICER_OFFSET_ADJ_CAL_P1f_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ4r
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ4r
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ4r
#define READLN_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ4r
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ4r
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ5
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd02e
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_5 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_CAL_LMS signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 *     RXD_SLICER_OFFSET_ADJ_CAL_P0 signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r (0x0001d02e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj5[1];
	uint32_t _dsc_rxd_slcr_offs_adj5;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_CLR(r) (r).dsc_rxd_slcr_offs_adj5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_SET(r,d) (r).dsc_rxd_slcr_offs_adj5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_GET(r) (r).dsc_rxd_slcr_offs_adj5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_GET(r) ((((r).dsc_rxd_slcr_offs_adj5[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_SET(r,f) (r).dsc_rxd_slcr_offs_adj5[0]=(((r).dsc_rxd_slcr_offs_adj5[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_GET(r) (((r).dsc_rxd_slcr_offs_adj5[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_SET(r,f) (r).dsc_rxd_slcr_offs_adj5[0]=(((r).dsc_rxd_slcr_offs_adj5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r,(_r._dsc_rxd_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r,(_r._dsc_rxd_slcr_offs_adj5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r,(_r._dsc_rxd_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r
#define DSC_RXD_SLCR_OFFS_ADJ5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_t DSC_RXD_SLCR_OFFS_ADJ5r_t;
#define DSC_RXD_SLCR_OFFS_ADJ5r_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_CLR
#define DSC_RXD_SLCR_OFFS_ADJ5r_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_SET
#define DSC_RXD_SLCR_OFFS_ADJ5r_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_GET
#define DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_GET
#define DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_P0f_SET
#define DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_GET
#define DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r_RXD_SLICER_OFFSET_ADJ_CAL_LMSf_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ5r
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ5r
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ5r
#define READLN_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ5r
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ5r
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_SLCR_OFFS_ADJ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_0A
 * BLOCKS:   DSC_A
 * REGADDR:  0xd030
 * DEVAD:    1
 * DESC:     trnsum pattern control 0a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_0 Related to the pattern based conditioning of trnsum.Pattern Match sel | pattern0 | pattern1 | pattern2--------------------------------------------------nrz						     | rx data  | {*1}     | {*2}pam4						     | lsb/bit0 | msb/bit1 | {*2}pam4 tbd  symbols 				     | lsb/bit0 | bit1     | bit2 (msb of the symbol)pam4 tbd dfe data 				     | lsb      | msb      | {*2}lms          					     | lms      | {*1}     | {*2}{*1}: set trnsum_pattern_1_bit_en to 0.{*2}: set trnsum_pattern_2_bit_en to 0.
 *     TRNSUM_PATTERN_FULL_CHECK_OFF one symbol location per interleave is enabled every rclk20.locations enabled [2,7,12,17] <> interleave [c, d, a, b]
 *     TRNSUM_EDGE_PATTERN_EN enables pattern matching on edges {-6,-5,-4,-3,-2,-1,data,0,1,2}.where a number (eg: -4) represents an edge between d[-4] and d[-3].This mode is only supported in NRZ modes.
 *     TRNSUM_INV_PATTERN_EN enables inverted pattern matching.This mode is only supported in NRZ modes.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar (0x0001d030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_0A.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_0a[1];
	uint32_t _dsc_trnsum_pat_ctl_0a;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_CLR(r) (r).dsc_trnsum_pat_ctl_0a[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_SET(r,d) (r).dsc_trnsum_pat_ctl_0a[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_GET(r) (r).dsc_trnsum_pat_ctl_0a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl_0a[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl_0a[0]=(((r).dsc_trnsum_pat_ctl_0a[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl_0a[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl_0a[0]=(((r).dsc_trnsum_pat_ctl_0a[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET(r) ((((r).dsc_trnsum_pat_ctl_0a[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET(r,f) (r).dsc_trnsum_pat_ctl_0a[0]=(((r).dsc_trnsum_pat_ctl_0a[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_GET(r) (((r).dsc_trnsum_pat_ctl_0a[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_SET(r,f) (r).dsc_trnsum_pat_ctl_0a[0]=(((r).dsc_trnsum_pat_ctl_0a[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_0A.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar,(_r._dsc_trnsum_pat_ctl_0a))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar,(_r._dsc_trnsum_pat_ctl_0a)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar,(_r._dsc_trnsum_pat_ctl_0a))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_0a))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_0a))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_0Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_0a))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar
#define DSC_TRNSUM_PAT_CTL_0Ar_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_t DSC_TRNSUM_PAT_CTL_0Ar_t;
#define DSC_TRNSUM_PAT_CTL_0Ar_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_CLR
#define DSC_TRNSUM_PAT_CTL_0Ar_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_SET
#define DSC_TRNSUM_PAT_CTL_0Ar_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_GET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_INV_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_EDGE_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_GET
#define DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar_TRNSUM_PATTERN_0f_SET
#define READ_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_0Ar
#define WRITE_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_0Ar
#define MODIFY_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_0Ar
#define READLN_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_0Ar
#define WRITELN_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_0Ar
#define WRITEALL_DSC_TRNSUM_PAT_CTL_0Ar BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_0Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_0B
 * BLOCKS:   DSC_A
 * REGADDR:  0xd031
 * DEVAD:    1
 * DESC:     trnsum pattern control 0b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_0_BIT_EN pattern mask 0 - corresponds to pattern_0See desciption of trnsum_pattern_0
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br (0x0001d031 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_0B.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_0b[1];
	uint32_t _dsc_trnsum_pat_ctl_0b;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_CLR(r) (r).dsc_trnsum_pat_ctl_0b[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_SET(r,d) (r).dsc_trnsum_pat_ctl_0b[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_GET(r) (r).dsc_trnsum_pat_ctl_0b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_GET(r) (((r).dsc_trnsum_pat_ctl_0b[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl_0b[0]=(((r).dsc_trnsum_pat_ctl_0b[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_0B.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_0Br(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br,(_r._dsc_trnsum_pat_ctl_0b))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_0Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br,(_r._dsc_trnsum_pat_ctl_0b)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_0Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br,(_r._dsc_trnsum_pat_ctl_0b))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_0Br(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_0b))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_0Br(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_0b))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_0Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_0b))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br
#define DSC_TRNSUM_PAT_CTL_0Br_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_t DSC_TRNSUM_PAT_CTL_0Br_t;
#define DSC_TRNSUM_PAT_CTL_0Br_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_CLR
#define DSC_TRNSUM_PAT_CTL_0Br_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_SET
#define DSC_TRNSUM_PAT_CTL_0Br_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_GET
#define DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_GET
#define DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br_TRNSUM_PATTERN_0_BIT_ENf_SET
#define READ_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_0Br
#define WRITE_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_0Br
#define MODIFY_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_0Br
#define READLN_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_0Br
#define WRITELN_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_0Br
#define WRITEALL_DSC_TRNSUM_PAT_CTL_0Br BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_0Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_0Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_1A
 * BLOCKS:   DSC_A
 * REGADDR:  0xd032
 * DEVAD:    1
 * DESC:     trnsum pattern control 1a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_1 pattern to be compared.See desciption of trnsum_pattern_0
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar (0x0001d032 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_1A.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_1a[1];
	uint32_t _dsc_trnsum_pat_ctl_1a;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_CLR(r) (r).dsc_trnsum_pat_ctl_1a[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_SET(r,d) (r).dsc_trnsum_pat_ctl_1a[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_GET(r) (r).dsc_trnsum_pat_ctl_1a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_GET(r) (((r).dsc_trnsum_pat_ctl_1a[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_SET(r,f) (r).dsc_trnsum_pat_ctl_1a[0]=(((r).dsc_trnsum_pat_ctl_1a[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_1A.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar,(_r._dsc_trnsum_pat_ctl_1a))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar,(_r._dsc_trnsum_pat_ctl_1a)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar,(_r._dsc_trnsum_pat_ctl_1a))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_1a))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_1a))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_1Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_1a))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar
#define DSC_TRNSUM_PAT_CTL_1Ar_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_t DSC_TRNSUM_PAT_CTL_1Ar_t;
#define DSC_TRNSUM_PAT_CTL_1Ar_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_CLR
#define DSC_TRNSUM_PAT_CTL_1Ar_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_SET
#define DSC_TRNSUM_PAT_CTL_1Ar_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_GET
#define DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_GET
#define DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar_TRNSUM_PATTERN_1f_SET
#define READ_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_1Ar
#define WRITE_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_1Ar
#define MODIFY_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_1Ar
#define READLN_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_1Ar
#define WRITELN_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_1Ar
#define WRITEALL_DSC_TRNSUM_PAT_CTL_1Ar BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_1Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_1B
 * BLOCKS:   DSC_A
 * REGADDR:  0xd033
 * DEVAD:    1
 * DESC:     trnsum pattern control 1b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_1_BIT_EN pattern mask  1 - corresponds to pattern 1See desciption of trnsum_pattern_0
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br (0x0001d033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_1B.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_1b[1];
	uint32_t _dsc_trnsum_pat_ctl_1b;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_CLR(r) (r).dsc_trnsum_pat_ctl_1b[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_SET(r,d) (r).dsc_trnsum_pat_ctl_1b[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_GET(r) (r).dsc_trnsum_pat_ctl_1b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_GET(r) (((r).dsc_trnsum_pat_ctl_1b[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl_1b[0]=(((r).dsc_trnsum_pat_ctl_1b[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_1B.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_1Br(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br,(_r._dsc_trnsum_pat_ctl_1b))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_1Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br,(_r._dsc_trnsum_pat_ctl_1b)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_1Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br,(_r._dsc_trnsum_pat_ctl_1b))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_1Br(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_1b))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_1Br(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_1b))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_1Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_1b))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br
#define DSC_TRNSUM_PAT_CTL_1Br_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_t DSC_TRNSUM_PAT_CTL_1Br_t;
#define DSC_TRNSUM_PAT_CTL_1Br_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_CLR
#define DSC_TRNSUM_PAT_CTL_1Br_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_SET
#define DSC_TRNSUM_PAT_CTL_1Br_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_GET
#define DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_GET
#define DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br_TRNSUM_PATTERN_1_BIT_ENf_SET
#define READ_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_1Br
#define WRITE_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_1Br
#define MODIFY_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_1Br
#define READLN_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_1Br
#define WRITELN_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_1Br
#define WRITEALL_DSC_TRNSUM_PAT_CTL_1Br BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_1Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_1Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_2A
 * BLOCKS:   DSC_A
 * REGADDR:  0xd034
 * DEVAD:    1
 * DESC:     trnsum pattern control 2a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_2 pattern to be compared. See desciption of trnsum_pattern_0
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar (0x0001d034 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_2A.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_2a[1];
	uint32_t _dsc_trnsum_pat_ctl_2a;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_CLR(r) (r).dsc_trnsum_pat_ctl_2a[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_SET(r,d) (r).dsc_trnsum_pat_ctl_2a[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_GET(r) (r).dsc_trnsum_pat_ctl_2a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_GET(r) (((r).dsc_trnsum_pat_ctl_2a[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_SET(r,f) (r).dsc_trnsum_pat_ctl_2a[0]=(((r).dsc_trnsum_pat_ctl_2a[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_2A.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar,(_r._dsc_trnsum_pat_ctl_2a))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar,(_r._dsc_trnsum_pat_ctl_2a)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar,(_r._dsc_trnsum_pat_ctl_2a))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_2a))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_2a))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_2Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_2a))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar
#define DSC_TRNSUM_PAT_CTL_2Ar_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_t DSC_TRNSUM_PAT_CTL_2Ar_t;
#define DSC_TRNSUM_PAT_CTL_2Ar_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_CLR
#define DSC_TRNSUM_PAT_CTL_2Ar_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_SET
#define DSC_TRNSUM_PAT_CTL_2Ar_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_GET
#define DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_GET
#define DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar_TRNSUM_PATTERN_2f_SET
#define READ_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_2Ar
#define WRITE_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_2Ar
#define MODIFY_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_2Ar
#define READLN_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_2Ar
#define WRITELN_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_2Ar
#define WRITEALL_DSC_TRNSUM_PAT_CTL_2Ar BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_2Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL_2B
 * BLOCKS:   DSC_A
 * REGADDR:  0xd035
 * DEVAD:    1
 * DESC:     trnsum pattern control 2b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_2_BIT_EN pattern mask 2 - corresponds to pattern 2See desciption of trnsum_pattern_0
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br (0x0001d035 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL_2B.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl_2b[1];
	uint32_t _dsc_trnsum_pat_ctl_2b;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_CLR(r) (r).dsc_trnsum_pat_ctl_2b[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_SET(r,d) (r).dsc_trnsum_pat_ctl_2b[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_GET(r) (r).dsc_trnsum_pat_ctl_2b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_GET(r) (((r).dsc_trnsum_pat_ctl_2b[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl_2b[0]=(((r).dsc_trnsum_pat_ctl_2b[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL_2B.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_2Br(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br,(_r._dsc_trnsum_pat_ctl_2b))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_2Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br,(_r._dsc_trnsum_pat_ctl_2b)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_2Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br,(_r._dsc_trnsum_pat_ctl_2b))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_2Br(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_2b))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_2Br(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl_2b))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_2Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl_2b))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br
#define DSC_TRNSUM_PAT_CTL_2Br_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_t DSC_TRNSUM_PAT_CTL_2Br_t;
#define DSC_TRNSUM_PAT_CTL_2Br_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_CLR
#define DSC_TRNSUM_PAT_CTL_2Br_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_SET
#define DSC_TRNSUM_PAT_CTL_2Br_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_GET
#define DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_GET
#define DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br_TRNSUM_PATTERN_2_BIT_ENf_SET
#define READ_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_PAT_CTL_2Br
#define WRITE_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_PAT_CTL_2Br
#define MODIFY_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL_2Br
#define READLN_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_PAT_CTL_2Br
#define WRITELN_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL_2Br
#define WRITEALL_DSC_TRNSUM_PAT_CTL_2Br BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL_2Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_PAT_CTL_2Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_CTL1
 * BLOCKS:   DSC_A
 * REGADDR:  0xd036
 * DEVAD:    1
 * DESC:     BLW canceller control register 1.
 * RESETVAL: 0x4296 (17046)
 * ACCESS:   R/W
 * FIELDS:
 *     BLW_LPF_COEF_MANT Pole frequency tuning coefficient mantissa (6-bit unsigned number).
 *     BLW_SPARE_CNTL_0 Spare control registers. Reserved for future use.
 *     BLW_LPF_COEF_EXP Pole frequency tuning coefficient exponent (2-bit selector)00 (shift right by 14)01 (shift right by 15)10 (shift right by 16)11 (shift right by 17)
 *     BLW_MAX_AMP_SEL  Select bit for blw_max_amp status sources. 0 -> blw_max_amp status field will report the peak detctor output. 1 -> blw_max_amp status field will report the peak detector input (i.e. 8 bits dc_corr post saturation)
 *     BLW_RESET        Active high reset control. Reset the internal state of the entire BLW canceller block. Should be asserted while blw_en=0.
 *     BLW_OUTPUT_INVERT Invert the polarity of the BLW canceller output.
 *     BLW_PHASE_SLICER_INVERT Invert the polarity of the phase slicer data from the CDR.
 *     BLW_GAIN_FRZ     Freeze gain adaptation and maintain a constant value.
 *     BLW_EN           BLW Canceller enable. 1'b1 will enable the BLW canceller and 1'b0 will disable it. When BLW block is disabled then BLW output will be forced to 1'b0.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r (0x0001d036 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_blw_ctl1[1];
	uint32_t _dsc_blw_ctl1;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_CLR(r) (r).dsc_blw_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_SET(r,d) (r).dsc_blw_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_GET(r) (r).dsc_blw_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_ENf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_ENf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_GAIN_FRZf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_GAIN_FRZf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_RESETf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_RESETf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_GET(r) ((((r).dsc_blw_ctl1[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_GET(r) ((((r).dsc_blw_ctl1[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_GET(r) (((r).dsc_blw_ctl1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_SET(r,f) (r).dsc_blw_ctl1[0]=(((r).dsc_blw_ctl1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_BLW_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r,(_r._dsc_blw_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r,(_r._dsc_blw_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r,(_r._dsc_blw_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r
#define DSC_BLW_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_t DSC_BLW_CTL1r_t;
#define DSC_BLW_CTL1r_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_CLR
#define DSC_BLW_CTL1r_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_SET
#define DSC_BLW_CTL1r_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_GET
#define DSC_BLW_CTL1r_BLW_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_ENf_GET
#define DSC_BLW_CTL1r_BLW_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_ENf_SET
#define DSC_BLW_CTL1r_BLW_GAIN_FRZf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_GAIN_FRZf_GET
#define DSC_BLW_CTL1r_BLW_GAIN_FRZf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_GAIN_FRZf_SET
#define DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_GET
#define DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_PHASE_SLICER_INVERTf_SET
#define DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_GET
#define DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_OUTPUT_INVERTf_SET
#define DSC_BLW_CTL1r_BLW_RESETf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_RESETf_GET
#define DSC_BLW_CTL1r_BLW_RESETf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_RESETf_SET
#define DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_GET
#define DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_MAX_AMP_SELf_SET
#define DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_GET
#define DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_EXPf_SET
#define DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_GET
#define DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_SPARE_CNTL_0f_SET
#define DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_GET
#define DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r_BLW_LPF_COEF_MANTf_SET
#define READ_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL1r
#define WRITE_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL1r
#define MODIFY_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL1r
#define READLN_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL1r
#define WRITELN_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL1r
#define WRITEALL_DSC_BLW_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_CTL2
 * BLOCKS:   DSC_A
 * REGADDR:  0xd037
 * DEVAD:    1
 * DESC:     BLW canceller control register 2.
 * RESETVAL: 0x1002 (4098)
 * ACCESS:   R/W
 * FIELDS:
 *     BLW_OUTPUT_SCALE Programmable truncation for the BLW output.blw_output_scale and blw_2x_mode are added (unsigned) together to create "L" in the system diagram above.000 (shift right by 6)001 (shift right by 7)010 (shift right by 8)011 (shift right by 9)100 (shift right by 10)101 (shift right by 11)110 (shift right by 12)111 (shift right by 13)
 *     DC_OFFS_INT_READ_EN Read status select in the status field dc_offset_bin. 1 -> read the internal DC offset status, 0 -> read the final DC offset value goig to the analog
 *     BLW_TRNSUM_SEL   Select a particular signal within the BLW block to send to the TRNSUM block for accumulation. Refer to section 4.1 for more details.
 *     BLW_MAX_AMP_CLR  Clear the max amplitude register and re-start from zero. Self-clear register field.
 *     BLW_2X_MODE      Enable OFFSET DAC 2x MODE by lowering the output BLW correction to half. blw_output_scale and blw_2x_mode are added (unsigned) together for Truncation of the BLW correction.
 *     BLW_MU_DLY_MODE  Control for blw_mu dly.00 - no delay.01 - 1 to 2 ms delay.10 - 2 to 3 ms delay.11 - reserved.
 *     BLW_LMS_MU       Step-size (mu) for the LMS gain adaptation loop. ("M" in the system diagram above)00 (no truncation)01 (truncate by 1)10 (truncate by 2)11 (truncate by 3)
 *     BLW_GAIN_SCALE   Programmable truncation after the gain gets registered ("G" in the system diagram above)00 (truncate by 8)01 (truncate by 9)10 (truncate by 10)11 (truncate by 11)
 *     DC_OFFS_DAC_INTEG_EN Enable the integrator at the interface with the DC offset DAC.
 *     DC_OFFS_DAC_8B_EN Saturate the BLW output to either 7-bits (1'b0) or 8-bits (1'b1).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r (0x0001d037 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_blw_ctl2[1];
	uint32_t _dsc_blw_ctl2;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_CLR(r) (r).dsc_blw_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_SET(r,d) (r).dsc_blw_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_GET(r) (r).dsc_blw_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_GAIN_SCALEf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_GAIN_SCALEf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_LMS_MUf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_LMS_MUf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_2X_MODEf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_2X_MODEf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_TRNSUM_SELf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_TRNSUM_SELf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_GET(r) ((((r).dsc_blw_ctl2[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_GET(r) (((r).dsc_blw_ctl2[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_SET(r,f) (r).dsc_blw_ctl2[0]=(((r).dsc_blw_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_BLW_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r,(_r._dsc_blw_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r,(_r._dsc_blw_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r,(_r._dsc_blw_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r
#define DSC_BLW_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_t DSC_BLW_CTL2r_t;
#define DSC_BLW_CTL2r_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_CLR
#define DSC_BLW_CTL2r_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_SET
#define DSC_BLW_CTL2r_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_GET
#define DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_GET
#define DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_8B_ENf_SET
#define DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_GET
#define DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_DAC_INTEG_ENf_SET
#define DSC_BLW_CTL2r_BLW_GAIN_SCALEf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_GAIN_SCALEf_GET
#define DSC_BLW_CTL2r_BLW_GAIN_SCALEf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_GAIN_SCALEf_SET
#define DSC_BLW_CTL2r_BLW_LMS_MUf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_LMS_MUf_GET
#define DSC_BLW_CTL2r_BLW_LMS_MUf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_LMS_MUf_SET
#define DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_GET
#define DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MU_DLY_MODEf_SET
#define DSC_BLW_CTL2r_BLW_2X_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_2X_MODEf_GET
#define DSC_BLW_CTL2r_BLW_2X_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_2X_MODEf_SET
#define DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_GET
#define DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_MAX_AMP_CLRf_SET
#define DSC_BLW_CTL2r_BLW_TRNSUM_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_TRNSUM_SELf_GET
#define DSC_BLW_CTL2r_BLW_TRNSUM_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_TRNSUM_SELf_SET
#define DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_GET
#define DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_DC_OFFS_INT_READ_ENf_SET
#define DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_GET
#define DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r_BLW_OUTPUT_SCALEf_SET
#define READ_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL2r
#define WRITE_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL2r
#define MODIFY_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL2r
#define READLN_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL2r
#define WRITELN_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL2r
#define WRITEALL_DSC_BLW_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_CTL3
 * BLOCKS:   DSC_A
 * REGADDR:  0xd038
 * DEVAD:    1
 * DESC:     BLW canceller control register 3.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLW_GAIN_FRC_VAL Write/force value to the adaptive gain register in 2's complement signed format.
 *     BLW_GAIN_FRC     Enable/force writing to the adaptive gain register. This is a self-clear register.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r (0x0001d038 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_blw_ctl3[1];
	uint32_t _dsc_blw_ctl3;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_CLR(r) (r).dsc_blw_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_SET(r,d) (r).dsc_blw_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_GET(r) (r).dsc_blw_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRCf_GET(r) ((((r).dsc_blw_ctl3[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRCf_SET(r,f) (r).dsc_blw_ctl3[0]=(((r).dsc_blw_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_GET(r) (((r).dsc_blw_ctl3[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_SET(r,f) (r).dsc_blw_ctl3[0]=(((r).dsc_blw_ctl3[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access DSC_BLW_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r,(_r._dsc_blw_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r,(_r._dsc_blw_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r,(_r._dsc_blw_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r
#define DSC_BLW_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_t DSC_BLW_CTL3r_t;
#define DSC_BLW_CTL3r_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_CLR
#define DSC_BLW_CTL3r_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_SET
#define DSC_BLW_CTL3r_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_GET
#define DSC_BLW_CTL3r_BLW_GAIN_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRCf_GET
#define DSC_BLW_CTL3r_BLW_GAIN_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRCf_SET
#define DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_GET
#define DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r_BLW_GAIN_FRC_VALf_SET
#define READ_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL3r
#define WRITE_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL3r
#define MODIFY_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL3r
#define READLN_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL3r
#define WRITELN_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL3r
#define WRITEALL_DSC_BLW_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_CTL4
 * BLOCKS:   DSC_A
 * REGADDR:  0xd039
 * DEVAD:    1
 * DESC:     BLW canceller control register 4.
 * RESETVAL: 0x7fff (32767)
 * ACCESS:   R/W
 * FIELDS:
 *     BLW_GAIN_SAT_HIGH Upper saturation limit for the adaptive gain loop in 2's complement signed format. Valid value 0 to 2^15 - 1 (decimal).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r (0x0001d039 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_blw_ctl4[1];
	uint32_t _dsc_blw_ctl4;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_CLR(r) (r).dsc_blw_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_SET(r,d) (r).dsc_blw_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_GET(r) (r).dsc_blw_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_GET(r) (((r).dsc_blw_ctl4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_SET(r,f) (r).dsc_blw_ctl4[0]=(((r).dsc_blw_ctl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_BLW_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r,(_r._dsc_blw_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r,(_r._dsc_blw_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r,(_r._dsc_blw_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r
#define DSC_BLW_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_t DSC_BLW_CTL4r_t;
#define DSC_BLW_CTL4r_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_CLR
#define DSC_BLW_CTL4r_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_SET
#define DSC_BLW_CTL4r_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_GET
#define DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_GET
#define DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r_BLW_GAIN_SAT_HIGHf_SET
#define READ_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL4r
#define WRITE_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL4r
#define MODIFY_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL4r
#define READLN_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL4r
#define WRITELN_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL4r
#define WRITEALL_DSC_BLW_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_CTL5
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03a
 * DEVAD:    1
 * DESC:     BLW canceller control register 5.
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     BLW_GAIN_SAT_LOW Lower saturation limit for the adaptive gain loop in 2's complement signed format. Valid value of -1 to -2^15 (decimal).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r (0x0001d03a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_blw_ctl5[1];
	uint32_t _dsc_blw_ctl5;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_CLR(r) (r).dsc_blw_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_SET(r,d) (r).dsc_blw_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_GET(r) (r).dsc_blw_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_GET(r) (((r).dsc_blw_ctl5[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_SET(r,f) (r).dsc_blw_ctl5[0]=(((r).dsc_blw_ctl5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_BLW_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r,(_r._dsc_blw_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r,(_r._dsc_blw_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r,(_r._dsc_blw_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r
#define DSC_BLW_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_t DSC_BLW_CTL5r_t;
#define DSC_BLW_CTL5r_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_CLR
#define DSC_BLW_CTL5r_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_SET
#define DSC_BLW_CTL5r_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_GET
#define DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_GET
#define DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r_BLW_GAIN_SAT_LOWf_SET
#define READ_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_CTL5r
#define WRITE_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_CTL5r
#define MODIFY_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_CTL5r
#define READLN_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_CTL5r
#define WRITELN_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_CTL5r
#define WRITEALL_DSC_BLW_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_STS_1_TYPE
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03b
 * DEVAD:    1
 * DESC:     BLW canceller status register 1
 * RESETVAL: 0x20 (32)
 * ACCESS:   R/O
 * FIELDS:
 *     BLW_GAIN         Status of the instantaneous value of the adaptive gain in 2's complement signed format.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr (0x0001d03b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_STS_1_TYPE.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_s {
	uint32_t v[1];
	uint32_t dsc_blw_sts_1_type[1];
	uint32_t _dsc_blw_sts_1_type;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_CLR(r) (r).dsc_blw_sts_1_type[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_SET(r,d) (r).dsc_blw_sts_1_type[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_GET(r) (r).dsc_blw_sts_1_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_BLW_GAINf_GET(r) (((r).dsc_blw_sts_1_type[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_BLW_GAINf_SET(r,f) (r).dsc_blw_sts_1_type[0]=(((r).dsc_blw_sts_1_type[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access DSC_BLW_STS_1_TYPE.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_STS_1_TYPEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr,(_r._dsc_blw_sts_1_type))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_STS_1_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr,(_r._dsc_blw_sts_1_type)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_STS_1_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr,(_r._dsc_blw_sts_1_type))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_STS_1_TYPEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_sts_1_type))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_STS_1_TYPEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_sts_1_type))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_STS_1_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_sts_1_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr
#define DSC_BLW_STS_1_TYPEr_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_t DSC_BLW_STS_1_TYPEr_t;
#define DSC_BLW_STS_1_TYPEr_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_CLR
#define DSC_BLW_STS_1_TYPEr_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_SET
#define DSC_BLW_STS_1_TYPEr_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_GET
#define DSC_BLW_STS_1_TYPEr_BLW_GAINf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_BLW_GAINf_GET
#define DSC_BLW_STS_1_TYPEr_BLW_GAINf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr_BLW_GAINf_SET
#define READ_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_STS_1_TYPEr
#define WRITE_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_STS_1_TYPEr
#define MODIFY_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_STS_1_TYPEr
#define READLN_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_STS_1_TYPEr
#define WRITELN_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_STS_1_TYPEr
#define WRITEALL_DSC_BLW_STS_1_TYPEr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_STS_1_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_1_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_BLW_STS_2_TYPE
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03c
 * DEVAD:    1
 * DESC:     BLW canceller status register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BLW_MAX_AMP      The maximum amplitude encountered at the output of the BLW block since the last reset or clear. Can be positive or negative.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr (0x0001d03c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program DSC_BLW_STS_2_TYPE.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_s {
	uint32_t v[1];
	uint32_t dsc_blw_sts_2_type[1];
	uint32_t _dsc_blw_sts_2_type;
} BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_CLR(r) (r).dsc_blw_sts_2_type[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_SET(r,d) (r).dsc_blw_sts_2_type[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_GET(r) (r).dsc_blw_sts_2_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_GET(r) (((r).dsc_blw_sts_2_type[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_SET(r,f) (r).dsc_blw_sts_2_type[0]=(((r).dsc_blw_sts_2_type[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_BLW_STS_2_TYPE.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_STS_2_TYPEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr,(_r._dsc_blw_sts_2_type))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_STS_2_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr,(_r._dsc_blw_sts_2_type)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_STS_2_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr,(_r._dsc_blw_sts_2_type))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_STS_2_TYPEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_sts_2_type))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_STS_2_TYPEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_blw_sts_2_type))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_STS_2_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_blw_sts_2_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr
#define DSC_BLW_STS_2_TYPEr_SIZE BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_t DSC_BLW_STS_2_TYPEr_t;
#define DSC_BLW_STS_2_TYPEr_CLR BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_CLR
#define DSC_BLW_STS_2_TYPEr_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_SET
#define DSC_BLW_STS_2_TYPEr_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_GET
#define DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_GET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_GET
#define DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_SET BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr_BLW_MAX_AMPf_SET
#define READ_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_READ_DSC_BLW_STS_2_TYPEr
#define WRITE_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_WRITE_DSC_BLW_STS_2_TYPEr
#define MODIFY_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_BLW_STS_2_TYPEr
#define READLN_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_READLN_DSC_BLW_STS_2_TYPEr
#define WRITELN_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_BLW_STS_2_TYPEr
#define WRITEALL_DSC_BLW_STS_2_TYPEr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_BLW_STS_2_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_BLW_STS_2_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03d
 * DEVAD:    1
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr (0x0001d03d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_UC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_UC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_uc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_UC_CTLr
#define READLN_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_UC_CTLr
#define WRITELN_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_UC_CTLr
#define WRITEALL_DSC_UC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03e
 * DEVAD:    1
 * DESC:     DSC uC Scratch
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr (0x0001d03e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr,(_r._dsc_scratch)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SCRATCHr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SCRATCHr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_scratch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SCRATCHr
#define READLN_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_READLN_DSC_SCRATCHr
#define WRITELN_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SCRATCHr
#define WRITEALL_DSC_SCRATCHr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SCRATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SCRATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_A_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd040
 * DEVAD:    1
 * DESC:     trnsum a low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A_LOW     Trnsum interleave 'a' LSB result (7:0)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr (0x0001d040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a_lo[1];
	uint32_t _dsc_trnsum_a_lo;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_CLR(r) (r).dsc_trnsum_a_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_SET(r,d) (r).dsc_trnsum_a_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_GET(r) (r).dsc_trnsum_a_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET(r) ((((r).dsc_trnsum_a_lo[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET(r,f) (r).dsc_trnsum_a_lo[0]=(((r).dsc_trnsum_a_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_A_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_A_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_A_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_a_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr
#define DSC_TRNSUM_A_LOr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_t DSC_TRNSUM_A_LOr_t;
#define DSC_TRNSUM_A_LOr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_CLR
#define DSC_TRNSUM_A_LOr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_SET
#define DSC_TRNSUM_A_LOr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET
#define READ_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_A_LOr
#define WRITE_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_A_LOr
#define MODIFY_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_A_LOr
#define READLN_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_A_LOr
#define WRITELN_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_A_LOr
#define WRITEALL_DSC_TRNSUM_A_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_A_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_A_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_A
 * BLOCKS:   DSC_B
 * REGADDR:  0xd041
 * DEVAD:    1
 * DESC:     trnsum a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A         Trnsum interleave 'a' result (23:8)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar (0x0001d041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a[1];
	uint32_t _dsc_trnsum_a;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_CLR(r) (r).dsc_trnsum_a[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_SET(r,d) (r).dsc_trnsum_a[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_GET(r) (r).dsc_trnsum_a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_GET(r) (((r).dsc_trnsum_a[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_SET(r,f) (r).dsc_trnsum_a[0]=(((r).dsc_trnsum_a[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_A.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Ar(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Ar(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Ar(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Ar(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_a))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar
#define DSC_TRNSUM_Ar_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_t DSC_TRNSUM_Ar_t;
#define DSC_TRNSUM_Ar_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_CLR
#define DSC_TRNSUM_Ar_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_SET
#define DSC_TRNSUM_Ar_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_SET
#define READ_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Ar
#define WRITE_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Ar
#define MODIFY_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Ar
#define READLN_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Ar
#define WRITELN_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Ar
#define WRITEALL_DSC_TRNSUM_Ar BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_B_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd042
 * DEVAD:    1
 * DESC:     trnsum b low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B_LOW     Trnsum interleave 'b' LSB result (7:0)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr (0x0001d042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b_lo[1];
	uint32_t _dsc_trnsum_b_lo;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_CLR(r) (r).dsc_trnsum_b_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_SET(r,d) (r).dsc_trnsum_b_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_GET(r) (r).dsc_trnsum_b_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET(r) ((((r).dsc_trnsum_b_lo[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET(r,f) (r).dsc_trnsum_b_lo[0]=(((r).dsc_trnsum_b_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_B_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_B_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_B_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_b_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr
#define DSC_TRNSUM_B_LOr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_t DSC_TRNSUM_B_LOr_t;
#define DSC_TRNSUM_B_LOr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_CLR
#define DSC_TRNSUM_B_LOr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_SET
#define DSC_TRNSUM_B_LOr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET
#define READ_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_B_LOr
#define WRITE_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_B_LOr
#define MODIFY_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_B_LOr
#define READLN_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_B_LOr
#define WRITELN_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_B_LOr
#define WRITEALL_DSC_TRNSUM_B_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_B_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_B_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_B
 * BLOCKS:   DSC_B
 * REGADDR:  0xd043
 * DEVAD:    1
 * DESC:     trnsum b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B         Trnsum interleave 'b' result (23:8)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br (0x0001d043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b[1];
	uint32_t _dsc_trnsum_b;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_CLR(r) (r).dsc_trnsum_b[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_SET(r,d) (r).dsc_trnsum_b[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_GET(r) (r).dsc_trnsum_b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_GET(r) (((r).dsc_trnsum_b[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_SET(r,f) (r).dsc_trnsum_b[0]=(((r).dsc_trnsum_b[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_B.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Br(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Br(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Br(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Br(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_b))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br
#define DSC_TRNSUM_Br_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_t DSC_TRNSUM_Br_t;
#define DSC_TRNSUM_Br_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_CLR
#define DSC_TRNSUM_Br_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_SET
#define DSC_TRNSUM_Br_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_SET
#define READ_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Br
#define WRITE_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Br
#define MODIFY_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Br
#define READLN_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Br
#define WRITELN_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Br
#define WRITEALL_DSC_TRNSUM_Br BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_C_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd044
 * DEVAD:    1
 * DESC:     trnsum c low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C_LOW     Trnsum interleave 'c' LSB result (7:0)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr (0x0001d044 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c_lo[1];
	uint32_t _dsc_trnsum_c_lo;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_CLR(r) (r).dsc_trnsum_c_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_SET(r,d) (r).dsc_trnsum_c_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_GET(r) (r).dsc_trnsum_c_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET(r) ((((r).dsc_trnsum_c_lo[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET(r,f) (r).dsc_trnsum_c_lo[0]=(((r).dsc_trnsum_c_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_C_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_C_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_C_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_c_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr
#define DSC_TRNSUM_C_LOr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_t DSC_TRNSUM_C_LOr_t;
#define DSC_TRNSUM_C_LOr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_CLR
#define DSC_TRNSUM_C_LOr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_SET
#define DSC_TRNSUM_C_LOr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET
#define READ_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_C_LOr
#define WRITE_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_C_LOr
#define MODIFY_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_C_LOr
#define READLN_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_C_LOr
#define WRITELN_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_C_LOr
#define WRITEALL_DSC_TRNSUM_C_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_C_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_C_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_C
 * BLOCKS:   DSC_B
 * REGADDR:  0xd045
 * DEVAD:    1
 * DESC:     trnsum c register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C         Trnsum interleave 'c' result (23:8)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr (0x0001d045 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c[1];
	uint32_t _dsc_trnsum_c;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_CLR(r) (r).dsc_trnsum_c[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_SET(r,d) (r).dsc_trnsum_c[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_GET(r) (r).dsc_trnsum_c[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_GET(r) (((r).dsc_trnsum_c[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_SET(r,f) (r).dsc_trnsum_c[0]=(((r).dsc_trnsum_c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_C.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Cr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Cr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Cr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Cr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Cr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Cr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_c))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr
#define DSC_TRNSUM_Cr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_t DSC_TRNSUM_Cr_t;
#define DSC_TRNSUM_Cr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_CLR
#define DSC_TRNSUM_Cr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_SET
#define DSC_TRNSUM_Cr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_SET
#define READ_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Cr
#define WRITE_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Cr
#define MODIFY_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Cr
#define READLN_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Cr
#define WRITELN_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Cr
#define WRITEALL_DSC_TRNSUM_Cr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Cr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Cr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_D_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd046
 * DEVAD:    1
 * DESC:     trnsum d low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D_LOW     Trnsum interleave 'd' LSB result (7:0)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr (0x0001d046 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d_lo[1];
	uint32_t _dsc_trnsum_d_lo;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_CLR(r) (r).dsc_trnsum_d_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_SET(r,d) (r).dsc_trnsum_d_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_GET(r) (r).dsc_trnsum_d_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET(r) ((((r).dsc_trnsum_d_lo[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET(r,f) (r).dsc_trnsum_d_lo[0]=(((r).dsc_trnsum_d_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_D_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_D_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_D_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_d_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr
#define DSC_TRNSUM_D_LOr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_t DSC_TRNSUM_D_LOr_t;
#define DSC_TRNSUM_D_LOr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_CLR
#define DSC_TRNSUM_D_LOr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_SET
#define DSC_TRNSUM_D_LOr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET
#define READ_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_D_LOr
#define WRITE_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_D_LOr
#define MODIFY_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_D_LOr
#define READLN_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_D_LOr
#define WRITELN_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_D_LOr
#define WRITEALL_DSC_TRNSUM_D_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_D_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_D_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_D
 * BLOCKS:   DSC_B
 * REGADDR:  0xd047
 * DEVAD:    1
 * DESC:     trnsum d register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D         Trnsum interleave 'd' result (15:8)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr (0x0001d047 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d[1];
	uint32_t _dsc_trnsum_d;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_CLR(r) (r).dsc_trnsum_d[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_SET(r,d) (r).dsc_trnsum_d[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_GET(r) (r).dsc_trnsum_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_GET(r) (((r).dsc_trnsum_d[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_SET(r,f) (r).dsc_trnsum_d[0]=(((r).dsc_trnsum_d[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_D.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Dr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Dr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Dr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr
#define DSC_TRNSUM_Dr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_t DSC_TRNSUM_Dr_t;
#define DSC_TRNSUM_Dr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_CLR
#define DSC_TRNSUM_Dr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_SET
#define DSC_TRNSUM_Dr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_SET
#define READ_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_Dr
#define WRITE_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_Dr
#define MODIFY_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_Dr
#define READLN_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_Dr
#define WRITELN_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_Dr
#define WRITEALL_DSC_TRNSUM_Dr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd048
 * DEVAD:    1
 * DESC:     trnsum low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_LOW       Trnsum  LSB result (9:0)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr (0x0001d048 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_lo[1];
	uint32_t _dsc_trnsum_lo;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_CLR(r) (r).dsc_trnsum_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_SET(r,d) (r).dsc_trnsum_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_GET(r) (r).dsc_trnsum_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET(r) ((((r).dsc_trnsum_lo[0]) >> 6) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET(r,f) (r).dsc_trnsum_lo[0]=(((r).dsc_trnsum_lo[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access DSC_TRNSUM_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr
#define DSC_TRNSUM_LOr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_t DSC_TRNSUM_LOr_t;
#define DSC_TRNSUM_LOr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_CLR
#define DSC_TRNSUM_LOr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_SET
#define DSC_TRNSUM_LOr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET
#define READ_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_LOr
#define WRITE_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_LOr
#define MODIFY_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_LOr
#define READLN_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_LOr
#define WRITELN_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_LOr
#define WRITEALL_DSC_TRNSUM_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM
 * BLOCKS:   DSC_B
 * REGADDR:  0xd049
 * DEVAD:    1
 * DESC:     trnsum register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM           Trnsum result (25:10)
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr (0x0001d049 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum[1];
	uint32_t _dsc_trnsum;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_CLR(r) (r).dsc_trnsum[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_SET(r,d) (r).dsc_trnsum[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_GET(r) (r).dsc_trnsum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_TRNSUMf_GET(r) (((r).dsc_trnsum[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_TRNSUMf_SET(r,f) (r).dsc_trnsum[0]=(((r).dsc_trnsum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUMr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUMr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUMr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr
#define DSC_TRNSUMr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_t DSC_TRNSUMr_t;
#define DSC_TRNSUMr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_CLR
#define DSC_TRNSUMr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_SET
#define DSC_TRNSUMr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_GET
#define DSC_TRNSUMr_TRNSUMf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_TRNSUMf_GET
#define DSC_TRNSUMr_TRNSUMf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr_TRNSUMf_SET
#define READ_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUMr
#define WRITE_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUMr
#define MODIFY_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUMr
#define READLN_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUMr
#define WRITELN_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUMr
#define WRITEALL_DSC_TRNSUMr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_VGA_PHASE_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04a
 * DEVAD:    1
 * DESC:     phase1 and phase02 threshold status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PHASE02_STATUS Read out of the phase02 Slicer threshold in 2's complement signed format.
 *     RX_PHASE1_STATUS Read out of the phase1 Slicer threshold in 2's complement signed format.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr (0x0001d04a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_PHASE_THR_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_phase_thr_sts[1];
	uint32_t _dsc_vga_phase_thr_sts;
} BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_CLR(r) (r).dsc_vga_phase_thr_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_SET(r,d) (r).dsc_vga_phase_thr_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_GET(r) (r).dsc_vga_phase_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET(r) ((((r).dsc_vga_phase_thr_sts[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET(r,f) (r).dsc_vga_phase_thr_sts[0]=(((r).dsc_vga_phase_thr_sts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET(r) (((r).dsc_vga_phase_thr_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET(r,f) (r).dsc_vga_phase_thr_sts[0]=(((r).dsc_vga_phase_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_PHASE_THR_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_PHASE_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_phase_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_PHASE_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_phase_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_phase_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr
#define DSC_VGA_PHASE_THR_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_t DSC_VGA_PHASE_THR_STSr_t;
#define DSC_VGA_PHASE_THR_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_CLR
#define DSC_VGA_PHASE_THR_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_SET
#define DSC_VGA_PHASE_THR_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET
#define READ_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_PHASE_THR_STSr
#define WRITE_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_PHASE_THR_STSr
#define MODIFY_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_PHASE_THR_STSr
#define READLN_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_PHASE_THR_STSr
#define WRITELN_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_PHASE_THR_STSr
#define WRITEALL_DSC_VGA_PHASE_THR_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_PHASE_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_VGA_PHASE_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_VGA_DATA_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04b
 * DEVAD:    1
 * DESC:     data14 and data05 threshold status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA05_STATUS Read out of the Data05 Slicer threshold in 2's complement signed format.
 *     RX_DATA14_STATUS Read out of the Data14 Slicer threshold in 2's complement signed format.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr (0x0001d04b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_DATA_THR_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_data_thr_sts[1];
	uint32_t _dsc_vga_data_thr_sts;
} BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_CLR(r) (r).dsc_vga_data_thr_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_SET(r,d) (r).dsc_vga_data_thr_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_GET(r) (r).dsc_vga_data_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET(r) ((((r).dsc_vga_data_thr_sts[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET(r,f) (r).dsc_vga_data_thr_sts[0]=(((r).dsc_vga_data_thr_sts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET(r) (((r).dsc_vga_data_thr_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET(r,f) (r).dsc_vga_data_thr_sts[0]=(((r).dsc_vga_data_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_DATA_THR_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_DATA_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_data_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_DATA_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_data_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_data_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr
#define DSC_VGA_DATA_THR_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_t DSC_VGA_DATA_THR_STSr_t;
#define DSC_VGA_DATA_THR_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_CLR
#define DSC_VGA_DATA_THR_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_SET
#define DSC_VGA_DATA_THR_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET
#define DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET
#define READ_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_DATA_THR_STSr
#define WRITE_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_DATA_THR_STSr
#define MODIFY_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_DATA_THR_STSr
#define READLN_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_DATA_THR_STSr
#define WRITELN_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_DATA_THR_STSr
#define WRITEALL_DSC_VGA_DATA_THR_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_DATA_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_VGA_DATA_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_DC_OFFS_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04c
 * DEVAD:    1
 * DESC:     dc offset status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DC_OFFSET_BIN    rx dc offset
 */
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr (0x0001d04c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_sts[1];
	uint32_t _dsc_dc_offs_sts;
} BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_CLR(r) (r).dsc_dc_offs_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_SET(r,d) (r).dsc_dc_offs_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_GET(r) (r).dsc_dc_offs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET(r) (((r).dsc_dc_offs_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET(r,f) (r).dsc_dc_offs_sts[0]=(((r).dsc_dc_offs_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr
#define DSC_DC_OFFS_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_t DSC_DC_OFFS_STSr_t;
#define DSC_DC_OFFS_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_CLR
#define DSC_DC_OFFS_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_SET
#define DSC_DC_OFFS_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET
#define READ_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_DC_OFFS_STSr
#define WRITE_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_DC_OFFS_STSr
#define MODIFY_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_DC_OFFS_STSr
#define READLN_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_DC_OFFS_STSr
#define WRITELN_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_DC_OFFS_STSr
#define WRITEALL_DSC_DC_OFFS_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_DC_OFFS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_VGA_D_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04d
 * DEVAD:    1
 * DESC:     vga gain and data1 threshold status register.
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA23_STATUS Read out of the Data23 Slicer threshold in 2's complement signed format.
 *     RX_VGA_STATUS    Read out of the VGA control.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr (0x0001d04d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_D_THR_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_d_thr_sts[1];
	uint32_t _dsc_vga_d_thr_sts;
} BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_CLR(r) (r).dsc_vga_d_thr_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_SET(r,d) (r).dsc_vga_d_thr_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_GET(r) (r).dsc_vga_d_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET(r) ((((r).dsc_vga_d_thr_sts[0]) >> 8) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET(r) (((r).dsc_vga_d_thr_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_D_THR_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_d_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr
#define DSC_VGA_D_THR_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_t DSC_VGA_D_THR_STSr_t;
#define DSC_VGA_D_THR_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_CLR
#define DSC_VGA_D_THR_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_SET
#define DSC_VGA_D_THR_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET
#define DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET
#define DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET
#define READ_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_VGA_D_THR_STSr
#define WRITE_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_VGA_D_THR_STSr
#define MODIFY_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_VGA_D_THR_STSr
#define READLN_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_VGA_D_THR_STSr
#define WRITELN_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_VGA_D_THR_STSr
#define WRITEALL_DSC_VGA_D_THR_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_VGA_D_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_VGA_D_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_C
 * REGADDR:  0xd050
 * DEVAD:    1
 * DESC:     cdr control register 0.
 * RESETVAL: 0x9 (9)
 * ACCESS:   R/W
 * FIELDS:
 *     OS_ALL_EDGES     NRZ: 0: 001/110 (and os_pattern_enhanced ==0 and br_pd_en ==0) , 1: x01/x10 patterns.PAM4NS: this one-hot control maps to pd_mode[0], which enables the OS mode phase detector.PAM4ES: this one-hot control maps to pd_mode[0], which enables the dfe_data based phase detector.For PAM4 modes, refer to documentation for os_pattern_enhanced.
 *     OS_PATTERN_ENHANCED NRZ: when 1, selects 001/110 and also 010/101 from 4 locations {n,n+1, n+9, n+10}.PAM4NS: this one-hot control maps to pd_mode[1], which enables the BR mode phase detector.PAM4ES: this one-hot control maps to pd_mode[1], which enables the 7-level symbol based phase detector.For PAM4 modes, refer to documentation for os_all_edges.
 *     BR_PD_EN         0: (refer to os_all_edges) 1: use 011/100 patterns should not be used in PAM4 modes/ lower os modes (os ration > 4).
 *     CDR_FREQ_EN      1: 2nd order loop output to contribute
 *     CDR_HS_FREEZE    0: HS CDR inc/dec sent to PI1: HS CDR inc/dec blocked (But manual strobe and dig loopback are allowed)
 *     CDR_INTEG_REG_CLR clear integ Register
 *     CDR_PHASE_ERR_FRZ 1: override phase error to be 0
 *     CDR_INTEG_SAT_SEL 0:(-24576, 24575), 1:(-16384, 16383)
 *     CDR_FREQ_OVERRIDE_EN 1:override integ Register with cdr_freq_override_val
 *     CDR_ZERO_POLARITY inverts the phase slicer information before the phase detector
 *     PAM4_CDR_PROP_BW_EXT {pam4_cdr_prop_bw_ext, prop gain from SM} Effective proportional gain{0,0} *1{0,1} *2{1,0} *2{1,1} *4
 *     PHASE_ERR_OFFSET_MULT2 0: phase error offset is within this range: [-8:7]0: phase error offset is multiplied by 2.
 *     RX_PAM4ES_PREC_DISABLED 1: PAM4 ES - precoder off @ transmit.0: PAM4 ES - precoder on @ transmit.For PAM4 NS - This bit is dont-care.
 *     RX_NRZ_VSR_MODE  NRZ mode select control and it is only applicable to the NRZ RX datapath.1: NRZ VSR mode.0: NRZ DFE mode.
 *     RX_PAM4_ES_MODE  PAM4 mode select control and it is only applicable to the PAM4 RX datapath.1: PAM4 ES (Extended Slicer) mode.0: PAM4 NS (Normal Slicer)   mode.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r (0x0001d050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_HS_FREEZEf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_HS_FREEZEf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET(r) (((r).dsc_cdr_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_GET
#define DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4_ES_MODEf_SET
#define DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET
#define DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET
#define DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_GET
#define DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_RX_PAM4ES_PREC_DISABLEDf_SET
#define DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_GET
#define DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PHASE_ERR_OFFSET_MULT2f_SET
#define DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_GET
#define DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_PAM4_CDR_PROP_BW_EXTf_SET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET
#define DSC_CDR_CTL0r_CDR_HS_FREEZEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_HS_FREEZEf_GET
#define DSC_CDR_CTL0r_CDR_HS_FREEZEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_HS_FREEZEf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET
#define DSC_CDR_CTL0r_BR_PD_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET
#define DSC_CDR_CTL0r_BR_PD_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET
#define READ_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL0r
#define READLN_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL0r
#define WRITELN_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL0r
#define WRITEALL_DSC_CDR_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd051
 * DEVAD:    1
 * DESC:     cdr control register 1.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_PHASE_SEL    [2], [1], [0] correspond to enabling phase information from pp2, p0, pn2
 *     CDR_POWER_OPT_CLOCK_GATE_EN When enabled it enables the clock gating signal in kslice_hs_dMux block
 *     CDR_FREQ_OVERRIDE_VAL Gets loaded into the integ reg @ reset. Also, see alternate use in description of cdr_freq_override_en  Program round(ppm_required * 83.89/32) to this registerppm_required = 200 if 200e-6 frequency offset is needed
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r (0x0001d051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl1[1];
	uint32_t _dsc_cdr_ctl1;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CLR(r) (r).dsc_cdr_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_SET(r,d) (r).dsc_cdr_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_GET(r) (r).dsc_cdr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) ((((r).dsc_cdr_ctl1[0]) >> 5) & 0x7ff)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_GET(r) ((((r).dsc_cdr_ctl1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_PHASE_SELf_GET(r) (((r).dsc_cdr_ctl1[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_PHASE_SELf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r
#define DSC_CDR_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_t DSC_CDR_CTL1r_t;
#define DSC_CDR_CTL1r_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CLR
#define DSC_CDR_CTL1r_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_SET
#define DSC_CDR_CTL1r_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_GET
#define DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_POWER_OPT_CLOCK_GATE_ENf_SET
#define DSC_CDR_CTL1r_CDR_PHASE_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_PHASE_SELf_GET
#define DSC_CDR_CTL1r_CDR_PHASE_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r_CDR_PHASE_SELf_SET
#define READ_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL1r
#define WRITE_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL1r
#define MODIFY_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL1r
#define READLN_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL1r
#define WRITELN_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL1r
#define WRITEALL_DSC_CDR_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd052
 * DEVAD:    1
 * DESC:     cdr control register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_LM_THR_SEL   cdr lock monitor looks for integ reg to be within sat level - (cdr_lm_thr_sel +1)*512 in magnitude
 *     CDR_1G_SWAP_PZ   When 1, this will swap the peaks and zeros going out as the DME data. It will still use the original peaks and zeros for data recovery.
 *     CDR_1G_FORCE_EN  Forces the enable on the 1g logic. Else it should be enabled with osr mode setting to correct value.
 *     TX_PI_LOOP_TIMING_SRC_SEL Needs to be 1 in order to gate the phase sum on.
 *     PHS_SUM_IGNORE_DSC_LOCK Normally the phase summer waits for dsc lock. This bit overrides that wait.
 *     CDR_1G_MANUAL_MODE Puts the 1G CDR in manual mode.
 *     CDR_1G_MANUAL_STROBE Manual Strobe for the 1G CDR.
 *     CDR_PROP_BW_EXTEND When 1, the proportional BW is increased by 2{cdr_prop_bw_extend, cdr_bwsel_prop_[norm/acqcdr]}: Gain===============================================0, 0                   :                 *10, 1                   :                 *21, 0                   :                 *31, 1                   :                 *4
 *     RX_PHASE_SUM_ACC_MODE 3'b000: osr-mode dependent scaling of rx pi phase steps3'b001: sum over 16 cycles and divide by 43'b010: sum over 20 cycles and divide by 5others: un-supported
 *     CDR_PHASE_SAT_CTRL Only for PAM4 CDR, the nrz cdr saturates to +/-10.1'b0: saturate the 1st order path to be within -16:161'b1: saturate the 1st order path to be within -10:10
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r (0x0001d052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 11) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET(r) (((r).dsc_cdr_ctl2[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_GET
#define DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PHASE_SAT_CTRLf_SET
#define DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_GET
#define DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_RX_PHASE_SUM_ACC_MODEf_SET
#define DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET
#define DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET
#define READ_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_CTL2r
#define READLN_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_CTL2r
#define WRITELN_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_CTL2r
#define WRITEALL_DSC_CDR_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd053
 * DEVAD:    1
 * DESC:     rx pi control register.
 * RESETVAL: 0x1000 (4096)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_SLICERS_EN bit-vector representing which PI's to adjust: [0] d, [1] dq, [2] p, [3] pq, [4] l, [5] lq
 *     RX_PI_PHASE_STEP_CNT # of steps to adjust: 0..15: [1, 92, 104, 116, 128, 140, 152, 168,46,52,  58,  64,  70,  76,  84, 2]
 *     RX_PI_MANUAL_MODE 0: normal, 1:disconnect all PI's from CDR when enabled
 *     RX_PI_MANUAL_STROBE perform a manual override over specified number of clocks
 *     RX_PI_STEP_SIZE  0: pi steps by 11: pi steps by 2Only applicable to NRZ modes. Do not set in PAM4 modes.In NRZ (other than fractional osr) modes, setting this bit doubles the step size of the CDR inc/decs. The other manual mode/ext mode do not double.
 *     RX_PI_DISP_MSB_STATUS 0: register reads of the pi counters are the lower 8 bits.1: register reads of the pi counters are the upper 8 bits.
 *     RX_PI_PHASE_STEP_DIR 0: left shift, 1: right shift
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr (0x0001d053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 6) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET(r) (((r).dsc_rx_pi_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET
#define DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET
#define DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET
#define DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_GET
#define DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_STEP_SIZEf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET
#define READ_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CTLr
#define READLN_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CTLr
#define WRITELN_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CTLr
#define WRITEALL_DSC_RX_PI_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd054
 * DEVAD:    1
 * DESC:     trnsum control 2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_CLR_SC    Self Clearing bitWhen asserted, the trnsum accumulator clears.
 *     TRNSUM_DISABLE_SM_CLEAR When asserted,a pulse on uc_trnsum_en no longer clears the accumulator.
 *     TRNSUM_PATTERN_MATCH_SEL 0: NRZ1: pam4ns2: pam4es symbols3: pam4es dfe_data4: lms5: Expected PRBS. (Needs fec_fdbk_en = 1 & fec_fdbk_data_sel = 1)
 *     TRNSUM_EYE_CLOSE_PREV_EN When 1, the first eye close event after previous 6 non-eye closure events is picked. The eye close condition settings need to be turned on for this setting to work.
 *     TRNSUM_EYE_CLOSURE_ERR_SEL When trnsum_eye_closure_en is set, this field determines what is compared against d slicer. d!=error_selected , where error_selected is:1'b0: emux1'b1: expected prbs
 *     TRNSUM_PATTERN_7LVL_EN This is a limited application mode.Only use this when pattern match sel selects dfe_data in ES mode.pattern_2[2:0] are compared to current 7 level symbol.
 *     TRNSUM_ALT_PATH_EN When 00, sum the trnsum error.When 01, sum the blw path  into the accumulators.When 10, sum the phase errorWhen 11, sum the 1g cdr phase steps
 *     TRNSUM_MODE_SEL  This field needs to be set to configure the trnsum to correctly select the data during different modes of operation.Specifically, used when trnsum_data_sel == {0, 1, 2, 3} or when trnsum_err_sel == {2} or when trnsum_pattern_match_sel == {5} or trnsum_eyec_sel == {1,2,3}  or when trnsum_multi_level_isi=={1}.2'b00: NRZ mode.2'b01: PAM4 NS mode.2'b10: PAM4 ES mode.2'b11: unsupported.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r (0x0001d054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl2[1];
	uint32_t _dsc_trnsum_ctl2;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_CLR(r) (r).dsc_trnsum_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_SET(r,d) (r).dsc_trnsum_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_GET(r) (r).dsc_trnsum_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 2) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET(r) (((r).dsc_trnsum_ctl2[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r
#define DSC_TRNSUM_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_t DSC_TRNSUM_CTL2r_t;
#define DSC_TRNSUM_CTL2r_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_CLR
#define DSC_TRNSUM_CTL2r_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_SET
#define DSC_TRNSUM_CTL2r_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_MODE_SELf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_ALT_PATH_ENf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_7LVL_ENf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET
#define READ_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_CTL2r
#define WRITE_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_CTL2r
#define MODIFY_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_CTL2r
#define READLN_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_CTL2r
#define WRITELN_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_CTL2r
#define WRITEALL_DSC_TRNSUM_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd055
 * DEVAD:    1
 * DESC:     trnsum control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_GAIN      bit-vector representing the gain to be applied: [0] 1, [1] 2, [2] 4, [3] 8
 *     TRNSUM_TAP_RANGE_SEL Taps -32 to 4 are broken into groups of 8 and                        this selects the range
 *     TRNSUM_COR_SEL   00: normal; 01: all 1s instead of emux; 10:                        count number of emux!= data; 11: all 1s instead of d[n-delay]
 *     TRNSUM_QPHASE_MULT_EN Enables cdr phase error to weigh the                        correlator output
 *     TRNSUM_RANDOM_TAPSEL_DISABLE Disables randomizing logic for tap                        selection. Enables sequential selection.
 *     TRNSUM_EYE_CLOSURE_EN When enabled this ands another term to the                        condition. d[n] != emux[n]
 *     TRNSUM_EN        Training sum enable
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr (0x0001d055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl[1];
	uint32_t _dsc_trnsum_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_CLR(r) (r).dsc_trnsum_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_SET(r,d) (r).dsc_trnsum_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_GET(r) (r).dsc_trnsum_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET(r) (((r).dsc_trnsum_ctl[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr
#define DSC_TRNSUM_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_t DSC_TRNSUM_CTLr_t;
#define DSC_TRNSUM_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_CLR
#define DSC_TRNSUM_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_SET
#define DSC_TRNSUM_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET
#define READ_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_CTLr
#define WRITE_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_CTLr
#define MODIFY_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_CTLr
#define READLN_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_CTLr
#define WRITELN_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_CTLr
#define WRITEALL_DSC_TRNSUM_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_TAP_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd056
 * DEVAD:    1
 * DESC:     trnsum tap control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_TAP_EN    Training taps enabled (either randomize over                        them or not)
 *     TRNSUM_TAP_SIGN  Sign of the 8 taps in the group
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr (0x0001d056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TAP_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tap_ctl[1];
	uint32_t _dsc_trnsum_tap_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_CLR(r) (r).dsc_trnsum_tap_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_SET(r,d) (r).dsc_trnsum_tap_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_GET(r) (r).dsc_trnsum_tap_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET(r) ((((r).dsc_trnsum_tap_ctl[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET(r) (((r).dsc_trnsum_tap_ctl[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TAP_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_TAP_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tap_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_TAP_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tap_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_tap_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr
#define DSC_TRNSUM_TAP_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_t DSC_TRNSUM_TAP_CTLr_t;
#define DSC_TRNSUM_TAP_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_CLR
#define DSC_TRNSUM_TAP_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_SET
#define DSC_TRNSUM_TAP_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET
#define READ_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_TAP_CTLr
#define WRITE_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_TAP_CTLr
#define MODIFY_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_TAP_CTLr
#define READLN_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_TAP_CTLr
#define WRITELN_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_TAP_CTLr
#define WRITEALL_DSC_TRNSUM_TAP_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_TAP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TAP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_TDT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd057
 * DEVAD:    1
 * DESC:     trnsum tdt control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_TRNSUM_EN    enables the tdt featureAt no point should this be disabled in the middle of collecting data over multiple locations.The counters which figure out which cycle to select while this bit is 1.
 *     TRNSUM_TDT_COUNT valid range is unsigned decimal 20:8191
 *     TRNSUM_TDT_SLIP  Self clearing. The tdt counter subtracts a 1, hence overflows 1 UI later. Hence the TDT slips to the next UI.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr (0x0001d057 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TDT_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tdt_ctl[1];
	uint32_t _dsc_trnsum_tdt_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_CLR(r) (r).dsc_trnsum_tdt_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_SET(r,d) (r).dsc_trnsum_tdt_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_GET(r) (r).dsc_trnsum_tdt_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 1) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x3fff << 1)) | ((((uint32_t)f) & 0x3fff) << 1)) | (16383 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET(r) (((r).dsc_trnsum_tdt_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TDT_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_TDT_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tdt_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_TDT_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tdt_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_tdt_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr
#define DSC_TRNSUM_TDT_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_t DSC_TRNSUM_TDT_CTLr_t;
#define DSC_TRNSUM_TDT_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_CLR
#define DSC_TRNSUM_TDT_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_SET
#define DSC_TRNSUM_TDT_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_GET
#define DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_GET
#define DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_SLIPf_SET
#define DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_GET
#define DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TRNSUM_TDT_COUNTf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET
#define READ_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_TDT_CTLr
#define WRITE_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_TDT_CTLr
#define MODIFY_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_TDT_CTLr
#define READLN_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_TDT_CTLr
#define WRITELN_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_TDT_CTLr
#define WRITEALL_DSC_TRNSUM_TDT_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_TDT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_TDT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_MISC
 * BLOCKS:   DSC_C
 * REGADDR:  0xd058
 * DEVAD:    1
 * DESC:     trnsum misc register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_PRBS_SLIP    Reserved bit (unused)
 *     UC_TRNSUM_EN     1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit.
 *     TRNSUM_DATA_SEL  trsnum data selector0: dfe_data (2 bit). Pam4 modes1: nrz rx_data/ d0[2:6]: [d1:d5]7: lms8: 19: 3 bit symbol
 *     TRNSUM_RND_FREE_RUNNING When 1, the randomizer runs continuously in the multi level isi mode.
 *     DC_OFFS_WRITE_EN self clearing dc offset write strobe
 *     TRNSUM_ERR_SEL   trsnum error selector
 *     TRNSUM_MULTI_LEVEL_ISI trsnum multi level mode enable
 *     TRNSUM_EYEC_SEL  trsnum eye close data selector (with appropriate trnsum_mode_sel)The slicer representation {d0:d5} does not map to the analog slicer numbering. Refer to block diagram for trnsum for details.0: rx data sign;1: nrz data/ d0[2:6] : [d1:d5]7: LMS8: 1
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr (0x0001d058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_MISC.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_misc[1];
	uint32_t _dsc_trnsum_misc;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_CLR(r) (r).dsc_trnsum_misc[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_SET(r,d) (r).dsc_trnsum_misc[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_GET(r) (r).dsc_trnsum_misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 2) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET(r) (((r).dsc_trnsum_misc[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_MISC.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_MISCr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_MISCr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_misc))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_MISCr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_misc))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr
#define DSC_TRNSUM_MISCr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_t DSC_TRNSUM_MISCr_t;
#define DSC_TRNSUM_MISCr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_CLR
#define DSC_TRNSUM_MISCr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_SET
#define DSC_TRNSUM_MISCr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_GET
#define DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_GET
#define DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_EYEC_SELf_SET
#define DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_GET
#define DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_MULTI_LEVEL_ISIf_SET
#define DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_GET
#define DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_ERR_SELf_SET
#define DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_GET
#define DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_DC_OFFS_WRITE_ENf_SET
#define DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_GET
#define DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_RND_FREE_RUNNINGf_SET
#define DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_GET
#define DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TRNSUM_DATA_SELf_SET
#define DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_GET
#define DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_UC_TRNSUM_ENf_SET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET
#define READ_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_MISCr
#define WRITE_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_MISCr
#define MODIFY_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_MISCr
#define READLN_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_MISCr
#define WRITELN_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_MISCr
#define WRITEALL_DSC_TRNSUM_MISCr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SLCRS_WRITE_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05b
 * DEVAD:    1
 * DESC:     slicers override write control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_AFE_OVERRIDE_SEL Based on this value, an override can be applied to one of the data, phase or lms slicers0 - Invalid; 1 - data23 slicer; 2 - data14 slicer; 3 - data05 slicer; 4 - phase1 slicer; 5 - phase02 slicer; 6 - dfe taps 2 or 3; 8 - lms threshold; 15 - Dont use (used in lms threshold readout).
 *     RX_AFE_OVERRIDE_VAL override val of slicersthis value is binary. It is converted to gray before it is routed to AFE
 *     RX_AFE_OVERRIDE_WRITE strobe to write slicer values
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr (0x0001d05b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SLCRS_WRITE_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_slcrs_write_ctl[1];
	uint32_t _dsc_slcrs_write_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_CLR(r) (r).dsc_slcrs_write_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_SET(r,d) (r).dsc_slcrs_write_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_GET(r) (r).dsc_slcrs_write_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET(r) ((((r).dsc_slcrs_write_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET(r) ((((r).dsc_slcrs_write_ctl[0]) >> 7) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7)) | (255 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET(r) (((r).dsc_slcrs_write_ctl[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SLCRS_WRITE_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SLCRS_WRITE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcrs_write_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SLCRS_WRITE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcrs_write_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_slcrs_write_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr
#define DSC_SLCRS_WRITE_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_t DSC_SLCRS_WRITE_CTLr_t;
#define DSC_SLCRS_WRITE_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_CLR
#define DSC_SLCRS_WRITE_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_SET
#define DSC_SLCRS_WRITE_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET
#define READ_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_SLCRS_WRITE_CTLr
#define WRITE_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SLCRS_WRITE_CTLr
#define MODIFY_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SLCRS_WRITE_CTLr
#define READLN_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_SLCRS_WRITE_CTLr
#define WRITELN_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SLCRS_WRITE_CTLr
#define WRITEALL_DSC_SLCRS_WRITE_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SLCRS_WRITE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SLCRS_WRITE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05d
 * DEVAD:    1
 * DESC:     lms threshold control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_THRESH_EN    Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen)
 *     LMS_THRESH_HYS_EN Needs to be 1 for hysteresis to be on
 *     LMS_THRESH_HYS_MAG 0: 11th bit <<7; 1: 11th bit <<5
 *     LMS_THRESH_GRADIENT_INVERT Inverts the sense of the update (inc,dec swap)
 *     LMS_THRESH_GAIN  multiplies the +-40 error by 2^{0,1,2,3}
 *     LMS_THRESH_ACC_CLR Clears the internal state except for the final tap
 *     DC_OFFS_BLW_PHASE_SEL when 1, the dc offset loop runs on the phase selected from the CDR
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr (0x0001d05d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_ctl[1];
	uint32_t _dsc_lms_thr_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_CLR(r) (r).dsc_lms_thr_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_SET(r,d) (r).dsc_lms_thr_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_GET(r) (r).dsc_lms_thr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 5) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_GET(r) ((((r).dsc_lms_thr_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ENf_GET(r) (((r).dsc_lms_thr_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ENf_SET(r,f) (r).dsc_lms_thr_ctl[0]=(((r).dsc_lms_thr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_LMS_THR_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr,(_r._dsc_lms_thr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr,(_r._dsc_lms_thr_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr,(_r._dsc_lms_thr_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr
#define DSC_LMS_THR_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_t DSC_LMS_THR_CTLr_t;
#define DSC_LMS_THR_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_CLR
#define DSC_LMS_THR_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_SET
#define DSC_LMS_THR_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_GET
#define DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_GET
#define DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_DC_OFFS_BLW_PHASE_SELf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ACC_CLRf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GAINf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_GRADIENT_INVERTf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_MAGf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_HYS_ENf_SET
#define DSC_LMS_THR_CTLr_LMS_THRESH_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ENf_GET
#define DSC_LMS_THR_CTLr_LMS_THRESH_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr_LMS_THRESH_ENf_SET
#define READ_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_CTLr
#define WRITE_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_CTLr
#define MODIFY_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_CTLr
#define READLN_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_CTLr
#define WRITELN_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_CTLr
#define WRITEALL_DSC_LMS_THR_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_DC_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05e
 * DEVAD:    1
 * DESC:     dc offset control register
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     DC_OFFS_EN       Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen)
 *     DC_OFFS_WRITE_FRC_EN self clearing dc offset force write strobeThis is simply an override to everything. This write gets sign gray converted and written to the dc_offset register
 *     DC_OFFS_HYS_EN   Needs to be 1 for hysteresis to be on
 *     DC_OFFS_HYS_MAG  0: 11th bit <<7; 1: 11th bit <<5
 *     DC_OFFS_GRADIENT_INVERT 1: Default mode. The input is a measure of the DC-level, which needs to be subtracted (inverted + added) to the DCO control .0: This does not invert the sense of the input .
 *     DC_OFFS_GAIN     multiplies the +-40 error by 2^{0,1,2,3}
 *     DC_OFFS_ACC_CLR  Clears the internal state except for the final tap
 *     DC_OFFS_WRITE_VAL write value for the dc offset in override modeThe logic walks to this value @ the start of automatic adaptation
 */
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr (0x0001d05e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_ctl[1];
	uint32_t _dsc_dc_offs_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_CLR(r) (r).dsc_dc_offs_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_SET(r,d) (r).dsc_dc_offs_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_GET(r) (r).dsc_dc_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 5) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET(r) (((r).dsc_dc_offs_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_DC_OFFS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_DC_OFFS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr
#define DSC_DC_OFFS_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_t DSC_DC_OFFS_CTLr_t;
#define DSC_DC_OFFS_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_CLR
#define DSC_DC_OFFS_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_SET
#define DSC_DC_OFFS_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET
#define READ_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_DC_OFFS_CTLr
#define WRITE_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_DC_OFFS_CTLr
#define MODIFY_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_DC_OFFS_CTLr
#define READLN_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_DC_OFFS_CTLr
#define WRITELN_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_DC_OFFS_CTLr
#define WRITEALL_DSC_DC_OFFS_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_DC_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_DC_OFFS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL0
 * BLOCKS:   DSC_D
 * REGADDR:  0xd060
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 0
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_MODE_EN      1'b1 will enable the EEE mode.
 *     EEE_QUIET_RX_AFE_PWRDWN_VAL 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode.
 *     IGNORE_RX_MODE   If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM.
 *     CL72_TIMER_EN    If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.
 *     UC_TUNE_EN       uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.
 *     HW_TUNE_EN       Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.  This is a self-clear register bit.
 *     EEE_MEASURE_EN   1'b1 Enables the measurement during EEE_MEASURE.
 *     UC_ACK_DSC_EEE_DONE 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESTART 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_CONFIG 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit.
 *     SET_MEAS_INCOMPLETE 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r (0x0001d060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl0[1];
	uint32_t _dsc_sm_ctl0;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CLR(r) (r).dsc_sm_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET(r,d) (r).dsc_sm_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_GET(r) (r).dsc_sm_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DSC_SM_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r
#define DSC_SM_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_t DSC_SM_CTL0r_t;
#define DSC_SM_CTL0r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CLR
#define DSC_SM_CTL0r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET
#define DSC_SM_CTL0r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET
#define DSC_SM_CTL0r_HW_TUNE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET
#define DSC_SM_CTL0r_HW_TUNE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET
#define DSC_SM_CTL0r_UC_TUNE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET
#define DSC_SM_CTL0r_UC_TUNE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET
#define DSC_SM_CTL0r_EEE_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET
#define DSC_SM_CTL0r_EEE_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET
#define READ_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL0r
#define WRITE_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL0r
#define MODIFY_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL0r
#define READLN_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL0r
#define WRITELN_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL0r
#define WRITEALL_DSC_SM_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd061
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 1
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 *     DSC_CLR_FRC      DSC clear force.
 *     DSC_CLR_FRC_VAL  DSC clear force value.
 *     TRNSUM_FRZ_FRC   Training Sum freeze force.
 *     TRNSUM_FRZ_FRC_VAL raining Sum freeze force value.
 *     TIMER_DONE_FRC   Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.
 *     TIMER_DONE_FRC_VAL If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state.
 *     FREQ_UPD_EN_FRC  Frequency update force.
 *     FREQ_UPD_EN_FRC_VAL Frequency update force value.
 *     CDR_FRZ_FRC      CDR Freeze force.
 *     CDR_FRZ_FRC_VAL  CDR Freeze force value.
 *     TRNSUM_CLR_FRC   Training Sum freeze force.
 *     TRNSUM_CLR_FRC_VAL raining Sum freeze force value.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r (0x0001d061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL1r
#define READLN_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL1r
#define WRITELN_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL1r
#define WRITEALL_DSC_SM_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd062
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 2
 * RESETVAL: 0x87 (135)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_LFSR_CNT     LFSR timer start value for all EEE timers except EEE_MEASURE.
 *     DSC_TIMEOUT_MULT DSC timer multiplication ratio.0: 1x   1: 2x   2: 4x   3: 8x   4:16x   5:32x
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r (0x0001d062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl2[1];
	uint32_t _dsc_sm_ctl2;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_CLR(r) (r).dsc_sm_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_SET(r,d) (r).dsc_sm_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_GET(r) (r).dsc_sm_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_GET(r) ((((r).dsc_sm_ctl2[0]) >> 13) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl2[0]) & 0x1fff)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r
#define DSC_SM_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_t DSC_SM_CTL2r_t;
#define DSC_SM_CTL2r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_CLR
#define DSC_SM_CTL2r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_SET
#define DSC_SM_CTL2r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_GET
#define DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_GET
#define DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_DSC_TIMEOUT_MULTf_SET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL2r
#define WRITE_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL2r
#define MODIFY_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL2r
#define READLN_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL2r
#define WRITELN_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL2r
#define WRITEALL_DSC_SM_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd063
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 3
 * RESETVAL: 0x1c1e (7198)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_LFSR_CNT LFSR timer start value for MEASURE and EEE_MEASURE state timers.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r (0x0001d063 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl3[1];
	uint32_t _dsc_sm_ctl3;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_CLR(r) (r).dsc_sm_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_SET(r,d) (r).dsc_sm_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_GET(r) (r).dsc_sm_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl3[0]) & 0x1fff)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl3[0]=(((r).dsc_sm_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r
#define DSC_SM_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_t DSC_SM_CTL3r_t;
#define DSC_SM_CTL3r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_CLR
#define DSC_SM_CTL3r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_SET
#define DSC_SM_CTL3r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL3r
#define WRITE_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL3r
#define MODIFY_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL3r
#define READLN_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL3r
#define WRITELN_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL3r
#define WRITEALL_DSC_SM_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd064
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ACQ_CDR_TIMEOUT  Defines timeout value for the ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     CDR_SETTLE_TIMEOUT Defines timeout value for the CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     HW_TUNE_TIMEOUT  Defines timeout value for the HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r (0x0001d064 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl4[1];
	uint32_t _dsc_sm_ctl4;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CLR(r) (r).dsc_sm_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_SET(r,d) (r).dsc_sm_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_GET(r) (r).dsc_sm_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET(r) (((r).dsc_sm_ctl4[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r
#define DSC_SM_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_t DSC_SM_CTL4r_t;
#define DSC_SM_CTL4r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CLR
#define DSC_SM_CTL4r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_SET
#define DSC_SM_CTL4r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET
#define READ_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL4r
#define WRITE_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL4r
#define MODIFY_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL4r
#define READLN_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL4r
#define WRITELN_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL4r
#define WRITEALL_DSC_SM_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL5
 * BLOCKS:   DSC_D
 * REGADDR:  0xd065
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 5
 * RESETVAL: 0x35ad (13741)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_TIMEOUT  Defines timeout value for the MEASURE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ACQ_CDR_TIMEOUT Defines timeout value for the EEE_ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_CDR_SETTLE_TIMEOUT Defines timeout value for the EEE_CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r (0x0001d065 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl5[1];
	uint32_t _dsc_sm_ctl5;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_CLR(r) (r).dsc_sm_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_SET(r,d) (r).dsc_sm_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_GET(r) (r).dsc_sm_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl5[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r
#define DSC_SM_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_t DSC_SM_CTL5r_t;
#define DSC_SM_CTL5r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_CLR
#define DSC_SM_CTL5r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_SET
#define DSC_SM_CTL5r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET
#define READ_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL5r
#define WRITE_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL5r
#define MODIFY_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL5r
#define READLN_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL5r
#define WRITELN_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL5r
#define WRITEALL_DSC_SM_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL6
 * BLOCKS:   DSC_D
 * REGADDR:  0xd066
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 6
 * RESETVAL: 0x340d (13325)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_HW_TUNE_TIMEOUT Defines timeout value for the EEE_HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ANA_PWR_TIMEOUT Defines timeout value for the EEE_ANA_PWR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r (0x0001d066 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl6[1];
	uint32_t _dsc_sm_ctl6;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_CLR(r) (r).dsc_sm_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_SET(r,d) (r).dsc_sm_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_GET(r) (r).dsc_sm_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl6[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r
#define DSC_SM_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_t DSC_SM_CTL6r_t;
#define DSC_SM_CTL6r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_CLR
#define DSC_SM_CTL6r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_SET
#define DSC_SM_CTL6r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET
#define READ_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL6r
#define WRITE_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL6r
#define MODIFY_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL6r
#define READLN_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL6r
#define WRITELN_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL6r
#define WRITEALL_DSC_SM_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL7
 * BLOCKS:   DSC_D
 * REGADDR:  0xd067
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_BWSEL_INTEG_ACQCDR CDR 2nd Order Loop Bandwidth select for ACQ_CDR state.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_INTEG_EEE_ACQCDR CDR 2nd Order Loop Bandwidth select for EEE_ACQ_CDR state.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_INTEG_NORM CDR 2nd Order Loop Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_PROP_ACQCDR CDR Proportional Bandwidth select for ACQ_CDR state.{0, 1} map to {2^0, 2^1}
 *     CDR_BWSEL_PROP_NORM CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1} map to {2^0, 2^1}
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r (0x0001d067 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl7[1];
	uint32_t _dsc_sm_ctl7;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CLR(r) (r).dsc_sm_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_SET(r,d) (r).dsc_sm_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_GET(r) (r).dsc_sm_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET(r) (((r).dsc_sm_ctl7[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r
#define DSC_SM_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_t DSC_SM_CTL7r_t;
#define DSC_SM_CTL7r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CLR
#define DSC_SM_CTL7r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_SET
#define DSC_SM_CTL7r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET
#define READ_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL7r
#define WRITE_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL7r
#define MODIFY_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL7r
#define READLN_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL7r
#define WRITELN_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL7r
#define WRITEALL_DSC_SM_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL8
 * BLOCKS:   DSC_D
 * REGADDR:  0xd068
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 8
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     PHASE_ERR_OFFSET Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg.
 *     EEE_PHASE_ERR_OFFSET Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.
 *     PHASE_ERR_OFFSET_EN Phase Error Offset Enable for non-EEE_ACQ_CDR states.
 *     EEE_PHASE_ERR_OFFSET_EN Phase Error Offset Enable for EEE_ACQ_CDR state.
 *     CDR_BWSEL_PROP_EEE_ACQCDR CDR Proportional Bandwidth select for EEE_ACQ_CDR state.{0, 1} map to {2^0, 2^1}
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r (0x0001d068 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL8.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl8[1];
	uint32_t _dsc_sm_ctl8;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CLR(r) (r).dsc_sm_ctl8[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_SET(r,d) (r).dsc_sm_ctl8[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_GET(r) (r).dsc_sm_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET(r) (((r).dsc_sm_ctl8[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r
#define DSC_SM_CTL8r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_t DSC_SM_CTL8r_t;
#define DSC_SM_CTL8r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CLR
#define DSC_SM_CTL8r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_SET
#define DSC_SM_CTL8r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET
#define READ_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL8r
#define WRITE_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL8r
#define MODIFY_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL8r
#define READLN_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL8r
#define WRITELN_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL8r
#define WRITEALL_DSC_SM_CTL8r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_D
 * REGADDR:  0xd069
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RESTART_PMD   1: restarts the RX PMD. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1: restarts the RX PMD and holds it in RESTART state until this bit is cleared.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r (0x0001d069 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_CTL9r
#define READLN_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_CTL9r
#define WRITELN_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_CTL9r
#define WRITEALL_DSC_SM_CTL9r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_STS_DSC_LOCK
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06a
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE DSC_LOCK STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DSC_LOCK      1 indicates that DSC is locked.
 *     MEAS_INCOMPLETE  1 indicates that measurement is incomplete. 0 indicates that measurement is complete.
 *     EEE_MEASURE_CNT  Indicates the eee_measure_cnt status. This is a debug register.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr (0x0001d06a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_LOCK.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_lock[1];
	uint32_t _dsc_sm_sts_dsc_lock;
} BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_CLR(r) (r).dsc_sm_sts_dsc_lock[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_SET(r,d) (r).dsc_sm_sts_dsc_lock[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_GET(r) (r).dsc_sm_sts_dsc_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 7) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET(r) (((r).dsc_sm_sts_dsc_lock[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_LOCK.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_lock))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr
#define DSC_SM_STS_DSC_LOCKr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_t DSC_SM_STS_DSC_LOCKr_t;
#define DSC_SM_STS_DSC_LOCKr_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_CLR
#define DSC_SM_STS_DSC_LOCKr_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_SET
#define DSC_SM_STS_DSC_LOCKr_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET
#define READ_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_LOCKr
#define WRITE_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr
#define MODIFY_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr
#define READLN_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_LOCKr
#define WRITELN_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr
#define WRITEALL_DSC_SM_STS_DSC_LOCKr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_LOCKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06b
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0001d06b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_EEE_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06c
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS EEE ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_EEE_ONE_HOT Sticky one-hot coded EEE state . These registers are cleared on read.EEE_QUIET       =  0EEE_ANA_PWR     =  1EEE_ACQ_CDR     =  2EEE_CDR_SETTLE  =  3EEE_HW_TUNE     =  4EEE_MEASURE     =  5EEE_DONE        =  6
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr (0x0001d06c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_eee_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_eee_one_hot;
} BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_eee_one_hot[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]=(((r).dsc_sm_sts_dsc_st_eee_one_hot[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_eee_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_STS_RESTART
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06d
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS RESTART
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESTART_PI_EXT_MODE Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read.
 *     RESTART_SIGDET   Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read.
 *     RESTART_PMD_RESTART Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read.
 *     EEE_QUIET_FROM_EEE_STATES Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr (0x0001d06d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_RESTART.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_restart[1];
	uint32_t _dsc_sm_sts_restart;
} BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_CLR(r) (r).dsc_sm_sts_restart[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_SET(r,d) (r).dsc_sm_sts_restart[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_GET(r) (r).dsc_sm_sts_restart[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET(r) (((r).dsc_sm_sts_restart[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_RESTART.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_restart))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr
#define DSC_SM_STS_RESTARTr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_t DSC_SM_STS_RESTARTr_t;
#define DSC_SM_STS_RESTARTr_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_CLR
#define DSC_SM_STS_RESTARTr_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_SET
#define DSC_SM_STS_RESTARTr_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET
#define READ_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_RESTARTr
#define WRITE_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_RESTARTr
#define MODIFY_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_RESTARTr
#define READLN_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_RESTARTr
#define WRITELN_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_RESTARTr
#define WRITEALL_DSC_SM_STS_RESTARTr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_RESTARTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_STS_RESTARTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06e
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     DSC_SM_SCRATCH   3 bits of dsc_scratch
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr (0x0001d06e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 1) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1)) | (63 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SM_STS_DSC_STr
#define READLN_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_READLN_DSC_SM_STS_DSC_STr
#define WRITELN_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SM_STS_DSC_STr
#define WRITEALL_DSC_SM_STS_DSC_STr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SM_STS_DSC_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SM_STS_DSC_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_PD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd070
 * DEVAD:    1
 * DESC:     rx_pi status register, both p and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P_PD     PI counter value for phase slicersee description of cnt_bin_pq
 *     CNT_BIN_D_PD     PI counter value for phase quadrature slicersee description of cnt_bin_pq
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr (0x0001d070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_PD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_pd[1];
	uint32_t _dsc_rx_pi_cnt_bin_pd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR(r) (r).dsc_rx_pi_cnt_bin_pd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_pd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET(r) (r).dsc_rx_pi_cnt_bin_pd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_pd[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET(r) (((r).dsc_rx_pi_cnt_bin_pd[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_PD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_pd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr
#define DSC_RX_PI_CNT_BIN_PDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_t DSC_RX_PI_CNT_BIN_PDr_t;
#define DSC_RX_PI_CNT_BIN_PDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR
#define DSC_RX_PI_CNT_BIN_PDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET
#define DSC_RX_PI_CNT_BIN_PDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET
#define READ_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr
#define WRITE_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr
#define MODIFY_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr
#define READLN_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr
#define WRITELN_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_PDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_PDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_LD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd071
 * DEVAD:    1
 * DESC:     rx_pi status register, both l and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L_LD     PI counter value for LMS slicersee description of cnt_bin_pq
 *     CNT_BIN_D_LD     PI counter value for LMS quadrature slicersee description of cnt_bin_pq
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr (0x0001d071 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_LD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_ld[1];
	uint32_t _dsc_rx_pi_cnt_bin_ld;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR(r) (r).dsc_rx_pi_cnt_bin_ld[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_ld[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET(r) (r).dsc_rx_pi_cnt_bin_ld[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_ld[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET(r) (((r).dsc_rx_pi_cnt_bin_ld[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_LD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_ld))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr
#define DSC_RX_PI_CNT_BIN_LDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_t DSC_RX_PI_CNT_BIN_LDr_t;
#define DSC_RX_PI_CNT_BIN_LDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR
#define DSC_RX_PI_CNT_BIN_LDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET
#define DSC_RX_PI_CNT_BIN_LDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET
#define READ_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr
#define WRITE_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr
#define MODIFY_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr
#define READLN_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr
#define WRITELN_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_LDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_LDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DATA_15_TO0
 * BLOCKS:   DSC_E
 * REGADDR:  0xd072
 * DEVAD:    1
 * DESC:     rx data bits 15 to 0.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_15_TO_0  Rx data is 40 bit wide in rclk40 domain. These are bits 15 to 0.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r (0x0001d072 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_15_TO0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_15_to0[1];
	uint32_t _dsc_rx_data_15_to0;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_CLR(r) (r).dsc_rx_data_15_to0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_SET(r,d) (r).dsc_rx_data_15_to0[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_GET(r) (r).dsc_rx_data_15_to0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET(r) (((r).dsc_rx_data_15_to0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET(r,f) (r).dsc_rx_data_15_to0[0]=(((r).dsc_rx_data_15_to0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_15_TO0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DATA_15_TO0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_15_to0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DATA_15_TO0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_15_to0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_data_15_to0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r
#define DSC_RX_DATA_15_TO0r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_t DSC_RX_DATA_15_TO0r_t;
#define DSC_RX_DATA_15_TO0r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_CLR
#define DSC_RX_DATA_15_TO0r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_SET
#define DSC_RX_DATA_15_TO0r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET
#define READ_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DATA_15_TO0r
#define WRITE_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DATA_15_TO0r
#define MODIFY_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DATA_15_TO0r
#define READLN_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DATA_15_TO0r
#define WRITELN_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DATA_15_TO0r
#define WRITEALL_DSC_RX_DATA_15_TO0r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DATA_15_TO0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_15_TO0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DATA_35_TO_20
 * BLOCKS:   DSC_E
 * REGADDR:  0xd073
 * DEVAD:    1
 * DESC:     rx data bits 35 to 20.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_35_TO_20 Rx data is 40 bit wide in rclk40 domain. These are bits 35 to 20.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r (0x0001d073 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_35_TO_20.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_35_to_20[1];
	uint32_t _dsc_rx_data_35_to_20;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_CLR(r) (r).dsc_rx_data_35_to_20[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_SET(r,d) (r).dsc_rx_data_35_to_20[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_GET(r) (r).dsc_rx_data_35_to_20[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET(r) (((r).dsc_rx_data_35_to_20[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET(r,f) (r).dsc_rx_data_35_to_20[0]=(((r).dsc_rx_data_35_to_20[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_35_TO_20.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DATA_35_TO_20r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_35_to_20))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DATA_35_TO_20r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_35_to_20))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_data_35_to_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r
#define DSC_RX_DATA_35_TO_20r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_t DSC_RX_DATA_35_TO_20r_t;
#define DSC_RX_DATA_35_TO_20r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_CLR
#define DSC_RX_DATA_35_TO_20r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_SET
#define DSC_RX_DATA_35_TO_20r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET
#define READ_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DATA_35_TO_20r
#define WRITE_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DATA_35_TO_20r
#define MODIFY_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DATA_35_TO_20r
#define READLN_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DATA_35_TO_20r
#define WRITELN_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DATA_35_TO_20r
#define WRITEALL_DSC_RX_DATA_35_TO_20r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DATA_35_TO_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DATA_35_TO_20r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_STS_PHASE_ERR
 * BLOCKS:   DSC_E
 * REGADDR:  0xd074
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x100 (256)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_PHASE_ERROR  shadowed version of phase error value
 *     CDR_LM_OUTOFLOCK CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read.And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on readThe valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_selHas more meaning after rx_dsc_lock is asserted.
 *     CDR_VCO_REG      shadowed version of cdr_vco_reg[3:0]
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr (0x0001d074 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_PHASE_ERR.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_phase_err[1];
	uint32_t _dsc_cdr_sts_phase_err;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR(r) (r).dsc_cdr_sts_phase_err[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_SET(r,d) (r).dsc_cdr_sts_phase_err[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_GET(r) (r).dsc_cdr_sts_phase_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET(r) ((((r).dsc_cdr_sts_phase_err[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET(r) ((((r).dsc_cdr_sts_phase_err[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET(r) (((r).dsc_cdr_sts_phase_err[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_CDR_STS_PHASE_ERR.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_phase_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr
#define DSC_CDR_STS_PHASE_ERRr_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_t DSC_CDR_STS_PHASE_ERRr_t;
#define DSC_CDR_STS_PHASE_ERRr_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR
#define DSC_CDR_STS_PHASE_ERRr_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_SET
#define DSC_CDR_STS_PHASE_ERRr_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET
#define DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET
#define READ_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_STS_PHASE_ERRr
#define WRITE_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr
#define MODIFY_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr
#define READLN_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr
#define WRITELN_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr
#define WRITEALL_DSC_CDR_STS_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_PHASE_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_E
 * REGADDR:  0xd075
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_D        PI counter value for data slicersee description of cnt_bin_pq
 *     CNT_BIN_DQ       PI counter value for data quadrature slicersee description of cnt_bin_pq
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr (0x0001d075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr
#define READLN_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr
#define WRITELN_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Dr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_E
 * REGADDR:  0xd076
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P        PI counter value for phase slicersee description of cnt_bin_pq
 *     CNT_BIN_PQ       PI counter value for phase quadrature slicer.When rx_pi_disp_msb_status is 0, the lower 8 bits of the 9 bit pointer are read..When rx_pi_disp_msb_status is 1, the upper 8 bits of the 9 bit pointer are read..
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr (0x0001d076 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_p))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr
#define READLN_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr
#define WRITELN_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Pr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Pr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_L
 * BLOCKS:   DSC_E
 * REGADDR:  0xd077
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L        PI counter value for LMS slicersee description of cnt_bin_pq
 *     CNT_BIN_LQ       PI counter value for LMS quadrature slicersee description of cnt_bin_pq
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr (0x0001d077 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_L.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_l[1];
	uint32_t _dsc_rx_pi_cnt_bin_l;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR(r) (r).dsc_rx_pi_cnt_bin_l[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET(r,d) (r).dsc_rx_pi_cnt_bin_l[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET(r) (r).dsc_rx_pi_cnt_bin_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_l[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET(r) (((r).dsc_rx_pi_cnt_bin_l[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_L.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_l))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr
#define DSC_RX_PI_CNT_BIN_Lr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_t DSC_RX_PI_CNT_BIN_Lr_t;
#define DSC_RX_PI_CNT_BIN_Lr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR
#define DSC_RX_PI_CNT_BIN_Lr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET
#define DSC_RX_PI_CNT_BIN_Lr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET
#define READ_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr
#define WRITE_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr
#define MODIFY_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr
#define READLN_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr
#define WRITELN_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Lr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CNT_BIN_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_E
 * REGADDR:  0xd078
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_INTEG_REG    Divide this by 83.886 to get the approximate ppm frequency offset the CDR is tracking. (The CDR must settle first - rx_dsc_lock asserted high).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr (0x0001d078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_integ))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_STS_INTEGr
#define READLN_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_STS_INTEGr
#define WRITELN_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_STS_INTEGr
#define WRITEALL_DSC_CDR_STS_INTEGr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_STS_INTEGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_STS_INTEGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_CDR_1G_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd079
 * DEVAD:    1
 * DESC:     1g cdr status reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_1G_PHASE_POINTER 1G phase pointer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr (0x0001d079 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_1G_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_1g_sts[1];
	uint32_t _dsc_cdr_1g_sts;
} BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CLR(r) (r).dsc_cdr_1g_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_SET(r,d) (r).dsc_cdr_1g_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_GET(r) (r).dsc_cdr_1g_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET(r) (((r).dsc_cdr_1g_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET(r,f) (r).dsc_cdr_1g_sts[0]=(((r).dsc_cdr_1g_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_CDR_1G_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_1G_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_1G_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_1G_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_1G_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_1g_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_1G_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_1g_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_1G_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_1g_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr
#define DSC_CDR_1G_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_t DSC_CDR_1G_STSr_t;
#define DSC_CDR_1G_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CLR
#define DSC_CDR_1G_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_SET
#define DSC_CDR_1G_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET
#define READ_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_CDR_1G_STSr
#define WRITE_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_CDR_1G_STSr
#define MODIFY_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_CDR_1G_STSr
#define READLN_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_CDR_1G_STSr
#define WRITELN_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_CDR_1G_STSr
#define WRITEALL_DSC_CDR_1G_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_CDR_1G_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_CDR_1G_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_CTR_PHASE_ERR
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07a
 * DEVAD:    1
 * DESC:     rxpi counter and phase error
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_PHASE_ERR_PICNT shadowed version of phase error value
 *     CNT_BIN_D_PERR   PI counter value for data slicersee description of cnt_bin_pq
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr (0x0001d07a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTR_PHASE_ERR.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctr_phase_err[1];
	uint32_t _dsc_rx_pi_ctr_phase_err;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CLR(r) (r).dsc_rx_pi_ctr_phase_err[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_SET(r,d) (r).dsc_rx_pi_ctr_phase_err[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_GET(r) (r).dsc_rx_pi_ctr_phase_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_GET(r) ((((r).dsc_rx_pi_ctr_phase_err[0]) >> 7) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_SET(r,f) (r).dsc_rx_pi_ctr_phase_err[0]=(((r).dsc_rx_pi_ctr_phase_err[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_GET(r) (((r).dsc_rx_pi_ctr_phase_err[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_SET(r,f) (r).dsc_rx_pi_ctr_phase_err[0]=(((r).dsc_rx_pi_ctr_phase_err[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTR_PHASE_ERR.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr,(_r._dsc_rx_pi_ctr_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr,(_r._dsc_rx_pi_ctr_phase_err)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr,(_r._dsc_rx_pi_ctr_phase_err))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctr_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctr_phase_err))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CTR_PHASE_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctr_phase_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr
#define DSC_RX_PI_CTR_PHASE_ERRr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_t DSC_RX_PI_CTR_PHASE_ERRr_t;
#define DSC_RX_PI_CTR_PHASE_ERRr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CLR
#define DSC_RX_PI_CTR_PHASE_ERRr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_SET
#define DSC_RX_PI_CTR_PHASE_ERRr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_GET
#define DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_GET
#define DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CNT_BIN_D_PERRf_SET
#define DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_GET
#define DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr_CDR_PHASE_ERR_PICNTf_SET
#define READ_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_CTR_PHASE_ERRr
#define WRITE_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_CTR_PHASE_ERRr
#define MODIFY_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_CTR_PHASE_ERRr
#define READLN_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_CTR_PHASE_ERRr
#define WRITELN_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_CTR_PHASE_ERRr
#define WRITEALL_DSC_RX_PI_CTR_PHASE_ERRr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_CTR_PHASE_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_CTR_PHASE_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07b
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXC_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXB_DFE_TAP2_STATUS signed 2's complement  +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr (0x0001d07b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_sts[1];
	uint32_t _dsc_rx_dfe_tap2_sts;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_CLR(r) (r).dsc_rx_dfe_tap2_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_SET(r,d) (r).dsc_rx_dfe_tap2_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_GET(r) (r).dsc_rx_dfe_tap2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_sts[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_sts[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET(r) (((r).dsc_rx_dfe_tap2_sts[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr
#define DSC_RX_DFE_TAP2_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_t DSC_RX_DFE_TAP2_STSr_t;
#define DSC_RX_DFE_TAP2_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_CLR
#define DSC_RX_DFE_TAP2_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_SET
#define DSC_RX_DFE_TAP2_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_GET
#define DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET
#define READ_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_STSr
#define WRITE_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_STSr
#define MODIFY_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_STSr
#define READLN_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_STSr
#define WRITELN_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_STSr
#define WRITEALL_DSC_RX_DFE_TAP2_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_3_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07c
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_3_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXB_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr (0x0001d07c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_3_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_3_sts[1];
	uint32_t _dsc_rx_dfe_tap2_3_sts;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_CLR(r) (r).dsc_rx_dfe_tap2_3_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_SET(r,d) (r).dsc_rx_dfe_tap2_3_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_GET(r) (r).dsc_rx_dfe_tap2_3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_3_sts[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_3_sts[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET(r) (((r).dsc_rx_dfe_tap2_3_sts[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_3_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_3_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_3_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr
#define DSC_RX_DFE_TAP2_3_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_t DSC_RX_DFE_TAP2_3_STSr_t;
#define DSC_RX_DFE_TAP2_3_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_CLR
#define DSC_RX_DFE_TAP2_3_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_SET
#define DSC_RX_DFE_TAP2_3_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET
#define DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET
#define READ_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_3_STSr
#define WRITE_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_3_STSr
#define MODIFY_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_STSr
#define READLN_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_3_STSr
#define WRITELN_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_STSr
#define WRITEALL_DSC_RX_DFE_TAP2_3_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07d
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXD_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr (0x0001d07d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_sts[1];
	uint32_t _dsc_rx_dfe_tap3_sts;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_CLR(r) (r).dsc_rx_dfe_tap3_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_SET(r,d) (r).dsc_rx_dfe_tap3_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_GET(r) (r).dsc_rx_dfe_tap3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap3_sts[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap3_sts[0]=(((r).dsc_rx_dfe_tap3_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET(r) (((r).dsc_rx_dfe_tap3_sts[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap3_sts[0]=(((r).dsc_rx_dfe_tap3_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP3_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP3_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr
#define DSC_RX_DFE_TAP3_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_t DSC_RX_DFE_TAP3_STSr_t;
#define DSC_RX_DFE_TAP3_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_CLR
#define DSC_RX_DFE_TAP3_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_SET
#define DSC_RX_DFE_TAP3_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_GET
#define DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET
#define DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET
#define READ_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP3_STSr
#define WRITE_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP3_STSr
#define MODIFY_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP3_STSr
#define READLN_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP3_STSr
#define WRITELN_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP3_STSr
#define WRITEALL_DSC_RX_DFE_TAP3_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_PRESET
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07e
 * DEVAD:    1
 * DESC:     preset register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_C         Preset bit 1. Hooked up to dsc_sm bank
 *     PRESET_D         Preset bit 2. Hooked up to CDR trnsum bank
 *     PRESET_A         Preset bit 3. Hooked up to gen purpose bank a
 *     PRESET_F         Preset bit 4. Hooked up to gen purpose bank f
 *     PRESET_G         Preset bit 5. Hooked up to gen purpose bank g
 *     PRESET_H         Preset bit 6. Hooked up to gen purpose bank h
 *     PRESET_I         Preset bit 7. Hooked up to gen purpose bank i
 *     PRESET_SLICERS   Preset bit 8. Hooked up to data and phase slicers
 *     PRESET_DFE_TAPS_2_3 Preset bit 9. Hooked up to dfe taps 2 and 3
 */
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr (0x0001d07e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_SIZE 4

/*
 * This structure should be used to declare and program DSC_PRESET.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_PRESETr_s {
	uint32_t v[1];
	uint32_t dsc_preset[1];
	uint32_t _dsc_preset;
} BCMI_BLACKHAWK_XGXS_DSC_PRESETr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_CLR(r) (r).dsc_preset[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_SET(r,d) (r).dsc_preset[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_GET(r) (r).dsc_preset[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_DFE_TAPS_2_3f_GET(r) ((((r).dsc_preset[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_DFE_TAPS_2_3f_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_SLICERSf_GET(r) ((((r).dsc_preset[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_SLICERSf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_If_GET(r) ((((r).dsc_preset[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_If_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Hf_GET(r) ((((r).dsc_preset[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Hf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Gf_GET(r) ((((r).dsc_preset[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Gf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Ff_GET(r) ((((r).dsc_preset[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Ff_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Af_GET(r) ((((r).dsc_preset[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Af_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Df_GET(r) ((((r).dsc_preset[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Df_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Cf_GET(r) (((r).dsc_preset[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Cf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_PRESET.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_PRESETr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr,(_r._dsc_preset))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_PRESETr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr,(_r._dsc_preset)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_PRESETr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr,(_r._dsc_preset))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_PRESETr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_preset))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_PRESETr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_preset))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_PRESETr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_preset))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_PRESETr BCMI_BLACKHAWK_XGXS_DSC_PRESETr
#define DSC_PRESETr_SIZE BCMI_BLACKHAWK_XGXS_DSC_PRESETr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_PRESETr_t DSC_PRESETr_t;
#define DSC_PRESETr_CLR BCMI_BLACKHAWK_XGXS_DSC_PRESETr_CLR
#define DSC_PRESETr_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_SET
#define DSC_PRESETr_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_GET
#define DSC_PRESETr_PRESET_DFE_TAPS_2_3f_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_DFE_TAPS_2_3f_GET
#define DSC_PRESETr_PRESET_DFE_TAPS_2_3f_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_DFE_TAPS_2_3f_SET
#define DSC_PRESETr_PRESET_SLICERSf_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_SLICERSf_GET
#define DSC_PRESETr_PRESET_SLICERSf_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_SLICERSf_SET
#define DSC_PRESETr_PRESET_If_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_If_GET
#define DSC_PRESETr_PRESET_If_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_If_SET
#define DSC_PRESETr_PRESET_Hf_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Hf_GET
#define DSC_PRESETr_PRESET_Hf_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Hf_SET
#define DSC_PRESETr_PRESET_Gf_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Gf_GET
#define DSC_PRESETr_PRESET_Gf_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Gf_SET
#define DSC_PRESETr_PRESET_Ff_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Ff_GET
#define DSC_PRESETr_PRESET_Ff_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Ff_SET
#define DSC_PRESETr_PRESET_Af_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Af_GET
#define DSC_PRESETr_PRESET_Af_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Af_SET
#define DSC_PRESETr_PRESET_Df_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Df_GET
#define DSC_PRESETr_PRESET_Df_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Df_SET
#define DSC_PRESETr_PRESET_Cf_GET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Cf_GET
#define DSC_PRESETr_PRESET_Cf_SET BCMI_BLACKHAWK_XGXS_DSC_PRESETr_PRESET_Cf_SET
#define READ_DSC_PRESETr BCMI_BLACKHAWK_XGXS_READ_DSC_PRESETr
#define WRITE_DSC_PRESETr BCMI_BLACKHAWK_XGXS_WRITE_DSC_PRESETr
#define MODIFY_DSC_PRESETr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_PRESETr
#define READLN_DSC_PRESETr BCMI_BLACKHAWK_XGXS_READLN_DSC_PRESETr
#define WRITELN_DSC_PRESETr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_PRESETr
#define WRITEALL_DSC_PRESETr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_PRESETr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_PRESETr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL0
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd080
 * DEVAD:    1
 * DESC:     Control 0 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_RX_TRAINING_EN RX Training EnableEnables the frame lock fsm on the RX sides
 *     LINKTRN_TR_COARSE_LOCK Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured.linktrn_pmd, then, proceeds with establishing frame_lock.
 *     LINKTRN_RX_SIGNAL_OK Firmware sets this bit to 1'b0 when the training is in progressand sets this bit to 1'b1 when the training is complete
 *     LINKTRN_RX_TRN_MODE RX Training mode select0 - cl72/cl93 mode1 - 802.3cd mode
 *     LINKTRN_RX_ACTIVE Set to TRUE (1'b1) by the micro to indicate the link trainingis active on the rx side.This field is used in the RX lane(s) to determinewhen it is safe to turn on/off PAM4/NRZ decoded in thein the RX datapath. The firmware is required set this field thewhen link training is active in the RX side
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r (0x0001d080 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl0[1];
	uint32_t _lnktrnur_ctl0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_CLR(r) (r).lnktrnur_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_SET(r,d) (r).lnktrnur_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_GET(r) (r).lnktrnur_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_GET(r) ((((r).lnktrnur_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_SET(r,f) (r).lnktrnur_ctl0[0]=(((r).lnktrnur_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_GET(r) ((((r).lnktrnur_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_SET(r,f) (r).lnktrnur_ctl0[0]=(((r).lnktrnur_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_GET(r) ((((r).lnktrnur_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_SET(r,f) (r).lnktrnur_ctl0[0]=(((r).lnktrnur_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_GET(r) ((((r).lnktrnur_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_SET(r,f) (r).lnktrnur_ctl0[0]=(((r).lnktrnur_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_GET(r) (((r).lnktrnur_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_SET(r,f) (r).lnktrnur_ctl0[0]=(((r).lnktrnur_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r,(_r._lnktrnur_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r,(_r._lnktrnur_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r,(_r._lnktrnur_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r
#define LNKTRNUR_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_t LNKTRNUR_CTL0r_t;
#define LNKTRNUR_CTL0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_CLR
#define LNKTRNUR_CTL0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_SET
#define LNKTRNUR_CTL0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_GET
#define LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_GET
#define LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_ACTIVEf_SET
#define LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_GET
#define LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRN_MODEf_SET
#define LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_GET
#define LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_SIGNAL_OKf_SET
#define LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_GET
#define LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_TR_COARSE_LOCKf_SET
#define LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_GET
#define LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r_LINKTRN_RX_TRAINING_ENf_SET
#define READ_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL0r
#define WRITE_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL0r
#define MODIFY_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL0r
#define READLN_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL0r
#define WRITELN_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL0r
#define WRITEALL_LNKTRNUR_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL1
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd081
 * DEVAD:    1
 * DESC:     Control 1 Register
 * RESETVAL: 0x52 (82)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_GOOD_MARKER_CNT Number of good marker to checkbefore enabling frame lock
 *     LINKTRN_BAD_MARKER_CNT Number of bad marker to checkbefore losing frame lock
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r (0x0001d081 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl1[1];
	uint32_t _lnktrnur_ctl1;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_CLR(r) (r).lnktrnur_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_SET(r,d) (r).lnktrnur_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_GET(r) (r).lnktrnur_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_GET(r) ((((r).lnktrnur_ctl1[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_SET(r,f) (r).lnktrnur_ctl1[0]=(((r).lnktrnur_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_GET(r) (((r).lnktrnur_ctl1[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_SET(r,f) (r).lnktrnur_ctl1[0]=(((r).lnktrnur_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access LNKTRNUR_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r,(_r._lnktrnur_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r,(_r._lnktrnur_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r,(_r._lnktrnur_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r
#define LNKTRNUR_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_t LNKTRNUR_CTL1r_t;
#define LNKTRNUR_CTL1r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_CLR
#define LNKTRNUR_CTL1r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_SET
#define LNKTRNUR_CTL1r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_GET
#define LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_GET
#define LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_BAD_MARKER_CNTf_SET
#define LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_GET
#define LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r_LINKTRN_GOOD_MARKER_CNTf_SET
#define READ_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL1r
#define WRITE_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL1r
#define MODIFY_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL1r
#define READLN_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL1r
#define WRITELN_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL1r
#define WRITEALL_LNKTRNUR_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL2
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd082
 * DEVAD:    1
 * DESC:     Control 2 Register
 * RESETVAL: 0xb90 (2960)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_DME_CELL_BOUNDARY_CHK Check for DME cell boundary transitions0 - disabled1 - enabled
 *     LINKTRN_STRICT_DME_CHK This field specifies whether the edges of DME cells are allowedto shift by a couple samples0 - ignore bits 0, 3, 4 and 7 of the DME cell1 - check all 8 bits of the DME cell
 *     LINKTRN_STRICT_MARKER_CHK When determining frame lock, this field can be used tospecifies whether the edges of frame markers are allowedto shift by a couple samples0 - ignore first and last two samples of the marker1 - do not ignore first and last two samples of the markercheck for all 16 ones followed by 16 zeros
 *     LINKTRN_PPM_OFFSET_EN if enabled, linktrn tracks ppm offset of incoming datawhile checking from frame lock, the offset is ineither direction for every frame0 - disabled1 - enabled
 *     LINKTRN_RX_DP_LN_CLK_EN linktrn Rx datapath lane clock enable0 - disabled1 - enabled
 *     LINKTRN_FRAME_CONSISTENCY_CHK_EN linktrn frame consistency check enable0 - disabled1 - enabled - checks that three consective frames from the link partnerhas the same status response/coffcient update request informationbefore it set the sets the latched status bits
 *     LINKTRN_BLOCK_LP_IEEE_UPDATES linktrn Block new lp ieee control/status page updates while an interrupt is pending0 - when the consistency checks are disabled, allow lp ieee control/status pagesto be updated upon receiving new pages all of the time1 - when the consistency checks are disabled, block lp ieee control/status pagesto be updated upon receiving new pages if an interrupt is already pending
 *     LINKTRN_USEDME_MARKER_CHK This field allows the use of the bits from the DME cellfor frame marker checking. Using more bits for frame markerdecreases the probability of false frame marker locking0 - use only frame marker bits for the frame marker checking1 - use frame marker + DME cell bits for frame marker checking
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r (0x0001d082 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl2[1];
	uint32_t _lnktrnur_ctl2;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_CLR(r) (r).lnktrnur_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_SET(r,d) (r).lnktrnur_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_GET(r) (r).lnktrnur_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_GET(r) ((((r).lnktrnur_ctl2[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_SET(r,f) (r).lnktrnur_ctl2[0]=(((r).lnktrnur_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access LNKTRNUR_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r,(_r._lnktrnur_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r,(_r._lnktrnur_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r,(_r._lnktrnur_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r
#define LNKTRNUR_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_t LNKTRNUR_CTL2r_t;
#define LNKTRNUR_CTL2r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_CLR
#define LNKTRNUR_CTL2r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_SET
#define LNKTRNUR_CTL2r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_GET
#define LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_GET
#define LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_USEDME_MARKER_CHKf_SET
#define LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_GET
#define LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_BLOCK_LP_IEEE_UPDATESf_SET
#define LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_GET
#define LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_FRAME_CONSISTENCY_CHK_ENf_SET
#define LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_GET
#define LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_RX_DP_LN_CLK_ENf_SET
#define LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_GET
#define LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_PPM_OFFSET_ENf_SET
#define LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_GET
#define LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_MARKER_CHKf_SET
#define LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_GET
#define LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_STRICT_DME_CHKf_SET
#define LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_GET
#define LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r_LINKTRN_DME_CELL_BOUNDARY_CHKf_SET
#define READ_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL2r
#define WRITE_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL2r
#define MODIFY_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL2r
#define READLN_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL2r
#define WRITELN_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL2r
#define WRITEALL_LNKTRNUR_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_STS0
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd083
 * DEVAD:    1
 * DESC:     Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_FRAME_LOCK Frame Lock signal statusThis bit provides status of the frame lock signal from the frame lock fsm.1 - frame locked0 - frame not lockedThe status bit in the IEEE registers space is set by firmware
 *     LINKTRN_REMOTE_RX_READY remote_rx_ready statusThis bit provides status of the remote_rx_ready signal from the link partner.
 *     LINKTRN_FRAME_LOCK_LL frame_lock latch lowIt only goes to a 1 if the frame_lock field transitions from a 1 to a 0cleared upon reading this register
 *     LINKTRN_FRAME_LOCK_LH frame_lock latch highIt only goes to a 1 if the frame_lock field transitions from a 0 to a 1cleared upon reading this register
 *     LINKTRN_RCV_COEFF_UPDATE_PARITY This fields indicates the parity of the current value of thelinktrn_ieee_lp_coeff_update register field. This field can beused to determine if contents of linktrn_ieee_lp_coeff_updatehas parity error0 - even parity - linktrn_ieee_lp_coeff_update field has even number of 1's1 - odd parity  - linktrn_ieee_lp_coeff_update field has odd number of 1's
 *     LINKTRN_RCV_STATUS_REPORT_PARITY This fields indicates the parity of the current value of thelinktrn_ieee_lp_status_report register field. This field can beused to determine if contents of linktrn_ieee_lp_status_reporthas parity error0 - even parity - linktrn_ieee_lp_status_report field has even number of 1's1 - odd parity  - linktrn_ieee_lp_status_report field has odd number of 1's
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r (0x0001d083 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_s {
	uint32_t v[1];
	uint32_t lnktrnur_sts0[1];
	uint32_t _lnktrnur_sts0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_CLR(r) (r).lnktrnur_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_SET(r,d) (r).lnktrnur_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_GET(r) (r).lnktrnur_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_GET(r) ((((r).lnktrnur_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_GET(r) ((((r).lnktrnur_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_GET(r) ((((r).lnktrnur_sts0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_GET(r) ((((r).lnktrnur_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_GET(r) ((((r).lnktrnur_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_GET(r) (((r).lnktrnur_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_SET(r,f) (r).lnktrnur_sts0[0]=(((r).lnktrnur_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r,(_r._lnktrnur_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r,(_r._lnktrnur_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r,(_r._lnktrnur_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r
#define LNKTRNUR_STS0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_t LNKTRNUR_STS0r_t;
#define LNKTRNUR_STS0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_CLR
#define LNKTRNUR_STS0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_SET
#define LNKTRNUR_STS0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_GET
#define LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_GET
#define LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_STATUS_REPORT_PARITYf_SET
#define LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_GET
#define LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_RCV_COEFF_UPDATE_PARITYf_SET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_GET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LHf_SET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_GET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCK_LLf_SET
#define LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_GET
#define LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_REMOTE_RX_READYf_SET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_GET
#define LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r_LINKTRN_FRAME_LOCKf_SET
#define READ_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_STS0r
#define WRITE_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_STS0r
#define MODIFY_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_STS0r
#define READLN_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_STS0r
#define WRITELN_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_STS0r
#define WRITEALL_LNKTRNUR_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_UC_INTR_CTL0
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd084
 * DEVAD:    1
 * DESC:     Micro Interrupt Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_MICRO_UPDATE_CHG_INT_EN Update field micro interrupt enable. Enables an interrupt when the update field value changes in the training frame received from Link PartnerThe Link parnter request a change to the Local Device TX FIR tap values via the update field1 - Enable. Generates an interrupt when linktrn_micro_lstatus_update_chg = 1'b1.0 - Disable
 *     LINKTRN_MICRO_STATUS_CHG_INT_EN Status field change micro interrupt enable. Enables an interrupt when the status field value changes in the training frame received from Link PartnerWhen the Local Devices requests Link Partner to change its TX FIR tap values, then the Link Partner updatestaps and sends a response on the stataus field of the training frame1 - Enable. Generates an interrupt when linktrn_micro_lstatus_status_chg = 1'b1.0 - Disable
 *     LINKTRN_MICRO_FRAME_LOCK_INT_EN frame_lock change micro interrupt enable.1 - Enable0 - Disable
 *     LINKTRN_MICRO_FFLOCK_INT_EN False frame lock micro interrupt enable.1 - Enable0 - Disable
 *     LINKTRN_MICRO_UPDATE_REQ_INT_FRC Force an interrupt on linktrn_micro_update_req_int pin0 -  interrupt on the linktrn_micro_update_req_int pingenerated when the update field value changes in the trainingframe received from Link Partner andlinktrn_micro_update_chg_int_en field is set to 1'b11 -  interrupt on the linktrn_micro_update_req_int pingenerated by the linktrn_micro_update_req_int_frc_val field
 *     LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VAL Force value on linktrn_micro_update_req_int pinwhen linktrn_micro_update_req_int_frc field is set to 1'b1
 *     LINKTRN_MICRO_STATUS_RESP_INT_FRC Force an interrupt on linktrn_micro_status_resp_int pin0 -  interrupt on the linktrn_micro_status_resp_int pingenerated when the status field value changes in the trainingframe received from Link Partner andlinktrn_micro_status_chg_int_en field is set to 1'b11 -  interrupt on the linktrn_micro_status_resp_int pingenerated by the linktrn_micro_status_resp_int_frc_val field
 *     LINKTRN_MICRO_STATUS_RESP_INT_FRC_VAL Force value on linktrn_micro_status_resp_int pinwhen linktrn_micro_status_resp_int_frc field is set to 1'b1
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r (0x0001d084 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_UC_INTR_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t lnktrnur_uc_intr_ctl0[1];
	uint32_t _lnktrnur_uc_intr_ctl0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_CLR(r) (r).lnktrnur_uc_intr_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_SET(r,d) (r).lnktrnur_uc_intr_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_GET(r) (r).lnktrnur_uc_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_GET(r) ((((r).lnktrnur_uc_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_GET(r) (((r).lnktrnur_uc_intr_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_SET(r,f) (r).lnktrnur_uc_intr_ctl0[0]=(((r).lnktrnur_uc_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_UC_INTR_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r,(_r._lnktrnur_uc_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r,(_r._lnktrnur_uc_intr_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r,(_r._lnktrnur_uc_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_uc_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r
#define LNKTRNUR_UC_INTR_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_t LNKTRNUR_UC_INTR_CTL0r_t;
#define LNKTRNUR_UC_INTR_CTL0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_CLR
#define LNKTRNUR_UC_INTR_CTL0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_SET
#define LNKTRNUR_UC_INTR_CTL0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRC_VALf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_RESP_INT_FRCf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRC_VALf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_REQ_INT_FRCf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FFLOCK_INT_ENf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_FRAME_LOCK_INT_ENf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_STATUS_CHG_INT_ENf_SET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_GET
#define LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r_LINKTRN_MICRO_UPDATE_CHG_INT_ENf_SET
#define READ_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL0r
#define WRITE_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL0r
#define MODIFY_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL0r
#define READLN_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL0r
#define WRITELN_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL0r
#define WRITEALL_LNKTRNUR_UC_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_UC_STS0
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd085
 * DEVAD:    1
 * DESC:     Micro Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_MICRO_UPDATE_CHG_LSTATUS coeffcient update field change latched status -  This bit is set to 1'b1 when the update field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r (0x0001d085 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_UC_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_s {
	uint32_t v[1];
	uint32_t lnktrnur_uc_sts0[1];
	uint32_t _lnktrnur_uc_sts0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_CLR(r) (r).lnktrnur_uc_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_SET(r,d) (r).lnktrnur_uc_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_GET(r) (r).lnktrnur_uc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_GET(r) (((r).lnktrnur_uc_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_SET(r,f) (r).lnktrnur_uc_sts0[0]=(((r).lnktrnur_uc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_UC_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r,(_r._lnktrnur_uc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r,(_r._lnktrnur_uc_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r,(_r._lnktrnur_uc_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_uc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r
#define LNKTRNUR_UC_STS0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_t LNKTRNUR_UC_STS0r_t;
#define LNKTRNUR_UC_STS0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_CLR
#define LNKTRNUR_UC_STS0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_SET
#define LNKTRNUR_UC_STS0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_GET
#define LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_GET
#define LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r_LINKTRN_MICRO_UPDATE_CHG_LSTATUSf_SET
#define READ_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_STS0r
#define WRITE_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_STS0r
#define MODIFY_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_STS0r
#define READLN_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_STS0r
#define WRITELN_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_STS0r
#define WRITEALL_LNKTRNUR_UC_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_UC_STS1
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd086
 * DEVAD:    1
 * DESC:     Micro Status 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_MICRO_STATUS_CHG_LSTATUS coeffcient status field latched status - This bit is set to 1'b1 when the status field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 *     LINKTRN_MICRO_FRAME_LOCK_LSTATUS Frame lock change latched status - This bit is set to 1'b1 when a change is detected on the frame lock signalThis bit cleared when this register is read.
 *     LINKTRN_MICRO_FFLOCK_LSTATUS False frame lock latched status - This bit is set to 1'b1 when a number of consective frames with DME errors are detected.The number of the frames are specified by the linktrn_fflock_derr_consec_fcnt fieldThis bit cleared when this register is read.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r (0x0001d086 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_UC_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_s {
	uint32_t v[1];
	uint32_t lnktrnur_uc_sts1[1];
	uint32_t _lnktrnur_uc_sts1;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_CLR(r) (r).lnktrnur_uc_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_SET(r,d) (r).lnktrnur_uc_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_GET(r) (r).lnktrnur_uc_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_GET(r) ((((r).lnktrnur_uc_sts1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_SET(r,f) (r).lnktrnur_uc_sts1[0]=(((r).lnktrnur_uc_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_GET(r) ((((r).lnktrnur_uc_sts1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_SET(r,f) (r).lnktrnur_uc_sts1[0]=(((r).lnktrnur_uc_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_GET(r) (((r).lnktrnur_uc_sts1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_SET(r,f) (r).lnktrnur_uc_sts1[0]=(((r).lnktrnur_uc_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_UC_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r,(_r._lnktrnur_uc_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r,(_r._lnktrnur_uc_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r,(_r._lnktrnur_uc_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_uc_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r
#define LNKTRNUR_UC_STS1r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_t LNKTRNUR_UC_STS1r_t;
#define LNKTRNUR_UC_STS1r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_CLR
#define LNKTRNUR_UC_STS1r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_SET
#define LNKTRNUR_UC_STS1r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_GET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_GET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FFLOCK_LSTATUSf_SET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_GET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_FRAME_LOCK_LSTATUSf_SET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_GET
#define LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r_LINKTRN_MICRO_STATUS_CHG_LSTATUSf_SET
#define READ_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_STS1r
#define WRITE_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_STS1r
#define MODIFY_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_STS1r
#define READLN_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_STS1r
#define WRITELN_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_STS1r
#define WRITEALL_LNKTRNUR_UC_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL3
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd087
 * DEVAD:    1
 * DESC:     Control 3 Register
 * RESETVAL: 0xd (13)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_RX_SIGNDATA_SEL Select sign data for link training1 - Use 20 bit sign data(i.e. sign bit from phase slicers in PAM4 mode,and data bit from the data slicers in NRZ mode)0 - Use 40 bit rx data from the aggregator
 *     LINKTRN_ASYNC_PPM_ADJUST PPM offset adjustment select0 - allow 1 UI of drift from one frame to the next1 - allow upto 10UI of drift from one frame to the next
 *     LINKTRN_RX_PAM4_TRN_FRAME_SIZE In 802.3cd mode, RX training frame size1 - 16672 UI RX training frame0 - 4384 UI RX training frameUI = 2 bits
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r (0x0001d087 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl3[1];
	uint32_t _lnktrnur_ctl3;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_CLR(r) (r).lnktrnur_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_SET(r,d) (r).lnktrnur_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_GET(r) (r).lnktrnur_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_GET(r) ((((r).lnktrnur_ctl3[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_SET(r,f) (r).lnktrnur_ctl3[0]=(((r).lnktrnur_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_GET(r) ((((r).lnktrnur_ctl3[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_SET(r,f) (r).lnktrnur_ctl3[0]=(((r).lnktrnur_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_GET(r) (((r).lnktrnur_ctl3[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_SET(r,f) (r).lnktrnur_ctl3[0]=(((r).lnktrnur_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r,(_r._lnktrnur_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r,(_r._lnktrnur_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r,(_r._lnktrnur_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r
#define LNKTRNUR_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_t LNKTRNUR_CTL3r_t;
#define LNKTRNUR_CTL3r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_CLR
#define LNKTRNUR_CTL3r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_SET
#define LNKTRNUR_CTL3r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_GET
#define LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_GET
#define LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_PAM4_TRN_FRAME_SIZEf_SET
#define LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_GET
#define LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_ASYNC_PPM_ADJUSTf_SET
#define LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_GET
#define LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r_LINKTRN_RX_SIGNDATA_SELf_SET
#define READ_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL3r
#define WRITE_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL3r
#define MODIFY_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL3r
#define READLN_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL3r
#define WRITELN_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL3r
#define WRITEALL_LNKTRNUR_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL4
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd088
 * DEVAD:    1
 * DESC:     Control 4 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_RX_PRBS_CHK_EN In 802.3cd mode, PRBS checking in the RX link training frames1 - Enabled0 - DisabledThe micro (firmware) set's this field to 1 to start the RX link training PRBS checkingand clear it when the training is complete
 *     LINKTRN_RX_PRBS_CHK_AUTO_DETECT_EN In 802.3cd mode, Auto-detect PRBS polynomials in the RX Link training frames.1 - Enabled.0 - Disabled.{linktrn_rx_prbs_chk_auto_detect_en, linktrn_rx_prbs_chk_auto_detect_relock_en}{1'b0, 1'bx} : Disabled. Use linktrn_rx_prbs_chk_mode_sel to select PRBS polynomial for PRBS checking{1'b1, 1'b0} : Enabled. Use auto-detected PRBS polynomial until %LINKTRN_CFG%]_rx_prbs_chk_auto_detect_en = 0{1'b1, 1'b1} : Enabled. Re-auto-detected if linktrn_rx_prbs_chk_auto_detect_lock transitions to 0 ?
 *     LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_EN In 802.3cd mode, Re-auto-detect PRBS polynomial in the RX Link training frames1 - Re-auto-detect PRBS polynomial if linktrn_rx_prbs_chk_auto_detect_lock tranitions to 0 ?0 - use auto-detected PRBS polynomial until %LINKTRN_CFG%]_rx_prbs_chk_auto_detect_en =0
 *     LINKTRN_RX_PRBS_CHK_MODE_SEL In 802.3cd mode, RX Link training PRBS polynomial select.0:   1 + x  + x2 + x12 + x131:   1 + x2 + x3 + x7  + x132:   1 + x2 + x4 + x8  + x133:   1 + x2 + x5 + x9  + x13PLEASE NOTE:The default value of this register field is unique for each lane i.e.Lane 0,4 - 2'b00Lane 1,5 - 2'b01Lane 2,6 - 2'b10Lane 3,7 - 2'b11
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r (0x0001d088 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl4[1];
	uint32_t _lnktrnur_ctl4;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_CLR(r) (r).lnktrnur_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_SET(r,d) (r).lnktrnur_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_GET(r) (r).lnktrnur_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_GET(r) ((((r).lnktrnur_ctl4[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_SET(r,f) (r).lnktrnur_ctl4[0]=(((r).lnktrnur_ctl4[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET(r) ((((r).lnktrnur_ctl4[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET(r,f) (r).lnktrnur_ctl4[0]=(((r).lnktrnur_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_GET(r) ((((r).lnktrnur_ctl4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_SET(r,f) (r).lnktrnur_ctl4[0]=(((r).lnktrnur_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_GET(r) (((r).lnktrnur_ctl4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_SET(r,f) (r).lnktrnur_ctl4[0]=(((r).lnktrnur_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r,(_r._lnktrnur_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r,(_r._lnktrnur_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r,(_r._lnktrnur_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r
#define LNKTRNUR_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_t LNKTRNUR_CTL4r_t;
#define LNKTRNUR_CTL4r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_CLR
#define LNKTRNUR_CTL4r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_SET
#define LNKTRNUR_CTL4r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_GET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_GET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_MODE_SELf_SET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_GET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_ENf_SET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_GET
#define LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r_LINKTRN_RX_PRBS_CHK_ENf_SET
#define READ_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL4r
#define WRITE_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL4r
#define MODIFY_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL4r
#define READLN_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL4r
#define WRITELN_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL4r
#define WRITEALL_LNKTRNUR_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_STS1
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd089
 * DEVAD:    1
 * DESC:     Status 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCK In 802.3cd mode, Auto-detect PRBS polynomial lock status1 - Locked0 - Unlocked
 *     LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECT In 802.3cd mode, Status of the auto-detected polynomial, valid after linktrn_rx_prbs_chk_auto_detect_lock = 12'd0:   1 + x  + x2 + x12 + x132'd1:   1 + x2 + x3 + x7  + x132'd2:   1 + x2 + x4 + x8  + x132'd3:   1 + x2 + x5 + x9  + x13The default value of this field will depends on the lane number i.e.PLEASE NOTE:The default value of this register field for each lane is unique i.e.Lane 0,4 - 2'b00Lane 1,5 - 2'b01Lane 2,6 - 2'b10Lane 3,7 - 2'b11
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r (0x0001d089 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_s {
	uint32_t v[1];
	uint32_t lnktrnur_sts1[1];
	uint32_t _lnktrnur_sts1;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_CLR(r) (r).lnktrnur_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_SET(r,d) (r).lnktrnur_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_GET(r) (r).lnktrnur_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET(r) ((((r).lnktrnur_sts1[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET(r,f) (r).lnktrnur_sts1[0]=(((r).lnktrnur_sts1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_GET(r) (((r).lnktrnur_sts1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_SET(r,f) (r).lnktrnur_sts1[0]=(((r).lnktrnur_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUR_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r,(_r._lnktrnur_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r,(_r._lnktrnur_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r,(_r._lnktrnur_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r
#define LNKTRNUR_STS1r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_t LNKTRNUR_STS1r_t;
#define LNKTRNUR_STS1r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_CLR
#define LNKTRNUR_STS1r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_SET
#define LNKTRNUR_STS1r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_GET
#define LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET
#define LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET
#define LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_GET
#define LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r_LINKTRN_RX_PRBS_CHK_AUTO_DETECT_LOCKf_SET
#define READ_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_STS1r
#define WRITE_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_STS1r
#define MODIFY_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_STS1r
#define READLN_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_STS1r
#define WRITELN_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_STS1r
#define WRITEALL_LNKTRNUR_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_CTL5
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd08a
 * DEVAD:    1
 * DESC:     Control 5 Register
 * RESETVAL: 0x510 (1296)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_FFLOCK_DERR_CONSEC_FCNT This field defines the number of consective frame with dme errors to be detectedto identify false frame lock
 *     LINKTRN_FFLOCK_DERR_PER_FCNT This field specify the number of DME errors to be detected in a frame to be regard it as a bad frame
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r (0x0001d08a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_s {
	uint32_t v[1];
	uint32_t lnktrnur_ctl5[1];
	uint32_t _lnktrnur_ctl5;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_CLR(r) (r).lnktrnur_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_SET(r,d) (r).lnktrnur_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_GET(r) (r).lnktrnur_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_GET(r) ((((r).lnktrnur_ctl5[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_SET(r,f) (r).lnktrnur_ctl5[0]=(((r).lnktrnur_ctl5[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_GET(r) (((r).lnktrnur_ctl5[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_SET(r,f) (r).lnktrnur_ctl5[0]=(((r).lnktrnur_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LNKTRNUR_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r,(_r._lnktrnur_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r,(_r._lnktrnur_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r,(_r._lnktrnur_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r
#define LNKTRNUR_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_t LNKTRNUR_CTL5r_t;
#define LNKTRNUR_CTL5r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_CLR
#define LNKTRNUR_CTL5r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_SET
#define LNKTRNUR_CTL5r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_GET
#define LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_GET
#define LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_PER_FCNTf_SET
#define LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_GET
#define LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r_LINKTRN_FFLOCK_DERR_CONSEC_FCNTf_SET
#define READ_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_CTL5r
#define WRITE_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_CTL5r
#define MODIFY_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_CTL5r
#define READLN_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_CTL5r
#define WRITELN_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_CTL5r
#define WRITEALL_LNKTRNUR_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_UC_INTR_CTL1
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd08d
 * DEVAD:    1
 * DESC:     Micro Interrupt Control 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGE Interrupt mask for the control page received from the link partner1 - mask. A change on the corresponding bit will not generate interrupt0 - normal mode.  A change on the corresponding bit will generate interruptshould be set 0xCFC0 during training
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r (0x0001d08d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_UC_INTR_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_s {
	uint32_t v[1];
	uint32_t lnktrnur_uc_intr_ctl1[1];
	uint32_t _lnktrnur_uc_intr_ctl1;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_CLR(r) (r).lnktrnur_uc_intr_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_SET(r,d) (r).lnktrnur_uc_intr_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_GET(r) (r).lnktrnur_uc_intr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_GET(r) (((r).lnktrnur_uc_intr_ctl1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_SET(r,f) (r).lnktrnur_uc_intr_ctl1[0]=(((r).lnktrnur_uc_intr_ctl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNUR_UC_INTR_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r,(_r._lnktrnur_uc_intr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r,(_r._lnktrnur_uc_intr_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r,(_r._lnktrnur_uc_intr_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_uc_intr_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r
#define LNKTRNUR_UC_INTR_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_t LNKTRNUR_UC_INTR_CTL1r_t;
#define LNKTRNUR_UC_INTR_CTL1r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_CLR
#define LNKTRNUR_UC_INTR_CTL1r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_SET
#define LNKTRNUR_UC_INTR_CTL1r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_GET
#define LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_GET
#define LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r_LINKTRN_MICRO_INTERRUPT_MASK_CONTROL_PAGEf_SET
#define READ_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL1r
#define WRITE_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL1r
#define MODIFY_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL1r
#define READLN_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL1r
#define WRITELN_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL1r
#define WRITEALL_LNKTRNUR_UC_INTR_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUR_UC_INTR_CTL2
 * BLOCKS:   LINKTRN_USER_RX
 * REGADDR:  0xd08e
 * DEVAD:    1
 * DESC:     Micro Interrupt Control 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGE Interrupt mask for the status page received from the link partner1 - mask. A change on the corresponding bit will not generate interrupt0 - normal mode.  A change on the corresponding bit will generate interruptshould be set 0x7FC0 during training
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r (0x0001d08e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUR_UC_INTR_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_s {
	uint32_t v[1];
	uint32_t lnktrnur_uc_intr_ctl2[1];
	uint32_t _lnktrnur_uc_intr_ctl2;
} BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_CLR(r) (r).lnktrnur_uc_intr_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_SET(r,d) (r).lnktrnur_uc_intr_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_GET(r) (r).lnktrnur_uc_intr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_GET(r) (((r).lnktrnur_uc_intr_ctl2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_SET(r,f) (r).lnktrnur_uc_intr_ctl2[0]=(((r).lnktrnur_uc_intr_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNUR_UC_INTR_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r,(_r._lnktrnur_uc_intr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r,(_r._lnktrnur_uc_intr_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r,(_r._lnktrnur_uc_intr_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnur_uc_intr_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnur_uc_intr_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r
#define LNKTRNUR_UC_INTR_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_t LNKTRNUR_UC_INTR_CTL2r_t;
#define LNKTRNUR_UC_INTR_CTL2r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_CLR
#define LNKTRNUR_UC_INTR_CTL2r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_SET
#define LNKTRNUR_UC_INTR_CTL2r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_GET
#define LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_GET
#define LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r_LINKTRN_MICRO_INTERRUPT_MASK_STATUS_PAGEf_SET
#define READ_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUR_UC_INTR_CTL2r
#define WRITE_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUR_UC_INTR_CTL2r
#define MODIFY_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUR_UC_INTR_CTL2r
#define READLN_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUR_UC_INTR_CTL2r
#define WRITELN_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUR_UC_INTR_CTL2r
#define WRITEALL_LNKTRNUR_UC_INTR_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUR_UC_INTR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUR_UC_INTR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_XMT_UPD_PAGE
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd090
 * DEVAD:    1
 * DESC:     linktrn Send Coefficient Update Request to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_XMT_UPDATE_PAGE Local Device's transmit control pageThe contents of this register maps to the control fieldportion of the link training frame. This register isfully programmable and therefore the firmware has the flexibilityto map the register bits to different IEEE/OIF/FC standardsPlease see the apprpopiate standards for registers bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr (0x0001d090 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_XMT_UPD_PAGE.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_s {
	uint32_t v[1];
	uint32_t lnktrnut_xmt_upd_page[1];
	uint32_t _lnktrnut_xmt_upd_page;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_CLR(r) (r).lnktrnut_xmt_upd_page[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_SET(r,d) (r).lnktrnut_xmt_upd_page[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_GET(r) (r).lnktrnut_xmt_upd_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_GET(r) (((r).lnktrnut_xmt_upd_page[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_SET(r,f) (r).lnktrnut_xmt_upd_page[0]=(((r).lnktrnut_xmt_upd_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNUT_XMT_UPD_PAGE.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_XMT_UPD_PAGEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr,(_r._lnktrnut_xmt_upd_page))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_XMT_UPD_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr,(_r._lnktrnut_xmt_upd_page)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_XMT_UPD_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr,(_r._lnktrnut_xmt_upd_page))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_xmt_upd_page))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_xmt_upd_page))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_XMT_UPD_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_xmt_upd_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr
#define LNKTRNUT_XMT_UPD_PAGEr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_t LNKTRNUT_XMT_UPD_PAGEr_t;
#define LNKTRNUT_XMT_UPD_PAGEr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_CLR
#define LNKTRNUT_XMT_UPD_PAGEr_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_SET
#define LNKTRNUT_XMT_UPD_PAGEr_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_GET
#define LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_GET
#define LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr_LINKTRN_XMT_UPDATE_PAGEf_SET
#define READ_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_XMT_UPD_PAGEr
#define WRITE_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_XMT_UPD_PAGEr
#define MODIFY_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_XMT_UPD_PAGEr
#define READLN_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_XMT_UPD_PAGEr
#define WRITELN_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_XMT_UPD_PAGEr
#define WRITEALL_LNKTRNUT_XMT_UPD_PAGEr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_XMT_UPD_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_XMT_UPD_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_LD_XMT_STS_PAGE
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd091
 * DEVAD:    1
 * DESC:     linktrn Send Local Device's Coeffcient Status to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_LD_XMT_STATUS_PAGE Local Device's transmit status pageThe contents of this register maps to the Status Reportportion of the link training frame. This register isfully programmable and therefore the firmware has the flexibilityto map the register bits to different IEEE/OIF/FC standardsPlease see the apprpopiate standards for registers bit definitions.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr (0x0001d091 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_LD_XMT_STS_PAGE.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_s {
	uint32_t v[1];
	uint32_t lnktrnut_ld_xmt_sts_page[1];
	uint32_t _lnktrnut_ld_xmt_sts_page;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_CLR(r) (r).lnktrnut_ld_xmt_sts_page[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_SET(r,d) (r).lnktrnut_ld_xmt_sts_page[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_GET(r) (r).lnktrnut_ld_xmt_sts_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_GET(r) (((r).lnktrnut_ld_xmt_sts_page[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_SET(r,f) (r).lnktrnut_ld_xmt_sts_page[0]=(((r).lnktrnut_ld_xmt_sts_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNUT_LD_XMT_STS_PAGE.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr,(_r._lnktrnut_ld_xmt_sts_page))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr,(_r._lnktrnut_ld_xmt_sts_page)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr,(_r._lnktrnut_ld_xmt_sts_page))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ld_xmt_sts_page))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ld_xmt_sts_page))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ld_xmt_sts_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr
#define LNKTRNUT_LD_XMT_STS_PAGEr_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_t LNKTRNUT_LD_XMT_STS_PAGEr_t;
#define LNKTRNUT_LD_XMT_STS_PAGEr_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_CLR
#define LNKTRNUT_LD_XMT_STS_PAGEr_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_SET
#define LNKTRNUT_LD_XMT_STS_PAGEr_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_GET
#define LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_GET
#define LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr_LINKTRN_LD_XMT_STATUS_PAGEf_SET
#define READ_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_LD_XMT_STS_PAGEr
#define WRITE_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_LD_XMT_STS_PAGEr
#define MODIFY_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_LD_XMT_STS_PAGEr
#define READLN_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_LD_XMT_STS_PAGEr
#define WRITELN_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_LD_XMT_STS_PAGEr
#define WRITEALL_LNKTRNUT_LD_XMT_STS_PAGEr BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_LD_XMT_STS_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_LD_XMT_STS_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_CTL0
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd092
 * DEVAD:    1
 * DESC:     linktrn Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_SW_RX_TRAINED Set to TRUE (1'b1) by the micro when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     LINKTRN_SW_FRAME_LOCK Set to TRUE (1'b1) by the micro to indicate to the training fsmframe lock has been achieved
 *     LINKTRN_SW_REMOTE_RX_READY Set to TRUE (1'b1) by the micro to indicate to the training fsmlink parnter rx ready bit is set. It indicates that the remote is trained
 *     LINKTRN_IGNORE_XMT_REG_VALUE linktrn_ignore_xmt_reg_value is used to tell the linktrntransmitter that it should ignore the contents of linktrn_xmt_update_pageand linktrn_ld_xmt_status_page fields. This is used in applications thatonly allows the control and status to change during the same frame1 - ignore (do not use) linktrn_xmt_update_page/linktrn_ld_xmt_status_page    fields in the linktrn frame(s) trasmitterd to LP 0 - allow linktrn_xmt_update_page/linktrn_ld_xmt_status_pagefields in the linktrn frame(s) trasmitterd to LP
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r (0x0001d092 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_s {
	uint32_t v[1];
	uint32_t lnktrnut_ctl0[1];
	uint32_t _lnktrnut_ctl0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_CLR(r) (r).lnktrnut_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_SET(r,d) (r).lnktrnut_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_GET(r) (r).lnktrnut_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_GET(r) ((((r).lnktrnut_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_SET(r,f) (r).lnktrnut_ctl0[0]=(((r).lnktrnut_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_GET(r) ((((r).lnktrnut_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_SET(r,f) (r).lnktrnut_ctl0[0]=(((r).lnktrnut_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_GET(r) ((((r).lnktrnut_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_SET(r,f) (r).lnktrnut_ctl0[0]=(((r).lnktrnut_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_GET(r) (((r).lnktrnut_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_SET(r,f) (r).lnktrnut_ctl0[0]=(((r).lnktrnut_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUT_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r,(_r._lnktrnut_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r,(_r._lnktrnut_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r,(_r._lnktrnut_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r
#define LNKTRNUT_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_t LNKTRNUT_CTL0r_t;
#define LNKTRNUT_CTL0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_CLR
#define LNKTRNUT_CTL0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_SET
#define LNKTRNUT_CTL0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_GET
#define LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_GET
#define LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_IGNORE_XMT_REG_VALUEf_SET
#define LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_GET
#define LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_REMOTE_RX_READYf_SET
#define LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_GET
#define LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_FRAME_LOCKf_SET
#define LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_GET
#define LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r_LINKTRN_SW_RX_TRAINEDf_SET
#define READ_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL0r
#define WRITE_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL0r
#define MODIFY_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL0r
#define READLN_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL0r
#define WRITELN_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL0r
#define WRITEALL_LNKTRNUT_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_CTL1
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd093
 * DEVAD:    1
 * DESC:     linktrn Control 1 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_BRK_RING_OSC PRBS 11 Ring Oscillator control1: No oscillating - low power mode0: Osciallate - normal mode
 *     LINKTRN_DIS_MAX_WAIT_TIMER disable max wait timer1 = max wait timer disabled0 = max wait timer enabled
 *     LINKTRN_TX_DP_LN_CLK_EN linktrn Tx Datapath lane clock enable0 - disabled1 - enabled
 *     LINKTRN_TIMER_VALUE_SEL This bit is used to select the register fields that sets themaximum training time and the number of frames to be sent bythe local device after it has been traininedThis field is normally set while the datapath reset is asserted.This bit is asynchronous to the txcom_* register fields1 = use txcom_linktrn_wait_cntr_limit_2ndset/txcom_linktrn_max_wait_timer_period_2ndset0 = use txcom_linktrn_wait_cntr_limit/txcom_linktrn_max_wait_timer_period
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r (0x0001d093 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_s {
	uint32_t v[1];
	uint32_t lnktrnut_ctl1[1];
	uint32_t _lnktrnut_ctl1;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_CLR(r) (r).lnktrnut_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_SET(r,d) (r).lnktrnut_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_GET(r) (r).lnktrnut_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_GET(r) ((((r).lnktrnut_ctl1[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_SET(r,f) (r).lnktrnut_ctl1[0]=(((r).lnktrnut_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_GET(r) ((((r).lnktrnut_ctl1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_SET(r,f) (r).lnktrnut_ctl1[0]=(((r).lnktrnut_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_GET(r) ((((r).lnktrnut_ctl1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).lnktrnut_ctl1[0]=(((r).lnktrnut_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_GET(r) (((r).lnktrnut_ctl1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_SET(r,f) (r).lnktrnut_ctl1[0]=(((r).lnktrnut_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUT_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r,(_r._lnktrnut_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r,(_r._lnktrnut_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r,(_r._lnktrnut_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r
#define LNKTRNUT_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_t LNKTRNUT_CTL1r_t;
#define LNKTRNUT_CTL1r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_CLR
#define LNKTRNUT_CTL1r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_SET
#define LNKTRNUT_CTL1r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_GET
#define LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_GET
#define LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TIMER_VALUE_SELf_SET
#define LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_GET
#define LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_TX_DP_LN_CLK_ENf_SET
#define LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_GET
#define LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_DIS_MAX_WAIT_TIMERf_SET
#define LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_GET
#define LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r_LINKTRN_BRK_RING_OSCf_SET
#define READ_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL1r
#define WRITE_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL1r
#define MODIFY_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL1r
#define READLN_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL1r
#define WRITELN_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL1r
#define WRITEALL_LNKTRNUT_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_CTL2
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd094
 * DEVAD:    1
 * DESC:     linktrn Control 2 Register
 * RESETVAL: 0x1021 (4129)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_PRBS_MODE_SEL This field is used to select prbs mode00 - cl72 mode. Uses 1 + x9  + x11 prbs polynomial01 - cl93 mode. linktrn_cl93prbs_poly_sel selects the cl93 PRBS polynomial10 - 802.3cd mode. linktrn_prbs13_poly_sel selects the PRBS13 polynomial
 *     LINKTRN_TX_TRN_MODE TX Training mode select0 - cl72/cl93 mode1 - 802.3cd mode
 *     LINKTRN_TX_PAM4_TRN_FRAME_SIZE In 802.3cd mode, TX training frame size select1 - 16672 UI TX training frame0 - 4384 UI TX training frameUI = 2 bits
 *     LINKTRN_PAM4M_SYM_SEL In 802.3cd mode, PRBS pattern symbol (modulation) select0 - PAM2/NRZ symbol (modulation). Each bit of the PRBS training pattern is repeatedto generate NRZ symbols1 - PAM4 symbol (modulation). Two bits of the PRBS training pattern is used to generatethe PAM4 symbols. Gray code and Precoding are disabled by default
 *     LINKTRN_PAM4M_PRECODER_EN In 802.3cd mode, PRBS pattern precoding enable0 - Diabled1 - Enabled
 *     LINKTRN_PAM4_SYMBOL_BIT_SWAP In 802.3cd mode PRBS Symbol bits {A,B} swap enable.Bit swapping is done just before the gray encoder.1 => 2 bits symbol bits will be swapped. Symbol bits {A,B}maps to the datastream bits {[n+1], [n]} where n is the first bitin transmission order.0 => No swapping, default mode. Symbol bits {A,B} maps to thedatastream bits {[n], [n+1]} where n is the first bit in transmission order.
 *     LINKTRN_PAM4M_GRAYCODER_EN_FRC_VAL Please see linktrn_pam4m_graycoder_en_frc
 *     LINKTRN_PAM4M_GRAYCODER_EN_FRC In 802.3cd mode, gray coding for PRBS pattern is::a) Disabled when PAM2/NRZ modulation is usedb) Enabled when PAM4 modulation is usedHowever, graycoding can be forced on/off usinglinktrn_pam4m_graycoder_en_frc and linktrn_pam4m_graycoder_en_frc_val register fields i.e.{linktrn_pam4m_graycoder_en_frc linktrn_pam4m_graycoder_en_frc_val register fields}2'b0x - normal mode2'b10 - force gray coding off2'b11 - force gray coding on
 *     LINKTRN_PAM4M_PRBS_REPL_MODE PRBS bit replication mode during 802.3cd PAM2 modulation0 - disable replication1 - replicate/map even bits from the PRBS generator and discard odd bits2 - replicate/map odd bits from the PRBS generator and discard even bits3 - replicate/map both odd and even bits from the PRBS generator (for Sinai/cl72/cl93 NRZ pattern)
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r (0x0001d094 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_s {
	uint32_t v[1];
	uint32_t lnktrnut_ctl2[1];
	uint32_t _lnktrnut_ctl2;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_CLR(r) (r).lnktrnut_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_SET(r,d) (r).lnktrnut_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_GET(r) (r).lnktrnut_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_GET(r) ((((r).lnktrnut_ctl2[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_GET(r) (((r).lnktrnut_ctl2[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_SET(r,f) (r).lnktrnut_ctl2[0]=(((r).lnktrnut_ctl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access LNKTRNUT_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r,(_r._lnktrnut_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r,(_r._lnktrnut_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r,(_r._lnktrnut_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r
#define LNKTRNUT_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_t LNKTRNUT_CTL2r_t;
#define LNKTRNUT_CTL2r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_CLR
#define LNKTRNUT_CTL2r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_SET
#define LNKTRNUT_CTL2r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRBS_REPL_MODEf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRCf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_GRAYCODER_EN_FRC_VALf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4_SYMBOL_BIT_SWAPf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_PRECODER_ENf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PAM4M_SYM_SELf_SET
#define LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_GET
#define LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_PAM4_TRN_FRAME_SIZEf_SET
#define LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_GET
#define LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_TX_TRN_MODEf_SET
#define LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_GET
#define LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r_LINKTRN_PRBS_MODE_SELf_SET
#define READ_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL2r
#define WRITE_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL2r
#define MODIFY_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL2r
#define READLN_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL2r
#define WRITELN_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL2r
#define WRITEALL_LNKTRNUT_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_CTL3
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd095
 * DEVAD:    1
 * DESC:     linktrn Control 3 Register
 * RESETVAL: 0x1aa0 (6816)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_PRBS13_SEED_VAL prbs13 seed valueThese bits can be used to specify the prbs13 seed valuesPLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE standardsdefines the following default seed values for each lane:Lane 0,4 - 13'h1AA0Lane 1,5 - 13'h105CLane 2,6 - 13'h0689Lane 3,7 - 13'h0822
 *     LINKTRN_PRBS13_POLY_SEL prbs13 polynomial selectThese bits are used to select prbs13 polynomials when prbs_mode_sel field is set to 22'b00:   1 + x  + x2 + x12 + x132'b01:   1 + x2 + x3 + x7  + x132'b10:   1 + x2 + x4 + x8  + x132'b11:   1 + x2 + x5 + x9  + x13PLEASE NOTE:The default value of this register field for each lane is unique.the default values for lanes are:Lane 0,4 - 2'b00Lane 1,5 - 2'b01Lane 2,6 - 2'b10Lane 3,7 - 2'b11
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r (0x0001d095 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_s {
	uint32_t v[1];
	uint32_t lnktrnut_ctl3[1];
	uint32_t _lnktrnut_ctl3;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_CLR(r) (r).lnktrnut_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_SET(r,d) (r).lnktrnut_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_GET(r) (r).lnktrnut_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_GET(r) ((((r).lnktrnut_ctl3[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_SET(r,f) (r).lnktrnut_ctl3[0]=(((r).lnktrnut_ctl3[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_GET(r) (((r).lnktrnut_ctl3[0]) & 0x1fff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_SET(r,f) (r).lnktrnut_ctl3[0]=(((r).lnktrnut_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access LNKTRNUT_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r,(_r._lnktrnut_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r,(_r._lnktrnut_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r,(_r._lnktrnut_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r
#define LNKTRNUT_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_t LNKTRNUT_CTL3r_t;
#define LNKTRNUT_CTL3r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_CLR
#define LNKTRNUT_CTL3r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_SET
#define LNKTRNUT_CTL3r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_GET
#define LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_GET
#define LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_POLY_SELf_SET
#define LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_GET
#define LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r_LINKTRN_PRBS13_SEED_VALf_SET
#define READ_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL3r
#define WRITE_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL3r
#define MODIFY_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL3r
#define READLN_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL3r
#define WRITELN_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL3r
#define WRITEALL_LNKTRNUT_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_STS0
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd096
 * DEVAD:    1
 * DESC:     linktrn Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_LOCAL_RX_READY Set to TRUE (1'b1) by the FSM when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     LINKTRN_TRAINING_FSM_SIGNAL_DETECT 1 - linktrn is in SEND_DATA state0 - linktrn is in training or reset state
 *     LINKTRN_XMT_COEFF_UPDATE_PARITY This fields indicates the parity of the current value of thelinktrn_xmt_update_page register field. This field can beused to adjust the parity of the Coeffcient Update field beforeit is sent to the link partner.0 - even parity - linktrn_xmt_update_page field has even number of 1's1 - odd parity  - linktrn_xmt_update_page field has odd number of 1'slinktrn_ignore_xmt_reg_value can be set to 1 stop the contents oflinktrn_xmt_update_page being sent while parity is being adjusted
 *     LINKTRN_XMT_STATUS_REPORT_PARITY This fields indicates the parity of the current value of thelinktrn_ld_xmt_status_page register field. This field can beused to adjust the parity of the Status page field beforeit is sent to the link partner.0 - even parity - linktrn_ld_xmt_status_page field has even number of 1's1 - odd parity  - linktrn_ld_xmt_status_page field has odd number of 1'slinktrn_ignore_xmt_reg_value can be set to 1 stop the contents oflinktrn_ld_xmt_status_page being sent while parity is being adjusted
 *     LINKTRN_SM_CURRENT_STATE Training State machine current state0 = ST_INITIALIZE1 = ST_SEND_TRAINING2 = ST_TRAIN_LOCAL3 = ST_TRAIN_REMOTE4 = ST_LINK_READY5 = ST_SEND_DATA6 = ST_TRAINING_FAILURE
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r (0x0001d096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_s {
	uint32_t v[1];
	uint32_t lnktrnut_sts0[1];
	uint32_t _lnktrnut_sts0;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_CLR(r) (r).lnktrnut_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_SET(r,d) (r).lnktrnut_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_GET(r) (r).lnktrnut_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET(r) ((((r).lnktrnut_sts0[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET(r) ((((r).lnktrnut_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET(r) ((((r).lnktrnut_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET(r) ((((r).lnktrnut_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET(r) (((r).lnktrnut_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUT_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r
#define LNKTRNUT_STS0r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_t LNKTRNUT_STS0r_t;
#define LNKTRNUT_STS0r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_CLR
#define LNKTRNUT_STS0r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_SET
#define LNKTRNUT_STS0r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_GET
#define LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET
#define LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET
#define LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET
#define LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET
#define LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET
#define LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET
#define LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET
#define LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET
#define LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET
#define LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET
#define READ_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_STS0r
#define WRITE_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_STS0r
#define MODIFY_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_STS0r
#define READLN_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_STS0r
#define WRITELN_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_STS0r
#define WRITEALL_LNKTRNUT_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LNKTRNUT_CTL4
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd097
 * DEVAD:    1
 * DESC:     linktrn Control 4 Register
 * RESETVAL: 0x3f5 (1013)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_PRBS_SEED_VAL prbs seed valueThese bits can be used to specify the cl72/cl93 prbs seed valuesPLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1defines the following default seed values for each lane:Lane 0,4 - 11'h3F5Lane 1,5 - 11'h513Lane 2,6 - 11'h5A7Lane 3,7 - 11'h36F
 *     LINKTRN_CL93PRBS_POLY_SEL cl93 mode prbs polynomial selectThese bits are used to select the following prbs polynomials when prbs_mode_sel field is set to 1'b1:2'b00: 1 + x5 + x6 + x10 + x112'b01: 1 + x5 + x6 + x9  + x112'b10: 1 + x4 + x6 + x8  + x112'b11: 1 + x4 + x6 + x7  + x11PLEASE NOTE:The default value of this register field is unique for each lane. The IEEE P802.3bj-2014defines the following default seed values for each lane:Lane 0,4 - 2'b00Lane 1,5 - 2'b01Lane 2,6 - 2'b10Lane 3,7 - 2'b11
 *     LINKTRN_PRBS_SEED_SEL These bits used to select the seed for prbs generator during the training sequence:2'b00 - cl72 mode - random seed every frame, cl93 mode - seed specified by the linktrn_prbs_seed_val field802.3cd mode - seed specified by the linktrn_prbs13_seed_val field2'b01 - random seed every frame2'b10 - random seed first frame only and then same seed every frame2'b11 - seed specified by the linktrn_prbs_seed_val and/or linktrn_prbs13_seed_val fields
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r (0x0001d097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_s {
	uint32_t v[1];
	uint32_t lnktrnut_ctl4[1];
	uint32_t _lnktrnut_ctl4;
} BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_CLR(r) (r).lnktrnut_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_SET(r,d) (r).lnktrnut_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_GET(r) (r).lnktrnut_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_GET(r) ((((r).lnktrnut_ctl4[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_SET(r,f) (r).lnktrnut_ctl4[0]=(((r).lnktrnut_ctl4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_GET(r) ((((r).lnktrnut_ctl4[0]) >> 11) & 0x3)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_SET(r,f) (r).lnktrnut_ctl4[0]=(((r).lnktrnut_ctl4[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_GET(r) (((r).lnktrnut_ctl4[0]) & 0x7ff)
#define BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_SET(r,f) (r).lnktrnut_ctl4[0]=(((r).lnktrnut_ctl4[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access LNKTRNUT_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r,(_r._lnktrnut_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r,(_r._lnktrnut_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r,(_r._lnktrnut_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r
#define LNKTRNUT_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_t LNKTRNUT_CTL4r_t;
#define LNKTRNUT_CTL4r_CLR BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_CLR
#define LNKTRNUT_CTL4r_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_SET
#define LNKTRNUT_CTL4r_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_GET
#define LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_GET
#define LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_SELf_SET
#define LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_GET
#define LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_CL93PRBS_POLY_SELf_SET
#define LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_GET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_GET
#define LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_SET BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r_LINKTRN_PRBS_SEED_VALf_SET
#define READ_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_READ_LNKTRNUT_CTL4r
#define WRITE_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_LNKTRNUT_CTL4r
#define MODIFY_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_LNKTRNUT_CTL4r
#define READLN_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_READLN_LNKTRNUT_CTL4r
#define WRITELN_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_LNKTRNUT_CTL4r
#define WRITEALL_LNKTRNUT_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_LNKTRNUT_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LNKTRNUT_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL0
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a0
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 0
 * RESETVAL: 0x7000 (28672)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.3'd0 - 110 KHz3'd1 - 220 KHz3'd2 - 440 KHz3'd3 - 880 KHz3'd4 - 1.7 MHz>= 3'd5 is unused and reserved for future use.
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 7.
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r (0x0001d0a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl0[1];
	uint32_t _tx_pi_ctl0;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_CLR(r) (r).tx_pi_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_SET(r,d) (r).tx_pi_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_GET(r) (r).tx_pi_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 7) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r
#define TX_PI_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_t TX_PI_CTL0r_t;
#define TX_PI_CTL0r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_CLR
#define TX_PI_CTL0r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_SET
#define TX_PI_CTL0r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_CTL0r_TX_PI_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET
#define TX_PI_CTL0r_TX_PI_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL0r
#define WRITE_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL0r
#define MODIFY_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL0r
#define READLN_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL0r
#define WRITELN_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL0r
#define WRITEALL_TX_PI_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL1
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a1
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r (0x0001d0a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl1[1];
	uint32_t _tx_pi_ctl1;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_CLR(r) (r).tx_pi_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_SET(r,d) (r).tx_pi_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_GET(r) (r).tx_pi_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_ctl1[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_ctl1[0]=(((r).tx_pi_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r
#define TX_PI_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_t TX_PI_CTL1r_t;
#define TX_PI_CTL1r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_CLR
#define TX_PI_CTL1r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_SET
#define TX_PI_CTL1r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL1r
#define WRITE_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL1r
#define MODIFY_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL1r
#define READLN_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL1r
#define WRITELN_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL1r
#define WRITEALL_TX_PI_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL2
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a2
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r (0x0001d0a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl2[1];
	uint32_t _tx_pi_ctl2;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_CLR(r) (r).tx_pi_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_SET(r,d) (r).tx_pi_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_GET(r) (r).tx_pi_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_ctl2[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_ctl2[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r
#define TX_PI_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_t TX_PI_CTL2r_t;
#define TX_PI_CTL2r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_CLR
#define TX_PI_CTL2r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_SET
#define TX_PI_CTL2r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL2r
#define WRITE_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL2r
#define MODIFY_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL2r
#define READLN_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL2r
#define WRITELN_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL2r
#define WRITEALL_TX_PI_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL3
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a3
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 3
 * RESETVAL: 0x100 (256)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_PHASE_OVERRIDE Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode.
 *     TX_PI_PHASE_STROBE Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr is 1'b1.If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase steps from the IIR filter.Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift.
 *     TX_PI_PHASE_STEP_DIR Manual Phase Step direction.1'b0: Increment1'b1: Decrement
 *     TX_PI_PHASE_INVERT 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic.
 *     TX_PI_PHASE_STEP_NUM Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r (0x0001d0a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl3[1];
	uint32_t _tx_pi_ctl3;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_CLR(r) (r).tx_pi_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_SET(r,d) (r).tx_pi_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_GET(r) (r).tx_pi_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET(r) ((((r).tx_pi_ctl3[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_pi_ctl3[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_pi_ctl3[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_pi_ctl3[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET(r) (((r).tx_pi_ctl3[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r
#define TX_PI_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_t TX_PI_CTL3r_t;
#define TX_PI_CTL3r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_CLR
#define TX_PI_CTL3r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_SET
#define TX_PI_CTL3r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET
#define READ_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL3r
#define WRITE_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL3r
#define MODIFY_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL3r
#define READLN_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL3r
#define WRITELN_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL3r
#define WRITEALL_TX_PI_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL4
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a4
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 4
 * RESETVAL: 0x704 (1796)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FRZ_FRC    IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation.
 *     TX_PI_FRZ_FRC_VAL Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation.
 *     TX_PI_FRZ_MODE   Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *     TX_PI_RESET_CODE_DBG Debug register.Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI.
 *     TX_PI_FRZ_MODE_S1 Freeze Mode. 1'b1 will freeze the integ2 reg for the first stage fliter so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value. tx_pi_frz_mode should be 0 when this bit is enabled.1'b1 will freeze the integ2 reg  for the first stage fliter so that during the freeze, TX PI will generate the phase steps based on the integ2_s1 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *     TX_PI_SAMPLER_MAX_CNT This register defines the sampling of the phase_sum_val from the CDR by TX_PI. There is a local counter running with TX_PI clock (i.e. tclk) which counts from 0 to tx_pi_sample_max_cnt.This register value should be pragrammed such that (tx_pi_sample_max_cnt+1)*N cycles of tclk equals the phase_sum_val_toggle period. N should be >=1 and the smallest number.Supported values are from 7 to 15. Do not program values less than 7.Programming examples are as below for widely used modes.----------------------------------------------------------------------------------------------------------------------------------------------------------------------------phase_sum_val_toggle period in tclk terms   tx_pi_sample_max_cnt  comments----------------------------------------------------------------------------------------------------------------------------------------------------------------------------8                                     7               default mode used in remote loopback and repeater application between same kind of PMD cores and same data rate.10 or 20                               916 or 32                              15  (or 7)40                                     9  (or 7)
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r (0x0001d0a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl4[1];
	uint32_t _tx_pi_ctl4;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_CLR(r) (r).tx_pi_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_SET(r,d) (r).tx_pi_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_GET(r) (r).tx_pi_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_GET(r) ((((r).tx_pi_ctl4[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_GET(r) ((((r).tx_pi_ctl4[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET(r) ((((r).tx_pi_ctl4[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET(r) ((((r).tx_pi_ctl4[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET(r) ((((r).tx_pi_ctl4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET(r) (((r).tx_pi_ctl4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r
#define TX_PI_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_t TX_PI_CTL4r_t;
#define TX_PI_CTL4r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_CLR
#define TX_PI_CTL4r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_SET
#define TX_PI_CTL4r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_GET
#define TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_GET
#define TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_SAMPLER_MAX_CNTf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODE_S1f_SET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET
#define READ_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL4r
#define WRITE_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL4r
#define MODIFY_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL4r
#define READLN_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL4r
#define WRITELN_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL4r
#define WRITEALL_TX_PI_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_CTL5
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a5
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 5
 * RESETVAL: 0x84 (132)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR_INVERT 1'b1: Inverts the hs_fifo_phserr[4:0] to invert the meaning of inc/dec from hs_fifo_phserr[4:0]. When this bit is 1'b0, 1'b1 is increment and 1'b0 is decrement.
 *     TX_PI_REPEATER_MODE_EN Selects the source of the Loop Timing CDR and Phase Detector inc/dec information.1'b1: Select external CDR and hs_fifo_phserr[4:0] from the high speed Phase FIFO PD inside AFE for ultra-low latency path.1'b0: selects the internal CDR and inc/dec from the Remote Loopback Phase Detector.
 *     TX_PI_EXT_PD_SEL Selects the source of the Phase Detector inc/dec information.1'b1: Select external PD path irrespective of rg_tx_pi_repeater_mode_en1'b0: Select PD path based on rg_tx_pi_repeater_mode_en
 *     TX_PI_HS_FIFO_PHSERR_SEL Selects the source of the Phase Detector inc/dec information. tx_pi_ext_pd_sel has higher priority so it should be 1'b0 for tx_pi_hs_fifo_phserr_sel to select.1'b1: hs_fifo_phserr[4] from the PD inside AFE for ultra-low latency path or TCA irrespective of rg_tx_pi_repeater_mode_en.1'b0: Select PD path based on rg_tx_pi_repeater_mode_en.
 *     TX_PI_EXT_PHASE_STEP_CNT_INVERT 1'b1 : invert pmd_tx_pi_ext_phase_step_cnt such that -x will become +x and vice-versa and 0 will remain 0.It is only valid when tx_pi_ext_phase_step_cnt_sel OR tx_pi_ext_pd_sel bits are 1'b1.
 *     TX_PI_EXT_PHASE_STEP_CNT_SEL 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec complete bypass mux .If tx_pi_jitter_filter_en OR tx_pi_freq_override_en OR tx_pi_ext_ctrl_en reg fields are enabled then final mux will automatically switch to the normal tx_pi modeas if tx_pi_ext_phase_step_cnt_sel is 1'b0. Once all these fields are cleared then it will switch back to the pmd_tx_pi_ext_pd_inc/dec pin control mode if tx_pi_ext_phase_step_cnt_sel is 1.
 *     TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASS 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec full bypass mux . Only have effect when tx_pi_ext_phase_step_cnt_sel = 1.1'b0 : pmd_tx_pi_ext_phase_step_cnt will go through the dsm2 filter
 *     AFE_TX_FIFO_RESETB 1'b0: will assert the reset pin tx_fifo_resetb to 1'b0.1'b1: Once this bit is written to 1'b1 then phase error (bit 4) from FIFO is looked for 2 transitions and then reset is de-asserted to the Phase FIFO.
 *     AFE_TX_FIFO_RESETB_FRC 1'b0: Normal mode where reset pin tx_fifo_resetb is controlled as per the description of the register afe_tx_fifo_resetb.1'b1: force the reset pin tx_fifo_resetb to value indicated in the register afe_tx_fifo_resetb.
 *     TX_PI_PD_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from all sources to get a quicker phase locking time.
 *     TX_PI_PD_BYPASS_VCO 1'b1 will enable filter and vco bypass for inc/dec indication from all sources to get a quicker phase locking time.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r (0x0001d0a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl5[1];
	uint32_t _tx_pi_ctl5;
} BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_CLR(r) (r).tx_pi_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_SET(r,d) (r).tx_pi_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_GET(r) (r).tx_pi_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET(r) ((((r).tx_pi_ctl5[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET(r) ((((r).tx_pi_ctl5[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_ctl5[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET(r) ((((r).tx_pi_ctl5[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET(r) ((((r).tx_pi_ctl5[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TX_PI_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r
#define TX_PI_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_t TX_PI_CTL5r_t;
#define TX_PI_CTL5r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_CLR
#define TX_PI_CTL5r_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_SET
#define TX_PI_CTL5r_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET
#define READ_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_READ_TX_PI_CTL5r
#define WRITE_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_CTL5r
#define MODIFY_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_CTL5r
#define READLN_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_CTL5r
#define WRITELN_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_CTL5r
#define WRITEALL_TX_PI_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS0
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a8
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_CNTR TX PI Phase Counter. Signed Value.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r (0x0001d0a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts0[1];
	uint32_t _tx_pi_sts0;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_CLR(r) (r).tx_pi_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_SET(r,d) (r).tx_pi_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_GET(r) (r).tx_pi_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_pi_sts0[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_pi_sts0[0]=(((r).tx_pi_sts0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_PI_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS0r BCMI_BLACKHAWK_XGXS_TX_PI_STS0r
#define TX_PI_STS0r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_t TX_PI_STS0r_t;
#define TX_PI_STS0r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_CLR
#define TX_PI_STS0r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_SET
#define TX_PI_STS0r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS0r
#define WRITE_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS0r
#define MODIFY_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS0r
#define READLN_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS0r
#define WRITELN_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS0r
#define WRITEALL_TX_PI_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS1
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a9
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.This field is meant for internal debug only.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r (0x0001d0a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts1[1];
	uint32_t _tx_pi_sts1;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_CLR(r) (r).tx_pi_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_SET(r,d) (r).tx_pi_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_GET(r) (r).tx_pi_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_sts1[0]) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_sts1[0]=(((r).tx_pi_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_PI_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS1r BCMI_BLACKHAWK_XGXS_TX_PI_STS1r
#define TX_PI_STS1r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_t TX_PI_STS1r_t;
#define TX_PI_STS1r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_CLR
#define TX_PI_STS1r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_SET
#define TX_PI_STS1r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS1r
#define WRITE_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS1r
#define MODIFY_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS1r
#define READLN_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS1r
#define WRITELN_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS1r
#define WRITEALL_TX_PI_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS2
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0aa
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.Divide this register value by 10.485 to get the tclk ppm.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r (0x0001d0aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts2[1];
	uint32_t _tx_pi_sts2;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_CLR(r) (r).tx_pi_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_SET(r,d) (r).tx_pi_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_GET(r) (r).tx_pi_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_sts2[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_sts2[0]=(((r).tx_pi_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS2r BCMI_BLACKHAWK_XGXS_TX_PI_STS2r
#define TX_PI_STS2r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_t TX_PI_STS2r_t;
#define TX_PI_STS2r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_CLR
#define TX_PI_STS2r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_SET
#define TX_PI_STS2r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS2r
#define WRITE_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS2r
#define MODIFY_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS2r
#define READLN_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS2r
#define WRITELN_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS2r
#define WRITEALL_TX_PI_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS3
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0ab
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_ERR  TX PI Phase Error. Signed Value. Valid values are -8 to +8.
 *     TX_PI_PHASE_ERR_S1 TX PI Phase Error for the first stage jitter filter. Signed Value. Valid values are -8 to +8.
 *     TX_PI_PHASE_SUM_CAPTURE_RESYNC_LH Debug latch high status bit to indicate when phase_sum_val transfer to tclk domain mechanism is resynced. It is clear upon read status.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r (0x0001d0ab | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts3[1];
	uint32_t _tx_pi_sts3;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_CLR(r) (r).tx_pi_sts3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_SET(r,d) (r).tx_pi_sts3[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_GET(r) (r).tx_pi_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_GET(r) ((((r).tx_pi_sts3[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_GET(r) ((((r).tx_pi_sts3[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET(r) (((r).tx_pi_sts3[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_STS3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS3r BCMI_BLACKHAWK_XGXS_TX_PI_STS3r
#define TX_PI_STS3r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_t TX_PI_STS3r_t;
#define TX_PI_STS3r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_CLR
#define TX_PI_STS3r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_SET
#define TX_PI_STS3r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_GET
#define TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_GET
#define TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_SUM_CAPTURE_RESYNC_LHf_SET
#define TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERR_S1f_SET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET
#define READ_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS3r
#define WRITE_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS3r
#define MODIFY_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS3r
#define READLN_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS3r
#define WRITELN_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS3r
#define WRITEALL_TX_PI_STS3r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS4
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0ac
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR Bit 4 of hs_fifo_pherr.
 *     ST_AFE_TX_FIFO_RESETB Status of the final afe_tx_fifo_resetb signal connected to the AFE pin.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r (0x0001d0ac | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts4[1];
	uint32_t _tx_pi_sts4;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_CLR(r) (r).tx_pi_sts4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_SET(r,d) (r).tx_pi_sts4[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_GET(r) (r).tx_pi_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_sts4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET(r) (((r).tx_pi_sts4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_STS4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS4r BCMI_BLACKHAWK_XGXS_TX_PI_STS4r
#define TX_PI_STS4r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_t TX_PI_STS4r_t;
#define TX_PI_STS4r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_CLR
#define TX_PI_STS4r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_SET
#define TX_PI_STS4r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET
#define READ_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS4r
#define WRITE_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS4r
#define MODIFY_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS4r
#define READLN_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS4r
#define WRITELN_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS4r
#define WRITEALL_TX_PI_STS4r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_TX_FIFO_OVFB_STS
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0ad
 * DEVAD:    1
 * DESC:     TX FIFO Overflow Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_FIFO_OVFB     Indiactes live status of the tx_fifo_ovfb signal from AFE/High Speed Phase FIFO.
 *     TX_FIFO_OVFB_FALL_EDGE_LH lathc high indication for 1 -> 0 transition on tx_fifo_ovfb signal from AFE/High Speed Phase FIFO. This is clear on read status.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr (0x0001d0ad | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_TX_FIFO_OVFB_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_s {
	uint32_t v[1];
	uint32_t tx_pi_tx_fifo_ovfb_sts[1];
	uint32_t _tx_pi_tx_fifo_ovfb_sts;
} BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_CLR(r) (r).tx_pi_tx_fifo_ovfb_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SET(r,d) (r).tx_pi_tx_fifo_ovfb_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_GET(r) (r).tx_pi_tx_fifo_ovfb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET(r) ((((r).tx_pi_tx_fifo_ovfb_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET(r) (((r).tx_pi_tx_fifo_ovfb_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_TX_FIFO_OVFB_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_TX_FIFO_OVFB_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_TX_FIFO_OVFB_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_tx_fifo_ovfb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr
#define TX_PI_TX_FIFO_OVFB_STSr_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_t TX_PI_TX_FIFO_OVFB_STSr_t;
#define TX_PI_TX_FIFO_OVFB_STSr_CLR BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_CLR
#define TX_PI_TX_FIFO_OVFB_STSr_SET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SET
#define TX_PI_TX_FIFO_OVFB_STSr_GET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET
#define READ_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_READ_TX_PI_TX_FIFO_OVFB_STSr
#define WRITE_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_TX_FIFO_OVFB_STSr
#define MODIFY_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_TX_FIFO_OVFB_STSr
#define READLN_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_READLN_TX_PI_TX_FIFO_OVFB_STSr
#define WRITELN_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_TX_FIFO_OVFB_STSr
#define WRITEALL_TX_PI_TX_FIFO_OVFB_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_TX_FIFO_OVFB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_TX_FIFO_OVFB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_STS5
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0ae
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG_S1 TX PI integ2 register for the First Stage (s1 refers to first stage) jitter filter. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.Divide this register value by 10.485 to get the tclk ppm.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r (0x0001d0ae | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts5[1];
	uint32_t _tx_pi_sts5;
} BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_CLR(r) (r).tx_pi_sts5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_SET(r,d) (r).tx_pi_sts5[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_GET(r) (r).tx_pi_sts5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_GET(r) (((r).tx_pi_sts5[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_SET(r,f) (r).tx_pi_sts5[0]=(((r).tx_pi_sts5[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_STS5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r,(_r._tx_pi_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r,(_r._tx_pi_sts5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r,(_r._tx_pi_sts5))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_STS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS5r BCMI_BLACKHAWK_XGXS_TX_PI_STS5r
#define TX_PI_STS5r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_t TX_PI_STS5r_t;
#define TX_PI_STS5r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_CLR
#define TX_PI_STS5r_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_SET
#define TX_PI_STS5r_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_GET
#define TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_GET
#define TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_STS5r_TX_PI_INTEG2_REG_S1f_SET
#define READ_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_READ_TX_PI_STS5r
#define WRITE_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_STS5r
#define MODIFY_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_STS5r
#define READLN_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_STS5r
#define WRITELN_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_STS5r
#define WRITEALL_TX_PI_STS5r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_STS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_STS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b0
 * DEVAD:    1
 * DESC:     RXTXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     PAM4_MODE_FRC    PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode
 *     OSR_MODE_FRC     NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr (0x0001d0b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_ctl[1];
	uint32_t _rxtxcom_osr_mode_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR(r) (r).rxtxcom_osr_mode_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxtxcom_osr_mode_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_GET(r) (r).rxtxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET(r) (((r).rxtxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr
#define RXTXCOM_OSR_MODE_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_t RXTXCOM_OSR_MODE_CTLr_t;
#define RXTXCOM_OSR_MODE_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR
#define RXTXCOM_OSR_MODE_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_SET
#define RXTXCOM_OSR_MODE_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET
#define READ_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_OSR_MODE_CTLr
#define WRITE_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr
#define MODIFY_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr
#define READLN_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr
#define WRITELN_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr
#define WRITEALL_RXTXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b1
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_S_RSTB     Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d0b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxtxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET(r) (((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET(r,f) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET
#define READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b3
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d0b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET(r) ((((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET(r) (((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET
#define READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b5
 * DEVAD:    1
 * DESC:     RXTXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr (0x0001d0b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_uc_ack_ln_ctl[1];
	uint32_t _rxtxcom_uc_ack_ln_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxtxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxtxcom_uc_ack_ln_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxtxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxtxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxtxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr
#define RXTXCOM_UC_ACK_LN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t RXTXCOM_UC_ACK_LN_CTLr_t;
#define RXTXCOM_UC_ACK_LN_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR
#define RXTXCOM_UC_ACK_LN_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET
#define RXTXCOM_UC_ACK_LN_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr
#define WRITE_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr
#define READLN_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXTXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b6
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr (0x0001d0b6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_occ_ctl[1];
	uint32_t _rxtxcom_ln_rst_occ_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxtxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxtxcom_ln_rst_occ_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxtxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxtxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxtxcom_ln_rst_occ_ctl[0]=(((r).rxtxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr
#define RXTXCOM_LN_RST_OCC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t RXTXCOM_LN_RST_OCC_CTLr_t;
#define RXTXCOM_LN_RST_OCC_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR
#define RXTXCOM_LN_RST_OCC_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET
#define RXTXCOM_LN_RST_OCC_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr
#define WRITE_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr
#define READLN_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXTXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_PLL_SEL_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b7
 * DEVAD:    1
 * DESC:     RXTXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_SELECT       This register controls the selection of the PLL0 or PLL1 as clock source for the  lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when  lane datapath is in reset.0 - Select PLL0 as clock for  lane.1 - Select PLL1 as clock for  lane.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr (0x0001d0b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_pll_sel_ctl[1];
	uint32_t _rxtxcom_pll_sel_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_CLR(r) (r).rxtxcom_pll_sel_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_SET(r,d) (r).rxtxcom_pll_sel_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_GET(r) (r).rxtxcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET(r) (((r).rxtxcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET(r,f) (r).rxtxcom_pll_sel_ctl[0]=(((r).rxtxcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_PLL_SEL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr
#define RXTXCOM_PLL_SEL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_t RXTXCOM_PLL_SEL_CTLr_t;
#define RXTXCOM_PLL_SEL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_CLR
#define RXTXCOM_PLL_SEL_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_SET
#define RXTXCOM_PLL_SEL_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_GET
#define RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET
#define RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET
#define READ_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_PLL_SEL_CTLr
#define WRITE_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_PLL_SEL_CTLr
#define MODIFY_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_PLL_SEL_CTLr
#define READLN_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_PLL_SEL_CTLr
#define WRITELN_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_PLL_SEL_CTLr
#define WRITEALL_RXTXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b9
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr (0x0001d0b9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxtxcom_ln_dp_rst_st_sts;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxtxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxtxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxtxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET(r) (((r).rxtxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET(r,f) (r).rxtxcom_ln_dp_rst_st_sts[0]=(((r).rxtxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr
#define RXTXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t RXTXCOM_LN_DP_RST_ST_STSr_t;
#define RXTXCOM_LN_DP_RST_ST_STSr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR
#define RXTXCOM_LN_DP_RST_ST_STSr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET
#define RXTXCOM_LN_DP_RST_ST_STSr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET
#define READ_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr
#define READLN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_MCST_MASK_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0ba
 * DEVAD:    1
 * DESC:     RXTXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr (0x0001d0ba | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_mcst_mask_ctl[1];
	uint32_t _rxtxcom_mcst_mask_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR(r) (r).rxtxcom_mcst_mask_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxtxcom_mcst_mask_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_GET(r) (r).rxtxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxtxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxtxcom_mcst_mask_ctl[0]=(((r).rxtxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_MCST_MASK_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr
#define RXTXCOM_MCST_MASK_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_t RXTXCOM_MCST_MASK_CTLr_t;
#define RXTXCOM_MCST_MASK_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR
#define RXTXCOM_MCST_MASK_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_SET
#define RXTXCOM_MCST_MASK_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET
#define READ_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_MCST_MASK_CTLr
#define WRITE_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr
#define MODIFY_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr
#define READLN_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr
#define WRITELN_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr
#define WRITEALL_RXTXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0bb
 * DEVAD:    1
 * DESC:     RXTXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE         OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     PAM4_MODE        PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr (0x0001d0bb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxtxcom_osr_mode_sts_mc_mask;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxtxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxtxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxtxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxtxcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET(r) ((((r).rxtxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET(r) (((r).rxtxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t RXTXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET
#define READ_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0bc
 * DEVAD:    1
 * DESC:     RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE_PIN     Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     PAM4_MODE_PIN    Indicates the status of the pmd_pam4_mode input pin.Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d0bc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_GET(r) ((((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_SET(r,f) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET(r) (((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET(r,f) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_GET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_PAM4_MODE_PINf_SET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET
#define READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXTXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0be
 * DEVAD:    1
 * DESC:     RXTXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once reset register/pin conditions are de-asserted.This register bit is unused in RX lane.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr (0x0001d0be | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_s_rstb_ctl[1];
	uint32_t _rxtxcom_ln_s_rstb_ctl;
} BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxtxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxtxcom_ln_s_rstb_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxtxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).rxtxcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).rxtxcom_ln_s_rstb_ctl[0]=(((r).rxtxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).rxtxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).rxtxcom_ln_s_rstb_ctl[0]=(((r).rxtxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr
#define RXTXCOM_LN_S_RSTB_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t RXTXCOM_LN_S_RSTB_CTLr_t;
#define RXTXCOM_LN_S_RSTB_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR
#define RXTXCOM_LN_S_RSTB_CTLr_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET
#define RXTXCOM_LN_S_RSTB_CTLr_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET
#define RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET
#define RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr
#define WRITE_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr
#define READLN_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXTXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXTXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL0
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c0
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_0
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MASTER_DIODES_IBIAS master diodes ibias (max, mode, min) amsbus ctrl_out  2:0DFT_MUX
 *     AMS_RX_SIGDET_THRESHOLD NA. Please use afe_sigdet_thresh from sigdet module. amsbus ctrl_out  5:3
 *     AMS_RX_SIGDET_PWRDN default=0 for enable signal detector amsbus ctrl_out  6:6DFT_MUX
 *     AMS_RX_RXCLK66_EN enables 66T clock amsbus ctrl_out  7:7DFT_MUX
 *     AMS_RX_TPORT_EN  output rx_rclk20 to PLL test port amsbus ctrl_out  8:8DFT_MUX
 *     AMS_RX_VGA_10G_BW reduces the the VGA BW for 10G mode. Also see rx_ctrl[111:108] amsbus ctrl_out  9:9
 *     AMS_RX_EQ_LZ_EN  enables lower freq EQ peaking used in 10G mode, both bits [10:9] must be asserted for the complete 10G mode amsbus ctrl_out  10:10
 *     AMS_RX_DFE_HGAIN_EN enables high, fixed gain for the DFE summer and buffer and non-DFE modes. amsbus ctrl_out  11:11
 *     AMS_RX_DC_COUPLE for QSGMII DC mode with 50 Ohm pull-up to RVDD0P8 amsbus ctrl_out  12:12DFT_DFS=1'b0
 *     AMS_RX_PEAKING_FILTER_IBIAS peaking filter ibias (max, mode, min) amsbus ctrl_out  15:13
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r (0x0001d0c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl0[1];
	uint32_t _ams_rx_rx_ctl0;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_CLR(r) (r).ams_rx_rx_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_SET(r,d) (r).ams_rx_rx_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_GET(r) (r).ams_rx_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 13) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 3) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET(r) (((r).ams_rx_rx_ctl0[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r,(_r._ams_rx_rx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r,(_r._ams_rx_rx_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r,(_r._ams_rx_rx_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r
#define AMS_RX_RX_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_t AMS_RX_RX_CTL0r_t;
#define AMS_RX_RX_CTL0r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_CLR
#define AMS_RX_RX_CTL0r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_SET
#define AMS_RX_RX_CTL0r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_GET
#define AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_RXCLK66_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET
#define READ_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL0r
#define WRITE_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL0r
#define MODIFY_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL0r
#define READLN_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL0r
#define WRITELN_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL0r
#define WRITEALL_AMS_RX_RX_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL1
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c1
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_BYPASS_AC_CAP test mode to bypass the internal AC cap to measure the internal DC voltages. Not intended for normal operation with data traffic. amsbus ctrl_out  16:16DFT_MUX
 *     AMS_RX_VGA0_IBIAS VGA0 ibias (max, mode, min) amsbus ctrl_out  19:17
 *     AMS_RX_VGA1_IBIAS VGA1 ibias (max, mode, min) amsbus ctrl_out  22:20
 *     AMS_RX_VGA2_IBIAS VGA2 ibias (max, mode, min) amsbus ctrl_out  25:23
 *     AMS_RX_PF3_IBIAS pf3_ibias (max, mode, min) amsbus ctrl_out  28:26
 *     AMS_RX_CM_VOLTAGE_IBIAS input CM voltage ibias (max, mode, min) amsbus ctrl_out  31:29DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r (0x0001d0c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl1[1];
	uint32_t _ams_rx_rx_ctl1;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_CLR(r) (r).ams_rx_rx_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_SET(r,d) (r).ams_rx_rx_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_GET(r) (r).ams_rx_rx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 13) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 10) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 7) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 1) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_GET(r) (((r).ams_rx_rx_ctl1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r,(_r._ams_rx_rx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r,(_r._ams_rx_rx_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r,(_r._ams_rx_rx_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r
#define AMS_RX_RX_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_t AMS_RX_RX_CTL1r_t;
#define AMS_RX_RX_CTL1r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_CLR
#define AMS_RX_RX_CTL1r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_SET
#define AMS_RX_RX_CTL1r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_GET
#define AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_PF3_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r_AMS_RX_BYPASS_AC_CAPf_SET
#define READ_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL1r
#define WRITE_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL1r
#define MODIFY_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL1r
#define READLN_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL1r
#define WRITELN_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL1r
#define WRITEALL_AMS_RX_RX_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL2
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c2
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_2
 * RESETVAL: 0xe00 (3584)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_SIGDET_IBIAS signal detect ibias (max, mode, min) amsbus ctrl_out  34:32
 *     AMS_RX_PHASE_INTERPOLATORS_IBIAS phase interpolators ibias (max, mode, min) amsbus ctrl_out  37:35DFT_MUX
 *     AMS_RX_DFE_TAP_WEIGHT_IBIAS DFE tap weight ibias (max, mode, min) amsbus ctrl_out  40:38
 *     AMS_RX_DFESUM_BW set BW of DFE summer stage, 00 = <15G, 01 = 15-20G, 10 = 20-25G, 11 = >25G amsbus ctrl_out  42:41
 *     AMS_RX_SEL_TH4DFE DFE tap threshold voltage 00=12mW, 01=150mV, 10=175mV, 11=200mV amsbus ctrl_out  44:43
 *     AMS_RX_PD_CH_P1  power down the p1, aka lms, channel, reduces power by ~10mW amsbus ctrl_out  45:45
 *     AMS_RX_VGA3_IND  adjusts the inductor value for VGA3 amsbus ctrl_out  46:46
 *     AMS_RX_PWRDN_FTAP power down for the DFE floating taps, use for 25G-SR and all OS2 and OS4 modes, ~-1mW amsbus ctrl_out  47:47
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r (0x0001d0c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl2[1];
	uint32_t _ams_rx_rx_ctl2;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_CLR(r) (r).ams_rx_rx_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_SET(r,d) (r).ams_rx_rx_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_GET(r) (r).ams_rx_rx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 11) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 9) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 6) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 3) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET(r) (((r).ams_rx_rx_ctl2[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r,(_r._ams_rx_rx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r,(_r._ams_rx_rx_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r,(_r._ams_rx_rx_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r
#define AMS_RX_RX_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_t AMS_RX_RX_CTL2r_t;
#define AMS_RX_RX_CTL2r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_CLR
#define AMS_RX_RX_CTL2r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_SET
#define AMS_RX_RX_CTL2r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_VGA3_INDf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFESUM_BWf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET
#define READ_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL2r
#define WRITE_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL2r
#define MODIFY_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL2r
#define READLN_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL2r
#define WRITELN_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL2r
#define WRITEALL_AMS_RX_RX_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL3
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c3
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MET_R_IBIAS met R ibias (max, mode, min), threshold voltage ladder amsbus ctrl_out  50:48
 *     AMS_RX_DLL_IBIAS DLL ibias (max, mode, min), clkgen for 4-phase div and mux amsbus ctrl_out  53:51DFT_MUX
 *     AMS_RX_OFFSET_CORRECTION_IBIAS offset correction ibias (max, mode, min) amsbus ctrl_out  56:54
 *     AMS_RX_DFE_SUM_BUF_IBIAS DFE sum/buf ibias (max, mode, min) amsbus ctrl_out  59:57
 *     AMS_RX_DFE_SLICER_IBIAS dfe_slicer_ibias (max, mode, min), only mux/latch amsbus ctrl_out  62:60
 *     AMS_RX_FFE_ENABLE ffe enable, is non-sampled, continuous mode with FFE clocks off amsbus ctrl_out  63:63
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r (0x0001d0c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl3[1];
	uint32_t _ams_rx_rx_ctl3;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_CLR(r) (r).ams_rx_rx_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_SET(r,d) (r).ams_rx_rx_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_GET(r) (r).ams_rx_rx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 9) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 6) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 3) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET(r) (((r).ams_rx_rx_ctl3[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r,(_r._ams_rx_rx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r,(_r._ams_rx_rx_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r,(_r._ams_rx_rx_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r
#define AMS_RX_RX_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_t AMS_RX_RX_CTL3r_t;
#define AMS_RX_RX_CTL3r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_CLR
#define AMS_RX_RX_CTL3r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_SET
#define AMS_RX_RX_CTL3r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_GET
#define AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_FFE_ENABLEf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET
#define READ_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL3r
#define WRITE_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL3r
#define MODIFY_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL3r
#define READLN_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL3r
#define WRITELN_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL3r
#define WRITEALL_AMS_RX_RX_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL4
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c4
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_FFE_SUMMER_TAP_IBIAS FFE tap weight bias, 3P1CcaIR (max, mode, min) amsbus ctrl_out  66:64
 *     AMS_RX_FFE_SHA_IBIAS FFE sample and hold bias, BGR (max, mode, min) amsbus ctrl_out  69:67
 *     AMS_RX_VGA0_RESCAL_MUX VGA0 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  74:70
 *     AMS_RX_VGA1_RESCAL_MUX VGA1 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  79:75
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r (0x0001d0c4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl4[1];
	uint32_t _ams_rx_rx_ctl4;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_CLR(r) (r).ams_rx_rx_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_SET(r,d) (r).ams_rx_rx_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_GET(r) (r).ams_rx_rx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 3) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_GET(r) (((r).ams_rx_rx_ctl4[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r,(_r._ams_rx_rx_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r,(_r._ams_rx_rx_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r,(_r._ams_rx_rx_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r
#define AMS_RX_RX_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_t AMS_RX_RX_CTL4r_t;
#define AMS_RX_RX_CTL4r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_CLR
#define AMS_RX_RX_CTL4r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_SET
#define AMS_RX_RX_CTL4r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SHA_IBIASf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r_AMS_RX_FFE_SUMMER_TAP_IBIASf_SET
#define READ_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL4r
#define WRITE_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL4r
#define MODIFY_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL4r
#define READLN_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL4r
#define WRITELN_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL4r
#define WRITEALL_AMS_RX_RX_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL5
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c5
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_VGA2_RESCAL_MUX VGA2 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  84:80
 *     AMS_RX_SD_CAL_NEG offfset adj bits for SD neg amsbus ctrl_out  87:85
 *     AMS_RX_SD_CAL_POS offfset adj bits for SD pos amsbus ctrl_out  90:88
 *     AMS_RX_SD_CAL_POLARITY selects the pos or neg threshold path for signal detect calibration amsbus ctrl_out  91:91
 *     AMS_RX_TESTCLK_DIV divides/muxes rclk20 for test port, 00:div1, 01:div2, 10:div4, 11:div8, also see rx_ctrl[8] amsbus ctrl_out  93:92
 *     AMS_RX_TESTCLK_MUX selects between local test clock, defined by rx_ctrl[93:92], and from adjacent lane, 0 = local, 1 = adjacent amsbus ctrl_out  94:94
 *     AMS_RX_SD_CAL_EN enables the calibration of the signal detect cicruits to cover about +/-20mV amsbus ctrl_out  95:95
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r (0x0001d0c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl5[1];
	uint32_t _ams_rx_rx_ctl5;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_CLR(r) (r).ams_rx_rx_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_SET(r,d) (r).ams_rx_rx_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_GET(r) (r).ams_rx_rx_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 5) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET(r) (((r).ams_rx_rx_ctl5[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r,(_r._ams_rx_rx_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r,(_r._ams_rx_rx_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r,(_r._ams_rx_rx_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r
#define AMS_RX_RX_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_t AMS_RX_RX_CTL5r_t;
#define AMS_RX_RX_CTL5r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_CLR
#define AMS_RX_RX_CTL5r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_SET
#define AMS_RX_RX_CTL5r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_ENf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POLARITYf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_POSf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_SD_CAL_NEGf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET
#define READ_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL5r
#define WRITE_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL5r
#define MODIFY_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL5r
#define READLN_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL5r
#define WRITELN_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL5r
#define WRITEALL_AMS_RX_RX_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL6
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c6
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_PEAKING_FILTER_RESCAL_MUX peaking filter rescal mux- (force, ctrl[3:1]) -rescal override amsbus ctrl_out  99:96
 *     AMS_RX_OFFSET_CORRECTION_RESCAL_MUX offset correction rescal mux (force, ctrl[3:1]) - rescal override amsbus ctrl_out  103:100
 *     AMS_RX_RXCLK32_EN enables 32T clock amsbus ctrl_out  104:104DFT_MUX
 *     AMS_RX_PD_PHS_SLR power down +2, -2 phase slicers amsbus ctrl_out  105:105
 *     AMS_RX_DFESUM_LP Adds peaking at 17G, intended for VSR mode with no DFE, lower power ~5mW amsbus ctrl_out  106:106
 *     AMS_RX_CML_LP    DFE mux selection and latch. Assert for OS2 and OS4 rates to lower power. ~10mW. Not part of 25G VSR mode amsbus ctrl_out  107:107
 *     AMS_RX_EN_TAP9DELAY increased to 2 bits for 16nm 00 => 25G, 01 = 22-25G, 1x = <22G amsbus ctrl_out  109:108
 *     AMS_RX_DFE_SUMMER_VCM adjusts summer Vcm to match ladder Vcm amsbus ctrl_out  111:110
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r (0x0001d0c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl6[1];
	uint32_t _ams_rx_rx_ctl6;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_CLR(r) (r).ams_rx_rx_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_SET(r,d) (r).ams_rx_rx_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_GET(r) (r).ams_rx_rx_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET(r) (((r).ams_rx_rx_ctl6[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r,(_r._ams_rx_rx_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r,(_r._ams_rx_rx_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r,(_r._ams_rx_rx_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r
#define AMS_RX_RX_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_t AMS_RX_RX_CTL6r_t;
#define AMS_RX_RX_CTL6r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_CLR
#define AMS_RX_RX_CTL6r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_SET
#define AMS_RX_RX_CTL6r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_GET
#define AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFE_SUMMER_VCMf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_EN_TAP9DELAYf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_CML_LPf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_DFESUM_LPf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PD_PHS_SLRf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_RXCLK32_ENf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET
#define READ_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL6r
#define WRITE_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL6r
#define MODIFY_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL6r
#define READLN_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL6r
#define WRITELN_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL6r
#define WRITEALL_AMS_RX_RX_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL7
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c7
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DC_OFFSET dc_offset amsbus ctrl_out  119:112
 *     AMS_RX_FORCE_DC_OFFSET enables override using register bits amsbus ctrl_out  120:120
 *     AMS_RX_RX_OFFSET_PD pwrdn AFE offset cancellation DAC amsbus ctrl_out  121:121
 *     AMS_RX_SHORT_VGA_OUTPUT used for slicer calibration amsbus ctrl_out  122:122
 *     AMS_RX_DC_OFFSET_HALF_RANGE reduces DC offset range and LSB by 50% to improve accuracy amsbus ctrl_out  123:123
 *     AMS_RX_EQ_IND_DIS shunts and disables inductor peaking which reduces the EQ BW for OS2 modes, overriden by rx_ctrl[10]. Test mode amsbus ctrl_out  124:124
 *     AMS_RX_EQ_PKCOMP_DIS disables the residual peaking compensation cap at the EQ output. Peaking ~3-5dB at ~11 GHz over PVT. Test mode amsbus ctrl_out  125:125
 *     AMS_RX_VGA_STEP_MODE VGA step mode, See AMS amsbus ctrl_out  127:126
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r (0x0001d0c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl7[1];
	uint32_t _ams_rx_rx_ctl7;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_CLR(r) (r).ams_rx_rx_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_SET(r,d) (r).ams_rx_rx_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_GET(r) (r).ams_rx_rx_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET(r) (((r).ams_rx_rx_ctl7[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r,(_r._ams_rx_rx_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r,(_r._ams_rx_rx_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r,(_r._ams_rx_rx_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r
#define AMS_RX_RX_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_t AMS_RX_RX_CTL7r_t;
#define AMS_RX_RX_CTL7r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_CLR
#define AMS_RX_RX_CTL7r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_SET
#define AMS_RX_RX_CTL7r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_GET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_PKCOMP_DISf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_EQ_IND_DISf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_HALF_RANGEf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET
#define READ_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL7r
#define WRITE_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL7r
#define MODIFY_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL7r
#define READLN_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL7r
#define WRITELN_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL7r
#define WRITEALL_AMS_RX_RX_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL8
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c8
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_LMS_I dac4ck_lms_i amsbus ctrl_out  131:128
 *     AMS_RX_DAC4CK_LMS_Q dac4ck_lms_q amsbus ctrl_out  135:132
 *     AMS_RX_DAC4CK_PHS_I dac4ck_phs_i amsbus ctrl_out  139:136
 *     AMS_RX_DAC4CK_PHS_Q dac4ck_phs_q amsbus ctrl_out  143:140
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r (0x0001d0c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL8.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl8[1];
	uint32_t _ams_rx_rx_ctl8;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_CLR(r) (r).ams_rx_rx_ctl8[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_SET(r,d) (r).ams_rx_rx_ctl8[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_GET(r) (r).ams_rx_rx_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_GET(r) (((r).ams_rx_rx_ctl8[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r,(_r._ams_rx_rx_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r,(_r._ams_rx_rx_ctl8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r,(_r._ams_rx_rx_ctl8))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r
#define AMS_RX_RX_CTL8r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_t AMS_RX_RX_CTL8r_t;
#define AMS_RX_RX_CTL8r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_CLR
#define AMS_RX_RX_CTL8r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_SET
#define AMS_RX_RX_CTL8r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_Qf_SET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHS_If_SET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_Qf_SET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMS_If_SET
#define READ_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL8r
#define WRITE_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL8r
#define MODIFY_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL8r
#define READLN_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL8r
#define WRITELN_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL8r
#define WRITEALL_AMS_RX_RX_CTL8r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL9
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c9
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_9
 * RESETVAL: 0x300 (768)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_DAT_I 4-bit for each clock: dac4ck[3:0], sign+binary(2:0). 0000 or 1000 is default without adjustment. 0111(+) abd 1111(-) is the maximum value amsbus ctrl_out  147:144DFT_MUX
 *     AMS_RX_DAC4CK_DAT_Q 4-bit for each clock: dac4ck[3:0], sign+binary(2:0). 0000 or 1000 is default without adjustment. 0111(+) abd 1111(-) is the maximum value amsbus ctrl_out  151:148DFT_MUX
 *     AMS_RX_CLK_BW_CTRL clk_bw_ctrl<1:0> for 15G to 28G, see AMS amsbus ctrl_out  153:152DFT_MUX
 *     AMS_RX_SPARE_154 NA. Use pll_select register fields from ckrst_ctrl regmap. 0=4T clks from PLL0; 1=4T clks from PLL1 amsbus ctrl_out  154:154
 *     AMS_RX_SEL_D2CLP 0, high power for 25-28g amsbus ctrl_out  155:155DFT_MUX
 *     AMS_RX_D2C_CLKBUF_IBIAS d2c and clock buffer ibias (max, mode, min) - one control bus for six 100uA currents. amsbus ctrl_out  158:156DFT_MUX
 *     AMS_RX_CLOCK_CAL_EN send PLL clock to slicer inputs for phase alignment calibration amsbus ctrl_out  159:159
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r (0x0001d0c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL9.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl9[1];
	uint32_t _ams_rx_rx_ctl9;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_CLR(r) (r).ams_rx_rx_ctl9[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_SET(r,d) (r).ams_rx_rx_ctl9[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_GET(r) (r).ams_rx_rx_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_GET(r) (((r).ams_rx_rx_ctl9[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r,(_r._ams_rx_rx_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r,(_r._ams_rx_rx_ctl9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r,(_r._ams_rx_rx_ctl9))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r
#define AMS_RX_RX_CTL9r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_t AMS_RX_RX_CTL9r_t;
#define AMS_RX_RX_CTL9r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_CLR
#define AMS_RX_RX_CTL9r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_SET
#define AMS_RX_RX_CTL9r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_GET
#define AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLOCK_CAL_ENf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_GET
#define AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_SPARE_154f_SET
#define AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_Qf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_GET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DAT_If_SET
#define READ_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL9r
#define WRITE_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL9r
#define MODIFY_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL9r
#define READLN_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL9r
#define WRITELN_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL9r
#define WRITEALL_AMS_RX_RX_CTL9r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_CTL_10
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0ca
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_PF3_CTRL  controls boost for new PF with higher freq range, Gray code amsbus ctrl_out  163:160
 *     AMS_RX_PF3_RESCAL_MUX (force, ctrl[3:1]) - rescal override. Can be used to adjust the BW vs gain & possibly peaking amsbus ctrl_out  167:164
 *     AMS_RX_PF3_MAX_BW increases rolloff pole BW 20%, lowers DC gain 2 dB, rescal still valid, bias currents not scaled amsbus ctrl_out  168:168
 *     AMS_RX_PF3_LZ_EN shift zero/pole pair to lower freq amsbus ctrl_out  169:169
 *     AMS_RX_PF3_IND_DIS shunts and disables inductor peaking which reduces the PF3 BW, overridden by rx_ctrl[169]. Test mode amsbus ctrl_out  170:170
 *     AMS_RX_PF3_PKCOMP_DIS disables the residual peaking compensation cap at the PF3 output. Peaking ~3-5dB at ~11GHz over PVT. Test mode amsbus ctrl_out  171:171
 *     AMS_RX_VGA_BW_CTRL_CAP fine BW control for the VGA stages, adds caps to VGA01 amsbus ctrl_out  173:172
 *     AMS_RX_VGA_BW_CTRL_IND coarse BW control for the VGA stages, removes shunt peaking inductors, VGA3, VGA10 amsbus ctrl_out  175:174
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r (0x0001d0ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL_10.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl_10[1];
	uint32_t _ams_rx_rx_ctl_10;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_CLR(r) (r).ams_rx_rx_ctl_10[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_SET(r,d) (r).ams_rx_rx_ctl_10[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_GET(r) (r).ams_rx_rx_ctl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl_10[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET(r) (((r).ams_rx_rx_ctl_10[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL_10.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r
#define AMS_RX_RX_CTL_10r_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_t AMS_RX_RX_CTL_10r_t;
#define AMS_RX_RX_CTL_10r_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_CLR
#define AMS_RX_RX_CTL_10r_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_SET
#define AMS_RX_RX_CTL_10r_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_INDf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_VGA_BW_CTRL_CAPf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_PKCOMP_DISf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_IND_DISf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_LZ_ENf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_MAX_BWf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET
#define READ_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_CTL_10r
#define WRITE_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_CTL_10r
#define MODIFY_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_CTL_10r
#define READLN_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_CTL_10r
#define WRITELN_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_CTL_10r
#define WRITEALL_AMS_RX_RX_CTL_10r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_CTL_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_CTL_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_RX_RX_STS
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0cc
 * DEVAD:    1
 * DESC:     AMS RX STATUS
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_RX_VGA       Copy of VGA control vga_ctrl[4:0]
 *     AMS_RX_DATA_THRESH_SEL RX data thresh sel
 *     AMS_RX_PF        Copy of peaking filter control rx_pf_ctrl[3:0]
 *     AMS_RX_SIGDET    Signal Detect status
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr (0x0001d0cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_sts[1];
	uint32_t _ams_rx_rx_sts;
} BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_t;

#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_CLR(r) (r).ams_rx_rx_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_SET(r,d) (r).ams_rx_rx_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_GET(r) (r).ams_rx_rx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_PFf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 11) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_PFf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 5) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_VGAf_GET(r) (((r).ams_rx_rx_sts[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_VGAf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_RX_RX_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr,(_r._ams_rx_rx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr,(_r._ams_rx_rx_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr,(_r._ams_rx_rx_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr
#define AMS_RX_RX_STSr_SIZE BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_t AMS_RX_RX_STSr_t;
#define AMS_RX_RX_STSr_CLR BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_CLR
#define AMS_RX_RX_STSr_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_SET
#define AMS_RX_RX_STSr_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_GET
#define AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET
#define AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET
#define AMS_RX_RX_STSr_AMS_RX_PFf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_PFf_GET
#define AMS_RX_RX_STSr_AMS_RX_PFf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_PFf_SET
#define AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_GET
#define AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_DATA_THRESH_SELf_SET
#define AMS_RX_RX_STSr_AMS_RX_VGAf_GET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_VGAf_GET
#define AMS_RX_RX_STSr_AMS_RX_VGAf_SET BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr_AMS_RX_VGAf_SET
#define READ_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_READ_AMS_RX_RX_STSr
#define WRITE_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_WRITE_AMS_RX_RX_STSr
#define MODIFY_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_MODIFY_AMS_RX_RX_STSr
#define READLN_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_READLN_AMS_RX_RX_STSr
#define WRITELN_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_WRITELN_AMS_RX_RX_STSr
#define WRITEALL_AMS_RX_RX_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_RX_RX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_RX_RX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_TX_TX_CTL0
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d0
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_0
 * RESETVAL: 0x40 (64)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_SKEW_PN   adjusts skew between TX P and N outputs, ~0.5ps per step amsbus ctrl_out  2:0
 *     AMS_TX_SKEW_POLARITY skew polarity 0=delay TX N, 1=delay TX P amsbus ctrl_out  3:3
 *     AMS_TX_SKEW_ENABLE skew enable amsbus ctrl_out  4:4
 *     AMS_TX_SPARE_5   AMS reserved bits 5 amsbus ctrl_out  5:5
 *     AMS_TX_TICKSEL   timing control of load signal at ana/dig interface, use 01 for all rates amsbus ctrl_out  7:6
 *     AMS_TX_VDDR_BGB  bias mode control for LDO reference amsbus ctrl_out  8:8DFT_MUX
 *     AMS_TX_SPARE_9   AMS reserved [9] amsbus ctrl_out  9:9
 *     AMS_TX_DCC_DIS   disable differential DC correction, common mode feedback only amsbus ctrl_out  10:10
 *     AMS_TX_CAL_OFF   disable RESCAL[3:0], enable cal_aux[3:0] amsbus ctrl_out  11:11DFT_MUX
 *     AMS_TX_CAL_AUX   Rescal manual control when cal_off=1 amsbus ctrl_out  15:12DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r (0x0001d0d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl0[1];
	uint32_t _ams_tx_tx_ctl0;
} BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_CLR(r) (r).ams_tx_tx_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_SET(r,d) (r).ams_tx_tx_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_GET(r) (r).ams_tx_tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_GET(r) (((r).ams_tx_tx_ctl0[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r,(_r._ams_tx_tx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r,(_r._ams_tx_tx_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r,(_r._ams_tx_tx_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r
#define AMS_TX_TX_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_t AMS_TX_TX_CTL0r_t;
#define AMS_TX_TX_CTL0r_CLR BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_CLR
#define AMS_TX_TX_CTL0r_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_SET
#define AMS_TX_TX_CTL0r_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_9f_SET
#define AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SPARE_5f_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_ENABLEf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_POLARITYf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r_AMS_TX_SKEW_PNf_SET
#define READ_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL0r
#define WRITE_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL0r
#define MODIFY_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL0r
#define READLN_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL0r
#define WRITELN_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL0r
#define WRITEALL_AMS_TX_TX_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_TX_TX_CTL1
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d1
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_IBIAS     master bias diode amsbus ctrl_out  18:16DFT_MUX
 *     AMS_TX_IPHINT    phase interpolator current control amsbus ctrl_out  21:19DFT_MUX
 *     AMS_TX_SPARE_24_22 AMS reserved [24:22] amsbus ctrl_out  24:22
 *     AMS_TX_ILDO      LDO bias current control amsbus ctrl_out  27:25
 *     AMS_TX_LDO_VREF  adjusts internal driver supply voltage, scales output amplitute ~2% per step. 00=0.89V, 01=0.93V, 10=0.97V, 11=1.01V amsbus ctrl_out  29:28DFT_MUX
 *     AMS_TX_TXCLK66_EN enables the 66T clock. amsbus ctrl_out  30:30DFT_MUX
 *     AMS_TX_TXCLK32_EN enables the 32T clock. amsbus ctrl_out  31:31DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r (0x0001d0d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl1[1];
	uint32_t _ams_tx_tx_ctl1;
} BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_CLR(r) (r).ams_tx_tx_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_SET(r,d) (r).ams_tx_tx_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_GET(r) (r).ams_tx_tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 9) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 6) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 3) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET(r) (((r).ams_tx_tx_ctl1[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r,(_r._ams_tx_tx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r,(_r._ams_tx_tx_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r,(_r._ams_tx_tx_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r
#define AMS_TX_TX_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_t AMS_TX_TX_CTL1r_t;
#define AMS_TX_TX_CTL1r_CLR BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_CLR
#define AMS_TX_TX_CTL1r_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_SET
#define AMS_TX_TX_CTL1r_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_GET
#define AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK32_ENf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_TXCLK66_ENf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_GET
#define AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_SPARE_24_22f_SET
#define AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET
#define READ_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL1r
#define WRITE_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL1r
#define MODIFY_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL1r
#define READLN_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL1r
#define WRITELN_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL1r
#define WRITEALL_AMS_TX_TX_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_TX_TX_CTL2
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d2
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_HPF_CTRL  adds a feed forward zero to tx output.helps to cancel pkg loss w/o using FIR range amsbus ctrl_out  33:32DFT_MUX
 *     AMS_TX_SPARE_34  NA. Use pll_select register fields from ckrst_ctrl regmap. 0=2T clks from PLL0; 1=2T clks from PLL1 amsbus ctrl_out  34:34
 *     AMS_TX_SLEW_RATE Enables both the HPF bits to add loading to the TX output and increase the transition time for compliance with lower speed standards amsbus ctrl_out  35:35
 *     AMS_TX_TEST_DATA generates output pattern amsbus ctrl_out  37:36
 *     AMS_TX_DRIVER_RES_CAL dedicated rescal code for the DAC driver amsbus ctrl_out  39:38
 *     AMS_TX_SPARE_46_40 AMS reserved bits 46:40 amsbus ctrl_out  46:40
 *     AMS_TX_ELEC_IDLE_AUX force electrical idle mode amsbus ctrl_out  47:47DFT_MUX_AND_PRE
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r (0x0001d0d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl2[1];
	uint32_t _ams_tx_tx_ctl2;
} BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_CLR(r) (r).ams_tx_tx_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_SET(r,d) (r).ams_tx_tx_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_GET(r) (r).ams_tx_tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 8) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_GET(r) (((r).ams_tx_tx_ctl2[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r,(_r._ams_tx_tx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r,(_r._ams_tx_tx_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r,(_r._ams_tx_tx_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r
#define AMS_TX_TX_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_t AMS_TX_TX_CTL2r_t;
#define AMS_TX_TX_CTL2r_CLR BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_CLR
#define AMS_TX_TX_CTL2r_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_SET
#define AMS_TX_TX_CTL2r_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_GET
#define AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_GET
#define AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_46_40f_SET
#define AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_RES_CALf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_TEST_DATAf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SLEW_RATEf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_GET
#define AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_SPARE_34f_SET
#define AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r_AMS_TX_HPF_CTRLf_SET
#define READ_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL2r
#define WRITE_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL2r
#define MODIFY_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL2r
#define READLN_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL2r
#define WRITELN_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL2r
#define WRITEALL_AMS_TX_TX_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_TX_TX_CTL3
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d3
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_SPARE_52_48 AMS reserved[52:48] amsbus ctrl_out  52:48
 *     AMS_TX_PDET_MODE select update rate for phase detect (pdet) output. 0:Fwclk, 1:Fwclk/5 amsbus ctrl_out  53:53
 *     AMS_TX_SPARE_54  AMS reserved [54] amsbus ctrl_out  54:54
 *     AMS_TX_SEL_TXMASTER select TX lane as master, only one TX lane can be set to master. amsbus ctrl_out  55:55
 *     AMS_TX_SPARE_63_56 AMS reserved[63:56] amsbus ctrl_out  63:56
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r (0x0001d0d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl3[1];
	uint32_t _ams_tx_tx_ctl3;
} BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_CLR(r) (r).ams_tx_tx_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_SET(r,d) (r).ams_tx_tx_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_GET(r) (r).ams_tx_tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET(r) (((r).ams_tx_tx_ctl3[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r
#define AMS_TX_TX_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_t AMS_TX_TX_CTL3r_t;
#define AMS_TX_TX_CTL3r_CLR BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_CLR
#define AMS_TX_TX_CTL3r_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_SET
#define AMS_TX_TX_CTL3r_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET
#define READ_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_CTL3r
#define WRITE_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_CTL3r
#define MODIFY_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_CTL3r
#define READLN_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_CTL3r
#define WRITELN_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_CTL3r
#define WRITEALL_AMS_TX_TX_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_TX_TX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_TX_TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d9
 * DEVAD:    1
 * DESC:     AMS TX STATUS
 * RESETVAL: 0xa0 (160)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_TX_VERSION_ID AMS version ID. Used to track the core version.
 *     AMS_TX_ANA_RESCAL Copy of ana_rescal bus. Control code for global resistor calibration. See AMS for more details.
 *     AMS_TX_DRV_HV_DISABLE Copy of of tx_drv_hv_disable. By default, assume high voltage driver (HVD) mode and 1.25V
 *     AMS_TX_SPARE_13  AMS tx_sts bit13 reserve
 *     AMS_TX_LANE_ID   TX Lane ID
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr (0x0001d0d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_sts[1];
	uint32_t _ams_tx_tx_sts;
} BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_t;

#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_CLR(r) (r).ams_tx_tx_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_SET(r,d) (r).ams_tx_tx_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_GET(r) (r).ams_tx_tx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET(r) ((((r).ams_tx_tx_sts[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET(r) (((r).ams_tx_tx_sts[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AMS_TX_TX_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr
#define AMS_TX_TX_STSr_SIZE BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_t AMS_TX_TX_STSr_t;
#define AMS_TX_TX_STSr_CLR BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_CLR
#define AMS_TX_TX_STSr_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_SET
#define AMS_TX_TX_STSr_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET
#define READ_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_READ_AMS_TX_TX_STSr
#define WRITE_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_WRITE_AMS_TX_TX_STSr
#define MODIFY_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_MODIFY_AMS_TX_TX_STSr
#define READLN_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_READLN_AMS_TX_TX_STSr
#define WRITELN_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_WRITELN_AMS_TX_TX_STSr
#define WRITEALL_AMS_TX_TX_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_TX_TX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_TX_TX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_CTL0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e0
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_0
 * RESETVAL: 0x1109 (4361)
 * ACCESS:   R/W
 * FIELDS:
 *     SIGNAL_DETECT_FILTER_COUNT Defines the width of the signal_detect==1'b1 pulses which will be filtered out in the criteria for signal detect.Valid range is 0 to 31 which maps to 0 to 448 comclk cycles. Refer to los_filter_count field for mapping.
 *     LOS_FILTER_COUNT Defines the width of the signal_detect==1'b0 pulses which will be filtered out in the criteria for loss of signal.Valid range is 0 to 31 which maps to 0 to 448 clock cycles. By default, these clock cycles are comclk cycles butif signal_detect_filter_1us register field is set to 1, these clock cycles are 1us heartbeat clock cycles.0:31 maps to (0:448) clock cycles as shown below0            0 clocks1	       1 clocks2	       2 clocks3	       3 clocks4	       4 clocks5	       5 clocks6	       6 clocks7	       7 clocks8	       8 clocks9	      10 clocks10	      12 clocks11	      14 clocks12	      16 clocks13	      20 clocks14	      24 clocks15	      28 clocks16	      32 clocks17	      40 clocks18	      48 clocks19	      56 clocks20	      64 clocks21	      80 clocks22	      96 clocks23	     112 clocks24	     128 clocks25	     160 clocks26	     192 clocks27	     224 clocks28	     256 clocks29	     320 clocks30	     384 clocks31	     448 clocks
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r (0x0001d0e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl0[1];
	uint32_t _sigdet_ctl0;
} BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_CLR(r) (r).sigdet_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SET(r,d) (r).sigdet_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_GET(r) (r).sigdet_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET(r) (((r).sigdet_ctl0[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r
#define SIGDET_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_t SIGDET_CTL0r_t;
#define SIGDET_CTL0r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_CLR
#define SIGDET_CTL0r_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SET
#define SIGDET_CTL0r_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET
#define READ_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL0r
#define WRITE_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL0r
#define MODIFY_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL0r
#define READLN_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL0r
#define WRITELN_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL0r
#define WRITEALL_SIGDET_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_CTL1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e1
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_1
 * RESETVAL: 0xa008 (40968)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_SIGNAL_DETECT_DIS 1'b1 will disable the signal_detect from AFE.
 *     EXT_LOS_EN       1'b1 will enable the external (optical) LOS path into the sigdet filter.
 *     EXT_LOS_INV      1'b1 will invert the polarity of the pmd_ext_los pin.
 *     IGNORE_LP_MODE   1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS
 *     SIGNAL_DETECT_FILTER_1US 1'b1 will use 1us heartbeat for los_filter_count counter instead of comclk.
 *     ENERGY_DETECT_FRC pmd_energy_detect Force.
 *     ENERGY_DETECT_FRC_VAL pmd_energy_detect Force Value.
 *     SIGNAL_DETECT_FRC pmd_signal_detect Force.
 *     SIGNAL_DETECT_FRC_VAL pmd_signal_detect Force Value.
 *     ENERGY_DETECT_MASK_COUNT Defines the mask_count timer for energy_detect. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r (0x0001d0e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl1[1];
	uint32_t _sigdet_ctl1;
} BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_CLR(r) (r).sigdet_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SET(r,d) (r).sigdet_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_GET(r) (r).sigdet_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET(r) ((((r).sigdet_ctl1[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET(r) ((((r).sigdet_ctl1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET(r) ((((r).sigdet_ctl1[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET(r) ((((r).sigdet_ctl1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET(r) ((((r).sigdet_ctl1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET(r) (((r).sigdet_ctl1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r
#define SIGDET_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_t SIGDET_CTL1r_t;
#define SIGDET_CTL1r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_CLR
#define SIGDET_CTL1r_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SET
#define SIGDET_CTL1r_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET
#define SIGDET_CTL1r_EXT_LOS_INVf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET
#define SIGDET_CTL1r_EXT_LOS_INVf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET
#define SIGDET_CTL1r_EXT_LOS_ENf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET
#define SIGDET_CTL1r_EXT_LOS_ENf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET
#define READ_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL1r
#define WRITE_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL1r
#define MODIFY_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL1r
#define READLN_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL1r
#define WRITELN_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL1r
#define WRITEALL_SIGDET_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_CTL2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e2
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_2
 * RESETVAL: 0x3f22 (16162)
 * ACCESS:   R/W
 * FIELDS:
 *     LOS_THRESH       AFE signal detect threshold to be used when filtered signal_detect == 1.
 *     SIGNAL_DETECT_THRESH AFE signal detect threshold to be used when filtered signal_detect == 0.
 *     HOLD_LOS_COUNT   HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *     HOLD_SD_COUNT    HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r (0x0001d0e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl2[1];
	uint32_t _sigdet_ctl2;
} BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_CLR(r) (r).sigdet_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SET(r,d) (r).sigdet_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_GET(r) (r).sigdet_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 11) & 0x7)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET(r) ((((r).sigdet_ctl2[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET(r) (((r).sigdet_ctl2[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SIGDET_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r
#define SIGDET_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_t SIGDET_CTL2r_t;
#define SIGDET_CTL2r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_CLR
#define SIGDET_CTL2r_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SET
#define SIGDET_CTL2r_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET
#define SIGDET_CTL2r_LOS_THRESHf_GET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET
#define SIGDET_CTL2r_LOS_THRESHf_SET BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET
#define READ_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_READ_SIGDET_CTL2r
#define WRITE_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_CTL2r
#define MODIFY_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_CTL2r
#define READLN_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_CTL2r
#define WRITELN_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_CTL2r
#define WRITEALL_SIGDET_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e8
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     EXT_SIGDET       External LOS/sigdet from the pin going into the sigdet filter.
 *     EXT_SIGDET_CHANGE This latches the transition on ext_sigdet and cleared on read.
 *     AFE_SIGDET       Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     AFE_SIGDET_CHANGE This latches the transition on afe_sigdet and cleared on read.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r (0x0001d0e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r,(_r._sigdet_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_BLACKHAWK_XGXS_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_AFE_SIGDETf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET
#define SIGDET_STS0r_AFE_SIGDETf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_EXT_SIGDETf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET
#define SIGDET_STS0r_EXT_SIGDETf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS0r
#define READLN_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS0r
#define WRITELN_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS0r
#define WRITEALL_SIGDET_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_STS1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e9
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 *     UC_SIGNAL_DETECT_CHANGE This latches the transition on uc_signal_detect and cleared on read.
 *     UC_EXT_SIGDET    External LOS/sigdet from the pin going into the sigdet filter.
 *     UC_EXT_SIGDET_CHANGE This latches the transition on uc_ext_sigdet and cleared on read.
 *     UC_AFE_SIGDET    Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     UC_AFE_SIGDET_CHANGE This latches the transition on uc_afe_sigdet and cleared on read.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r (0x0001d0e9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_s {
	uint32_t v[1];
	uint32_t sigdet_sts1[1];
	uint32_t _sigdet_sts1;
} BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_CLR(r) (r).sigdet_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_SET(r,d) (r).sigdet_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_GET(r) (r).sigdet_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r,(_r._sigdet_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r,(_r._sigdet_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r,(_r._sigdet_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS1r BCMI_BLACKHAWK_XGXS_SIGDET_STS1r
#define SIGDET_STS1r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_t SIGDET_STS1r_t;
#define SIGDET_STS1r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_CLR
#define SIGDET_STS1r_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_SET
#define SIGDET_STS1r_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_AFE_SIGDETf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_GET
#define SIGDET_STS1r_UC_AFE_SIGDETf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_SET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_EXT_SIGDETf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_GET
#define SIGDET_STS1r_UC_EXT_SIGDETf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS1r
#define WRITE_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS1r
#define MODIFY_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS1r
#define READLN_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS1r
#define WRITELN_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS1r
#define WRITEALL_SIGDET_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_STS2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0ea
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENERGY_DETECT    Filtered version of Energy Detect after frc/frc_val.
 *     ENERGY_DETECT_CHANGE This latches the transition on energy_detect and cleared on read.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r (0x0001d0ea | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_s {
	uint32_t v[1];
	uint32_t sigdet_sts2[1];
	uint32_t _sigdet_sts2;
} BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_CLR(r) (r).sigdet_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_SET(r,d) (r).sigdet_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_GET(r) (r).sigdet_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts2[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECTf_GET(r) (((r).sigdet_sts2[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECTf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r,(_r._sigdet_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r,(_r._sigdet_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r,(_r._sigdet_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS2r BCMI_BLACKHAWK_XGXS_SIGDET_STS2r
#define SIGDET_STS2r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_t SIGDET_STS2r_t;
#define SIGDET_STS2r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_CLR
#define SIGDET_STS2r_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_SET
#define SIGDET_STS2r_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET
#define SIGDET_STS2r_ENERGY_DETECTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECTf_GET
#define SIGDET_STS2r_ENERGY_DETECTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS2r_ENERGY_DETECTf_SET
#define READ_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS2r
#define WRITE_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS2r
#define MODIFY_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS2r
#define READLN_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS2r
#define WRITELN_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS2r
#define WRITEALL_SIGDET_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_STS3
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0eb
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r (0x0001d0eb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS3.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_s {
	uint32_t v[1];
	uint32_t sigdet_sts3[1];
	uint32_t _sigdet_sts3;
} BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_CLR(r) (r).sigdet_sts3[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_SET(r,d) (r).sigdet_sts3[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_GET(r) (r).sigdet_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts3[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts3[0]=(((r).sigdet_sts3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r,(_r._sigdet_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r,(_r._sigdet_sts3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r,(_r._sigdet_sts3))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS3r BCMI_BLACKHAWK_XGXS_SIGDET_STS3r
#define SIGDET_STS3r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_t SIGDET_STS3r_t;
#define SIGDET_STS3r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_CLR
#define SIGDET_STS3r_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_SET
#define SIGDET_STS3r_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS3r
#define WRITE_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS3r
#define MODIFY_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS3r
#define READLN_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS3r
#define WRITELN_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS3r
#define WRITEALL_SIGDET_STS3r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  SIGDET_STS4
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0ec
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_4
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_SIGDET_THRESH Live status of sigdet_thresh going to AFE.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r (0x0001d0ec | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS4.
 */
typedef union BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_s {
	uint32_t v[1];
	uint32_t sigdet_sts4[1];
	uint32_t _sigdet_sts4;
} BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_t;

#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_CLR(r) (r).sigdet_sts4[0] = 0
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_SET(r,d) (r).sigdet_sts4[0] = d
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_GET(r) (r).sigdet_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET(r) (((r).sigdet_sts4[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET(r,f) (r).sigdet_sts4[0]=(((r).sigdet_sts4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SIGDET_STS4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r,(_r._sigdet_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r,(_r._sigdet_sts4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r,(_r._sigdet_sts4))
#define BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS4r BCMI_BLACKHAWK_XGXS_SIGDET_STS4r
#define SIGDET_STS4r_SIZE BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_t SIGDET_STS4r_t;
#define SIGDET_STS4r_CLR BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_CLR
#define SIGDET_STS4r_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_SET
#define SIGDET_STS4r_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_GET BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_SET BCMI_BLACKHAWK_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET
#define READ_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_READ_SIGDET_STS4r
#define WRITE_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_WRITE_SIGDET_STS4r
#define MODIFY_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_MODIFY_SIGDET_STS4r
#define READLN_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_READLN_SIGDET_STS4r
#define WRITELN_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_WRITELN_SIGDET_STS4r
#define WRITEALL_SIGDET_STS4r BCMI_BLACKHAWK_XGXS_WRITEALL_SIGDET_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_SIGDET_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_HOFFS_JITGEN
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f0
 * DEVAD:    1
 * DESC:     rx horiz offset jitter generator register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HOFFS_JGEN_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.
 *     HOFFS_JGEN_EN    Jitter Generator EnableCDR's phase error offset should be 0 when this is enabled.
 *     HOFFS_JGEN_JIT_AMP Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr (0x0001d0f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_HOFFS_JITGEN.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_s {
	uint32_t v[1];
	uint32_t dsc_rx_hoffs_jitgen[1];
	uint32_t _dsc_rx_hoffs_jitgen;
} BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_CLR(r) (r).dsc_rx_hoffs_jitgen[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_SET(r,d) (r).dsc_rx_hoffs_jitgen[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_GET(r) (r).dsc_rx_hoffs_jitgen[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_GET(r) ((((r).dsc_rx_hoffs_jitgen[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_SET(r,f) (r).dsc_rx_hoffs_jitgen[0]=(((r).dsc_rx_hoffs_jitgen[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_GET(r) ((((r).dsc_rx_hoffs_jitgen[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_SET(r,f) (r).dsc_rx_hoffs_jitgen[0]=(((r).dsc_rx_hoffs_jitgen[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_GET(r) (((r).dsc_rx_hoffs_jitgen[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_SET(r,f) (r).dsc_rx_hoffs_jitgen[0]=(((r).dsc_rx_hoffs_jitgen[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_HOFFS_JITGEN.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_HOFFS_JITGENr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr,(_r._dsc_rx_hoffs_jitgen))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_HOFFS_JITGENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr,(_r._dsc_rx_hoffs_jitgen)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_HOFFS_JITGENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr,(_r._dsc_rx_hoffs_jitgen))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_HOFFS_JITGENr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_hoffs_jitgen))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_HOFFS_JITGENr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_hoffs_jitgen))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_HOFFS_JITGENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_hoffs_jitgen))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr
#define DSC_RX_HOFFS_JITGENr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_t DSC_RX_HOFFS_JITGENr_t;
#define DSC_RX_HOFFS_JITGENr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_CLR
#define DSC_RX_HOFFS_JITGENr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_SET
#define DSC_RX_HOFFS_JITGENr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_GET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_GET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_AMPf_SET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_GET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_ENf_SET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_GET
#define DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr_HOFFS_JGEN_JIT_FREQ_IDXf_SET
#define READ_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_HOFFS_JITGENr
#define WRITE_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_HOFFS_JITGENr
#define MODIFY_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_HOFFS_JITGENr
#define READLN_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_HOFFS_JITGENr
#define WRITELN_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_HOFFS_JITGENr
#define WRITEALL_DSC_RX_HOFFS_JITGENr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_HOFFS_JITGENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_HOFFS_JITGENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM1
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f1
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH1  Random threshold level for lms_rnd_eyec_sel = 1
 *     LMS_RND_THRESH2  Random threshold level for lms_rnd_eyec_sel = 1
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r (0x0001d0f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random1[1];
	uint32_t _dsc_lms_thr_random1;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_CLR(r) (r).dsc_lms_thr_random1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_SET(r,d) (r).dsc_lms_thr_random1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_GET(r) (r).dsc_lms_thr_random1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_GET(r) ((((r).dsc_lms_thr_random1[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_SET(r,f) (r).dsc_lms_thr_random1[0]=(((r).dsc_lms_thr_random1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_GET(r) (((r).dsc_lms_thr_random1[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_SET(r,f) (r).dsc_lms_thr_random1[0]=(((r).dsc_lms_thr_random1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r,(_r._dsc_lms_thr_random1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r,(_r._dsc_lms_thr_random1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r,(_r._dsc_lms_thr_random1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r
#define DSC_LMS_THR_RANDOM1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_t DSC_LMS_THR_RANDOM1r_t;
#define DSC_LMS_THR_RANDOM1r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_CLR
#define DSC_LMS_THR_RANDOM1r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_SET
#define DSC_LMS_THR_RANDOM1r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_GET
#define DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_GET
#define DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH2f_SET
#define DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_GET
#define DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r_LMS_RND_THRESH1f_SET
#define READ_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM1r
#define WRITE_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM1r
#define MODIFY_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM1r
#define READLN_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM1r
#define WRITELN_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM1r
#define WRITEALL_DSC_LMS_THR_RANDOM1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM2
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f2
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH3  Random threshold level for lms_rnd_eyec_sel = 2
 *     LMS_RND_THRESH4  Random threshold level for lms_rnd_eyec_sel = 2
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r (0x0001d0f2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random2[1];
	uint32_t _dsc_lms_thr_random2;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_CLR(r) (r).dsc_lms_thr_random2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_SET(r,d) (r).dsc_lms_thr_random2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_GET(r) (r).dsc_lms_thr_random2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_GET(r) ((((r).dsc_lms_thr_random2[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_SET(r,f) (r).dsc_lms_thr_random2[0]=(((r).dsc_lms_thr_random2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_GET(r) (((r).dsc_lms_thr_random2[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_SET(r,f) (r).dsc_lms_thr_random2[0]=(((r).dsc_lms_thr_random2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r,(_r._dsc_lms_thr_random2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r,(_r._dsc_lms_thr_random2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r,(_r._dsc_lms_thr_random2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r
#define DSC_LMS_THR_RANDOM2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_t DSC_LMS_THR_RANDOM2r_t;
#define DSC_LMS_THR_RANDOM2r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_CLR
#define DSC_LMS_THR_RANDOM2r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_SET
#define DSC_LMS_THR_RANDOM2r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_GET
#define DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_GET
#define DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH4f_SET
#define DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_GET
#define DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r_LMS_RND_THRESH3f_SET
#define READ_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM2r
#define WRITE_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM2r
#define MODIFY_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM2r
#define READLN_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM2r
#define WRITELN_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM2r
#define WRITEALL_DSC_LMS_THR_RANDOM2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM3
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f3
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH5  Random threshold level for lms_rnd_eyec_sel = 3
 *     LMS_RND_THRESH6  Random threshold level for lms_rnd_eyec_sel = 3
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r (0x0001d0f3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random3[1];
	uint32_t _dsc_lms_thr_random3;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_CLR(r) (r).dsc_lms_thr_random3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_SET(r,d) (r).dsc_lms_thr_random3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_GET(r) (r).dsc_lms_thr_random3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_GET(r) ((((r).dsc_lms_thr_random3[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_SET(r,f) (r).dsc_lms_thr_random3[0]=(((r).dsc_lms_thr_random3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_GET(r) (((r).dsc_lms_thr_random3[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_SET(r,f) (r).dsc_lms_thr_random3[0]=(((r).dsc_lms_thr_random3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r,(_r._dsc_lms_thr_random3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r,(_r._dsc_lms_thr_random3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r,(_r._dsc_lms_thr_random3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r
#define DSC_LMS_THR_RANDOM3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_t DSC_LMS_THR_RANDOM3r_t;
#define DSC_LMS_THR_RANDOM3r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_CLR
#define DSC_LMS_THR_RANDOM3r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_SET
#define DSC_LMS_THR_RANDOM3r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_GET
#define DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_GET
#define DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH6f_SET
#define DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_GET
#define DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r_LMS_RND_THRESH5f_SET
#define READ_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM3r
#define WRITE_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM3r
#define MODIFY_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM3r
#define READLN_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM3r
#define WRITELN_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM3r
#define WRITEALL_DSC_LMS_THR_RANDOM3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM4
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f4
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH7  Random threshold level for lms_rnd_eyec_sel = 4
 *     LMS_RND_THRESH8  Random threshold level for lms_rnd_eyec_sel = 4
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r (0x0001d0f4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random4[1];
	uint32_t _dsc_lms_thr_random4;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_CLR(r) (r).dsc_lms_thr_random4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_SET(r,d) (r).dsc_lms_thr_random4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_GET(r) (r).dsc_lms_thr_random4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_GET(r) ((((r).dsc_lms_thr_random4[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_SET(r,f) (r).dsc_lms_thr_random4[0]=(((r).dsc_lms_thr_random4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_GET(r) (((r).dsc_lms_thr_random4[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_SET(r,f) (r).dsc_lms_thr_random4[0]=(((r).dsc_lms_thr_random4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r,(_r._dsc_lms_thr_random4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r,(_r._dsc_lms_thr_random4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r,(_r._dsc_lms_thr_random4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r
#define DSC_LMS_THR_RANDOM4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_t DSC_LMS_THR_RANDOM4r_t;
#define DSC_LMS_THR_RANDOM4r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_CLR
#define DSC_LMS_THR_RANDOM4r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_SET
#define DSC_LMS_THR_RANDOM4r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_GET
#define DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_GET
#define DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH8f_SET
#define DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_GET
#define DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r_LMS_RND_THRESH7f_SET
#define READ_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM4r
#define WRITE_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM4r
#define MODIFY_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM4r
#define READLN_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM4r
#define WRITELN_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM4r
#define WRITEALL_DSC_LMS_THR_RANDOM4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM5
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f5
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH9  Random threshold level for lms_rnd_eyec_sel = 5
 *     LMS_RND_THRESH10 Random threshold level for lms_rnd_eyec_sel = 5
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r (0x0001d0f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random5[1];
	uint32_t _dsc_lms_thr_random5;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_CLR(r) (r).dsc_lms_thr_random5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_SET(r,d) (r).dsc_lms_thr_random5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_GET(r) (r).dsc_lms_thr_random5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_GET(r) ((((r).dsc_lms_thr_random5[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_SET(r,f) (r).dsc_lms_thr_random5[0]=(((r).dsc_lms_thr_random5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_GET(r) (((r).dsc_lms_thr_random5[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_SET(r,f) (r).dsc_lms_thr_random5[0]=(((r).dsc_lms_thr_random5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r,(_r._dsc_lms_thr_random5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r,(_r._dsc_lms_thr_random5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r,(_r._dsc_lms_thr_random5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r
#define DSC_LMS_THR_RANDOM5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_t DSC_LMS_THR_RANDOM5r_t;
#define DSC_LMS_THR_RANDOM5r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_CLR
#define DSC_LMS_THR_RANDOM5r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_SET
#define DSC_LMS_THR_RANDOM5r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_GET
#define DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_GET
#define DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH10f_SET
#define DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_GET
#define DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r_LMS_RND_THRESH9f_SET
#define READ_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM5r
#define WRITE_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM5r
#define MODIFY_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM5r
#define READLN_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM5r
#define WRITELN_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM5r
#define WRITEALL_DSC_LMS_THR_RANDOM5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_RANDOM6
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f6
 * DEVAD:    1
 * DESC:     rx trnsum lms random threshold values3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_RND_THRESH11 Random threshold level for lms_rnd_eyec_sel = 6
 *     LMS_RND_THRESH12 Random threshold level for lms_rnd_eyec_sel = 6
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r (0x0001d0f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_RANDOM6.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_random6[1];
	uint32_t _dsc_lms_thr_random6;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_CLR(r) (r).dsc_lms_thr_random6[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_SET(r,d) (r).dsc_lms_thr_random6[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_GET(r) (r).dsc_lms_thr_random6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_GET(r) ((((r).dsc_lms_thr_random6[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_SET(r,f) (r).dsc_lms_thr_random6[0]=(((r).dsc_lms_thr_random6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_GET(r) (((r).dsc_lms_thr_random6[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_SET(r,f) (r).dsc_lms_thr_random6[0]=(((r).dsc_lms_thr_random6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_RANDOM6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r,(_r._dsc_lms_thr_random6))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r,(_r._dsc_lms_thr_random6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r,(_r._dsc_lms_thr_random6))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_random6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_random6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r
#define DSC_LMS_THR_RANDOM6r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_t DSC_LMS_THR_RANDOM6r_t;
#define DSC_LMS_THR_RANDOM6r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_CLR
#define DSC_LMS_THR_RANDOM6r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_SET
#define DSC_LMS_THR_RANDOM6r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_GET
#define DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_GET
#define DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH12f_SET
#define DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_GET
#define DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r_LMS_RND_THRESH11f_SET
#define READ_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_RANDOM6r
#define WRITE_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_RANDOM6r
#define MODIFY_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_RANDOM6r
#define READLN_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_RANDOM6r
#define WRITELN_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_RANDOM6r
#define WRITEALL_DSC_LMS_THR_RANDOM6r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_RANDOM6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_RANDOM6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f7
 * DEVAD:    1
 * DESC:     lms threshold offset register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LMS_THRESH_OFFS  This offset term is scaled and added to the lms threshold adaptation loop.Signed 2's complement. Range: -8191:8191.This gets divided by 512 and added to trnsum_error.Example of usage:x = offset (1e-2 for example) needed such that 1-x occurences are above the steady state level.((1-x)(1) + x(-1))*P(pattern)*20 + offset = 0offset = (2x-1)*P(pattern)*20.reg_offset = round(offset * 512).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr (0x0001d0f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_OFFS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_offs[1];
	uint32_t _dsc_lms_thr_offs;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_CLR(r) (r).dsc_lms_thr_offs[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_SET(r,d) (r).dsc_lms_thr_offs[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_GET(r) (r).dsc_lms_thr_offs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_GET(r) (((r).dsc_lms_thr_offs[0]) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_SET(r,f) (r).dsc_lms_thr_offs[0]=(((r).dsc_lms_thr_offs[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_OFFS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_OFFSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr,(_r._dsc_lms_thr_offs))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_OFFSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr,(_r._dsc_lms_thr_offs)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_OFFSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr,(_r._dsc_lms_thr_offs))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_OFFSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_offs))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_OFFSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_offs))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_OFFSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr
#define DSC_LMS_THR_OFFSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_t DSC_LMS_THR_OFFSr_t;
#define DSC_LMS_THR_OFFSr_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_CLR
#define DSC_LMS_THR_OFFSr_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_SET
#define DSC_LMS_THR_OFFSr_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_GET
#define DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_GET
#define DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr_LMS_THRESH_OFFSf_SET
#define READ_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_OFFSr
#define WRITE_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_OFFSr
#define MODIFY_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_OFFSr
#define READLN_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_OFFSr
#define WRITELN_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_OFFSr
#define WRITEALL_DSC_LMS_THR_OFFSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_OFFSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_STS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f8
 * DEVAD:    1
 * DESC:     Internal lms threshold status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LMS_THRESH_BIN   bits [9:2]:  signed 2's complement; +/-127*4. 127=300mVIt reads out the hardware loop high resolution lms threshold/ override value left shifted by 2 (with lower two bits as 0).
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr (0x0001d0f8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_sts[1];
	uint32_t _dsc_lms_thr_sts;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_CLR(r) (r).dsc_lms_thr_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_SET(r,d) (r).dsc_lms_thr_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_GET(r) (r).dsc_lms_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_LMS_THRESH_BINf_GET(r) (((r).dsc_lms_thr_sts[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_LMS_THRESH_BINf_SET(r,f) (r).dsc_lms_thr_sts[0]=(((r).dsc_lms_thr_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr,(_r._dsc_lms_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr,(_r._dsc_lms_thr_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr,(_r._dsc_lms_thr_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr
#define DSC_LMS_THR_STSr_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_t DSC_LMS_THR_STSr_t;
#define DSC_LMS_THR_STSr_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_CLR
#define DSC_LMS_THR_STSr_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_SET
#define DSC_LMS_THR_STSr_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_GET
#define DSC_LMS_THR_STSr_LMS_THRESH_BINf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_LMS_THRESH_BINf_GET
#define DSC_LMS_THR_STSr_LMS_THRESH_BINf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr_LMS_THRESH_BINf_SET
#define READ_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_STSr
#define WRITE_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_STSr
#define MODIFY_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_STSr
#define READLN_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_STSr
#define WRITELN_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_STSr
#define WRITEALL_DSC_LMS_THR_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_LMS_THR_STS2
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0f9
 * DEVAD:    1
 * DESC:     AFE lms threshold status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_LMS_THRESH_BIN LMS threshold value applied to the analog.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r (0x0001d0f9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_LMS_THR_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_s {
	uint32_t v[1];
	uint32_t dsc_lms_thr_sts2[1];
	uint32_t _dsc_lms_thr_sts2;
} BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_CLR(r) (r).dsc_lms_thr_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_SET(r,d) (r).dsc_lms_thr_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_GET(r) (r).dsc_lms_thr_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_GET(r) (((r).dsc_lms_thr_sts2[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_SET(r,f) (r).dsc_lms_thr_sts2[0]=(((r).dsc_lms_thr_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_LMS_THR_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r,(_r._dsc_lms_thr_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r,(_r._dsc_lms_thr_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r,(_r._dsc_lms_thr_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_lms_thr_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_lms_thr_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r
#define DSC_LMS_THR_STS2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_t DSC_LMS_THR_STS2r_t;
#define DSC_LMS_THR_STS2r_CLR BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_CLR
#define DSC_LMS_THR_STS2r_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_SET
#define DSC_LMS_THR_STS2r_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_GET
#define DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_GET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_GET
#define DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_SET BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r_AFE_LMS_THRESH_BINf_SET
#define READ_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_READ_DSC_LMS_THR_STS2r
#define WRITE_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_LMS_THR_STS2r
#define MODIFY_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_LMS_THR_STS2r
#define READLN_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_READLN_DSC_LMS_THR_STS2r
#define WRITELN_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_LMS_THR_STS2r
#define WRITEALL_DSC_LMS_THR_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_LMS_THR_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_LMS_THR_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_TRNSUM_INL_MEAS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd0fa
 * DEVAD:    1
 * DESC:     Trnsum INL measurement register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_INL_MEAS_EN When 1: trnsum is configured to sum phase error for {D PI code == trnsum_inl_phs_ptr}.Set trnsum_alt_path_en to 'h2 for this feature.Set this field before enabling trnsum.
 *     TRNSUM_INL_PHS_PTR Lower 7 bits of the PI code for which the INL metric is to be measured. Refer to 'trnsum_inl_meas_en'Trnsum accumulators A/B/C/D will accumulate for different 2 MSB bits.Eg: if 7'd1 is used, trnsum_A will accumulate for 9'd1, trnsum_B for 9'd129, C for 9'd257 and D for 9'd389
 *     TRNSUM_PRBS_DP_INVERT This should be set when the data path needs inversion
 *     TRNSUM_PRBS_PRECODER_LOAD_ZERO See trnsum_prbs_precoder_load_seed
 *     TRNSUM_PRBS_PRECODER_AUTOSEED When 1, a rising edge on either trnsum_en or prbs_lock will kick off the load seed function.
 *     TRNSUM_PRBS_PRECODER_LOAD_SEED Self Clearing signal. This is intended to be used when the expected PRBS stream is used either for pattern matching or eye closure.'When asserted, this kicks off a hunt for 8 rclk20 cycles to be error free. On the 8th cycle, the local precoder is seeded with the correct value - if trnsum_prbs_precoder_load_zero == 0, else it loads 0. '
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr (0x0001d0fa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_INL_MEAS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_inl_meas[1];
	uint32_t _dsc_trnsum_inl_meas;
} BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_CLR(r) (r).dsc_trnsum_inl_meas[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_SET(r,d) (r).dsc_trnsum_inl_meas[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_GET(r) (r).dsc_trnsum_inl_meas[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_GET(r) ((((r).dsc_trnsum_inl_meas[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_GET(r) ((((r).dsc_trnsum_inl_meas[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_GET(r) ((((r).dsc_trnsum_inl_meas[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_GET(r) ((((r).dsc_trnsum_inl_meas[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_GET(r) ((((r).dsc_trnsum_inl_meas[0]) >> 1) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1)) | (127 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_GET(r) (((r).dsc_trnsum_inl_meas[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_SET(r,f) (r).dsc_trnsum_inl_meas[0]=(((r).dsc_trnsum_inl_meas[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_INL_MEAS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_INL_MEASr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr,(_r._dsc_trnsum_inl_meas))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_INL_MEASr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr,(_r._dsc_trnsum_inl_meas)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_INL_MEASr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr,(_r._dsc_trnsum_inl_meas))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_INL_MEASr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_inl_meas))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_INL_MEASr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_inl_meas))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_INL_MEASr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_inl_meas))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr
#define DSC_TRNSUM_INL_MEASr_SIZE BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_t DSC_TRNSUM_INL_MEASr_t;
#define DSC_TRNSUM_INL_MEASr_CLR BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_CLR
#define DSC_TRNSUM_INL_MEASr_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_SET
#define DSC_TRNSUM_INL_MEASr_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_SEEDf_SET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_AUTOSEEDf_SET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_PRECODER_LOAD_ZEROf_SET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_PRBS_DP_INVERTf_SET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_PHS_PTRf_SET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_GET
#define DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr_TRNSUM_INL_MEAS_ENf_SET
#define READ_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_READ_DSC_TRNSUM_INL_MEASr
#define WRITE_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_WRITE_DSC_TRNSUM_INL_MEASr
#define MODIFY_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_TRNSUM_INL_MEASr
#define READLN_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_READLN_DSC_TRNSUM_INL_MEASr
#define WRITELN_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_TRNSUM_INL_MEASr
#define WRITEALL_DSC_TRNSUM_INL_MEASr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_TRNSUM_INL_MEASr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_TRNSUM_INL_MEASr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_REVID0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd100
 * DEVAD:    1
 * DESC:     REVID0
 * RESETVAL: 0x366 (870)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm6-7 = reserved
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r (0x0001d100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_REVID0r_s {
	uint32_t v[1];
	uint32_t dig_revid0[1];
	uint32_t _dig_revid0;
} BCMI_BLACKHAWK_XGXS_DIG_REVID0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_CLR(r) (r).dig_revid0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_SET(r,d) (r).dig_revid0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_GET(r) (r).dig_revid0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).dig_revid0[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).dig_revid0[0]) >> 11) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_BONDINGf_GET(r) ((((r).dig_revid0[0]) >> 9) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_BONDINGf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_PROCESSf_GET(r) ((((r).dig_revid0[0]) >> 6) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_PROCESSf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_MODELf_GET(r) (((r).dig_revid0[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_MODELf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DIG_REVID0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r,(_r._dig_revid0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID0r BCMI_BLACKHAWK_XGXS_DIG_REVID0r
#define DIG_REVID0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_REVID0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_REVID0r_t DIG_REVID0r_t;
#define DIG_REVID0r_CLR BCMI_BLACKHAWK_XGXS_DIG_REVID0r_CLR
#define DIG_REVID0r_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_SET
#define DIG_REVID0r_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_GET
#define DIG_REVID0r_REVID_REV_LETTERf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET
#define DIG_REVID0r_REVID_REV_LETTERf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET
#define DIG_REVID0r_REVID_REV_NUMBERf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET
#define DIG_REVID0r_REVID_REV_NUMBERf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET
#define DIG_REVID0r_REVID_BONDINGf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_BONDINGf_GET
#define DIG_REVID0r_REVID_BONDINGf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_BONDINGf_SET
#define DIG_REVID0r_REVID_PROCESSf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_PROCESSf_GET
#define DIG_REVID0r_REVID_PROCESSf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_PROCESSf_SET
#define DIG_REVID0r_REVID_MODELf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_MODELf_GET
#define DIG_REVID0r_REVID_MODELf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID0r_REVID_MODELf_SET
#define READ_DIG_REVID0r BCMI_BLACKHAWK_XGXS_READ_DIG_REVID0r
#define WRITE_DIG_REVID0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID0r
#define MODIFY_DIG_REVID0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID0r
#define READLN_DIG_REVID0r BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID0r
#define WRITELN_DIG_REVID0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID0r
#define WRITEALL_DIG_REVID0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_REVID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_RST_CTL_PMD
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd101
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PMD
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core.This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only bereset by assertion of the hard reset input pin pmd_por_h_rstb
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.This regiter bit can only be reset by assertion of the hard reset input pin pmd_por_h_rstb.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr (0x0001d101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_PMD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_pmd[1];
	uint32_t _dig_rst_ctl_pmd;
} BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CLR(r) (r).dig_rst_ctl_pmd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_SET(r,d) (r).dig_rst_ctl_pmd[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_GET(r) (r).dig_rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_GET(r) ((((r).dig_rst_ctl_pmd[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).dig_rst_ctl_pmd[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_RST_CTL_PMD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_pmd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr
#define DIG_RST_CTL_PMDr_SIZE BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_t DIG_RST_CTL_PMDr_t;
#define DIG_RST_CTL_PMDr_CLR BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CLR
#define DIG_RST_CTL_PMDr_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_SET
#define DIG_RST_CTL_PMDr_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_GET
#define DIG_RST_CTL_PMDr_UC_ACTIVEf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_GET
#define DIG_RST_CTL_PMDr_UC_ACTIVEf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_SET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_READ_DIG_RST_CTL_PMDr
#define WRITE_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_CTL_PMDr
#define MODIFY_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_CTL_PMDr
#define READLN_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_CTL_PMDr
#define WRITELN_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_CTL_PMDr
#define WRITEALL_DIG_RST_CTL_PMDr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_CTL_PMDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_PMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_RST_CTL_CORE_DP
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd102
 * DEVAD:    1
 * DESC:     RESET_CONTROL_CORE_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence force value.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     DISABLE_ACK_TIMEOUT Setting this bit to 1 disables the ack timeout for all ports.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr (0x0001d102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_CORE_DP.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_core_dp[1];
	uint32_t _dig_rst_ctl_core_dp;
} BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_CLR(r) (r).dig_rst_ctl_core_dp[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SET(r,d) (r).dig_rst_ctl_core_dp[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_GET(r) (r).dig_rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access DIG_RST_CTL_CORE_DP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_core_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr
#define DIG_RST_CTL_CORE_DPr_SIZE BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_t DIG_RST_CTL_CORE_DPr_t;
#define DIG_RST_CTL_CORE_DPr_CLR BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_CLR
#define DIG_RST_CTL_CORE_DPr_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SET
#define DIG_RST_CTL_CORE_DPr_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define READ_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_READ_DIG_RST_CTL_CORE_DPr
#define WRITE_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_CTL_CORE_DPr
#define MODIFY_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr
#define READLN_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_CTL_CORE_DPr
#define WRITELN_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr
#define WRITEALL_DIG_RST_CTL_CORE_DPr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_RST_CTL_CORE_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_MASKDATA
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd103
 * DEVAD:    1
 * DESC:     MASKDATA_REG
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MASKDATA         maskdata for writes that can be used with PMI_LP or PMI_MDIO port. This register will get reset to 0 after each transaction.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr (0x0001d103 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_SIZE 4

/*
 * This structure should be used to declare and program DIG_MASKDATA.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_s {
	uint32_t v[1];
	uint32_t dig_maskdata[1];
	uint32_t _dig_maskdata;
} BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_CLR(r) (r).dig_maskdata[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_SET(r,d) (r).dig_maskdata[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_GET(r) (r).dig_maskdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_MASKDATAf_GET(r) (((r).dig_maskdata[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_MASKDATAf_SET(r,f) (r).dig_maskdata[0]=(((r).dig_maskdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DIG_MASKDATA.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_MASKDATAr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr,(_r._dig_maskdata))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_MASKDATAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr,(_r._dig_maskdata)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_MASKDATAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr,(_r._dig_maskdata))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_MASKDATAr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_maskdata))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_MASKDATAr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_maskdata))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_MASKDATAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_maskdata))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr
#define DIG_MASKDATAr_SIZE BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_t DIG_MASKDATAr_t;
#define DIG_MASKDATAr_CLR BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_CLR
#define DIG_MASKDATAr_SET BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_SET
#define DIG_MASKDATAr_GET BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_GET
#define DIG_MASKDATAr_MASKDATAf_GET BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_MASKDATAf_GET
#define DIG_MASKDATAr_MASKDATAf_SET BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr_MASKDATAf_SET
#define READ_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_READ_DIG_MASKDATAr
#define WRITE_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_WRITE_DIG_MASKDATAr
#define MODIFY_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_MASKDATAr
#define READLN_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_READLN_DIG_MASKDATAr
#define WRITELN_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_MASKDATAr
#define WRITEALL_DIG_MASKDATAr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_MASKDATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_MASKDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_TOP_USER_CTL0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd104
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL_0
 * RESETVAL: 0x271 (625)
 * ACCESS:   R/W
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     MASKDATA_BUS_ASSIGN This register is used to assign the maskdata bus to either the mdio or pmi_lp port .0: maskdata register is assigned to MDIO port1: maskdata register is assigned to PMI_LP port
 *     MDIO_FAST_MODE_FRC_VAL This value will be used to drive the internal mdio_fast_mode signal when mdio_fast_mode_frc is set to 1.0: Normal mdio frame operation with preamble1: Fast mdio frame operation without preamble
 *     MDIO_FAST_MODE_FRC Setting this bit will allow the register value to be used for mdio_fast_mode.Otherwise the pin mdio_fast_mode will be used.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r (0x0001d104 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TOP_USER_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t dig_top_user_ctl0[1];
	uint32_t _dig_top_user_ctl0;
} BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_CLR(r) (r).dig_top_user_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_SET(r,d) (r).dig_top_user_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_GET(r) (r).dig_top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).dig_top_user_ctl0[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DIG_TOP_USER_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_top_user_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r
#define DIG_TOP_USER_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_t DIG_TOP_USER_CTL0r_t;
#define DIG_TOP_USER_CTL0r_CLR BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_CLR
#define DIG_TOP_USER_CTL0r_SET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_SET
#define DIG_TOP_USER_CTL0r_GET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_READ_DIG_TOP_USER_CTL0r
#define WRITE_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_TOP_USER_CTL0r
#define MODIFY_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_TOP_USER_CTL0r
#define READLN_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_READLN_DIG_TOP_USER_CTL0r
#define WRITELN_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_TOP_USER_CTL0r
#define WRITEALL_DIG_TOP_USER_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_TOP_USER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_TOP_USER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_CORE_RST_OCC_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd106
 * DEVAD:    1
 * DESC:     CORE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_REG_RESET_OCCURRED Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr (0x0001d106 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_RST_OCC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t dig_core_rst_occ_ctl[1];
	uint32_t _dig_core_rst_occ_ctl;
} BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CLR(r) (r).dig_core_rst_occ_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_SET(r,d) (r).dig_core_rst_occ_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_GET(r) (r).dig_core_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET(r) (((r).dig_core_rst_occ_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET(r,f) (r).dig_core_rst_occ_ctl[0]=(((r).dig_core_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_CORE_RST_OCC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr
#define DIG_CORE_RST_OCC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_t DIG_CORE_RST_OCC_CTLr_t;
#define DIG_CORE_RST_OCC_CTLr_CLR BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CLR
#define DIG_CORE_RST_OCC_CTLr_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_SET
#define DIG_CORE_RST_OCC_CTLr_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET
#define READ_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READ_DIG_CORE_RST_OCC_CTLr
#define WRITE_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr
#define MODIFY_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr
#define READLN_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READLN_DIG_CORE_RST_OCC_CTLr
#define WRITELN_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr
#define WRITEALL_DIG_CORE_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_CORE_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_RST_SEQ_TMR_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd107
 * DEVAD:    1
 * DESC:     RST_SEQ_TIMER_CONTROL
 * RESETVAL: 0x8304 (33540)
 * ACCESS:   R/W
 * FIELDS:
 *     RST_SEQ_TIMER    Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 2 to 16 clock cycles between de-assertion of AFE RX/TX lane resetand clock muxing from comclk to lane clock. Wait_time = 2 * (rst_seq_timer + 1).
 *     PWRDN_SEQ_TIMER  Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdnand clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1).
 *     RST_SEQ_DIS_FLT_MODE Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.2'd0 - filter is bypassed where input is passed to output untouched.2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr (0x0001d107 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_SEQ_TMR_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t dig_rst_seq_tmr_ctl[1];
	uint32_t _dig_rst_seq_tmr_ctl;
} BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR(r) (r).dig_rst_seq_tmr_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_SET(r,d) (r).dig_rst_seq_tmr_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_GET(r) (r).dig_rst_seq_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET(r) (((r).dig_rst_seq_tmr_ctl[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DIG_RST_SEQ_TMR_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_seq_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr
#define DIG_RST_SEQ_TMR_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_t DIG_RST_SEQ_TMR_CTLr_t;
#define DIG_RST_SEQ_TMR_CTLr_CLR BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR
#define DIG_RST_SEQ_TMR_CTLr_SET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_SET
#define DIG_RST_SEQ_TMR_CTLr_GET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET
#define READ_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_READ_DIG_RST_SEQ_TMR_CTLr
#define WRITE_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr
#define MODIFY_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr
#define READLN_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr
#define WRITELN_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr
#define WRITEALL_DIG_RST_SEQ_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_RST_SEQ_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_CORE_DP_RST_ST_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd108
 * DEVAD:    1
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_RESET_RELEASED_INDEX Index of the lane number of the first TX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first RX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {rx_lane_dp_reset_active, rx_lane_dp_reset_occurred} = 01.
 *     TX_LANE_RESET_RELEASED indicates if a lane is currently at {tx_lane_dp_reset_active, tx_lane_dp_reset_occurred} = 01.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr (0x0001d108 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_DP_RST_ST_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t dig_core_dp_rst_st_sts[1];
	uint32_t _dig_core_dp_rst_st_sts;
} BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_t;

#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR(r) (r).dig_core_dp_rst_st_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_SET(r,d) (r).dig_core_dp_rst_st_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_GET(r) (r).dig_core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 3) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))

/*
 * These macros can be used to access DIG_CORE_DP_RST_ST_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr
#define DIG_CORE_DP_RST_ST_STSr_SIZE BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_t DIG_CORE_DP_RST_ST_STSr_t;
#define DIG_CORE_DP_RST_ST_STSr_CLR BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR
#define DIG_CORE_DP_RST_ST_STSr_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_SET
#define DIG_CORE_DP_RST_ST_STSr_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET
#define READ_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READ_DIG_CORE_DP_RST_ST_STSr
#define WRITE_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr
#define MODIFY_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr
#define READLN_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr
#define WRITELN_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr
#define WRITEALL_DIG_CORE_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_CORE_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_REVID1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10a
 * DEVAD:    1
 * DESC:     REVID1
 * RESETVAL: 0x803c (32828)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r (0x0001d10a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_REVID1r_s {
	uint32_t v[1];
	uint32_t dig_revid1[1];
	uint32_t _dig_revid1;
} BCMI_BLACKHAWK_XGXS_DIG_REVID1r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_CLR(r) (r).dig_revid1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_SET(r,d) (r).dig_revid1[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_GET(r) (r).dig_revid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).dig_revid1[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MDIOf_GET(r) ((((r).dig_revid1[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MDIOf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MICROf_GET(r) ((((r).dig_revid1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MICROf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_CL72f_GET(r) ((((r).dig_revid1[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_CL72f_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_PIRf_GET(r) ((((r).dig_revid1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_PIRf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_LLPf_GET(r) ((((r).dig_revid1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_LLPf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_EEEf_GET(r) (((r).dig_revid1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_EEEf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_REVID1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r,(_r._dig_revid1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID1r BCMI_BLACKHAWK_XGXS_DIG_REVID1r
#define DIG_REVID1r_SIZE BCMI_BLACKHAWK_XGXS_DIG_REVID1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_REVID1r_t DIG_REVID1r_t;
#define DIG_REVID1r_CLR BCMI_BLACKHAWK_XGXS_DIG_REVID1r_CLR
#define DIG_REVID1r_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_SET
#define DIG_REVID1r_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET
#define DIG_REVID1r_REVID_MDIOf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MDIOf_GET
#define DIG_REVID1r_REVID_MDIOf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MDIOf_SET
#define DIG_REVID1r_REVID_MICROf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MICROf_GET
#define DIG_REVID1r_REVID_MICROf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_MICROf_SET
#define DIG_REVID1r_REVID_CL72f_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_CL72f_GET
#define DIG_REVID1r_REVID_CL72f_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_CL72f_SET
#define DIG_REVID1r_REVID_PIRf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_PIRf_GET
#define DIG_REVID1r_REVID_PIRf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_PIRf_SET
#define DIG_REVID1r_REVID_LLPf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_LLPf_GET
#define DIG_REVID1r_REVID_LLPf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_LLPf_SET
#define DIG_REVID1r_REVID_EEEf_GET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_EEEf_GET
#define DIG_REVID1r_REVID_EEEf_SET BCMI_BLACKHAWK_XGXS_DIG_REVID1r_REVID_EEEf_SET
#define READ_DIG_REVID1r BCMI_BLACKHAWK_XGXS_READ_DIG_REVID1r
#define WRITE_DIG_REVID1r BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID1r
#define MODIFY_DIG_REVID1r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID1r
#define READLN_DIG_REVID1r BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID1r
#define WRITELN_DIG_REVID1r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID1r
#define WRITEALL_DIG_REVID1r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_REVID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_REVID2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10e
 * DEVAD:    1
 * DESC:     REVID2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID2           Revision ID2 code
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r (0x0001d10e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_REVID2r_s {
	uint32_t v[1];
	uint32_t dig_revid2[1];
	uint32_t _dig_revid2;
} BCMI_BLACKHAWK_XGXS_DIG_REVID2r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_CLR(r) (r).dig_revid2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_SET(r,d) (r).dig_revid2[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_GET(r) (r).dig_revid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_REVID2f_GET(r) (((r).dig_revid2[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DIG_REVID2r_REVID2f_SET(r,f) (r).dig_revid2[0]=(((r).dig_revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DIG_REVID2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r,(_r._dig_revid2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID2r BCMI_BLACKHAWK_XGXS_DIG_REVID2r
#define DIG_REVID2r_SIZE BCMI_BLACKHAWK_XGXS_DIG_REVID2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_REVID2r_t DIG_REVID2r_t;
#define DIG_REVID2r_CLR BCMI_BLACKHAWK_XGXS_DIG_REVID2r_CLR
#define DIG_REVID2r_SET BCMI_BLACKHAWK_XGXS_DIG_REVID2r_SET
#define DIG_REVID2r_GET BCMI_BLACKHAWK_XGXS_DIG_REVID2r_GET
#define DIG_REVID2r_REVID2f_GET BCMI_BLACKHAWK_XGXS_DIG_REVID2r_REVID2f_GET
#define DIG_REVID2r_REVID2f_SET BCMI_BLACKHAWK_XGXS_DIG_REVID2r_REVID2f_SET
#define READ_DIG_REVID2r BCMI_BLACKHAWK_XGXS_READ_DIG_REVID2r
#define WRITE_DIG_REVID2r BCMI_BLACKHAWK_XGXS_WRITE_DIG_REVID2r
#define MODIFY_DIG_REVID2r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_REVID2r
#define READLN_DIG_REVID2r BCMI_BLACKHAWK_XGXS_READLN_DIG_REVID2r
#define WRITELN_DIG_REVID2r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_REVID2r
#define WRITEALL_DIG_REVID2r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_REVID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_REVID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL0
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd110
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_0
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SET_CLK4PCS program clk freq for clk4pcs. Combine with pll_ctrl[107] to form 3-bit control register. See AMS for details. amsbus ctrl_out  1:0DFT_MUX
 *     AMS_PLL_CP_CMFDBK_IADJ increases CP opamp current, 00:50uA, x1:CMF=100uA, 1x:UG=100uA amsbus ctrl_out  3:2DFT_MUX
 *     AMS_PLL_FP3_CTRL adjusts caps in 3rd pole, typically used in frc-N mode, and with fp3_rh, higher code=lower pole freq amsbus ctrl_out  7:4DFT_MUX
 *     AMS_PLL_FP3_RH   adjust res in 3rd pole by 4x amsbus ctrl_out  8:8DFT_MUX
 *     AMS_PLL_LPF_RZ   adjust Rz in the loop filter, 00=0.71K, 01=1K, 10=1.7K, 11=5K amsbus ctrl_out  10:9DFT_MUX
 *     AMS_PLL_SPARE_11_11 AMS reserved[11:11] amsbus ctrl_out  11:11DFT_DFS=1'd0
 *     AMS_PLL_RESCAL_AUX over-ride ana_rescal[3:0] if force_rescal(pll_ctrl[79])=1 amsbus ctrl_out  15:12DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r (0x0001d110 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl0[1];
	uint32_t _ams_pll_pll_ctl0;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_CLR(r) (r).ams_pll_pll_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_SET(r,d) (r).ams_pll_pll_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_GET(r) (r).ams_pll_pll_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 9) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET(r) (((r).ams_pll_pll_ctl0[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r
#define AMS_PLL_PLL_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_t AMS_PLL_PLL_CTL0r_t;
#define AMS_PLL_PLL_CTL0r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_CLR
#define AMS_PLL_PLL_CTL0r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_SET
#define AMS_PLL_PLL_CTL0r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_11_11f_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET
#define READ_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL0r
#define WRITE_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL0r
#define MODIFY_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL0r
#define READLN_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL0r
#define WRITELN_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL0r
#define WRITEALL_AMS_PLL_PLL_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL1
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd111
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_1
 * RESETVAL: 0x8001 (32769)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_COMP_THRESH VCO tuning threshold (See AMS for details) amsbus ctrl_out  18:16DFT_MUX
 *     AMS_PLL_DRV_HV_DISABLE must be 0 if TVDD1P20=1.2V amsbus ctrl_out  19:19DFT_MUX
 *     AMS_PLL_SPARE_20_20 AMS reserved[20] amsbus ctrl_out  20:20DFT_DFS=1'd0
 *     AMS_PLL_VCO_RES_CS test mode to enable a resistor only current bias for the main VCO, should reduce RJ, possibly worse PSRR amsbus ctrl_out  21:21DFT_MUX
 *     AMS_PLL_VCO_AUTOGM enables auto reduction of the VCO gm for lower jitter when pll_range > 128d amsbus ctrl_out  22:22DFT_MUX
 *     AMS_PLL_VCO2_15G enable and select the 15-22.6G VCO amsbus ctrl_out  23:23DFT_MUX
 *     AMS_PLL_VCOICTRL adjusts VCO bias current, ~6% steps. Only active if pll_ctrl[21]=0. amsbus ctrl_out  25:24DFT_MUX
 *     AMS_PLL_TEST_VCO2_CSSW test mode to disable current bias and convert current source to a switch. Could help with startup problems. amsbus ctrl_out  26:26DFT_MUX
 *     AMS_PLL_IVCO     ivco[2:0], max, min, mode amsbus ctrl_out  29:27DFT_MUX
 *     AMS_PLL_RESET    PLL reset, active high amsbus ctrl_out  30:30DFT_MUX
 *     AMS_PLL_ENABLE_FTUNE comparator for VCO tuning amsbus ctrl_out  31:31DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r (0x0001d111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl1[1];
	uint32_t _ams_pll_pll_ctl1;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_CLR(r) (r).ams_pll_pll_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_SET(r,d) (r).ams_pll_pll_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_GET(r) (r).ams_pll_pll_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 11) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET(r) (((r).ams_pll_pll_ctl1[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r
#define AMS_PLL_PLL_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_t AMS_PLL_PLL_CTL1r_t;
#define AMS_PLL_PLL_CTL1r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_CLR
#define AMS_PLL_PLL_CTL1r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_SET
#define AMS_PLL_PLL_CTL1r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_AUTOGMf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_20_20f_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET
#define READ_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL1r
#define WRITE_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL1r
#define MODIFY_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL1r
#define READLN_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL1r
#define WRITELN_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL1r
#define WRITEALL_AMS_PLL_PLL_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL2
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd112
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_2
 * RESETVAL: 0xf (15)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IQP      charge pump current, 50,100,150,..800uA amsbus ctrl_out  35:32DFT_MUX
 *     AMS_PLL_VDD88_EN keep bias current at 100uA if PVDD0P8=0.88V, typ amsbus ctrl_out  36:36DFT_MUX
 *     AMS_PLL_REFL_PLL when pll_ctrl[75]=1, decrease Ibias 10% amsbus ctrl_out  37:37DFT_MUX
 *     AMS_PLL_REFH_PLL when pll_ctrl[75]=1, increase Ibias 10% amsbus ctrl_out  38:38DFT_MUX
 *     AMS_PLL_IMIN_IBIAS see AMS amsbus ctrl_out  39:39DFT_MUX
 *     AMS_PLL_IMODE_IBIAS sign is reversed vs current sources amsbus ctrl_out  40:40DFT_MUX
 *     AMS_PLL_IMAX_IBIAS ibias all 6 above - master diode in biasgen amsbus ctrl_out  41:41DFT_MUX
 *     AMS_PLL_IMIN_ICP see AMS amsbus ctrl_out  42:42DFT_MUX
 *     AMS_PLL_IMODE_ICP see AMS amsbus ctrl_out  43:43DFT_MUX
 *     AMS_PLL_IMAX_ICP charge pump amsbus ctrl_out  44:44DFT_MUX
 *     AMS_PLL_IMIN_ICK see AMS amsbus ctrl_out  45:45DFT_MUX
 *     AMS_PLL_IMODE_ICK see AMS amsbus ctrl_out  46:46DFT_MUX
 *     AMS_PLL_IMAX_ICK refclk input buffer amsbus ctrl_out  47:47DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r (0x0001d112 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl2[1];
	uint32_t _ams_pll_pll_ctl2;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_CLR(r) (r).ams_pll_pll_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_SET(r,d) (r).ams_pll_pll_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_GET(r) (r).ams_pll_pll_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET(r) (((r).ams_pll_pll_ctl2[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r,(_r._ams_pll_pll_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r,(_r._ams_pll_pll_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r,(_r._ams_pll_pll_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r
#define AMS_PLL_PLL_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_t AMS_PLL_PLL_CTL2r_t;
#define AMS_PLL_PLL_CTL2r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_CLR
#define AMS_PLL_PLL_CTL2r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_SET
#define AMS_PLL_PLL_CTL2r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_VDD88_ENf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET
#define READ_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL2r
#define WRITE_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL2r
#define MODIFY_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL2r
#define READLN_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL2r
#define WRITELN_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL2r
#define WRITEALL_AMS_PLL_PLL_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL3
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd113
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IMIN_IRXCLKBUF see AMS amsbus ctrl_out  48:48DFT_MUX
 *     AMS_PLL_IMODE_IRXCLKBUF see AMS amsbus ctrl_out  49:49DFT_MUX
 *     AMS_PLL_IMAX_IRXCLKBUF rxclkbuf amsbus ctrl_out  50:50DFT_MUX
 *     AMS_PLL_IMIN_ICMLDIV see AMS amsbus ctrl_out  51:51DFT_MUX
 *     AMS_PLL_IMODE_ICMLDIV see AMS amsbus ctrl_out  52:52DFT_MUX
 *     AMS_PLL_IMAX_ICMLDIV VCO divider/buffer amsbus ctrl_out  53:53DFT_MUX
 *     AMS_PLL_IMIN_ICOMP see AMS amsbus ctrl_out  54:54DFT_MUX
 *     AMS_PLL_IMODE_ICOMP see AMS amsbus ctrl_out  55:55DFT_MUX
 *     AMS_PLL_IMAX_ICOMP VCO comparator amsbus ctrl_out  56:56DFT_MUX
 *     AMS_PLL_IMIN_IOP see AMS amsbus ctrl_out  57:57DFT_MUX
 *     AMS_PLL_IMODE_IOP see AMS amsbus ctrl_out  58:58DFT_MUX
 *     AMS_PLL_IMAX_IOP test current amsbus ctrl_out  59:59DFT_MUX
 *     AMS_PLL_TEST_VREF test vref amsbus ctrl_out  60:60DFT_MUX
 *     AMS_PLL_TEST_VC  test Vcontrol. See section 36 of AMS amsbus ctrl_out  61:61DFT_MUX
 *     AMS_PLL_TEST_PLL output divided VCO clk both on - test LC amsbus ctrl_out  62:62DFT_MUX
 *     AMS_PLL_TEST_RX  send RX word ck to PLL test port amsbus ctrl_out  63:63DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r (0x0001d113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl3[1];
	uint32_t _ams_pll_pll_ctl3;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_CLR(r) (r).ams_pll_pll_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_SET(r,d) (r).ams_pll_pll_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_GET(r) (r).ams_pll_pll_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET(r) (((r).ams_pll_pll_ctl3[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r,(_r._ams_pll_pll_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r,(_r._ams_pll_pll_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r,(_r._ams_pll_pll_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r
#define AMS_PLL_PLL_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_t AMS_PLL_PLL_CTL3r_t;
#define AMS_PLL_PLL_CTL3r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_CLR
#define AMS_PLL_PLL_CTL3r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_SET
#define AMS_PLL_PLL_CTL3r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET
#define READ_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL3r
#define WRITE_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL3r
#define MODIFY_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL3r
#define READLN_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL3r
#define WRITELN_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL3r
#define WRITEALL_AMS_PLL_PLL_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL4
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd114
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_4
 * RESETVAL: 0x77 (119)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_BGR_PTATADJ BG bias, same decoder as CTAT amsbus ctrl_out  67:64DFT_MUX
 *     AMS_PLL_BGR_CTATADJ BG CTAT bias control amsbus ctrl_out  71:68DFT_MUX
 *     AMS_PLL_PLL2RX_CLKBW controls BW of PLL output buffers for the RX/TX clks. See AMS for details. amsbus ctrl_out  73:72DFT_MUX
 *     AMS_PLL_TEST_VDDR4BG test mode to force VddR bias to BG amsbus ctrl_out  74:74DFT_MUX
 *     AMS_PLL_VDDR_BGB select between PVDD or BG, default, Vreference for the PLL bias currents amsbus ctrl_out  75:75DFT_MUX
 *     AMS_PLL_KVH_FORCE force Kvco, override tuning control amsbus ctrl_out  77:76DFT_MUX
 *     AMS_PLL_FORCE_KVH_BW enable force KVH,BW,test_vco2_cssw modes amsbus ctrl_out  78:78DFT_MUX
 *     AMS_PLL_FORCE_RESCAL force_rescal with pll_ctrl<15:12> amsbus ctrl_out  79:79DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r (0x0001d114 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl4[1];
	uint32_t _ams_pll_pll_ctl4;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_CLR(r) (r).ams_pll_pll_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_SET(r,d) (r).ams_pll_pll_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_GET(r) (r).ams_pll_pll_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET(r) (((r).ams_pll_pll_ctl4[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r
#define AMS_PLL_PLL_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_t AMS_PLL_PLL_CTL4r_t;
#define AMS_PLL_PLL_CTL4r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_CLR
#define AMS_PLL_PLL_CTL4r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_SET
#define AMS_PLL_PLL_CTL4r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET
#define READ_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL4r
#define WRITE_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL4r
#define MODIFY_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL4r
#define READLN_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL4r
#define WRITELN_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL4r
#define WRITEALL_AMS_PLL_PLL_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL5
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd115
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_5
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_MAX_TEST_PORT_AMPLITUDE 325 mVppse, with 50 ohm termination, default ~250 mVppse amsbus ctrl_out  80:80DFT_MUX
 *     AMS_PLL_BGIP     test, measure Ibg internal PMOS current, ~40uA, or 20uA each for P/CTAT amsbus ctrl_out  81:81DFT_MUX
 *     AMS_PLL_BGINT    test enable and measure Vbg internal, ~0.4V, using BG res, and P/CTAT portions. Must not be enabled during functional operation amsbus ctrl_out  82:82DFT_MUX
 *     AMS_PLL_VBYPASS  test, bypass test port opamp buffer amsbus ctrl_out  83:83DFT_MUX
 *     AMS_PLL_TEST_PNP Measure internal BG nodes, NPN 00:off, 01:Vbe, 10:Vbe2, 11:Vbe_low. To fully enable this mode, pll_ctrl[83:82]=11 amsbus ctrl_out  85:84DFT_MUX
 *     AMS_PLL_MIX3P1C_CALR_CTATADJ bias control for Mix3P1C/calR amsbus ctrl_out  90:86DFT_MUX
 *     AMS_PLL_MIX3P1C_CALR_PTATADJ bias control for Mix3P1C/calR amsbus ctrl_out  95:91DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r (0x0001d115 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl5[1];
	uint32_t _ams_pll_pll_ctl5;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_CLR(r) (r).ams_pll_pll_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_SET(r,d) (r).ams_pll_pll_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_GET(r) (r).ams_pll_pll_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_GET(r) (((r).ams_pll_pll_ctl5[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r,(_r._ams_pll_pll_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r,(_r._ams_pll_pll_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r,(_r._ams_pll_pll_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r
#define AMS_PLL_PLL_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_t AMS_PLL_PLL_CTL5r_t;
#define AMS_PLL_PLL_CTL5r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_CLR
#define AMS_PLL_PLL_CTL5r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_SET
#define AMS_PLL_PLL_CTL5r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLITUDEf_SET
#define READ_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL5r
#define WRITE_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL5r
#define MODIFY_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL5r
#define READLN_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL5r
#define WRITELN_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL5r
#define WRITEALL_AMS_PLL_PLL_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL6
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd116
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM200 set refclk termination impedance to 200 ohm amsbus ctrl_out  96:96DFT_MUX
 *     AMS_PLL_DIV2     input refclk divided 2 amsbus ctrl_out  97:97
 *     AMS_PLL_DIV4     input refclk divided 4 amsbus ctrl_out  98:98
 *     AMS_PLL_RTERM400 set refclk termination impedance to 400 ohm differential amsbus ctrl_out  99:99DFT_MUX
 *     AMS_PLL_RTERMHIZ set refclk termination impedance to HiZ amsbus ctrl_out  100:100DFT_MUX
 *     AMS_PLL_RTERM300 set refclk termination impedance to 300 ohm differential amsbus ctrl_out  101:101DFT_MUX
 *     AMS_PLL_CLK4SYNC_DIV Sets clk4sync output freq, 0=8T, 1=6T and T=1/VCO freq amsbus ctrl_out  102:102DFT_MUX
 *     AMS_PLL_CLK4SYNC_EN Enable control for clk4sync clock (0=disable, 1=enable) amsbus ctrl_out  103:103
 *     AMS_PLL_DOUBLER_CAP increases supported refclk freq by reducing delay with lower cap amsbus ctrl_out  106:104DFT_MUX
 *     AMS_PLL_SET_CLK4PCS_MSB msb of set_clk4pcs control. See definition of control bits 1:0 amsbus ctrl_out  107:107DFT_MUX
 *     AMS_PLL_DOUBLER_RES increases supported refclk freq by reducing delay with lower res. See AMS for details. amsbus ctrl_out  110:108DFT_MUX
 *     AMS_PLL_REFCLK_DOUBLER test mode pending lab data, increases internal refclk freq by 2X and should be useful for frac-N mode to reduce the Q noise. amsbus ctrl_out  111:111DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r (0x0001d116 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl6[1];
	uint32_t _ams_pll_pll_ctl6;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_CLR(r) (r).ams_pll_pll_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_SET(r,d) (r).ams_pll_pll_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_GET(r) (r).ams_pll_pll_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET(r) (((r).ams_pll_pll_ctl6[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r
#define AMS_PLL_PLL_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_t AMS_PLL_PLL_CTL6r_t;
#define AMS_PLL_PLL_CTL6r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_CLR
#define AMS_PLL_PLL_CTL6r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_SET
#define AMS_PLL_PLL_CTL6r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET
#define READ_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL6r
#define WRITE_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL6r
#define MODIFY_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL6r
#define READLN_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL6r
#define WRITELN_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL6r
#define WRITEALL_AMS_PLL_PLL_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL7
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd117
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_7
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_TEST_FRACN_EN test mode to power up fracn block when using the integer block and check for noise amsbus ctrl_out  112:112DFT_MUX
 *     AMS_PLL_PFD_SKEW_ENLARGE increases above delays to ~300ps. All are optional settings for frac-N mode amsbus ctrl_out  113:113DFT_MUX
 *     AMS_PLL_PFD_FB_SKEW adds ~150ps of delay in fdbck path amsbus ctrl_out  114:114DFT_MUX
 *     AMS_PLL_PFD_REF_SKEW adds ~150ps of delay in refclk path amsbus ctrl_out  115:115DFT_MUX
 *     AMS_PLL_NDIV_FRAC_VALID toggle high, then low to load in a new value for fracn_div[17:0]. This new mode should minimize any glitches when the fractional value is changed dynamically amsbus ctrl_out  116:116DFT_MUX
 *     AMS_PLL_VCODIV_REFOUT enables VCO divided by integer value, eg 80, and sent to refoutp/n, TBD for now amsbus ctrl_out  117:117DFT_MUX
 *     AMS_PLL_MIX3P1CR_CTATADJ CTAT bias control for Mix3P1C/R amsbus ctrl_out  122:118DFT_MUX
 *     AMS_PLL_MIX3P1CR_PTATADJ PTAT bias control for Mix3P1C/R which is used in RX amsbus ctrl_out  127:123DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r (0x0001d117 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl7[1];
	uint32_t _ams_pll_pll_ctl7;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_CLR(r) (r).ams_pll_pll_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_SET(r,d) (r).ams_pll_pll_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_GET(r) (r).ams_pll_pll_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET(r) (((r).ams_pll_pll_ctl7[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r
#define AMS_PLL_PLL_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_t AMS_PLL_PLL_CTL7r_t;
#define AMS_PLL_PLL_CTL7r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_CLR
#define AMS_PLL_PLL_CTL7r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_SET
#define AMS_PLL_PLL_CTL7r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET
#define READ_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL7r
#define WRITE_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL7r
#define MODIFY_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL7r
#define READLN_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL7r
#define WRITELN_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL7r
#define WRITEALL_AMS_PLL_PLL_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL8
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd118
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV lower 16 bits fractional control of feedback divider. See AMS for details. amsbus ctrl_out  143:128DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r (0x0001d118 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL8.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl8[1];
	uint32_t _ams_pll_pll_ctl8;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_CLR(r) (r).ams_pll_pll_ctl8[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_SET(r,d) (r).ams_pll_pll_ctl8[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_GET(r) (r).ams_pll_pll_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET(r) (((r).ams_pll_pll_ctl8[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET(r,f) (r).ams_pll_pll_ctl8[0]=(((r).ams_pll_pll_ctl8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r
#define AMS_PLL_PLL_CTL8r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_t AMS_PLL_PLL_CTL8r_t;
#define AMS_PLL_PLL_CTL8r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_CLR
#define AMS_PLL_PLL_CTL8r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_SET
#define AMS_PLL_PLL_CTL8r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET
#define READ_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL8r
#define WRITE_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL8r
#define MODIFY_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL8r
#define READLN_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL8r
#define WRITELN_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL8r
#define WRITEALL_AMS_PLL_PLL_CTL8r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL9
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd119
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV_17_16 Upper 2 bits for fractional divider amsbus ctrl_out  145:144DFT_MUX
 *     AMS_PLL_FRACN_DIVRANGE selects MMD integer range for the value programmed by fracn_ndiv_int[9:0]. See AMS for details. amsbus ctrl_out  146:146DFT_MUX
 *     AMS_PLL_FRACN_BYPASS test option to bypass the integer mode of the frac-N SDM block. See AMS for details amsbus ctrl_out  147:147DFT_MUX
 *     AMS_PLL_FRACN_NDIV_INT fracn-N feedback divider integer control, See AMS for details amsbus ctrl_out  157:148DFT_MUX
 *     AMS_PLL_DITHEREN enables dithering to reduce the refclk spur, and can be used during frac-N integer mode amsbus ctrl_out  158:158DFT_MUX
 *     AMS_PLL_FRACN_SEL master enable and select for the frac-N mode, disables the orignal integer mode controlled by pll_mode amsbus ctrl_out  159:159DFT_MUX
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r (0x0001d119 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL9.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl9[1];
	uint32_t _ams_pll_pll_ctl9;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_CLR(r) (r).ams_pll_pll_ctl9[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_SET(r,d) (r).ams_pll_pll_ctl9[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_GET(r) (r).ams_pll_pll_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 4) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3ff << 4)) | ((((uint32_t)f) & 0x3ff) << 4)) | (1023 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET(r) (((r).ams_pll_pll_ctl9[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r
#define AMS_PLL_PLL_CTL9r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_t AMS_PLL_PLL_CTL9r_t;
#define AMS_PLL_PLL_CTL9r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_CLR
#define AMS_PLL_PLL_CTL9r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_SET
#define AMS_PLL_PLL_CTL9r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET
#define READ_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL9r
#define WRITE_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL9r
#define MODIFY_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL9r
#define READLN_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL9r
#define WRITELN_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL9r
#define WRITEALL_AMS_PLL_PLL_CTL9r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL_10
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11a
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RX_CLK_RPTR_PD disables clock repeater buffer to send RX IQ clocks from one quad to the other one amsbus ctrl_out  160:160DFT_MUX
 *     AMS_PLL_RX_CLKRPTR_BIAS rxclk_rptr,max,mode,min - bias currents for RX clock repeater buffers, 3P1C/calR amsbus ctrl_out  163:161DFT_MUX
 *     AMS_PLL_RX_CLKRPTR_BW similar to pll_ctrl[73:72] amsbus ctrl_out  165:164DFT_MUX
 *     AMS_PLL_SPARE_167_166 AMS reserved[167:166] amsbus ctrl_out  167:166DFT_DFS=2'd0
 *     AMS_PLL_TX_CLK_RPTR_PD disables clock repeater buffer to send TX IQ clocks from one quad to the other one amsbus ctrl_out  168:168DFT_MUX
 *     AMS_PLL_TX_CLKRPTR_BIAS txclk_rptr,max,mode,min - bias currents for TX clock repeater buffers, 3P1C/calR amsbus ctrl_out  171:169DFT_MUX
 *     AMS_PLL_TX_CLKRPTR_BW similar to pll_ctrl[73:72] amsbus ctrl_out  173:172DFT_MUX
 *     AMS_PLL_SPARE_175_174 AMS reserved[175:174] amsbus ctrl_out  175:174DFT_DFS=2'd0
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r (0x0001d11a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL_10.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl_10[1];
	uint32_t _ams_pll_pll_ctl_10;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_CLR(r) (r).ams_pll_pll_ctl_10[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_SET(r,d) (r).ams_pll_pll_ctl_10[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_GET(r) (r).ams_pll_pll_ctl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 9) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_GET(r) ((((r).ams_pll_pll_ctl_10[0]) >> 1) & 0x7)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_GET(r) (((r).ams_pll_pll_ctl_10[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_SET(r,f) (r).ams_pll_pll_ctl_10[0]=(((r).ams_pll_pll_ctl_10[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL_10.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r,(_r._ams_pll_pll_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r,(_r._ams_pll_pll_ctl_10)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r,(_r._ams_pll_pll_ctl_10))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r
#define AMS_PLL_PLL_CTL_10r_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_t AMS_PLL_PLL_CTL_10r_t;
#define AMS_PLL_PLL_CTL_10r_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_CLR
#define AMS_PLL_PLL_CTL_10r_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_SET
#define AMS_PLL_PLL_CTL_10r_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_175_174f_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BWf_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLKRPTR_BIASf_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_TX_CLK_RPTR_PDf_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_SPARE_167_166f_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BWf_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLKRPTR_BIASf_SET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_GET
#define AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r_AMS_PLL_RX_CLK_RPTR_PDf_SET
#define READ_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_CTL_10r
#define WRITE_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_CTL_10r
#define MODIFY_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_CTL_10r
#define READLN_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_CTL_10r
#define WRITELN_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_CTL_10r
#define WRITEALL_AMS_PLL_PLL_CTL_10r BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_CTL_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_CTL_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_INTCTL
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11b
 * DEVAD:    1
 * DESC:     INTERNAL PLL CONTROL
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM_SEL when 0, sel rterm input pins, when 1 sel pll AMS ctrl
 *     AMS_PLL_DIV4_2_SEL when 0, sel div4/2 input pin, when 1 sel pll AMS ctrl
 *     AMS_PLL_PWRDN    when1, power down pll
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr (0x0001d11b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_INTCTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_intctl[1];
	uint32_t _ams_pll_pll_intctl;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_CLR(r) (r).ams_pll_pll_intctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_SET(r,d) (r).ams_pll_pll_intctl[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_GET(r) (r).ams_pll_pll_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET(r) (((r).ams_pll_pll_intctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_INTCTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_INTCTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_intctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_INTCTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_intctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_intctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr
#define AMS_PLL_PLL_INTCTLr_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_t AMS_PLL_PLL_INTCTLr_t;
#define AMS_PLL_PLL_INTCTLr_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_CLR
#define AMS_PLL_PLL_INTCTLr_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_SET
#define AMS_PLL_PLL_INTCTLr_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET
#define READ_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_INTCTLr
#define WRITE_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_INTCTLr
#define MODIFY_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_INTCTLr
#define READLN_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_INTCTLr
#define WRITELN_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_INTCTLr
#define WRITEALL_AMS_PLL_PLL_INTCTLr BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_INTCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  AMS_PLL_PLL_STS
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11c
 * DEVAD:    1
 * DESC:     AMS PLL STATUS
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_PLL_MODE     pll_mode[4:0] bits
 *     AMS_PLL_LOW      VCO tuning output, HIGH when VCO Vctrl is low or PLL frequency is too low
 *     AMS_PLL_RANGE    VCO frequency range control (8 bits)
 *     AMS_PLL_KVH      KVH[1:0]
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr (0x0001d11c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_sts[1];
	uint32_t _ams_pll_pll_sts;
} BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_t;

#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_CLR(r) (r).ams_pll_pll_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_SET(r,d) (r).ams_pll_pll_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_GET(r) (r).ams_pll_pll_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 6) & 0xff)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET(r) (((r).ams_pll_pll_sts[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr
#define AMS_PLL_PLL_STSr_SIZE BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_t AMS_PLL_PLL_STSr_t;
#define AMS_PLL_PLL_STSr_CLR BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_CLR
#define AMS_PLL_PLL_STSr_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_SET
#define AMS_PLL_PLL_STSr_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET
#define READ_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_READ_AMS_PLL_PLL_STSr
#define WRITE_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_WRITE_AMS_PLL_PLL_STSr
#define MODIFY_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_MODIFY_AMS_PLL_PLL_STSr
#define READLN_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_READLN_AMS_PLL_PLL_STSr
#define WRITELN_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_WRITELN_AMS_PLL_PLL_STSr
#define WRITEALL_AMS_PLL_PLL_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_AMS_PLL_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_AMS_PLL_PLL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ0
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd120
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 0
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r (0x0001d120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ0.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq0[1];
	uint32_t _patgen_patgen_seq0;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_CLR(r) (r).patgen_patgen_seq0[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_SET(r,d) (r).patgen_patgen_seq0[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_GET(r) (r).patgen_patgen_seq0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patgen_patgen_seq0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patgen_patgen_seq0[0]=(((r).patgen_patgen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r
#define PATGEN_PATGEN_SEQ0r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_t PATGEN_PATGEN_SEQ0r_t;
#define PATGEN_PATGEN_SEQ0r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_CLR
#define PATGEN_PATGEN_SEQ0r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_SET
#define PATGEN_PATGEN_SEQ0r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ0r
#define WRITE_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ0r
#define MODIFY_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ0r
#define READLN_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ0r
#define WRITELN_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ0r
#define WRITEALL_PATGEN_PATGEN_SEQ0r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ1
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd121
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 1
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r (0x0001d121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ1.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq1[1];
	uint32_t _patgen_patgen_seq1;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_CLR(r) (r).patgen_patgen_seq1[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_SET(r,d) (r).patgen_patgen_seq1[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_GET(r) (r).patgen_patgen_seq1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patgen_patgen_seq1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patgen_patgen_seq1[0]=(((r).patgen_patgen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r
#define PATGEN_PATGEN_SEQ1r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_t PATGEN_PATGEN_SEQ1r_t;
#define PATGEN_PATGEN_SEQ1r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_CLR
#define PATGEN_PATGEN_SEQ1r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_SET
#define PATGEN_PATGEN_SEQ1r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ1r
#define WRITE_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ1r
#define MODIFY_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ1r
#define READLN_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ1r
#define WRITELN_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ1r
#define WRITEALL_PATGEN_PATGEN_SEQ1r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ2
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd122
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 2
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r (0x0001d122 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ2.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq2[1];
	uint32_t _patgen_patgen_seq2;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_CLR(r) (r).patgen_patgen_seq2[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_SET(r,d) (r).patgen_patgen_seq2[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_GET(r) (r).patgen_patgen_seq2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patgen_patgen_seq2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patgen_patgen_seq2[0]=(((r).patgen_patgen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r
#define PATGEN_PATGEN_SEQ2r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_t PATGEN_PATGEN_SEQ2r_t;
#define PATGEN_PATGEN_SEQ2r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_CLR
#define PATGEN_PATGEN_SEQ2r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_SET
#define PATGEN_PATGEN_SEQ2r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ2r
#define WRITE_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ2r
#define MODIFY_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ2r
#define READLN_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ2r
#define WRITELN_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ2r
#define WRITEALL_PATGEN_PATGEN_SEQ2r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ3
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd123
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 3
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r (0x0001d123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ3.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq3[1];
	uint32_t _patgen_patgen_seq3;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_CLR(r) (r).patgen_patgen_seq3[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_SET(r,d) (r).patgen_patgen_seq3[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_GET(r) (r).patgen_patgen_seq3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patgen_patgen_seq3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patgen_patgen_seq3[0]=(((r).patgen_patgen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r
#define PATGEN_PATGEN_SEQ3r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_t PATGEN_PATGEN_SEQ3r_t;
#define PATGEN_PATGEN_SEQ3r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_CLR
#define PATGEN_PATGEN_SEQ3r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_SET
#define PATGEN_PATGEN_SEQ3r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ3r
#define WRITE_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ3r
#define MODIFY_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ3r
#define READLN_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ3r
#define WRITELN_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ3r
#define WRITEALL_PATGEN_PATGEN_SEQ3r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ4
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd124
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 4
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r (0x0001d124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ4.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq4[1];
	uint32_t _patgen_patgen_seq4;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_CLR(r) (r).patgen_patgen_seq4[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_SET(r,d) (r).patgen_patgen_seq4[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_GET(r) (r).patgen_patgen_seq4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patgen_patgen_seq4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patgen_patgen_seq4[0]=(((r).patgen_patgen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r
#define PATGEN_PATGEN_SEQ4r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_t PATGEN_PATGEN_SEQ4r_t;
#define PATGEN_PATGEN_SEQ4r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_CLR
#define PATGEN_PATGEN_SEQ4r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_SET
#define PATGEN_PATGEN_SEQ4r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ4r
#define WRITE_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ4r
#define MODIFY_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ4r
#define READLN_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ4r
#define WRITELN_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ4r
#define WRITEALL_PATGEN_PATGEN_SEQ4r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ5
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd125
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 5
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r (0x0001d125 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ5.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq5[1];
	uint32_t _patgen_patgen_seq5;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_CLR(r) (r).patgen_patgen_seq5[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_SET(r,d) (r).patgen_patgen_seq5[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_GET(r) (r).patgen_patgen_seq5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patgen_patgen_seq5[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patgen_patgen_seq5[0]=(((r).patgen_patgen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r
#define PATGEN_PATGEN_SEQ5r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_t PATGEN_PATGEN_SEQ5r_t;
#define PATGEN_PATGEN_SEQ5r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_CLR
#define PATGEN_PATGEN_SEQ5r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_SET
#define PATGEN_PATGEN_SEQ5r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ5r
#define WRITE_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ5r
#define MODIFY_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ5r
#define READLN_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ5r
#define WRITELN_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ5r
#define WRITEALL_PATGEN_PATGEN_SEQ5r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ6
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd126
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 6
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r (0x0001d126 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ6.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq6[1];
	uint32_t _patgen_patgen_seq6;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_CLR(r) (r).patgen_patgen_seq6[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_SET(r,d) (r).patgen_patgen_seq6[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_GET(r) (r).patgen_patgen_seq6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patgen_patgen_seq6[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patgen_patgen_seq6[0]=(((r).patgen_patgen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r
#define PATGEN_PATGEN_SEQ6r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_t PATGEN_PATGEN_SEQ6r_t;
#define PATGEN_PATGEN_SEQ6r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_CLR
#define PATGEN_PATGEN_SEQ6r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_SET
#define PATGEN_PATGEN_SEQ6r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ6r
#define WRITE_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ6r
#define MODIFY_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ6r
#define READLN_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ6r
#define WRITELN_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ6r
#define WRITEALL_PATGEN_PATGEN_SEQ6r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ7
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd127
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 7
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r (0x0001d127 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ7.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq7[1];
	uint32_t _patgen_patgen_seq7;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_CLR(r) (r).patgen_patgen_seq7[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_SET(r,d) (r).patgen_patgen_seq7[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_GET(r) (r).patgen_patgen_seq7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patgen_patgen_seq7[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patgen_patgen_seq7[0]=(((r).patgen_patgen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r
#define PATGEN_PATGEN_SEQ7r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_t PATGEN_PATGEN_SEQ7r_t;
#define PATGEN_PATGEN_SEQ7r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_CLR
#define PATGEN_PATGEN_SEQ7r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_SET
#define PATGEN_PATGEN_SEQ7r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ7r
#define WRITE_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ7r
#define MODIFY_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ7r
#define READLN_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ7r
#define WRITELN_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ7r
#define WRITEALL_PATGEN_PATGEN_SEQ7r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ8
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd128
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 8
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r (0x0001d128 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ8.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq8[1];
	uint32_t _patgen_patgen_seq8;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_CLR(r) (r).patgen_patgen_seq8[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_SET(r,d) (r).patgen_patgen_seq8[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_GET(r) (r).patgen_patgen_seq8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patgen_patgen_seq8[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patgen_patgen_seq8[0]=(((r).patgen_patgen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r
#define PATGEN_PATGEN_SEQ8r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_t PATGEN_PATGEN_SEQ8r_t;
#define PATGEN_PATGEN_SEQ8r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_CLR
#define PATGEN_PATGEN_SEQ8r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_SET
#define PATGEN_PATGEN_SEQ8r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ8r
#define WRITE_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ8r
#define MODIFY_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ8r
#define READLN_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ8r
#define WRITELN_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ8r
#define WRITEALL_PATGEN_PATGEN_SEQ8r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ9
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd129
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 9
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r (0x0001d129 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ9.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq9[1];
	uint32_t _patgen_patgen_seq9;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_CLR(r) (r).patgen_patgen_seq9[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_SET(r,d) (r).patgen_patgen_seq9[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_GET(r) (r).patgen_patgen_seq9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patgen_patgen_seq9[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patgen_patgen_seq9[0]=(((r).patgen_patgen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r
#define PATGEN_PATGEN_SEQ9r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_t PATGEN_PATGEN_SEQ9r_t;
#define PATGEN_PATGEN_SEQ9r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_CLR
#define PATGEN_PATGEN_SEQ9r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_SET
#define PATGEN_PATGEN_SEQ9r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ9r
#define WRITE_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ9r
#define MODIFY_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ9r
#define READLN_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ9r
#define WRITELN_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ9r
#define WRITEALL_PATGEN_PATGEN_SEQ9r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_10
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12a
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 10
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r (0x0001d12a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_10.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_10[1];
	uint32_t _patgen_patgen_seq_10;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_CLR(r) (r).patgen_patgen_seq_10[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_SET(r,d) (r).patgen_patgen_seq_10[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_GET(r) (r).patgen_patgen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patgen_patgen_seq_10[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patgen_patgen_seq_10[0]=(((r).patgen_patgen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_10.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_10))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_10))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r
#define PATGEN_PATGEN_SEQ_10r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_t PATGEN_PATGEN_SEQ_10r_t;
#define PATGEN_PATGEN_SEQ_10r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_CLR
#define PATGEN_PATGEN_SEQ_10r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_SET
#define PATGEN_PATGEN_SEQ_10r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_10r
#define WRITE_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_10r
#define MODIFY_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_10r
#define READLN_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_10r
#define WRITELN_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_10r
#define WRITEALL_PATGEN_PATGEN_SEQ_10r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_11
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12b
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 11
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r (0x0001d12b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_11.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_11[1];
	uint32_t _patgen_patgen_seq_11;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_CLR(r) (r).patgen_patgen_seq_11[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_SET(r,d) (r).patgen_patgen_seq_11[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_GET(r) (r).patgen_patgen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patgen_patgen_seq_11[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patgen_patgen_seq_11[0]=(((r).patgen_patgen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_11.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_11r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_11))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_11r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_11))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r
#define PATGEN_PATGEN_SEQ_11r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_t PATGEN_PATGEN_SEQ_11r_t;
#define PATGEN_PATGEN_SEQ_11r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_CLR
#define PATGEN_PATGEN_SEQ_11r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_SET
#define PATGEN_PATGEN_SEQ_11r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_11r
#define WRITE_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_11r
#define MODIFY_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_11r
#define READLN_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_11r
#define WRITELN_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_11r
#define WRITEALL_PATGEN_PATGEN_SEQ_11r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_12
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12c
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 12
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r (0x0001d12c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_12.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_12[1];
	uint32_t _patgen_patgen_seq_12;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_CLR(r) (r).patgen_patgen_seq_12[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_SET(r,d) (r).patgen_patgen_seq_12[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_GET(r) (r).patgen_patgen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patgen_patgen_seq_12[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patgen_patgen_seq_12[0]=(((r).patgen_patgen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_12.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_12r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_12))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_12r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_12))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r
#define PATGEN_PATGEN_SEQ_12r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_t PATGEN_PATGEN_SEQ_12r_t;
#define PATGEN_PATGEN_SEQ_12r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_CLR
#define PATGEN_PATGEN_SEQ_12r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_SET
#define PATGEN_PATGEN_SEQ_12r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_12r
#define WRITE_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_12r
#define MODIFY_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_12r
#define READLN_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_12r
#define WRITELN_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_12r
#define WRITEALL_PATGEN_PATGEN_SEQ_12r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_13
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12d
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 13
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r (0x0001d12d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_13.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_13[1];
	uint32_t _patgen_patgen_seq_13;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_CLR(r) (r).patgen_patgen_seq_13[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_SET(r,d) (r).patgen_patgen_seq_13[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_GET(r) (r).patgen_patgen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patgen_patgen_seq_13[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patgen_patgen_seq_13[0]=(((r).patgen_patgen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_13.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_13r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_13))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_13r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_13))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r
#define PATGEN_PATGEN_SEQ_13r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_t PATGEN_PATGEN_SEQ_13r_t;
#define PATGEN_PATGEN_SEQ_13r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_CLR
#define PATGEN_PATGEN_SEQ_13r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_SET
#define PATGEN_PATGEN_SEQ_13r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_13r
#define WRITE_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_13r
#define MODIFY_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_13r
#define READLN_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_13r
#define WRITELN_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_13r
#define WRITEALL_PATGEN_PATGEN_SEQ_13r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_14
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12e
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 14
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r (0x0001d12e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_14.
 */
typedef union BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_14[1];
	uint32_t _patgen_patgen_seq_14;
} BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_t;

#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_CLR(r) (r).patgen_patgen_seq_14[0] = 0
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_SET(r,d) (r).patgen_patgen_seq_14[0] = d
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_GET(r) (r).patgen_patgen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patgen_patgen_seq_14[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patgen_patgen_seq_14[0]=(((r).patgen_patgen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_14.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14))
#define BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14))
#define BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_14r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_14))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_14r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_14))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r
#define PATGEN_PATGEN_SEQ_14r_SIZE BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_t PATGEN_PATGEN_SEQ_14r_t;
#define PATGEN_PATGEN_SEQ_14r_CLR BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_CLR
#define PATGEN_PATGEN_SEQ_14r_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_SET
#define PATGEN_PATGEN_SEQ_14r_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_READ_PATGEN_PATGEN_SEQ_14r
#define WRITE_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_WRITE_PATGEN_PATGEN_SEQ_14r
#define MODIFY_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_MODIFY_PATGEN_PATGEN_SEQ_14r
#define READLN_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_READLN_PATGEN_PATGEN_SEQ_14r
#define WRITELN_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_WRITELN_PATGEN_PATGEN_SEQ_14r
#define WRITEALL_PATGEN_PATGEN_SEQ_14r BCMI_BLACKHAWK_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PATGEN_PATGEN_SEQ_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_UC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd130
 * DEVAD:    1
 * DESC:     Micro Control 0 Register
 * RESETVAL: 0xc160 (49504)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL93N72 forced modePlease see Falcon PMD Internal Functional Specification for details
 *     TX_DISABLE_TRIGGER Tx disable triggerWhen this bit is set to 1, it triggers a TX disable with timer starting at 0.No matter where the TX disable state is, it start a new timer and apply TX disable.This bit is self clearing
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path resetNeed to set this bit to 1 if tx_disable_output_sel = 2'b01 (send TX power down).
 *     PMD_TX_DISABLE_PKILL Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r (0x0001d130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_UC_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_uc_ctl0[1];
	uint32_t _txfir_uc_ctl0;
} BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_CLR(r) (r).txfir_uc_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_SET(r,d) (r).txfir_uc_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_GET(r) (r).txfir_uc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 4) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4)) | (63 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET(r) (((r).txfir_uc_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_UC_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_uc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r
#define TXFIR_UC_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_t TXFIR_UC_CTL0r_t;
#define TXFIR_UC_CTL0r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_CLR
#define TXFIR_UC_CTL0r_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_SET
#define TXFIR_UC_CTL0r_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET
#define READ_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_READ_TXFIR_UC_CTL0r
#define WRITE_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_UC_CTL0r
#define MODIFY_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_UC_CTL0r
#define READLN_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_UC_CTL0r
#define WRITELN_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_UC_CTL0r
#define WRITEALL_TXFIR_UC_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_UC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_UC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_MISC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd131
 * DEVAD:    1
 * DESC:     Misc Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r (0x0001d131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_ctl0[1];
	uint32_t _txfir_misc_ctl0;
} BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_CLR(r) (r).txfir_misc_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SET(r,d) (r).txfir_misc_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_GET(r) (r).txfir_misc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).txfir_misc_ctl0[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET(r) (((r).txfir_misc_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_MISC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_MISC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r
#define TXFIR_MISC_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_t TXFIR_MISC_CTL0r_t;
#define TXFIR_MISC_CTL0r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_CLR
#define TXFIR_MISC_CTL0r_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SET
#define TXFIR_MISC_CTL0r_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET
#define READ_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_READ_TXFIR_MISC_CTL0r
#define WRITE_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_MISC_CTL0r
#define MODIFY_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_MISC_CTL0r
#define READLN_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_MISC_CTL0r
#define WRITELN_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_MISC_CTL0r
#define WRITEALL_TXFIR_MISC_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_MISC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_MISC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_MISC_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd132
 * DEVAD:    1
 * DESC:     Misc Status 0 Register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_DISABLE_STATUS tx disable statusWhen this bit is set it indicates the tx_disable is active due to:1) pin at AN/PCS to PMD Interface OR2) dp_reset being asserted3) register bit dedicated to micro use4) register bit dedicated to SDK use5) tx disable timer that guarntees minimum assertion time has not expired
 *     TX_ELEC_IDLE_STATUS tx electrical idle statusWhen this bit is set it indicates the tx elecrticl idle active due to:1) tx disable being programmed to send electrical idles or2) An internal logic signal derived from PMD interface pins for EEE TX MODE
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r (0x0001d132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_sts0[1];
	uint32_t _txfir_misc_sts0;
} BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_CLR(r) (r).txfir_misc_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_SET(r,d) (r).txfir_misc_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_GET(r) (r).txfir_misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET(r) ((((r).txfir_misc_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET(r) (((r).txfir_misc_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r
#define TXFIR_MISC_STS0r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_t TXFIR_MISC_STS0r_t;
#define TXFIR_MISC_STS0r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_CLR
#define TXFIR_MISC_STS0r_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_SET
#define TXFIR_MISC_STS0r_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET
#define READ_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_READ_TXFIR_MISC_STS0r
#define WRITE_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_MISC_STS0r
#define MODIFY_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_MISC_STS0r
#define READLN_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_MISC_STS0r
#define WRITELN_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_MISC_STS0r
#define WRITEALL_TXFIR_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_MISC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd133
 * DEVAD:    1
 * DESC:     txfir tap control 0 register
 * RESETVAL: 0x3000 (12288)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP0_COEFF TXFIR tap 0 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 *     TXFIR_NRZ_TAP_RANGE_SEL TXFIR NRZ tap range select0 - PAM4 tap range -170..+1701 - NRZ tap range -127..+127
 *     TXFIR_TAP_LOAD   Load txfir tap valuesThe sequence to load the taps is:1) set taps values in the txfir_tap*_coeff fields as needed2) set txfir_tap_load field to 1'b1.This field is self-clearing, always read-back 0
 *     TXFIR_TAP_EN     txfir taps enable2'd0 - tap2:tap02'd1 - tap5:tap02'd2 - tap8:tap02'd3 - tap11:tap0
 *     TXFIR_TEST_DATA_EN txfir DAC test data enable1 - Test mode. Enables test data path from the DAC memory to the DAC for characterization0 - Normal modes. TXFIR DAC driver is used to drive the DAC.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r (0x0001d133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl0[1];
	uint32_t _txfir_tap_ctl0;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_CLR(r) (r).txfir_tap_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_SET(r,d) (r).txfir_tap_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_GET(r) (r).txfir_tap_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET(r) (((r).txfir_tap_ctl0[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r
#define TXFIR_TAP_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_t TXFIR_TAP_CTL0r_t;
#define TXFIR_TAP_CTL0r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_CLR
#define TXFIR_TAP_CTL0r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_SET
#define TXFIR_TAP_CTL0r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_GET
#define TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET
#define TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET
#define TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET
#define READ_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL0r
#define WRITE_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL0r
#define MODIFY_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL0r
#define READLN_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL0r
#define WRITELN_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL0r
#define WRITEALL_TXFIR_TAP_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd134
 * DEVAD:    1
 * DESC:     txfir tap control 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP1_COEFF TXFIR tap 1 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r (0x0001d134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl1[1];
	uint32_t _txfir_tap_ctl1;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_CLR(r) (r).txfir_tap_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_SET(r,d) (r).txfir_tap_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_GET(r) (r).txfir_tap_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET(r) (((r).txfir_tap_ctl1[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET(r,f) (r).txfir_tap_ctl1[0]=(((r).txfir_tap_ctl1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r
#define TXFIR_TAP_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_t TXFIR_TAP_CTL1r_t;
#define TXFIR_TAP_CTL1r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_CLR
#define TXFIR_TAP_CTL1r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_SET
#define TXFIR_TAP_CTL1r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_GET
#define TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET
#define TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET
#define READ_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL1r
#define WRITE_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL1r
#define MODIFY_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL1r
#define READLN_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL1r
#define WRITELN_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL1r
#define WRITEALL_TXFIR_TAP_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd135
 * DEVAD:    1
 * DESC:     txfir tap control 2 register
 * RESETVAL: 0xa8 (168)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP2_COEFF TXFIR tap 2 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r (0x0001d135 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl2[1];
	uint32_t _txfir_tap_ctl2;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_CLR(r) (r).txfir_tap_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_SET(r,d) (r).txfir_tap_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_GET(r) (r).txfir_tap_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET(r) (((r).txfir_tap_ctl2[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET(r,f) (r).txfir_tap_ctl2[0]=(((r).txfir_tap_ctl2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r
#define TXFIR_TAP_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_t TXFIR_TAP_CTL2r_t;
#define TXFIR_TAP_CTL2r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_CLR
#define TXFIR_TAP_CTL2r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_SET
#define TXFIR_TAP_CTL2r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_GET
#define TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET
#define TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET
#define READ_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL2r
#define WRITE_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL2r
#define MODIFY_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL2r
#define READLN_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL2r
#define WRITELN_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL2r
#define WRITEALL_TXFIR_TAP_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd136
 * DEVAD:    1
 * DESC:     txfir tap control 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP3_COEFF TXFIR tap 3 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r (0x0001d136 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl3[1];
	uint32_t _txfir_tap_ctl3;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_CLR(r) (r).txfir_tap_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_SET(r,d) (r).txfir_tap_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_GET(r) (r).txfir_tap_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET(r) (((r).txfir_tap_ctl3[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET(r,f) (r).txfir_tap_ctl3[0]=(((r).txfir_tap_ctl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r
#define TXFIR_TAP_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_t TXFIR_TAP_CTL3r_t;
#define TXFIR_TAP_CTL3r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_CLR
#define TXFIR_TAP_CTL3r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_SET
#define TXFIR_TAP_CTL3r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_GET
#define TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET
#define TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET
#define READ_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL3r
#define WRITE_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL3r
#define MODIFY_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL3r
#define READLN_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL3r
#define WRITELN_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL3r
#define WRITEALL_TXFIR_TAP_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd137
 * DEVAD:    1
 * DESC:     txfir tap control 4 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP4_COEFF TXFIR tap 4 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r (0x0001d137 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl4[1];
	uint32_t _txfir_tap_ctl4;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_CLR(r) (r).txfir_tap_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_SET(r,d) (r).txfir_tap_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_GET(r) (r).txfir_tap_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET(r) (((r).txfir_tap_ctl4[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET(r,f) (r).txfir_tap_ctl4[0]=(((r).txfir_tap_ctl4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r
#define TXFIR_TAP_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_t TXFIR_TAP_CTL4r_t;
#define TXFIR_TAP_CTL4r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_CLR
#define TXFIR_TAP_CTL4r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_SET
#define TXFIR_TAP_CTL4r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_GET
#define TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET
#define TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET
#define READ_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL4r
#define WRITE_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL4r
#define MODIFY_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL4r
#define READLN_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL4r
#define WRITELN_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL4r
#define WRITEALL_TXFIR_TAP_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL5
 * BLOCKS:   TX_FED
 * REGADDR:  0xd138
 * DEVAD:    1
 * DESC:     txfir tap control 5 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP5_COEFF TXFIR tap 5 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r (0x0001d138 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl5[1];
	uint32_t _txfir_tap_ctl5;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_CLR(r) (r).txfir_tap_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_SET(r,d) (r).txfir_tap_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_GET(r) (r).txfir_tap_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET(r) (((r).txfir_tap_ctl5[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET(r,f) (r).txfir_tap_ctl5[0]=(((r).txfir_tap_ctl5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r
#define TXFIR_TAP_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_t TXFIR_TAP_CTL5r_t;
#define TXFIR_TAP_CTL5r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_CLR
#define TXFIR_TAP_CTL5r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_SET
#define TXFIR_TAP_CTL5r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_GET
#define TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET
#define TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET
#define READ_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL5r
#define WRITE_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL5r
#define MODIFY_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL5r
#define READLN_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL5r
#define WRITELN_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL5r
#define WRITEALL_TXFIR_TAP_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL6
 * BLOCKS:   TX_FED
 * REGADDR:  0xd139
 * DEVAD:    1
 * DESC:     txfir tap control 6 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP6_COEFF TXFIR tap 6 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 *     TXFIR_DC_ADJUST  This field specify the amount of DC offset added to TXFIR outputThe range is -64 to +63
 *     TXFIR_LEVEL_SHIFT_MODE_EN Level shifting enable. Level shifting is achieved by re-purposingthe last 6 taps such that taps 6-8 provide level adjustment forlevel = 3 and Taps 9-11 for level = -31 - enabled0 - disabled
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r (0x0001d139 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl6[1];
	uint32_t _txfir_tap_ctl6;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_CLR(r) (r).txfir_tap_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_SET(r,d) (r).txfir_tap_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_GET(r) (r).txfir_tap_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET(r) ((((r).txfir_tap_ctl6[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET(r) ((((r).txfir_tap_ctl6[0]) >> 8) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET(r) (((r).txfir_tap_ctl6[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r
#define TXFIR_TAP_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_t TXFIR_TAP_CTL6r_t;
#define TXFIR_TAP_CTL6r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_CLR
#define TXFIR_TAP_CTL6r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_SET
#define TXFIR_TAP_CTL6r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_GET
#define TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET
#define TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET
#define TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET
#define TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET
#define TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET
#define TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET
#define READ_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL6r
#define WRITE_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL6r
#define MODIFY_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL6r
#define READLN_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL6r
#define WRITELN_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL6r
#define WRITEALL_TXFIR_TAP_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL7
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13a
 * DEVAD:    1
 * DESC:     txfir tap control 7 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP7_COEFF TXFIR tap 7 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r (0x0001d13a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl7[1];
	uint32_t _txfir_tap_ctl7;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_CLR(r) (r).txfir_tap_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_SET(r,d) (r).txfir_tap_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_GET(r) (r).txfir_tap_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET(r) (((r).txfir_tap_ctl7[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET(r,f) (r).txfir_tap_ctl7[0]=(((r).txfir_tap_ctl7[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r
#define TXFIR_TAP_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_t TXFIR_TAP_CTL7r_t;
#define TXFIR_TAP_CTL7r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_CLR
#define TXFIR_TAP_CTL7r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_SET
#define TXFIR_TAP_CTL7r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_GET
#define TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET
#define TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET
#define READ_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL7r
#define WRITE_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL7r
#define MODIFY_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL7r
#define READLN_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL7r
#define WRITELN_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL7r
#define WRITEALL_TXFIR_TAP_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL8
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13b
 * DEVAD:    1
 * DESC:     txfir tap control 8 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP8_COEFF TXFIR tap 8 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r (0x0001d13b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL8.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl8[1];
	uint32_t _txfir_tap_ctl8;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_CLR(r) (r).txfir_tap_ctl8[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_SET(r,d) (r).txfir_tap_ctl8[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_GET(r) (r).txfir_tap_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET(r) (((r).txfir_tap_ctl8[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET(r,f) (r).txfir_tap_ctl8[0]=(((r).txfir_tap_ctl8[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r
#define TXFIR_TAP_CTL8r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_t TXFIR_TAP_CTL8r_t;
#define TXFIR_TAP_CTL8r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_CLR
#define TXFIR_TAP_CTL8r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_SET
#define TXFIR_TAP_CTL8r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_GET
#define TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET
#define TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET
#define READ_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL8r
#define WRITE_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL8r
#define MODIFY_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL8r
#define READLN_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL8r
#define WRITELN_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL8r
#define WRITEALL_TXFIR_TAP_CTL8r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL9
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13c
 * DEVAD:    1
 * DESC:     txfir tap control 9 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP9_COEFF TXFIR tap 9 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r (0x0001d13c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL9.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl9[1];
	uint32_t _txfir_tap_ctl9;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_CLR(r) (r).txfir_tap_ctl9[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_SET(r,d) (r).txfir_tap_ctl9[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_GET(r) (r).txfir_tap_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET(r) (((r).txfir_tap_ctl9[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET(r,f) (r).txfir_tap_ctl9[0]=(((r).txfir_tap_ctl9[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r
#define TXFIR_TAP_CTL9r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_t TXFIR_TAP_CTL9r_t;
#define TXFIR_TAP_CTL9r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_CLR
#define TXFIR_TAP_CTL9r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_SET
#define TXFIR_TAP_CTL9r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_GET
#define TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET
#define TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET
#define READ_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL9r
#define WRITE_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL9r
#define MODIFY_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL9r
#define READLN_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL9r
#define WRITELN_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL9r
#define WRITEALL_TXFIR_TAP_CTL9r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL10
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13d
 * DEVAD:    1
 * DESC:     txfir tap control 10 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP10_COEFF TXFIR tap 10 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r (0x0001d13d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL10.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl10[1];
	uint32_t _txfir_tap_ctl10;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_CLR(r) (r).txfir_tap_ctl10[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_SET(r,d) (r).txfir_tap_ctl10[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_GET(r) (r).txfir_tap_ctl10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET(r) (((r).txfir_tap_ctl10[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET(r,f) (r).txfir_tap_ctl10[0]=(((r).txfir_tap_ctl10[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL10.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl10))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl10))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r
#define TXFIR_TAP_CTL10r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_t TXFIR_TAP_CTL10r_t;
#define TXFIR_TAP_CTL10r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_CLR
#define TXFIR_TAP_CTL10r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_SET
#define TXFIR_TAP_CTL10r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_GET
#define TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET
#define TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET
#define READ_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL10r
#define WRITE_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL10r
#define MODIFY_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL10r
#define READLN_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL10r
#define WRITELN_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL10r
#define WRITEALL_TXFIR_TAP_CTL10r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXFIR_TAP_CTL11
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13e
 * DEVAD:    1
 * DESC:     txfir tap control 11 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP11_COEFF TXFIR tap 11 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r (0x0001d13e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL11.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl11[1];
	uint32_t _txfir_tap_ctl11;
} BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_t;

#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_CLR(r) (r).txfir_tap_ctl11[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_SET(r,d) (r).txfir_tap_ctl11[0] = d
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_GET(r) (r).txfir_tap_ctl11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET(r) (((r).txfir_tap_ctl11[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET(r,f) (r).txfir_tap_ctl11[0]=(((r).txfir_tap_ctl11[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL11.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11))
#define BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL11r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl11))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL11r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl11))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r
#define TXFIR_TAP_CTL11r_SIZE BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_t TXFIR_TAP_CTL11r_t;
#define TXFIR_TAP_CTL11r_CLR BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_CLR
#define TXFIR_TAP_CTL11r_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_SET
#define TXFIR_TAP_CTL11r_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_GET
#define TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET
#define TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET
#define READ_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_READ_TXFIR_TAP_CTL11r
#define WRITE_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_WRITE_TXFIR_TAP_CTL11r
#define MODIFY_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_MODIFY_TXFIR_TAP_CTL11r
#define READLN_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_READLN_TXFIR_TAP_CTL11r
#define WRITELN_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_WRITELN_TXFIR_TAP_CTL11r
#define WRITEALL_TXFIR_TAP_CTL11r BCMI_BLACKHAWK_XGXS_WRITEALL_TXFIR_TAP_CTL11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXFIR_TAP_CTL11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd140
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 0.
 * RESETVAL: 0xc803 (51203)
 * ACCESS:   R/W
 * FIELDS:
 *     VCO_STEP_TIME    VCO time between iterations
 *     VCO_START_TIME   VCO powerup wait time
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r (0x0001d140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl0[1];
	uint32_t _pll_cal_ctl0;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_CLR(r) (r).pll_cal_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_SET(r,d) (r).pll_cal_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_GET(r) (r).pll_cal_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET(r) ((((r).pll_cal_ctl0[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET(r) (((r).pll_cal_ctl0[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r
#define PLL_CAL_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_t PLL_CAL_CTL0r_t;
#define PLL_CAL_CTL0r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_CLR
#define PLL_CAL_CTL0r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_SET
#define PLL_CAL_CTL0r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET
#define READ_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL0r
#define WRITE_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL0r
#define MODIFY_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL0r
#define READLN_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL0r
#define WRITELN_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL0r
#define WRITEALL_PLL_CAL_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd141
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 1.
 * RESETVAL: 0xc8ff (51455)
 * ACCESS:   R/W
 * FIELDS:
 *     RETRY_TIME       retry wait time
 *     PRE_FREQ_DET_TIME wait time prior to freq det
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r (0x0001d141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl1[1];
	uint32_t _pll_cal_ctl1;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_CLR(r) (r).pll_cal_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_SET(r,d) (r).pll_cal_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_GET(r) (r).pll_cal_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET(r) ((((r).pll_cal_ctl1[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET(r) (((r).pll_cal_ctl1[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r
#define PLL_CAL_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_t PLL_CAL_CTL1r_t;
#define PLL_CAL_CTL1r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_CLR
#define PLL_CAL_CTL1r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_SET
#define PLL_CAL_CTL1r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET
#define PLL_CAL_CTL1r_RETRY_TIMEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET
#define PLL_CAL_CTL1r_RETRY_TIMEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET
#define READ_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL1r
#define WRITE_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL1r
#define MODIFY_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL1r
#define READLN_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL1r
#define WRITELN_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL1r
#define WRITEALL_PLL_CAL_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL2
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd142
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 2.
 * RESETVAL: 0xff01 (65281)
 * ACCESS:   R/W
 * FIELDS:
 *     WIN_CAL_CNTR     freq. counter's 8-lsbits stoping value
 *     RES_CAL_CNTR     freq. counter's 8-msbits starting value
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r (0x0001d142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl2[1];
	uint32_t _pll_cal_ctl2;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_CLR(r) (r).pll_cal_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_SET(r,d) (r).pll_cal_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_GET(r) (r).pll_cal_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET(r) ((((r).pll_cal_ctl2[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET(r) (((r).pll_cal_ctl2[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r
#define PLL_CAL_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_t PLL_CAL_CTL2r_t;
#define PLL_CAL_CTL2r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_CLR
#define PLL_CAL_CTL2r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_SET
#define PLL_CAL_CTL2r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET
#define READ_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL2r
#define WRITE_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL2r
#define MODIFY_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL2r
#define READLN_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL2r
#define WRITELN_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL2r
#define WRITEALL_PLL_CAL_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL3
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd143
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 3.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FAST_SEARCH_MODE force cap sequencer using select_m value for fast searching
 *     CAP_CNT_MASK_EN  masks cap count to allow control of max value
 *     CAP_SEQ_CYA      cya bit to revert cap sequencer back to original hyper/xaui sequence
 *     CAP_RESTART      force cap sequencer to restart, set to high then low
 *     CAP_RETRY_EN     enable retry on cap search failure
 *     CAP_FORCE_SLOWDOWN slowdown force value
 *     CAP_FORCE_SLOWDOWN_EN slowdown force enable
 *     CAP_SELECT_M_EN  Manual vco cap value mode, force using pll_range force value
 *     CAP_SELECT_M     Manual vco cap value (i.e pll_range[7:0])
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r (0x0001d143 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl3[1];
	uint32_t _pll_cal_ctl3;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CLR(r) (r).pll_cal_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_SET(r,d) (r).pll_cal_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_GET(r) (r).pll_cal_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET(r) ((((r).pll_cal_ctl3[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET(r) ((((r).pll_cal_ctl3[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET(r) ((((r).pll_cal_ctl3[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET(r) ((((r).pll_cal_ctl3[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET(r) (((r).pll_cal_ctl3[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r
#define PLL_CAL_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_t PLL_CAL_CTL3r_t;
#define PLL_CAL_CTL3r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CLR
#define PLL_CAL_CTL3r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_SET
#define PLL_CAL_CTL3r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET
#define PLL_CAL_CTL3r_CAP_RESTARTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET
#define PLL_CAL_CTL3r_CAP_RESTARTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET
#define READ_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL3r
#define WRITE_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL3r
#define MODIFY_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL3r
#define READLN_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL3r
#define WRITELN_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL3r
#define WRITEALL_PLL_CAL_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL4
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd144
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 4.
 * RESETVAL: 0xa80d (43021)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_FRC_VAL force pll lock value
 *     PLL_LOCK_FRC     force pll lock
 *     PLL_FORCE_CAP_PASS force cappass
 *     PLL_FORCE_CAP_PASS_EN enable pllforcecappass
 *     PLL_FORCE_CAP_DONE force capdone
 *     PLL_FORCE_CAP_DONE_EN enable pllforcecapdone
 *     PLL_FORCE_FPASS  force freqpass
 *     PLL_FORCE_FDONE  force freqdone
 *     PLL_FORCE_FDONE_EN enable pllforcefdone & pllforcefpass into pllseq
 *     VCO_RST_EN       enable pll reset when state machine is in start state. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 *     SLOWDN_XOR       invert sense of the slowdn/pll_low input from AFE
 *     FREQ_MONITOR_EN  continuously monitor vco freq
 *     FREQ_DET_RESTART_EN enable restart when not freq locked
 *     FREQ_DET_RETRY_EN enable retry on freq det failure
 *     VCO_DONE_EN      enable vco_done status bit
 *     PLL_SEQ_START    start pll sequencer by writing to 1'b0 followed by writing to 1'b1. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r (0x0001d144 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl4[1];
	uint32_t _pll_cal_ctl4;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_CLR(r) (r).pll_cal_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SET(r,d) (r).pll_cal_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_GET(r) (r).pll_cal_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET(r) ((((r).pll_cal_ctl4[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET(r) ((((r).pll_cal_ctl4[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET(r) ((((r).pll_cal_ctl4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET(r) (((r).pll_cal_ctl4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r
#define PLL_CAL_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_t PLL_CAL_CTL4r_t;
#define PLL_CAL_CTL4r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_CLR
#define PLL_CAL_CTL4r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SET
#define PLL_CAL_CTL4r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET
#define PLL_CAL_CTL4r_SLOWDN_XORf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET
#define PLL_CAL_CTL4r_SLOWDN_XORf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET
#define PLL_CAL_CTL4r_VCO_RST_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET
#define PLL_CAL_CTL4r_VCO_RST_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET
#define READ_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL4r
#define WRITE_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL4r
#define MODIFY_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL4r
#define READLN_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL4r
#define WRITELN_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL4r
#define WRITEALL_PLL_CAL_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL5
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd145
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 5.
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT    Refclk Divider Count to generate a slower divided refclk enable pulse for the PLL calibration logic.Most of the PLL calibration logic including PLL calibration state machines uses this divided version of the refclk clock signal.PLL calibration time is proportional to this register value.
 *     DEC_SEARCH_EN    VCO range decremental search enable control.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r (0x0001d145 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl5[1];
	uint32_t _pll_cal_ctl5;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_CLR(r) (r).pll_cal_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_SET(r,d) (r).pll_cal_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_GET(r) (r).pll_cal_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_DEC_SEARCH_ENf_GET(r) ((((r).pll_cal_ctl5[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_DEC_SEARCH_ENf_SET(r,f) (r).pll_cal_ctl5[0]=(((r).pll_cal_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET(r) (((r).pll_cal_ctl5[0]) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET(r,f) (r).pll_cal_ctl5[0]=(((r).pll_cal_ctl5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r
#define PLL_CAL_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_t PLL_CAL_CTL5r_t;
#define PLL_CAL_CTL5r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_CLR
#define PLL_CAL_CTL5r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_SET
#define PLL_CAL_CTL5r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_GET
#define PLL_CAL_CTL5r_DEC_SEARCH_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_DEC_SEARCH_ENf_GET
#define PLL_CAL_CTL5r_DEC_SEARCH_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_DEC_SEARCH_ENf_SET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET
#define READ_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL5r
#define WRITE_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL5r
#define MODIFY_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL5r
#define READLN_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL5r
#define WRITELN_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL5r
#define WRITEALL_PLL_CAL_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL6
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd146
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 6.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT_SEL Refclk Divider Mode Select.Value 7: will select refclk_divcnt[13:0] as refclk divider value which has max value of 16383.Value 0 to 6 are reserved for future use and should not be selected.
 *     VCO_RANGE_ADJUST signed 2's complement vco_range_offset value to be added to vco_range to AFE.
 *     VCO_RANGE_ADJUST_EN enable vco_range_adjust by hardware when set to 1
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r (0x0001d146 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl6[1];
	uint32_t _pll_cal_ctl6;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_CLR(r) (r).pll_cal_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_SET(r,d) (r).pll_cal_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_GET(r) (r).pll_cal_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_GET(r) ((((r).pll_cal_ctl6[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_GET(r) ((((r).pll_cal_ctl6[0]) >> 8) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET(r) (((r).pll_cal_ctl6[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r
#define PLL_CAL_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_t PLL_CAL_CTL6r_t;
#define PLL_CAL_CTL6r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_CLR
#define PLL_CAL_CTL6r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_SET
#define PLL_CAL_CTL6r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_GET
#define PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_GET
#define PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUST_ENf_SET
#define PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_GET
#define PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_VCO_RANGE_ADJUSTf_SET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET
#define READ_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL6r
#define WRITE_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL6r
#define MODIFY_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL6r
#define READLN_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL6r
#define WRITELN_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL6r
#define WRITEALL_PLL_CAL_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL7
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd147
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 7.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_MODE         PLL Multiplier.00000  = 64;00001  = 66;00010  = 80;00011  = 128;00100  = 132;00101  = 140;00110  = 160;00111  = 165;01000  = 168;01001  = 170;01010  = 175;01011  = 180;01100  = 184;01101  = 200;01110  = 224;01111  = 264;10000  = 96;10001  = 120;10010  = 144;10011  = 198'
 *     RESCAL_FRC_VAL   rescal force value.
 *     RESCAL_FRC       rescal force to use rescal force value.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r (0x0001d147 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl7[1];
	uint32_t _pll_cal_ctl7;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_CLR(r) (r).pll_cal_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_SET(r,d) (r).pll_cal_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_GET(r) (r).pll_cal_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET(r) ((((r).pll_cal_ctl7[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET(r) ((((r).pll_cal_ctl7[0]) >> 6) & 0xf)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET(r) (((r).pll_cal_ctl7[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PLL_CAL_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r
#define PLL_CAL_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_t PLL_CAL_CTL7r_t;
#define PLL_CAL_CTL7r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_CLR
#define PLL_CAL_CTL7r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_SET
#define PLL_CAL_CTL7r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET
#define PLL_CAL_CTL7r_PLL_MODEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET
#define PLL_CAL_CTL7r_PLL_MODEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET
#define READ_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL7r
#define WRITE_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL7r
#define MODIFY_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL7r
#define READLN_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL7r
#define WRITELN_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL7r
#define WRITEALL_PLL_CAL_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL_STS0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd148
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_LOCK_LH_LL   indicates change on pll_lock status bit. It is clear on read status register
 *     PLL_SEQ_PASS_LH_LL indicates change on pll_seq_pass status bit. It is clear on read status register
 *     PLL_SEQ_DONE_LH_LL indicates change on pll_seq_done status bit. It is clear on read status register
 *     FREQ_PASS_SM_LH_LL indicates change on freq_pass_sm status bit. It is clear on read status register
 *     FREQ_DONE_SM_LH_LL indicates change on freq_done_sm status bit. It is clear on read status register
 *     CAP_PASS_LH_LL   indicates change on cap_pass status bit. It is clear on read status register
 *     CAP_DONE_LH_LL   indicates change on cap_done status bit. It is clear on read status register
 *     PLL_LOCK         status bit indicating PLL is locked
 *     PLL_SEQ_PASS     status bit indicating pll sequencer finised successfully
 *     PLL_SEQ_DONE     status bit indicating pll sequencer is done
 *     FREQ_PASS_SM     status bit indicating frequency lock
 *     FREQ_DONE_SM     status bit indicating freq det is done
 *     CAP_PASS         status indicating cap value was found
 *     CAP_DONE         status indicating cap sequencer is done
 *     LOST_PLL_LOCK_SM status bit indicating pll_lock was lost, clear on read
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r (0x0001d148 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts0[1];
	uint32_t _pll_cal_ctl_sts0;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CLR(r) (r).pll_cal_ctl_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_SET(r,d) (r).pll_cal_ctl_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_GET(r) (r).pll_cal_ctl_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET(r) (((r).pll_cal_ctl_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r
#define PLL_CAL_CTL_STS0r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_t PLL_CAL_CTL_STS0r_t;
#define PLL_CAL_CTL_STS0r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CLR
#define PLL_CAL_CTL_STS0r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_SET
#define PLL_CAL_CTL_STS0r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET
#define READ_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS0r
#define WRITE_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS0r
#define MODIFY_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS0r
#define READLN_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS0r
#define WRITELN_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS0r
#define WRITEALL_PLL_CAL_CTL_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL_STS1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd149
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CAP_SELECT       status bit indicating the selected cap value (i.e. pll_range[7:0])
 *     RESCAL_IN        rescal input value
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r (0x0001d149 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts1[1];
	uint32_t _pll_cal_ctl_sts1;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CLR(r) (r).pll_cal_ctl_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_SET(r,d) (r).pll_cal_ctl_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_GET(r) (r).pll_cal_ctl_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET(r) ((((r).pll_cal_ctl_sts1[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET(r) (((r).pll_cal_ctl_sts1[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r
#define PLL_CAL_CTL_STS1r_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_t PLL_CAL_CTL_STS1r_t;
#define PLL_CAL_CTL_STS1r_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CLR
#define PLL_CAL_CTL_STS1r_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_SET
#define PLL_CAL_CTL_STS1r_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET
#define READ_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS1r
#define WRITE_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS1r
#define MODIFY_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS1r
#define READLN_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS1r
#define WRITELN_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS1r
#define WRITEALL_PLL_CAL_CTL_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  PLL_CAL_CTL_STS_DBG
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd14a
 * DEVAD:    1
 * DESC:     PLL CAL debug status registers register.
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_SLOWDN       Indicates AFE pll_low/slowdn output signal status.
 *     DBG_SLOWDN_CHANGE Indicates change on AFE pll_low/slowdn output signal. It is clear on read status register
 *     DBG_FDBCK        Indicates change on AFE fdbck output signal. clear on read status register.Will be used to see if fdbck clock from AFE is toggling and alive
 *     DBG_CAP_STATE_ONE_HOT Indicates one hot encoded Cap Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State    dbg_cap_state_one_hot[x] where x is :==================================================Start          0WaitAmpL       1WaitSpeedL     2IncCapL        3Finish         4
 *     DBG_PLL_STATE_ONE_HOT Indicates one hot encoded PLL Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State   dbg_pll_state_one_hot[x] where x is :==============================================Start          0WaitVco        1VcoAdjust      2WaitFreq       3FreqDet        4Fail           5FreqMon        6Finish         7
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr (0x0001d14a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS_DBG.
 */
typedef union BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts_dbg[1];
	uint32_t _pll_cal_ctl_sts_dbg;
} BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_t;

#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_CLR(r) (r).pll_cal_ctl_sts_dbg[0] = 0
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_SET(r,d) (r).pll_cal_ctl_sts_dbg[0] = d
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_GET(r) (r).pll_cal_ctl_sts_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 3) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET(r) (((r).pll_cal_ctl_sts_dbg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS_DBG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts_dbg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr
#define PLL_CAL_CTL_STS_DBGr_SIZE BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_t PLL_CAL_CTL_STS_DBGr_t;
#define PLL_CAL_CTL_STS_DBGr_CLR BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_CLR
#define PLL_CAL_CTL_STS_DBGr_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_SET
#define PLL_CAL_CTL_STS_DBGr_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET
#define READ_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_READ_PLL_CAL_CTL_STS_DBGr
#define WRITE_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr
#define MODIFY_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr
#define READLN_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_READLN_PLL_CAL_CTL_STS_DBGr
#define WRITELN_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr
#define WRITEALL_PLL_CAL_CTL_STS_DBGr BCMI_BLACKHAWK_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_PLL_CAL_CTL_STS_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_CTL2
 * BLOCKS:   TXCOM
 * REGADDR:  0xd152
 * DEVAD:    1
 * DESC:     TX common control 2 register
 * RESETVAL: 0x1f4 (500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD Maximum Training Time in msPeriod/range is 500 ms
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r (0x0001d152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_s {
	uint32_t v[1];
	uint32_t txcom_ctl2[1];
	uint32_t _txcom_ctl2;
} BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_CLR(r) (r).txcom_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_SET(r,d) (r).txcom_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_GET(r) (r).txcom_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).txcom_ctl2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).txcom_ctl2[0]=(((r).txcom_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXCOM_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r,(_r._txcom_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r,(_r._txcom_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r,(_r._txcom_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r
#define TXCOM_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_t TXCOM_CTL2r_t;
#define TXCOM_CTL2r_CLR BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_CLR
#define TXCOM_CTL2r_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_SET
#define TXCOM_CTL2r_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_GET
#define TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_GET
#define TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIODf_SET
#define READ_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL2r
#define WRITE_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL2r
#define MODIFY_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL2r
#define READLN_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL2r
#define WRITELN_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL2r
#define WRITEALL_TXCOM_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_CTL3
 * BLOCKS:   TXCOM
 * REGADDR:  0xd153
 * DEVAD:    1
 * DESC:     TX common control 3 register
 * RESETVAL: 0xc8 (200)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_LINKTRN_WAIT_CNTR_LIMIT Period/range is 100-300 framesPeriod to keep transiming frames after the local device has completed trainingThe units are training pages.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r (0x0001d153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_s {
	uint32_t v[1];
	uint32_t txcom_ctl3[1];
	uint32_t _txcom_ctl3;
} BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_CLR(r) (r).txcom_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_SET(r,d) (r).txcom_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_GET(r) (r).txcom_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_GET(r) (((r).txcom_ctl3[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_SET(r,f) (r).txcom_ctl3[0]=(((r).txcom_ctl3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TXCOM_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r,(_r._txcom_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r,(_r._txcom_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r,(_r._txcom_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r
#define TXCOM_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_t TXCOM_CTL3r_t;
#define TXCOM_CTL3r_CLR BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_CLR
#define TXCOM_CTL3r_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_SET
#define TXCOM_CTL3r_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_GET
#define TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_GET
#define TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r_TXCOM_LINKTRN_WAIT_CNTR_LIMITf_SET
#define READ_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL3r
#define WRITE_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL3r
#define MODIFY_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL3r
#define READLN_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL3r
#define WRITELN_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL3r
#define WRITEALL_TXCOM_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_CTL4
 * BLOCKS:   TXCOM
 * REGADDR:  0xd154
 * DEVAD:    1
 * DESC:     TX common control 4 register
 * RESETVAL: 0x5dc (1500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSET Maximum Training Time in msPeriod/range is 500 ms for EternetPeriod/range is 1.5s for Fibre ChannelSecond copy to allow for different training times for 10G,25G and Fibre channel linksThe defaults are set to for Fibre channel
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r (0x0001d154 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_s {
	uint32_t v[1];
	uint32_t txcom_ctl4[1];
	uint32_t _txcom_ctl4;
} BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_CLR(r) (r).txcom_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_SET(r,d) (r).txcom_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_GET(r) (r).txcom_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET(r) (((r).txcom_ctl4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET(r,f) (r).txcom_ctl4[0]=(((r).txcom_ctl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXCOM_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r,(_r._txcom_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r,(_r._txcom_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r,(_r._txcom_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r
#define TXCOM_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_t TXCOM_CTL4r_t;
#define TXCOM_CTL4r_CLR BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_CLR
#define TXCOM_CTL4r_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_SET
#define TXCOM_CTL4r_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_GET
#define TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET
#define TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r_TXCOM_LINKTRN_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET
#define READ_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL4r
#define WRITE_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL4r
#define MODIFY_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL4r
#define READLN_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL4r
#define WRITELN_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL4r
#define WRITEALL_TXCOM_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_CTL5
 * BLOCKS:   TXCOM
 * REGADDR:  0xd155
 * DEVAD:    1
 * DESC:     TX common control 5 register
 * RESETVAL: 0x1b8 (440)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSET Period/range is 32us-96us (220-660 frames) for Fiber channelPeriod/range is 100-300 frames for EthernetPeriod to keep transmiting frames after the local device has completed trainingThe units are training pages. Second copy to allow for different training times for 10G, 25G and fibre channel linksThe defaults are set to for Fibre channel
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r (0x0001d155 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_s {
	uint32_t v[1];
	uint32_t txcom_ctl5[1];
	uint32_t _txcom_ctl5;
} BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_CLR(r) (r).txcom_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_SET(r,d) (r).txcom_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_GET(r) (r).txcom_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_GET(r) (((r).txcom_ctl5[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_SET(r,f) (r).txcom_ctl5[0]=(((r).txcom_ctl5[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TXCOM_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r,(_r._txcom_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r,(_r._txcom_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r,(_r._txcom_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r
#define TXCOM_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_t TXCOM_CTL5r_t;
#define TXCOM_CTL5r_CLR BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_CLR
#define TXCOM_CTL5r_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_SET
#define TXCOM_CTL5r_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_GET
#define TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_GET BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_GET
#define TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_SET BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r_TXCOM_LINKTRN_WAIT_CNTR_LIMIT_2NDSETf_SET
#define READ_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_READ_TXCOM_CTL5r
#define WRITE_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_CTL5r
#define MODIFY_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_CTL5r
#define READLN_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_READLN_TXCOM_CTL5r
#define WRITELN_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_CTL5r
#define WRITEALL_TXCOM_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd160
 * DEVAD:    1
 * DESC:     PRBS Checker Count Control
 * RESETVAL: 0x8602 (34306)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 *     RX_TRN_ACTIVE_AUTO_MODE_EN 1'b1 will forcefully disable the below described RX datapath functions automatically while RX Link Training is enabled and active irrespective of the below register bit settings .- PAM4 Gray Decoder         (enabled by field pam4_gray_dec_en       )- PAM4 Decoder              (enabled by field pam4_decoder_en        )- PAM4 Symbol bit-swap      (enabled by field pam4_rx_symbol_bit_swap)- PAM4 Back Channel Decoder (enabled by field bc_dec_en              )- PAM4 Descrambler          (enabled by field rx_descrambler_en      )- NRZ  Differential Decoder (enabled by field tlb_rx_diff_dec_en     )1'b0 will ignore the control signal from RX Link Training and the above RX datapath functions will be enabled based on their individual enable bits irrespective of the RX training status where enabled or disabled.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr (0x0001d160 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cnt_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr
#define READLN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd161
 * DEVAD:    1
 * DESC:     PRBS Checker Control
 * RESETVAL: 0x12a (298)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> PRBS 49 (1 + x^40 + x^49)
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.This mode results in faster locking, but bit errors are counted multiple times (often by 3x).2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_BURST_LEN_CHK_EN 0 => disbale, 1=> enable (default)
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 *     PRBS_CHK_MODE_SEL_MSB Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_chk_mode_sel[2:0].1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_chk_mode_sel[2:0].1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_chk_mode_sel[2:0].1'b1 & prbs_chk_mode_sel[2:0] == 0 will select PRBS 10.1'b1 & prbs_chk_mode_sel[2:0] == 1 will select PRBS 20.1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13.1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13  with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane 0 pattern.1'b1 & prbs_chk_mode_sel[2:0] == 3 is reserved for future use.1'b1 & prbs_chk_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13  polynomial (1 + x2 + x3 + x7  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13  polynomial (1 + x2 + x4 + x8  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13  polynomial (1 + x2 + x5 + x9  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 7 is reserved for future use.
 *     PRBS_CHK_BURST_ERR_CNT_EN PRBS checker burst error count mode enable.1'b1 will enable the PRBS checker burst error count mode. It should be enabled for prbs_chk_burst_err_cnt counter .Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en) are TRUE at any given time and not simultaneously TRUE.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr (0x0001d161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr
#define READLN_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd162
 * DEVAD:    1
 * DESC:     Digital Loopback Control
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_FLT_BYPASS Digital Loopback Phase Detector Filter Bypass. For repeater applications, it should be 1'b1.For other applications filter can be enabled for better jitter tolerance performance for the didgital loopback.
 *     DIG_LPBK_PD_BIAS_EN 1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle..1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr (0x0001d162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr
#define READLN_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr
#define WRITELN_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr
#define WRITEALL_TLB_RX_DIG_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd163
 * DEVAD:    1
 * DESC:     TLB RX Misc. Control
 * RESETVAL: 0x700 (1792)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     RX_DESCRAMBLER_EN PAM4 RX Datapath De-scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.Not applicable when external FEC feedback is used.1 => PAM4 RX Datapath  De-scrambler is Enabled. If rx_descrambler_en is enabled then 40 bits of the transmitted datawill be XORed with the 40 MSB bits of the fixed pattern sequence register {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0], patt_gen_seq_12[15:8]}.Make sure {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0], patt_gen_seq_12[15:8]} bits are only re-programmed or changed when rx_descrambler_en reg field is 1'b0.0 => PAM4 RX Datapath De-scrambler is Disabled.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 *     TLB_RX_DIFF_DEC_EN 1'b1 will enable the Differential Decoder for pmd_rx_data. Only applicable to PCS RX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 *     TLB_RX_NRZ_LL_MODE_EN RX low latency mode enable for the NRZ OSR modes. It is not applicable to the PAM4 modes.When Enabled by writing to 1'b1 for NRZ OS modes, following will be the data format on the 40 bit RX data bus. RX data_valid will be forced to 1'b1 in this case.PCS RX data can be fed directly to the PCS TX data (with TX native analog format mode bit enabled) on the other end for Repeater Applications.OS1/2/4 modes        - 20 bits of RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.OS8/16/32 modes      - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.OS16.5/OS20.25 modes - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.
 *     PAM4_GRAY_DEC_EN PAM4 Gray Decoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Gray Decoder is Enabled.0 => PAM4 Gray Decoder is Disabled.
 *     PAM4_DECODER_EN  PAM4 Decoder Enable. Enable it only for the PAM4 NS mode.1 => PAM4 Decoder is Enabled.0 => PAM4 Decoder is Disabled.
 *     PAM4_RX_SYMBOL_BIT_SWAP PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just after the PAM4 gray decoder.1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first bit in receive order.0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in receive order.
 *     PRBS_CHK_AUTO_DETECT_CNT Specifies the timer for the auto-detect search in each polynomial setting.
 *     PRBS_CHK_AUTO_DETECT_EN PRBS checker Auto detect mode enable. If enabled then it will go through all the supported PRBS polynomials in round-robin fashion and search for prbs_chk_lock=1 until AUTO-DETECT SEARCH timer is expired.
 *     PRBS_CHK_AUTO_DETECT_RELOCK_EN PRBS checker Auto detect Re-lock enable. If enabled then it will go and start the auto-detect upon loss of signal once it already found a valid AUTO-DETECT LOCK.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr (0x0001d163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_TLB_RX_MISC_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_tlb_rx_misc_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_tlb_rx_misc_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_tlb_rx_misc_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_TLB_RX_MISC_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_tlb_rx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr
#define TLB_RX_TLB_RX_MISC_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t TLB_RX_TLB_RX_MISC_CFGr_t;
#define TLB_RX_TLB_RX_MISC_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_TLB_RX_MISC_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET
#define TLB_RX_TLB_RX_MISC_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr
#define READLN_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITELN_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITEALL_TLB_RX_TLB_RX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_TLB_RX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd164
 * DEVAD:    1
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en) are TRUE at any given time and not simultaneously TRUE.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0001d164 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_en_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd165
 * DEVAD:    1
 * DESC:     PRBS Checker Burst Error Counter Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_BURST_ERR_CNT PRBS Checker Burst Error Counter Status Register. It is a clear on read register. This register countsthe number of Burst in errors separated by atleast 1 clock cycle worth of data without any bit in error.prbs_chk_burst_err_cnt_en should be set to 1'b1 for this counter to work.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr (0x0001d165 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_burst_err_cnt_sts[1];
	uint32_t _tlb_rx_prbs_chk_burst_err_cnt_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET(r,d) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET(r) (((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]=(((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_DBG_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd166
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_PMD_RX_LOCK  Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     DBG_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr (0x0001d166 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dbg_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_dbg_pmd_rx_lock_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dbg_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t TLB_RX_DBG_PMD_RX_LOCK_STSr_t;
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET
#define READ_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_UC_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd167
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_PMD_RX_LOCK   Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     UC_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr (0x0001d167 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_UC_PMD_RX_LOCK_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_uc_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_uc_pmd_rx_lock_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_uc_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_uc_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_UC_PMD_RX_LOCK_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_uc_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t TLB_RX_UC_PMD_RX_LOCK_STSr_t;
#define TLB_RX_UC_PMD_RX_LOCK_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET
#define READ_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd168
 * DEVAD:    1
 * DESC:     Digital Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 *     PRBS_CHK_AUTO_DETECT_LOCK Live indication of AUTO-DETECT Lock. Set to 1'b1 once auto-detect finds the PRBS lock.
 *     PRBS_CHK_INV_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Indicates te PRBS polynomial invert bit.
 *     PRBS_CHK_MODE_SEL_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel     register in auto-detect mode.
 *     PRBS_CHK_MODE_SEL_MSB_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel_msb register in auto-detect mode.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr (0x0001d168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 10) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr
#define READLN_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITELN_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITEALL_TLB_RX_DIG_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_DIG_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd169
 * DEVAD:    1
 * DESC:     PRBS Checker LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is searching for a LOCK.
 *     PRBS_CHK_ERR_CNT_NO_CLR PRBS Checker Error Counter which does not get cleared upon read.MSB bit 14 is OR of the MSB bits [30:14] of the internal error counter.LSB bits [13:0] are assigned to LSB bits [13:0] of the internal error counter.It can be cleared by reading the status register prbs_chk_err_cnt_msb.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr (0x0001d169 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET(r) ((((r).tlb_rx_prbs_chk_lock_sts[0]) >> 1) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1)) | (32767 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr
#define READLN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16a
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter MSB Status
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status register.prbs_chk_lock_lost_lh status bit also indicate other PRBS checker states as below.- PRBS Checker is currently not enabled ||- PRBS Checker is currently not locked ||- PRBS_LOCK was lost when checker was enabled since the last read
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0001d16a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16b
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter LSB Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0001d16b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16c
 * DEVAD:    1
 * DESC:     PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr (0x0001d16c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_PMD_RX_LOCK_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16d
 * DEVAD:    1
 * DESC:     PRBS Burst Error Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error length count. This the live indication of the live status of the PRBS burst error length and max at 6'd63. This register is cleared upon read.This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NS/ES modes with and without Back Channel enabled.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr (0x0001d16d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_prbs_burst_err_len_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_prbs_burst_err_len_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_prbs_burst_err_len_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_prbs_burst_err_len_sts[0]=(((r).tlb_rx_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16e
 * DEVAD:    1
 * DESC:     PRBS Burst Error Maximum Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAX_PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error max length count. This the status of the PRBS burst error max length and max at 6'd63. This register is cleared upon read.This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NS/ES modes with and without Back Channel enabled.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr (0x0001d16e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_max_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_max_prbs_burst_err_len_sts;
} BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_max_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_max_prbs_burst_err_len_sts[0]=(((r).tlb_rx_max_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_max_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_PATGEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd170
 * DEVAD:    1
 * DESC:     Pattern Generator Control
 * RESETVAL: 0xb000 (45056)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PAM4_TX_LINEARITY_PATT_EN PAM4 Transmitter Linearity Pattern Enable. Lower priority than pam4_tx_jp03b_patt_en if both bits are enabled simultaneously. Make sure gray encoder and PAM4 precoder is disabled for this fixed pattern mode.1 => enable  the fixed pattern for PAM4 Transmitter Linearity Pattern of 320 bits (i.e. 160 symbols) long repeating pattern of 10 PAM4 levels of {-1, -1/3, +1/3, +1, -1, +1, -1, +1, +1/3, -1/3} whereeach level is 16UI in duration.  Program reg field {patt_gen_seq_1[3:0], patt_gen_seq_0[15:0]} bits = 20'b_0001_1011_0011_0011_1001 = 20'h1B339 before enabling this pattern.Transmission order is MSB first.  If this bit is enabled then make sure that other lane fixed pattern do not use fixed pattern 20 bit chunk of bits 19:0.0 => disable the PAM4 Transmitter Linearity Pattern generation.
 *     PAM4_TX_JP03B_PATT_EN JP03B Fixed Pattern Enable. Higher priority than pam4_tx_linearity_patt_en if both bits are enabled simultaneously. Make sure gray encoder and PAM4 precoder is disabled for this fixed pattern mode.1 => Enable  the fixed pattern for JP03B pattern of 124 bits (i.e. 62 symbols) long repeating pattern of {15{00,11}} + {16{11,00}}. Program reg field patt_gen_seq_1[15:8] bits = 8'b_0011_1100 = 8'h3C before enabling this pattern.Transmission order is MSB first. If this bit is enabled then make sure that other lane fixed pattern do not use fixed pattern 20 bit chunk of bits 39:20.0 => Disable the JP03B fixed pattern generation.C
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr (0x0001d170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATGEN_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patgen_cfg[1];
	uint32_t _tlb_tx_patgen_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_CLR(r) (r).tlb_tx_patgen_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_SET(r,d) (r).tlb_tx_patgen_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_GET(r) (r).tlb_tx_patgen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 8) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patgen_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PATGEN_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_patgen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr
#define TLB_TX_PATGEN_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_t TLB_TX_PATGEN_CFGr_t;
#define TLB_TX_PATGEN_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_CLR
#define TLB_TX_PATGEN_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_SET
#define TLB_TX_PATGEN_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_TX_PATGEN_CFGr
#define WRITE_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_PATGEN_CFGr
#define MODIFY_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_PATGEN_CFGr
#define READLN_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_PATGEN_CFGr
#define WRITELN_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_PATGEN_CFGr
#define WRITEALL_TLB_TX_PATGEN_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_PATGEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd171
 * DEVAD:    1
 * DESC:     PRBS Generator Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> PRBS 49 (1 + x^40 + x^49)
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 *     PRBS_GEN_MODE_SEL_MSB Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_gen_mode_sel[2:0].1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_gen_mode_sel[2:0].1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_gen_mode_sel[2:0].1'b1 & prbs_gen_mode_sel[2:0] == 0 will select PRBS 10.1'b1 & prbs_gen_mode_sel[2:0] == 1 will select PRBS 20.1'b1 & prbs_gen_mode_sel[2:0] == 2 will select PRBS 13  with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane 0 pattern.1'b1 & prbs_gen_mode_sel[2:0] == 3 is reserved for future use.1'b1 & prbs_gen_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13  polynomial (1 + x2 + x3 + x7  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13  polynomial (1 + x2 + x4 + x8  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13  polynomial (1 + x2 + x5 + x9  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 7 is reserved for future use.
 *     PRBS_GEN_PAUSE_STROBE PRBS Generator Pause Strobe (debug register). It is a self clear register bit.Wrting to 1 will pause the PRBS generator for 1 clock cycle which means same 40 bits data will be replicated in the paused clock cycle. This will result into loss of prbs checker lock on the link partner.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr (0x0001d171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_prbs_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr
#define READLN_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr
#define WRITELN_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr
#define WRITEALL_TLB_TX_PRBS_GEN_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_PRBS_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd172
 * DEVAD:    1
 * DESC:     Remote Loopback Control
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr (0x0001d172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr
#define READLN_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr
#define WRITELN_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr
#define WRITEALL_TLB_TX_RMT_LPBK_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd173
 * DEVAD:    1
 * DESC:     TLB TX Misc. Control
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 *     TLB_TX_DIFF_ENC_EN 1'b1 will enable the Differential Encoder for pmd_tx_data. Only applicable to PCS TX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 *     TX_TRN_ACTIVE_AUTO_MODE_EN 1'b1 will forcefully disable the below described TX datapath functions automatically while TX Link Training is enabled and active irrespective of the below register bit settings .- PAM4 Gray Encoder         (enabled by field pam4_gray_enc_en)- PAM4 Precoder             (enabled by field pam4_precoder_en)- PAM4 Symbol bit-swap      (enabled by field pam4_tx_symbol_bit_swap)- NRZ Differential Encoder  (enabled by field tlb_tx_diff_enc_en)In addition to these function Back channel encoder and Scrambler are always disabled while TX Link Training is enabled and active irrespective of this register value.1'b0 will ignore the control signal from TX Link Training and the above TX datapath functions will be enabled based on their individual enable bits irrespective of the TX training status where enabled or disabled.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr (0x0001d173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_MISC_CFG.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_tlb_tx_misc_cfg;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_tlb_tx_misc_cfg[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_tlb_tx_misc_cfg[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_MISC_CFG.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr
#define TLB_TX_TLB_TX_MISC_CFGr_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t TLB_TX_TLB_TX_MISC_CFGr_t;
#define TLB_TX_TLB_TX_MISC_CFGr_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_TLB_TX_MISC_CFGr_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET
#define TLB_TX_TLB_TX_MISC_CFGr_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr
#define READLN_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITELN_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITEALL_TLB_TX_TLB_TX_MISC_CFGr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_PAM4_CFG0
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd175
 * DEVAD:    1
 * DESC:     TLB TX PAM4 Controls 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PAM4_GRAY_ENC_EN PAM4 Gray Encoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Gray Encoder is Enabled.0 => PAM4 Gray Encoder is Disabled.
 *     PAM4_PRECODER_EN PAM4 Precoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Precoder is Enabled.0 => PAM4 Precoder is Disabled.
 *     TX_SCRAMBLER_EN  PAM4 TX Datapath Scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.1 => PAM4 TX Datapath Scrambler is Enabled. If tx_scrambler_en is enabled then 40 bits of the transmitted datawill be XORed with the 40 LSB bits of the fixed pattern sequence register {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]}.Make sure {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]} bits are only re-programmed or changed when both tx_scrambler_en and bc_enc_err_ins_en reg fields are 1'b0.0 => PAM4 TX Datapath Scrambler is Disabled.
 *     PAM4_TX_SYMBOL_BIT_SWAP PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just before the PAM4 gray encoder.1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first bit in transmission order.0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in transmission order.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r (0x0001d175 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_PAM4_CFG0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_pam4_cfg0[1];
	uint32_t _tlb_tx_tlb_tx_pam4_cfg0;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_CLR(r) (r).tlb_tx_tlb_tx_pam4_cfg0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SET(r,d) (r).tlb_tx_tlb_tx_pam4_cfg0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_GET(r) (r).tlb_tx_tlb_tx_pam4_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET(r) (((r).tlb_tx_tlb_tx_pam4_cfg0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_PAM4_CFG0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_pam4_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r
#define TLB_TX_TLB_TX_PAM4_CFG0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_t TLB_TX_TLB_TX_PAM4_CFG0r_t;
#define TLB_TX_TLB_TX_PAM4_CFG0r_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_CLR
#define TLB_TX_TLB_TX_PAM4_CFG0r_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET
#define READ_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITE_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_PAM4_CFG0r
#define MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r
#define READLN_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd178
 * DEVAD:    1
 * DESC:     Remote Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr (0x0001d178 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr
#define READLN_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITELN_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITEALL_TLB_TX_RMT_LPBK_PD_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_RMT_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_BC_ENC_CFG0
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd179
 * DEVAD:    1
 * DESC:     TLB TX Back Channel Encoder Controls 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_ENC_EN        Back Channel Encoder Enable. Applicable only to PAM4 modes alongwith PRBS or PCS TX data sources.1 => Back Channel Encoder is Enabled.0 => Back Channel Encoder is Disabled.
 *     BC_ENC_UPDATE    Back Channel Encoder Update Control. Self-clear control register. Write this register to 1'b1 after updating the bc_enc_data and/or bc_enc_frm_len_sel fields.Updated information will be sent transmitted in the next back channel encoder word/frame.
 *     BC_ENC_ERR_INS_EN Back Channel Encoder Error Insert Enable. Applicable only for the modes when BC encoder is enabled.tx_scrambler_en reg field should be disabled for BC encoder error insertion to work otherwise all the TX data will be XORed instead and not only the BC encoder frame.1 => Back Channel Encoder Error Insert is Enabled. If BC encoder error insertion is enabled and tx_scrambler_en is disabled then 40 bits of the transmittedBC frame will be XORed with the 40 LSB bits of the fixed pattern sequence register {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]}.Make sure {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]} bits are only re-programmed or changed when both tx_scrambler_en and bc_enc_err_ins_en reg fields are 1'b0.0 => Back Channel Encoder Error Insert is Disabled.
 *     BC_ENC_FRM_LEN_SEL Back Channel Encoder Frame Length Select Control. Determines the distance between 2 adjacent back channel frames.Following table explains the value of this register and BC frame length in multiples of 128 tclk20 cycles or 128*20 PAM4 symbols.bc_enc_frm_len_sel[2:0]            BC frame length in multiples of 128*20 PAM4 symbols.0                                      11                                      16*2^02                                      16*2^13                                      16*2^24                                      16*2^35                                      16*2^46                                      16*2^57                                      16*2^6
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r (0x0001d179 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_BC_ENC_CFG0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_bc_enc_cfg0[1];
	uint32_t _tlb_tx_tlb_tx_bc_enc_cfg0;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_CLR(r) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_SET(r,d) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_GET(r) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_GET(r) ((((r).tlb_tx_tlb_tx_bc_enc_cfg0[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_GET(r) ((((r).tlb_tx_tlb_tx_bc_enc_cfg0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_GET(r) ((((r).tlb_tx_tlb_tx_bc_enc_cfg0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_GET(r) (((r).tlb_tx_tlb_tx_bc_enc_cfg0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg0[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_BC_ENC_CFG0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r,(_r._tlb_tx_tlb_tx_bc_enc_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r,(_r._tlb_tx_tlb_tx_bc_enc_cfg0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r,(_r._tlb_tx_tlb_tx_bc_enc_cfg0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_bc_enc_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_t TLB_TX_TLB_TX_BC_ENC_CFG0r_t;
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_CLR
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_FRM_LEN_SELf_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ERR_INS_ENf_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_UPDATEf_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r_BC_ENC_ENf_SET
#define READ_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define WRITE_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define READLN_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG0r
#define WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_BC_ENC_CFG1
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd17a
 * DEVAD:    1
 * DESC:     TLB TX Back Channel Encoder Controls 1
 * RESETVAL: 0xf628 (63016)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_ENC_DATA_LSB  Back Channel Encoder Data LSB bits [15:0].
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r (0x0001d17a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_BC_ENC_CFG1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_bc_enc_cfg1[1];
	uint32_t _tlb_tx_tlb_tx_bc_enc_cfg1;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_CLR(r) (r).tlb_tx_tlb_tx_bc_enc_cfg1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_SET(r,d) (r).tlb_tx_tlb_tx_bc_enc_cfg1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_GET(r) (r).tlb_tx_tlb_tx_bc_enc_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_GET(r) (((r).tlb_tx_tlb_tx_bc_enc_cfg1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg1[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_BC_ENC_CFG1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r,(_r._tlb_tx_tlb_tx_bc_enc_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r,(_r._tlb_tx_tlb_tx_bc_enc_cfg1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r,(_r._tlb_tx_tlb_tx_bc_enc_cfg1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_bc_enc_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_t TLB_TX_TLB_TX_BC_ENC_CFG1r_t;
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_CLR
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r_BC_ENC_DATA_LSBf_SET
#define READ_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define WRITE_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define READLN_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG1r
#define WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_BC_ENC_CFG2
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd17b
 * DEVAD:    1
 * DESC:     TLB TX Back Channel Encoder Controls 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_ENC_DATA_MSB  Back Channel Encoder Data LSB bits [15:0].
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r (0x0001d17b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_BC_ENC_CFG2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_bc_enc_cfg2[1];
	uint32_t _tlb_tx_tlb_tx_bc_enc_cfg2;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_CLR(r) (r).tlb_tx_tlb_tx_bc_enc_cfg2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_SET(r,d) (r).tlb_tx_tlb_tx_bc_enc_cfg2[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_GET(r) (r).tlb_tx_tlb_tx_bc_enc_cfg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_GET(r) (((r).tlb_tx_tlb_tx_bc_enc_cfg2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_cfg2[0]=(((r).tlb_tx_tlb_tx_bc_enc_cfg2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_BC_ENC_CFG2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r,(_r._tlb_tx_tlb_tx_bc_enc_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r,(_r._tlb_tx_tlb_tx_bc_enc_cfg2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r,(_r._tlb_tx_tlb_tx_bc_enc_cfg2))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_bc_enc_cfg2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_t TLB_TX_TLB_TX_BC_ENC_CFG2r_t;
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_CLR
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_SET
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_GET
#define TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r_BC_ENC_DATA_MSBf_SET
#define READ_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define WRITE_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define READLN_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_CFG2r
#define WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG2r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_CFG2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_CFG2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_TX_TLB_TX_BC_ENC_STS0
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd17e
 * DEVAD:    1
 * DESC:     TLB TX Back Channel Encoder Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_ENC_DATA_SENT Status bit (when set to 1) indicating that the first back channel frame/word with the updated BC data and/or frame lenghth have been transmitted.This is a clear-on-read status register. It is also cleared upon bc_enc_update assertion.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r (0x0001d17e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_BC_ENC_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_bc_enc_sts0[1];
	uint32_t _tlb_tx_tlb_tx_bc_enc_sts0;
} BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_CLR(r) (r).tlb_tx_tlb_tx_bc_enc_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_SET(r,d) (r).tlb_tx_tlb_tx_bc_enc_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_GET(r) (r).tlb_tx_tlb_tx_bc_enc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_GET(r) (((r).tlb_tx_tlb_tx_bc_enc_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_SET(r,f) (r).tlb_tx_tlb_tx_bc_enc_sts0[0]=(((r).tlb_tx_tlb_tx_bc_enc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_BC_ENC_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r,(_r._tlb_tx_tlb_tx_bc_enc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r,(_r._tlb_tx_tlb_tx_bc_enc_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r,(_r._tlb_tx_tlb_tx_bc_enc_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_bc_enc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_bc_enc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r
#define TLB_TX_TLB_TX_BC_ENC_STS0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_t TLB_TX_TLB_TX_BC_ENC_STS0r_t;
#define TLB_TX_TLB_TX_BC_ENC_STS0r_CLR BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_CLR
#define TLB_TX_TLB_TX_BC_ENC_STS0r_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_SET
#define TLB_TX_TLB_TX_BC_ENC_STS0r_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_GET
#define TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_GET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_GET
#define TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_SET BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r_BC_ENC_DATA_SENTf_SET
#define READ_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_READ_TLB_TX_TLB_TX_BC_ENC_STS0r
#define WRITE_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_TX_TLB_TX_BC_ENC_STS0r
#define MODIFY_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_TX_TLB_TX_BC_ENC_STS0r
#define READLN_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_READLN_TLB_TX_TLB_TX_BC_ENC_STS0r
#define WRITELN_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_TX_TLB_TX_BC_ENC_STS0r
#define WRITEALL_TLB_TX_TLB_TX_BC_ENC_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_TX_TLB_TX_BC_ENC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_TX_TLB_TX_BC_ENC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_PMD_CORE_MODE_STS
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd180
 * DEVAD:    1
 * DESC:     PMD_CORE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input bus pmd_core_mode[15:0].This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr (0x0001d180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PMD_CORE_MODE_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t core_pll_pmd_core_mode_sts[1];
	uint32_t _core_pll_pmd_core_mode_sts;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_CLR(r) (r).core_pll_pmd_core_mode_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SET(r,d) (r).core_pll_pmd_core_mode_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_GET(r) (r).core_pll_pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).core_pll_pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).core_pll_pmd_core_mode_sts[0]=(((r).core_pll_pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PMD_CORE_MODE_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pmd_core_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pmd_core_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pmd_core_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr
#define CORE_PLL_PMD_CORE_MODE_STSr_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_t CORE_PLL_PMD_CORE_MODE_STSr_t;
#define CORE_PLL_PMD_CORE_MODE_STSr_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_CLR
#define CORE_PLL_PMD_CORE_MODE_STSr_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SET
#define CORE_PLL_PMD_CORE_MODE_STSr_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_GET
#define CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITE_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PMD_CORE_MODE_STSr
#define MODIFY_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PMD_CORE_MODE_STSr
#define READLN_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITELN_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_PMD_CORE_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_RST_CTL_PLL_DP
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd182
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PLL_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_CORE_DP_H_RSTB_PKILL 1'b1 will disable the pmd_core_dp_h_rstb pin.
 *     REFCLK_LOC_MON_EN 1 - use the refclk_loc status to switch the refclk to comclk used in RMIC and PLL_CAL register block forecfully through the glitchless mux as refclk is already lost.
 *     REFCLK_S_COMCLK_SEL Mux control for selection of comclk for the refclk clock used in RMIC and PLL_CAL register block.If asserted by writing to 1'b1 will select the comclk for the refclk clock. This register bit will enable the glitchless switching of the refclk to comclk for the refclk used in RMIC and PLL_CAL register block.
 *     REFCLK_S_COMCLK_FRC_ON Mux control for selection of comclk for refclk by force.If asserted by writing to 1'b1 will select the comclk for the refclk clock. This is a debug bit and should be only used if refclk from AFE is unavailable or dead for unforeseen reasons.
 *     VCOCLK4PCS_S_COMCLK_SEL Mux control for selection of comclk for pmd_vcoclk4pcs clock.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock.It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_sel is asserted to 1'b1by using pmd_vcoclk4pcs_vld_frc/frc_val registers.
 *     VCOCLK4PCS_S_COMCLK_FRC_ON Mux control for selection of comclk for pmd_vcoclk4pcs by force.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock. This is a debug bit and should be only used if vcoclk4pcs from AFE is dead for unforeseen reasons.It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_frc_on is asserted to 1'b1by using pmd_vcoclk4pcs_vld_frc/frc_val registers.
 *     PMD_VCOCLK4PCS_VLD_FRC pmd_vcoclk4pcs_vld pin force.
 *     PMD_VCOCLK4PCS_VLD_FRC_VAL pmd_vcoclk4pcs_vld pin force value.
 *     AFE_S_PLL_RESET_FRC_VAL Active High PLL Reset force value control.
 *     AFE_S_PLL_RESET_FRC Active High PLL Reset force control.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr (0x0001d182 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_RST_CTL_PLL_DP.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_s {
	uint32_t v[1];
	uint32_t core_pll_rst_ctl_pll_dp[1];
	uint32_t _core_pll_rst_ctl_pll_dp;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_CLR(r) (r).core_pll_rst_ctl_pll_dp[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_SET(r,d) (r).core_pll_rst_ctl_pll_dp[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_GET(r) (r).core_pll_rst_ctl_pll_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CORE_PLL_RST_CTL_PLL_DP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr,(_r._core_pll_rst_ctl_pll_dp))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr,(_r._core_pll_rst_ctl_pll_dp)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr,(_r._core_pll_rst_ctl_pll_dp))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_RST_CTL_PLL_DPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_rst_ctl_pll_dp))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_RST_CTL_PLL_DPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_rst_ctl_pll_dp))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_rst_ctl_pll_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr
#define CORE_PLL_RST_CTL_PLL_DPr_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_t CORE_PLL_RST_CTL_PLL_DPr_t;
#define CORE_PLL_RST_CTL_PLL_DPr_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_CLR
#define CORE_PLL_RST_CTL_PLL_DPr_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_SET
#define CORE_PLL_RST_CTL_PLL_DPr_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_FRC_ONf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_S_COMCLK_SELf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_REFCLK_LOC_MON_ENf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET
#define READ_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_RST_CTL_PLL_DPr
#define WRITE_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_RST_CTL_PLL_DPr
#define MODIFY_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_RST_CTL_PLL_DPr
#define READLN_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_RST_CTL_PLL_DPr
#define WRITELN_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_RST_CTL_PLL_DPr
#define WRITEALL_CORE_PLL_RST_CTL_PLL_DPr BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_RST_CTL_PLL_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_RST_CTL_PLL_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_TOP_USER_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd184
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb.Minimum assertion time is 50 comclk cycles.
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.Minimum assertion time is 50 comclk cycles.
 *     CORE_HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the core which means there is no acknowledgement required from uC and core dp reset will be de-asserted once core reset register/pin conditions are de-asserted.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr (0x0001d184 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_TOP_USER_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_top_user_ctl[1];
	uint32_t _core_pll_top_user_ctl;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CLR(r) (r).core_pll_top_user_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_SET(r,d) (r).core_pll_top_user_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_GET(r) (r).core_pll_top_user_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access CORE_PLL_TOP_USER_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_TOP_USER_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_top_user_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_TOP_USER_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_top_user_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_top_user_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr
#define CORE_PLL_TOP_USER_CTLr_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_t CORE_PLL_TOP_USER_CTLr_t;
#define CORE_PLL_TOP_USER_CTLr_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CLR
#define CORE_PLL_TOP_USER_CTLr_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_SET
#define CORE_PLL_TOP_USER_CTLr_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET
#define READ_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_TOP_USER_CTLr
#define WRITE_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_TOP_USER_CTLr
#define MODIFY_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_TOP_USER_CTLr
#define READLN_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_TOP_USER_CTLr
#define WRITELN_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_TOP_USER_CTLr
#define WRITEALL_CORE_PLL_TOP_USER_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_TOP_USER_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_TOP_USER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_UC_ACK_CORE_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd185
 * DEVAD:    1
 * DESC:     UC_ACK_CORE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr (0x0001d185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_UC_ACK_CORE_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_uc_ack_core_ctl[1];
	uint32_t _core_pll_uc_ack_core_ctl;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_CLR(r) (r).core_pll_uc_ack_core_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SET(r,d) (r).core_pll_uc_ack_core_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_GET(r) (r).core_pll_uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).core_pll_uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).core_pll_uc_ack_core_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CORE_PLL_UC_ACK_CORE_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_uc_ack_core_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_uc_ack_core_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_uc_ack_core_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr
#define CORE_PLL_UC_ACK_CORE_CTLr_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_t CORE_PLL_UC_ACK_CORE_CTLr_t;
#define CORE_PLL_UC_ACK_CORE_CTLr_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_CLR
#define CORE_PLL_UC_ACK_CORE_CTLr_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITE_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_UC_ACK_CORE_CTLr
#define MODIFY_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_UC_ACK_CORE_CTLr
#define READLN_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITELN_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_UC_ACK_CORE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_PLL_DP_RST_ST_STS
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd188
 * DEVAD:    1
 * DESC:     PLL_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr (0x0001d188 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_DP_RST_ST_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t core_pll_pll_dp_rst_st_sts[1];
	uint32_t _core_pll_pll_dp_rst_st_sts;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CLR(r) (r).core_pll_pll_dp_rst_st_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SET(r,d) (r).core_pll_pll_dp_rst_st_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_GET(r) (r).core_pll_pll_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).core_pll_pll_dp_rst_st_sts[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).core_pll_pll_dp_rst_st_sts[0]=(((r).core_pll_pll_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_DP_RST_ST_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr
#define CORE_PLL_PLL_DP_RST_ST_STSr_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_t CORE_PLL_PLL_DP_RST_ST_STSr_t;
#define CORE_PLL_PLL_DP_RST_ST_STSr_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CLR
#define CORE_PLL_PLL_DP_RST_ST_STSr_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SET
#define CORE_PLL_PLL_DP_RST_ST_STSr_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITE_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr
#define MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr
#define READLN_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_CORE_PLL_COM_STS2
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd189
 * DEVAD:    1
 * DESC:     CORE_PLL_COM_STATUS_2
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_PWRDN_OR     pll_pwrdn after dft muxing
 *     REFCLK_LOC       Indicates the Loss of Clock indication for refclk. Loss of refclk monitor uses the comclk as the measuring clock so for this monitoring status to work properly comclk has to be there.If ratio of the (comclk freq/refclk freq) <= 4 then LOC monitor should not report it as LOC but any slower refclk than that will result into LOC even though refclk is toggling. So assuming mac comclk is 175 Mhz,then slowest refclk which will not result into LOC is 175/4 = 43.75 Mhz.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r (0x0001d189 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_CORE_PLL_COM_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_s {
	uint32_t v[1];
	uint32_t core_pll_core_pll_com_sts2[1];
	uint32_t _core_pll_core_pll_com_sts2;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_CLR(r) (r).core_pll_core_pll_com_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_SET(r,d) (r).core_pll_core_pll_com_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_GET(r) (r).core_pll_core_pll_com_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_GET(r) ((((r).core_pll_core_pll_com_sts2[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_SET(r,f) (r).core_pll_core_pll_com_sts2[0]=(((r).core_pll_core_pll_com_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_GET(r) (((r).core_pll_core_pll_com_sts2[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_SET(r,f) (r).core_pll_core_pll_com_sts2[0]=(((r).core_pll_core_pll_com_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CORE_PLL_CORE_PLL_COM_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r,(_r._core_pll_core_pll_com_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r,(_r._core_pll_core_pll_com_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r,(_r._core_pll_core_pll_com_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_core_pll_com_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_core_pll_com_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_CORE_PLL_COM_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_core_pll_com_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r
#define CORE_PLL_CORE_PLL_COM_STS2r_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_t CORE_PLL_CORE_PLL_COM_STS2r_t;
#define CORE_PLL_CORE_PLL_COM_STS2r_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_CLR
#define CORE_PLL_CORE_PLL_COM_STS2r_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_SET
#define CORE_PLL_CORE_PLL_COM_STS2r_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_GET
#define CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_GET
#define CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_REFCLK_LOCf_SET
#define CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_GET
#define CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r_PLL_PWRDN_ORf_SET
#define READ_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_CORE_PLL_COM_STS2r
#define WRITE_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_CORE_PLL_COM_STS2r
#define MODIFY_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_CORE_PLL_COM_STS2r
#define READLN_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_CORE_PLL_COM_STS2r
#define WRITELN_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_CORE_PLL_COM_STS2r
#define WRITEALL_CORE_PLL_CORE_PLL_COM_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_CORE_PLL_COM_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_CORE_PLL_COM_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_PLL_CFG_FWAPI_DATA0
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd18d
 * DEVAD:    1
 * DESC:     PLL_CFG_FWAPI_DATA0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_CFG_FWAPI_DATA0 PLL configuration firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangePLL configuration information
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r (0x0001d18d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_CFG_FWAPI_DATA0.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t core_pll_pll_cfg_fwapi_data0[1];
	uint32_t _core_pll_pll_cfg_fwapi_data0;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR(r) (r).core_pll_pll_cfg_fwapi_data0[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET(r,d) (r).core_pll_pll_cfg_fwapi_data0[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET(r) (r).core_pll_pll_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET(r) (((r).core_pll_pll_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET(r,f) (r).core_pll_pll_cfg_fwapi_data0[0]=(((r).core_pll_pll_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_CFG_FWAPI_DATA0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_t CORE_PLL_PLL_CFG_FWAPI_DATA0r_t;
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET
#define READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  CORE_PLL_PLL_CFG_FWAPI_DATA1
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd18e
 * DEVAD:    1
 * DESC:     PLL_CFG_FWAPI_DATA1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_CFG_FWAPI_DATA1 PLL configuration firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangePLL configuration information
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r (0x0001d18e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_CFG_FWAPI_DATA1.
 */
typedef union BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_s {
	uint32_t v[1];
	uint32_t core_pll_pll_cfg_fwapi_data1[1];
	uint32_t _core_pll_pll_cfg_fwapi_data1;
} BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_t;

#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR(r) (r).core_pll_pll_cfg_fwapi_data1[0] = 0
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET(r,d) (r).core_pll_pll_cfg_fwapi_data1[0] = d
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET(r) (r).core_pll_pll_cfg_fwapi_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET(r) (((r).core_pll_pll_cfg_fwapi_data1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET(r,f) (r).core_pll_pll_cfg_fwapi_data1[0]=(((r).core_pll_pll_cfg_fwapi_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_CFG_FWAPI_DATA1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_cfg_fwapi_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_t CORE_PLL_PLL_CFG_FWAPI_DATA1r_t;
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET
#define READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd190
 * DEVAD:    1
 * DESC:     LANE_ADDR_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_0   Determines the logical address associated with the PMD RX lane with physical index  "_0" at the PCS interface.rx_lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     TX_LANE_ADDR_0   Determines the logical address associated with the PMD TX lane with physical index  "_0" at the PCS interface.tx_lane_addr_0 is the logical address of the TX lane with pins at the PCS interface labeled "_0".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r (0x0001d190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR0r_s {
	uint32_t v[1];
	uint32_t ln_addr0[1];
	uint32_t _ln_addr0;
} BCMI_BLACKHAWK_XGXS_LN_ADDR0r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_CLR(r) (r).ln_addr0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_SET(r,d) (r).ln_addr0[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_GET(r) (r).ln_addr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET(r) ((((r).ln_addr0[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET(r) (((r).ln_addr0[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r,(_r._ln_addr0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR0r BCMI_BLACKHAWK_XGXS_LN_ADDR0r
#define LN_ADDR0r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR0r_t LN_ADDR0r_t;
#define LN_ADDR0r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR0r_CLR
#define LN_ADDR0r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_SET
#define LN_ADDR0r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET
#define LN_ADDR0r_RX_LANE_ADDR_0f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET
#define LN_ADDR0r_RX_LANE_ADDR_0f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET
#define READ_LN_ADDR0r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR0r
#define WRITE_LN_ADDR0r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR0r
#define MODIFY_LN_ADDR0r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR0r
#define READLN_LN_ADDR0r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR0r
#define WRITELN_LN_ADDR0r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR0r
#define WRITEALL_LN_ADDR0r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR1
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd191
 * DEVAD:    1
 * DESC:     LANE_ADDR_1
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_1   Determines the logical address associated with the PMD RX lane with physical index  "_1" at the PCS interface.rx_lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 *     TX_LANE_ADDR_1   Determines the logical address associated with the PMD TX lane with physical index  "_1" at the PCS interface.tx_lane_addr_1 is the logical address of the TX lane with pins at the PCS interface labeled "_1".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r (0x0001d191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR1r_s {
	uint32_t v[1];
	uint32_t ln_addr1[1];
	uint32_t _ln_addr1;
} BCMI_BLACKHAWK_XGXS_LN_ADDR1r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_CLR(r) (r).ln_addr1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_SET(r,d) (r).ln_addr1[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_GET(r) (r).ln_addr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET(r) ((((r).ln_addr1[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET(r) (((r).ln_addr1[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r,(_r._ln_addr1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR1r BCMI_BLACKHAWK_XGXS_LN_ADDR1r
#define LN_ADDR1r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR1r_t LN_ADDR1r_t;
#define LN_ADDR1r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR1r_CLR
#define LN_ADDR1r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_SET
#define LN_ADDR1r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET
#define LN_ADDR1r_RX_LANE_ADDR_1f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET
#define LN_ADDR1r_RX_LANE_ADDR_1f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET
#define READ_LN_ADDR1r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR1r
#define WRITE_LN_ADDR1r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR1r
#define MODIFY_LN_ADDR1r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR1r
#define READLN_LN_ADDR1r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR1r
#define WRITELN_LN_ADDR1r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR1r
#define WRITEALL_LN_ADDR1r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR2
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd192
 * DEVAD:    1
 * DESC:     LANE_ADDR_2
 * RESETVAL: 0x202 (514)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_2   Determines the logical address associated with the PMD RX lane with physical index  "_2" at the PCS interface.rx_lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     TX_LANE_ADDR_2   Determines the logical address associated with the PMD TX lane with physical index  "_2" at the PCS interface.tx_lane_addr_2 is the logical address of the TX lane with pins at the PCS interface labeled "_2".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r (0x0001d192 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR2.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR2r_s {
	uint32_t v[1];
	uint32_t ln_addr2[1];
	uint32_t _ln_addr2;
} BCMI_BLACKHAWK_XGXS_LN_ADDR2r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_CLR(r) (r).ln_addr2[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_SET(r,d) (r).ln_addr2[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_GET(r) (r).ln_addr2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET(r) ((((r).ln_addr2[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET(r) (((r).ln_addr2[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r,(_r._ln_addr2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR2r BCMI_BLACKHAWK_XGXS_LN_ADDR2r
#define LN_ADDR2r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR2r_t LN_ADDR2r_t;
#define LN_ADDR2r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR2r_CLR
#define LN_ADDR2r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_SET
#define LN_ADDR2r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET
#define LN_ADDR2r_RX_LANE_ADDR_2f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET
#define LN_ADDR2r_RX_LANE_ADDR_2f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET
#define READ_LN_ADDR2r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR2r
#define WRITE_LN_ADDR2r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR2r
#define MODIFY_LN_ADDR2r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR2r
#define READLN_LN_ADDR2r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR2r
#define WRITELN_LN_ADDR2r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR2r
#define WRITEALL_LN_ADDR2r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR3
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd193
 * DEVAD:    1
 * DESC:     LANE_ADDR_3
 * RESETVAL: 0x303 (771)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_3   Determines the logical address associated with the PMD RX lane with physical index  "_3" at the PCS interface.rx_lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 *     TX_LANE_ADDR_3   Determines the logical address associated with the PMD TX lane with physical index  "_3" at the PCS interface.tx_lane_addr_3 is the logical address of the TX lane with pins at the PCS interface labeled "_3".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r (0x0001d193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR3.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR3r_s {
	uint32_t v[1];
	uint32_t ln_addr3[1];
	uint32_t _ln_addr3;
} BCMI_BLACKHAWK_XGXS_LN_ADDR3r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_CLR(r) (r).ln_addr3[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_SET(r,d) (r).ln_addr3[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_GET(r) (r).ln_addr3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET(r) ((((r).ln_addr3[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET(r) (((r).ln_addr3[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r,(_r._ln_addr3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR3r BCMI_BLACKHAWK_XGXS_LN_ADDR3r
#define LN_ADDR3r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR3r_t LN_ADDR3r_t;
#define LN_ADDR3r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR3r_CLR
#define LN_ADDR3r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_SET
#define LN_ADDR3r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET
#define LN_ADDR3r_RX_LANE_ADDR_3f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET
#define LN_ADDR3r_RX_LANE_ADDR_3f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET
#define READ_LN_ADDR3r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR3r
#define WRITE_LN_ADDR3r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR3r
#define MODIFY_LN_ADDR3r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR3r
#define READLN_LN_ADDR3r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR3r
#define WRITELN_LN_ADDR3r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR3r
#define WRITEALL_LN_ADDR3r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR4
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd194
 * DEVAD:    1
 * DESC:     LANE_ADDR_4
 * RESETVAL: 0x404 (1028)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_4   Determines the logical address associated with the PMD RX lane with physical index  "_4" at the PCS interface.rx_lane_addr_4 is the logical address of the lane with pins at the PCS interface labeled "_4".
 *     TX_LANE_ADDR_4   Determines the logical address associated with the PMD TX lane with physical index  "_4" at the PCS interface.tx_lane_addr_4 is the logical address of the TX lane with pins at the PCS interface labeled "_4".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r (0x0001d194 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR4.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR4r_s {
	uint32_t v[1];
	uint32_t ln_addr4[1];
	uint32_t _ln_addr4;
} BCMI_BLACKHAWK_XGXS_LN_ADDR4r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_CLR(r) (r).ln_addr4[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_SET(r,d) (r).ln_addr4[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_GET(r) (r).ln_addr4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_GET(r) ((((r).ln_addr4[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_SET(r,f) (r).ln_addr4[0]=(((r).ln_addr4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_GET(r) (((r).ln_addr4[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_SET(r,f) (r).ln_addr4[0]=(((r).ln_addr4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r,(_r._ln_addr4))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r,(_r._ln_addr4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r,(_r._ln_addr4))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR4r BCMI_BLACKHAWK_XGXS_LN_ADDR4r
#define LN_ADDR4r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR4r_t LN_ADDR4r_t;
#define LN_ADDR4r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR4r_CLR
#define LN_ADDR4r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_SET
#define LN_ADDR4r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_GET
#define LN_ADDR4r_TX_LANE_ADDR_4f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_GET
#define LN_ADDR4r_TX_LANE_ADDR_4f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_SET
#define LN_ADDR4r_RX_LANE_ADDR_4f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_GET
#define LN_ADDR4r_RX_LANE_ADDR_4f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_SET
#define READ_LN_ADDR4r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR4r
#define WRITE_LN_ADDR4r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR4r
#define MODIFY_LN_ADDR4r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR4r
#define READLN_LN_ADDR4r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR4r
#define WRITELN_LN_ADDR4r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR4r
#define WRITEALL_LN_ADDR4r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR5
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd195
 * DEVAD:    1
 * DESC:     LANE_ADDR_5
 * RESETVAL: 0x505 (1285)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_5   Determines the logical address associated with the PMD RX lane with physical index  "_5" at the PCS interface.rx_lane_addr_5 is the logical address of the lane with pins at the PCS interface labeled "_5".
 *     TX_LANE_ADDR_5   Determines the logical address associated with the PMD TX lane with physical index  "_5" at the PCS interface.tx_lane_addr_5 is the logical address of the TX lane with pins at the PCS interface labeled "_5".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r (0x0001d195 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR5.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR5r_s {
	uint32_t v[1];
	uint32_t ln_addr5[1];
	uint32_t _ln_addr5;
} BCMI_BLACKHAWK_XGXS_LN_ADDR5r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_CLR(r) (r).ln_addr5[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_SET(r,d) (r).ln_addr5[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_GET(r) (r).ln_addr5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_GET(r) ((((r).ln_addr5[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_SET(r,f) (r).ln_addr5[0]=(((r).ln_addr5[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_GET(r) (((r).ln_addr5[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_SET(r,f) (r).ln_addr5[0]=(((r).ln_addr5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r,(_r._ln_addr5))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r,(_r._ln_addr5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r,(_r._ln_addr5))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR5r BCMI_BLACKHAWK_XGXS_LN_ADDR5r
#define LN_ADDR5r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR5r_t LN_ADDR5r_t;
#define LN_ADDR5r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR5r_CLR
#define LN_ADDR5r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_SET
#define LN_ADDR5r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_GET
#define LN_ADDR5r_TX_LANE_ADDR_5f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_GET
#define LN_ADDR5r_TX_LANE_ADDR_5f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_SET
#define LN_ADDR5r_RX_LANE_ADDR_5f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_GET
#define LN_ADDR5r_RX_LANE_ADDR_5f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_SET
#define READ_LN_ADDR5r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR5r
#define WRITE_LN_ADDR5r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR5r
#define MODIFY_LN_ADDR5r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR5r
#define READLN_LN_ADDR5r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR5r
#define WRITELN_LN_ADDR5r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR5r
#define WRITEALL_LN_ADDR5r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR6
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd196
 * DEVAD:    1
 * DESC:     LANE_ADDR_6
 * RESETVAL: 0x606 (1542)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_6   Determines the logical address associated with the PMD RX lane with physical index  "_6" at the PCS interface.rx_lane_addr_6 is the logical address of the lane with pins at the PCS interface labeled "_6".
 *     TX_LANE_ADDR_6   Determines the logical address associated with the PMD TX lane with physical index  "_6" at the PCS interface.tx_lane_addr_6 is the logical address of the TX lane with pins at the PCS interface labeled "_6".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r (0x0001d196 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR6.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR6r_s {
	uint32_t v[1];
	uint32_t ln_addr6[1];
	uint32_t _ln_addr6;
} BCMI_BLACKHAWK_XGXS_LN_ADDR6r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_CLR(r) (r).ln_addr6[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_SET(r,d) (r).ln_addr6[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_GET(r) (r).ln_addr6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_GET(r) ((((r).ln_addr6[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_SET(r,f) (r).ln_addr6[0]=(((r).ln_addr6[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_GET(r) (((r).ln_addr6[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_SET(r,f) (r).ln_addr6[0]=(((r).ln_addr6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r,(_r._ln_addr6))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r,(_r._ln_addr6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r,(_r._ln_addr6))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR6r BCMI_BLACKHAWK_XGXS_LN_ADDR6r
#define LN_ADDR6r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR6r_t LN_ADDR6r_t;
#define LN_ADDR6r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR6r_CLR
#define LN_ADDR6r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_SET
#define LN_ADDR6r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_GET
#define LN_ADDR6r_TX_LANE_ADDR_6f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_GET
#define LN_ADDR6r_TX_LANE_ADDR_6f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_SET
#define LN_ADDR6r_RX_LANE_ADDR_6f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_GET
#define LN_ADDR6r_RX_LANE_ADDR_6f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_SET
#define READ_LN_ADDR6r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR6r
#define WRITE_LN_ADDR6r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR6r
#define MODIFY_LN_ADDR6r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR6r
#define READLN_LN_ADDR6r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR6r
#define WRITELN_LN_ADDR6r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR6r
#define WRITEALL_LN_ADDR6r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_ADDR7
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd197
 * DEVAD:    1
 * DESC:     LANE_ADDR_7
 * RESETVAL: 0x707 (1799)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_7   Determines the logical address associated with the PMD RX lane with physical index  "_7" at the PCS interface.rx_lane_addr_7 is the logical address of the lane with pins at the PCS interface labeled "_7".
 *     TX_LANE_ADDR_7   Determines the logical address associated with the PMD TX lane with physical index  "_7" at the PCS interface.tx_lane_addr_7 is the logical address of the TX lane with pins at the PCS interface labeled "_7".
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r (0x0001d197 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR7.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_ADDR7r_s {
	uint32_t v[1];
	uint32_t ln_addr7[1];
	uint32_t _ln_addr7;
} BCMI_BLACKHAWK_XGXS_LN_ADDR7r_t;

#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_CLR(r) (r).ln_addr7[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_SET(r,d) (r).ln_addr7[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_GET(r) (r).ln_addr7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_GET(r) ((((r).ln_addr7[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_SET(r,f) (r).ln_addr7[0]=(((r).ln_addr7[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_GET(r) (((r).ln_addr7[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_SET(r,f) (r).ln_addr7[0]=(((r).ln_addr7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r,(_r._ln_addr7))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r,(_r._ln_addr7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r,(_r._ln_addr7))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR7r BCMI_BLACKHAWK_XGXS_LN_ADDR7r
#define LN_ADDR7r_SIZE BCMI_BLACKHAWK_XGXS_LN_ADDR7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_ADDR7r_t LN_ADDR7r_t;
#define LN_ADDR7r_CLR BCMI_BLACKHAWK_XGXS_LN_ADDR7r_CLR
#define LN_ADDR7r_SET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_SET
#define LN_ADDR7r_GET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_GET
#define LN_ADDR7r_TX_LANE_ADDR_7f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_GET
#define LN_ADDR7r_TX_LANE_ADDR_7f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_SET
#define LN_ADDR7r_RX_LANE_ADDR_7f_GET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_GET
#define LN_ADDR7r_RX_LANE_ADDR_7f_SET BCMI_BLACKHAWK_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_SET
#define READ_LN_ADDR7r BCMI_BLACKHAWK_XGXS_READ_LN_ADDR7r
#define WRITE_LN_ADDR7r BCMI_BLACKHAWK_XGXS_WRITE_LN_ADDR7r
#define MODIFY_LN_ADDR7r BCMI_BLACKHAWK_XGXS_MODIFY_LN_ADDR7r
#define READLN_LN_ADDR7r BCMI_BLACKHAWK_XGXS_READLN_LN_ADDR7r
#define WRITELN_LN_ADDR7r BCMI_BLACKHAWK_XGXS_WRITELN_LN_ADDR7r
#define WRITEALL_LN_ADDR7r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_ADDR7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_ADDR7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_COM_B_CTL_CLK4SYNC_DIV2_0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd19b
 * DEVAD:    1
 * DESC:     DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0
 * RESETVAL: 0x40 (64)
 * ACCESS:   R/W
 * FIELDS:
 *     CLK4SYNC_DIV2_EN Controls VCO/8 clock divider setting to generate the divided clk4sync_div2.1'b0 -> clk4sync_div2 = OFF. VCO divider is power gated and reset to save power.
 *     CLK4SYNC_DIV2_VCO_SELECT 0 - Select PLL0 clk4sync (i.e. VCO/8) clock from the AFE to generate clk4sync_div2 clock.1 - Select PLL1 clk4sync (i.e. VCO/8) clock from the AFE to generate clk4sync_div2 clock.
 *     CLK4SYNC_DIV2_LOC_MON_EN 1 - use the clk4sync_div2_loc status to switch the clk4sync_div2 to comclk forcefully through the glitchless mux as clk4sync_div2 is already lost.
 *     CLK4SYNC_DIV2_S_COMCLK_SEL Mux control for selection of comclk for the clk4sync_div2 clock .If asserted by writing to 1'b1 will select the comclk for the clk4sync_div2 clock. This register bit will enable the glitchless switching of the clk4sync_div2 to comclk for the clk4sync_div2 .
 *     CLK4SYNC_DIV2_S_COMCLK_FRC_ON Mux control for selection of comclk for clk4sync_div2 by force.If asserted by writing to 1'b1 will select the comclk for the clk4sync_div2 clock. This is a debug bit and should be only used if clk4sync_div2 from AFE is unavailable or dead for unforeseen reasons.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r (0x0001d19b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_COM_B_CTL_CLK4SYNC_DIV2_0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_s {
	uint32_t v[1];
	uint32_t dig_com_b_ctl_clk4sync_div2_0[1];
	uint32_t _dig_com_b_ctl_clk4sync_div2_0;
} BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLR(r) (r).dig_com_b_ctl_clk4sync_div2_0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SET(r,d) (r).dig_com_b_ctl_clk4sync_div2_0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_GET(r) (r).dig_com_b_ctl_clk4sync_div2_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_GET(r) ((((r).dig_com_b_ctl_clk4sync_div2_0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_SET(r,f) (r).dig_com_b_ctl_clk4sync_div2_0[0]=(((r).dig_com_b_ctl_clk4sync_div2_0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_GET(r) ((((r).dig_com_b_ctl_clk4sync_div2_0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_SET(r,f) (r).dig_com_b_ctl_clk4sync_div2_0[0]=(((r).dig_com_b_ctl_clk4sync_div2_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_GET(r) ((((r).dig_com_b_ctl_clk4sync_div2_0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_SET(r,f) (r).dig_com_b_ctl_clk4sync_div2_0[0]=(((r).dig_com_b_ctl_clk4sync_div2_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_GET(r) ((((r).dig_com_b_ctl_clk4sync_div2_0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_SET(r,f) (r).dig_com_b_ctl_clk4sync_div2_0[0]=(((r).dig_com_b_ctl_clk4sync_div2_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_GET(r) (((r).dig_com_b_ctl_clk4sync_div2_0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_SET(r,f) (r).dig_com_b_ctl_clk4sync_div2_0[0]=(((r).dig_com_b_ctl_clk4sync_div2_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_COM_B_CTL_CLK4SYNC_DIV2_0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r,(_r._dig_com_b_ctl_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r,(_r._dig_com_b_ctl_clk4sync_div2_0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r,(_r._dig_com_b_ctl_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_ctl_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_ctl_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_com_b_ctl_clk4sync_div2_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_t DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_t;
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLR BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLR
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_SET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_FRC_ONf_SET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_S_COMCLK_SELf_SET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOC_MON_ENf_SET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_VCO_SELECTf_SET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_GET
#define DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_ENf_SET
#define READ_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define WRITE_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define MODIFY_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define READLN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define WRITELN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r
#define WRITEALL_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_CLK4SYNC_DIV2_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_COM_B_STS_CLK4SYNC_DIV2_0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd19c
 * DEVAD:    1
 * DESC:     DIG_COM_B_STATUS_CLK4SYNC_DIV2_0
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     CLK4SYNC_DIV2_COMCLK_SEL Indicates status of the clk4sync_div2 glitchless mux select value. 0 - indicates that VCO derived clock is selected and 1 - indicates that comclk is selected.
 *     CLK4SYNC_DIV2_LOC Indicates the Loss of Clock indication for VCO derived clk4sync_div2 before glicthless muxing with comclk. Loss of clk4sync_div2 monitor uses the comclk as the measuring clock so for this monitoring status to work properly comclk has to be there.If ratio of the (comclk freq/clk4sync_div2 freq) <= 4 then LOC monitor should not report it as LOC but any slower clk4sync_div2 than that will result into LOC even though clk4sync_div2 is toggling. So assuming max comclk is 175 Mhz,then slowest clk4sync_div2 which will not result into LOC is 175/4 = 43.75 Mhz.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r (0x0001d19c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_COM_B_STS_CLK4SYNC_DIV2_0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_s {
	uint32_t v[1];
	uint32_t dig_com_b_sts_clk4sync_div2_0[1];
	uint32_t _dig_com_b_sts_clk4sync_div2_0;
} BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLR(r) (r).dig_com_b_sts_clk4sync_div2_0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SET(r,d) (r).dig_com_b_sts_clk4sync_div2_0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_GET(r) (r).dig_com_b_sts_clk4sync_div2_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_GET(r) ((((r).dig_com_b_sts_clk4sync_div2_0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_SET(r,f) (r).dig_com_b_sts_clk4sync_div2_0[0]=(((r).dig_com_b_sts_clk4sync_div2_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_GET(r) (((r).dig_com_b_sts_clk4sync_div2_0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_SET(r,f) (r).dig_com_b_sts_clk4sync_div2_0[0]=(((r).dig_com_b_sts_clk4sync_div2_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_COM_B_STS_CLK4SYNC_DIV2_0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r,(_r._dig_com_b_sts_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r,(_r._dig_com_b_sts_clk4sync_div2_0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r,(_r._dig_com_b_sts_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_sts_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_sts_clk4sync_div2_0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_STS_CLK4SYNC_DIV2_0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_com_b_sts_clk4sync_div2_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_t DIG_COM_B_STS_CLK4SYNC_DIV2_0r_t;
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLR BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLR
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_SET
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_GET
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_GET
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_LOCf_SET
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_GET
#define DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r_CLK4SYNC_DIV2_COMCLK_SELf_SET
#define READ_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define WRITE_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define MODIFY_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define READLN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define WRITELN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_STS_CLK4SYNC_DIV2_0r
#define WRITEALL_DIG_COM_B_STS_CLK4SYNC_DIV2_0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_STS_CLK4SYNC_DIV2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_CLK4SYNC_DIV2_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_COM_B_CTL_UC_CLK0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd19d
 * DEVAD:    1
 * DESC:     DIG_COM_B_CONTROL_MICRO_CLK_0
 * RESETVAL: 0x47 (71)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CLK_VCO_DIV Controls VCO/8 clock divider setting to generate the divided micro_clk.3'd0 -> micro_clk = VCO/48.3'd1 -> micro_clk = VCO/56.3'd2 -> micro_clk = VCO/64.3'd3 -> micro_clk = VCO/72.3'd4 -> micro_clk = VCO/80.3'd5 -> micro_clk = VCO/88.3'd6 -> micro_clk = VCO/96.3'd7 -> micro_clk = OFF. VCO divider is power gated and reset to save power.
 *     MICRO_CLK_VCO_SELECT 0 - Select PLL0 VCO/8 clock from the AFE to generate micro clock.1 - Select PLL1 VCO/8 clock from the AFE to generate micro clock.
 *     MICRO_CLK_LOC_MON_EN 1 - use the micro_clk_loc status to switch the micro_clk to comclk used in micro subsystem block forcefully through the glitchless mux as micro_clk is already lost.
 *     MICRO_CLK_S_COMCLK_SEL Mux control for selection of comclk for the micro_clk clock used in micro subsystem block.If asserted by writing to 1'b1 will select the comclk for the micro_clk clock. This register bit will enable the glitchless switching of the micro_clk to comclk for the micro_clk used in micro subsystem block.
 *     MICRO_CLK_S_COMCLK_FRC_ON Mux control for selection of comclk for micro_clk by force.If asserted by writing to 1'b1 will select the comclk for the micro_clk clock. This is a debug bit and should be only used if micro_clk from AFE is unavailable or dead for unforeseen reasons.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r (0x0001d19d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_COM_B_CTL_UC_CLK0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_s {
	uint32_t v[1];
	uint32_t dig_com_b_ctl_uc_clk0[1];
	uint32_t _dig_com_b_ctl_uc_clk0;
} BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_CLR(r) (r).dig_com_b_ctl_uc_clk0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_SET(r,d) (r).dig_com_b_ctl_uc_clk0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_GET(r) (r).dig_com_b_ctl_uc_clk0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_GET(r) ((((r).dig_com_b_ctl_uc_clk0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_SET(r,f) (r).dig_com_b_ctl_uc_clk0[0]=(((r).dig_com_b_ctl_uc_clk0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_GET(r) ((((r).dig_com_b_ctl_uc_clk0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_SET(r,f) (r).dig_com_b_ctl_uc_clk0[0]=(((r).dig_com_b_ctl_uc_clk0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_GET(r) ((((r).dig_com_b_ctl_uc_clk0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_SET(r,f) (r).dig_com_b_ctl_uc_clk0[0]=(((r).dig_com_b_ctl_uc_clk0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_GET(r) ((((r).dig_com_b_ctl_uc_clk0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_SET(r,f) (r).dig_com_b_ctl_uc_clk0[0]=(((r).dig_com_b_ctl_uc_clk0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_GET(r) (((r).dig_com_b_ctl_uc_clk0[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_SET(r,f) (r).dig_com_b_ctl_uc_clk0[0]=(((r).dig_com_b_ctl_uc_clk0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DIG_COM_B_CTL_UC_CLK0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_CTL_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r,(_r._dig_com_b_ctl_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_CTL_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r,(_r._dig_com_b_ctl_uc_clk0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_CTL_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r,(_r._dig_com_b_ctl_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_CTL_UC_CLK0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_ctl_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_CTL_UC_CLK0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_ctl_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_CTL_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_com_b_ctl_uc_clk0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r
#define DIG_COM_B_CTL_UC_CLK0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_t DIG_COM_B_CTL_UC_CLK0r_t;
#define DIG_COM_B_CTL_UC_CLK0r_CLR BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_CLR
#define DIG_COM_B_CTL_UC_CLK0r_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_SET
#define DIG_COM_B_CTL_UC_CLK0r_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_FRC_ONf_SET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_S_COMCLK_SELf_SET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_LOC_MON_ENf_SET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_SELECTf_SET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_GET
#define DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r_MICRO_CLK_VCO_DIVf_SET
#define READ_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_CTL_UC_CLK0r
#define WRITE_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_CTL_UC_CLK0r
#define MODIFY_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_CTL_UC_CLK0r
#define READLN_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_CTL_UC_CLK0r
#define WRITELN_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_CTL_UC_CLK0r
#define WRITEALL_DIG_COM_B_CTL_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_CTL_UC_CLK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_COM_B_CTL_UC_CLK0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DIG_COM_B_STS_UC_CLK0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd19e
 * DEVAD:    1
 * DESC:     DIG_COM_B_STATUS_MICRO_CLK_0
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CLK_COMCLK_SEL Indicates status of the micro_clk glitchless mux select value. 0 - indicates that VCO derived clock is selected and 1 - indicates that comclk is selected.
 *     MICRO_CLK_LOC    Indicates the Loss of Clock indication for VCO derived micro_clk before glicthless muxing with comclk. Loss of micro_clk monitor uses the comclk as the measuring clock so for this monitoring status to work properly comclk has to be there.If ratio of the (comclk freq/micro_clk freq) <= 4 then LOC monitor should not report it as LOC but any slower micro_clk than that will result into LOC even though micro_clk is toggling. So assuming max comclk is 175 Mhz,then slowest micro_clk which will not result into LOC is 175/4 = 43.75 Mhz.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r (0x0001d19e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_COM_B_STS_UC_CLK0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_s {
	uint32_t v[1];
	uint32_t dig_com_b_sts_uc_clk0[1];
	uint32_t _dig_com_b_sts_uc_clk0;
} BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_t;

#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_CLR(r) (r).dig_com_b_sts_uc_clk0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_SET(r,d) (r).dig_com_b_sts_uc_clk0[0] = d
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_GET(r) (r).dig_com_b_sts_uc_clk0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_GET(r) ((((r).dig_com_b_sts_uc_clk0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_SET(r,f) (r).dig_com_b_sts_uc_clk0[0]=(((r).dig_com_b_sts_uc_clk0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_GET(r) (((r).dig_com_b_sts_uc_clk0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_SET(r,f) (r).dig_com_b_sts_uc_clk0[0]=(((r).dig_com_b_sts_uc_clk0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_COM_B_STS_UC_CLK0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_STS_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r,(_r._dig_com_b_sts_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_STS_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r,(_r._dig_com_b_sts_uc_clk0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_STS_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r,(_r._dig_com_b_sts_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_STS_UC_CLK0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_sts_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_STS_UC_CLK0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_com_b_sts_uc_clk0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_STS_UC_CLK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_com_b_sts_uc_clk0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r
#define DIG_COM_B_STS_UC_CLK0r_SIZE BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_t DIG_COM_B_STS_UC_CLK0r_t;
#define DIG_COM_B_STS_UC_CLK0r_CLR BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_CLR
#define DIG_COM_B_STS_UC_CLK0r_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_SET
#define DIG_COM_B_STS_UC_CLK0r_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_GET
#define DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_GET
#define DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_LOCf_SET
#define DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_GET
#define DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r_MICRO_CLK_COMCLK_SELf_SET
#define READ_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_READ_DIG_COM_B_STS_UC_CLK0r
#define WRITE_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITE_DIG_COM_B_STS_UC_CLK0r
#define MODIFY_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_MODIFY_DIG_COM_B_STS_UC_CLK0r
#define READLN_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_READLN_DIG_COM_B_STS_UC_CLK0r
#define WRITELN_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITELN_DIG_COM_B_STS_UC_CLK0r
#define WRITEALL_DIG_COM_B_STS_UC_CLK0r BCMI_BLACKHAWK_XGXS_WRITEALL_DIG_COM_B_STS_UC_CLK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DIG_COM_B_STS_UC_CLK0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a1
 * DEVAD:    1
 * DESC:     RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET(r) ((((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET(r) (((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t RX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET
#define READ_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a2
 * DEVAD:    1
 * DESC:     RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *     AFE_RX_RCLK20_PWRDN_FRC AFE RX Lane rx_rclk20_pwrdwn force.
 *     AFE_RX_RCLK20_PWRDN_FRC_VAL AFE RX Lane rx_rclk20_pwrdwn force value.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0001d1a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _rx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET(r) (((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET
#define READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a3
 * DEVAD:    1
 * DESC:     RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET(r) (((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET(r,f) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET
#define READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_LN_DBG_RST_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a4
 * DEVAD:    1
 * DESC:     RX_LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_RSTB     Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_RX_DP_S_RSTB  Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     SIGDET_DP_RSTB_EN If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr (0x0001d1a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_DBG_RST_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_dbg_rst_ctl[1];
	uint32_t _rx_ln_dbg_rst_ctl;
} BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_CLR(r) (r).rx_ln_dbg_rst_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SET(r,d) (r).rx_ln_dbg_rst_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_GET(r) (r).rx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET(r) (((r).rx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_DBG_RST_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr
#define RX_LN_DBG_RST_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_t RX_LN_DBG_RST_CTLr_t;
#define RX_LN_DBG_RST_CTLr_CLR BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_CLR
#define RX_LN_DBG_RST_CTLr_SET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SET
#define RX_LN_DBG_RST_CTLr_GET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET
#define READ_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_READ_RX_LN_DBG_RST_CTLr
#define WRITE_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RX_LN_DBG_RST_CTLr
#define MODIFY_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RX_LN_DBG_RST_CTLr
#define READLN_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_READLN_RX_LN_DBG_RST_CTLr
#define WRITELN_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RX_LN_DBG_RST_CTLr
#define WRITEALL_RX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_CLK_N_RST_DBG_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a7
 * DEVAD:    1
 * DESC:     RX_CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_CLKGATE_FRC_ON RX Active High Lane clock gator enable. If 1'1b1 then rx lane clock will be gated off. It does not affect the rclk goingto RMIC block so rx lane based registers can still be readable but not writable.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while rx_s_clkgate_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_SEL Mux control for selection of comclk for RX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_FRC_ON Mux control for selection of comclk for RX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     PMD_RX_CLK_VLD_FRC pmd_rx_clk_vld core output pin force.
 *     PMD_RX_CLK_VLD_FRC_VAL pmd_rx_clk_vld core output pin force value.
 */
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr (0x0001d1a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t rx_clk_n_rst_dbg_ctl[1];
	uint32_t _rx_clk_n_rst_dbg_ctl;
} BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR(r) (r).rx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).rx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_GET(r) (r).rx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET(r) (((r).rx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CLK_N_RST_DBG_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr
#define RX_CLK_N_RST_DBG_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_t RX_CLK_N_RST_DBG_CTLr_t;
#define RX_CLK_N_RST_DBG_CTLr_CLR BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR
#define RX_CLK_N_RST_DBG_CTLr_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_SET
#define RX_CLK_N_RST_DBG_CTLr_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET
#define READ_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_READ_RX_CLK_N_RST_DBG_CTLr
#define WRITE_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr
#define MODIFY_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr
#define READLN_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr
#define WRITELN_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr
#define WRITEALL_RX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_PMD_LN_MODE_STS
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a8
 * DEVAD:    1
 * DESC:     RX_PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LANE_MODE This indicates the status of the core input pin pmd_rx_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr (0x0001d1a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_PMD_LN_MODE_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t rx_pmd_ln_mode_sts[1];
	uint32_t _rx_pmd_ln_mode_sts;
} BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_CLR(r) (r).rx_pmd_ln_mode_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_SET(r,d) (r).rx_pmd_ln_mode_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_GET(r) (r).rx_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET(r) (((r).rx_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET(r,f) (r).rx_pmd_ln_mode_sts[0]=(((r).rx_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_PMD_LN_MODE_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr
#define RX_PMD_LN_MODE_STSr_SIZE BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_t RX_PMD_LN_MODE_STSr_t;
#define RX_PMD_LN_MODE_STSr_CLR BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_CLR
#define RX_PMD_LN_MODE_STSr_SET BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_SET
#define RX_PMD_LN_MODE_STSr_GET BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_GET
#define RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET
#define RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET
#define READ_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_READ_RX_PMD_LN_MODE_STSr
#define WRITE_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITE_RX_PMD_LN_MODE_STSr
#define MODIFY_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RX_PMD_LN_MODE_STSr
#define READLN_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_READLN_RX_PMD_LN_MODE_STSr
#define WRITELN_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RX_PMD_LN_MODE_STSr
#define WRITEALL_RX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ac
 * DEVAD:    1
 * DESC:     RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_RX_PWRDN     Indicates the status of the afe_rx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_RX_RESET     Indicates the status of the afe_rx_reset signal to the AFE after frc/frc_val mux.
 *     AFE_RX_RCLK20_PWRDN Indicates the status of the afe_rx_rclk20_pwrdn signal to the AFE after frc/frc_val mux.
 */
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d1ac | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rx_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rx_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_GET(r) ((((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_SET(r,f) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET(r) ((((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET(r,f) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET(r) (((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET(r,f) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_GET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_SET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RCLK20_PWRDNf_SET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET
#define READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_CFG_FWAPI_DATA0
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ad
 * DEVAD:    1
 * DESC:     LANE_CFG_FWAPI_DATA0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_CFG_FWAPI_DATA0 Lane configuration firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangelane configuration information
 */
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r (0x0001d1ad | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program LN_CFG_FWAPI_DATA0.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t ln_cfg_fwapi_data0[1];
	uint32_t _ln_cfg_fwapi_data0;
} BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_t;

#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_CLR(r) (r).ln_cfg_fwapi_data0[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_SET(r,d) (r).ln_cfg_fwapi_data0[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_GET(r) (r).ln_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET(r) (((r).ln_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET(r,f) (r).ln_cfg_fwapi_data0[0]=(((r).ln_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_CFG_FWAPI_DATA0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r
#define LN_CFG_FWAPI_DATA0r_SIZE BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_t LN_CFG_FWAPI_DATA0r_t;
#define LN_CFG_FWAPI_DATA0r_CLR BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_CLR
#define LN_CFG_FWAPI_DATA0r_SET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_SET
#define LN_CFG_FWAPI_DATA0r_GET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_GET
#define LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET
#define LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET
#define READ_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READ_LN_CFG_FWAPI_DATA0r
#define WRITE_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITE_LN_CFG_FWAPI_DATA0r
#define MODIFY_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_MODIFY_LN_CFG_FWAPI_DATA0r
#define READLN_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READLN_LN_CFG_FWAPI_DATA0r
#define WRITELN_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITELN_LN_CFG_FWAPI_DATA0r
#define WRITEALL_LN_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  LN_CFG_FWAPI_DATA1
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ae
 * DEVAD:    1
 * DESC:     LANE_CFG_FWAPI_DATA1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_CFG_FWAPI_DATA1 Lane configuration firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangelane configuration information
 */
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r (0x0001d1ae | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program LN_CFG_FWAPI_DATA1.
 */
typedef union BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_s {
	uint32_t v[1];
	uint32_t ln_cfg_fwapi_data1[1];
	uint32_t _ln_cfg_fwapi_data1;
} BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_t;

#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_CLR(r) (r).ln_cfg_fwapi_data1[0] = 0
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_SET(r,d) (r).ln_cfg_fwapi_data1[0] = d
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_GET(r) (r).ln_cfg_fwapi_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET(r) (((r).ln_cfg_fwapi_data1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET(r,f) (r).ln_cfg_fwapi_data1[0]=(((r).ln_cfg_fwapi_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_CFG_FWAPI_DATA1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITE_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_READLN_LN_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_LN_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_cfg_fwapi_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r
#define LN_CFG_FWAPI_DATA1r_SIZE BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_t LN_CFG_FWAPI_DATA1r_t;
#define LN_CFG_FWAPI_DATA1r_CLR BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_CLR
#define LN_CFG_FWAPI_DATA1r_SET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_SET
#define LN_CFG_FWAPI_DATA1r_GET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_GET
#define LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET
#define LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET
#define READ_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_READ_LN_CFG_FWAPI_DATA1r
#define WRITE_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITE_LN_CFG_FWAPI_DATA1r
#define MODIFY_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_MODIFY_LN_CFG_FWAPI_DATA1r
#define READLN_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_READLN_LN_CFG_FWAPI_DATA1r
#define WRITELN_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITELN_LN_CFG_FWAPI_DATA1r
#define WRITEALL_LN_CFG_FWAPI_DATA1r BCMI_BLACKHAWK_XGXS_WRITEALL_LN_CFG_FWAPI_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_LN_CFG_FWAPI_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b1
 * DEVAD:    1
 * DESC:     TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_TX_RESET_DEASSERT AFE TX Lane reset control. This register will be reset upon POR reg/pin or lane reset reg/pin. Lower priority than the afe_tx_reset_frc/frc_val option.1 - AFE TX Lane tx_reset pin will be forcefully de-asserted irrespective of core/lane datapath pin/reg resets asserted.This bit must be set to 1'b1 for TX_Disable all 1s/0s mode to allow TX AFE to transmit the all 1s/0s data.0 - AFE TX Lane tx_reset pin will be asserted if core/lane pin/reg resets are asserted.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _tx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET(r) ((((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET(r) (((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t TX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET
#define READ_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b2
 * DEVAD:    1
 * DESC:     TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0001d1b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _tx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET(r) (((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET
#define READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b3
 * DEVAD:    1
 * DESC:     TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _tx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET(r) (((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET(r,f) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET
#define READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_LN_DBG_RST_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b4
 * DEVAD:    1
 * DESC:     TX_LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr (0x0001d1b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_DBG_RST_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_dbg_rst_ctl[1];
	uint32_t _tx_ln_dbg_rst_ctl;
} BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_CLR(r) (r).tx_ln_dbg_rst_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_SET(r,d) (r).tx_ln_dbg_rst_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_GET(r) (r).tx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).tx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) (((r).tx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_DBG_RST_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr
#define TX_LN_DBG_RST_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_t TX_LN_DBG_RST_CTLr_t;
#define TX_LN_DBG_RST_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_CLR
#define TX_LN_DBG_RST_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_SET
#define TX_LN_DBG_RST_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define READ_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_LN_DBG_RST_CTLr
#define WRITE_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_LN_DBG_RST_CTLr
#define MODIFY_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_LN_DBG_RST_CTLr
#define READLN_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_LN_DBG_RST_CTLr
#define WRITELN_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_LN_DBG_RST_CTLr
#define WRITEALL_TX_LN_DBG_RST_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_CLK_N_RST_DBG_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b7
 * DEVAD:    1
 * DESC:     TX_CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_SEL Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 */
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr (0x0001d1b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_dbg_ctl[1];
	uint32_t _tx_clk_n_rst_dbg_ctl;
} BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR(r) (r).tx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).tx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_GET(r) (r).tx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET(r) (((r).tx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_DBG_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr
#define TX_CLK_N_RST_DBG_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_t TX_CLK_N_RST_DBG_CTLr_t;
#define TX_CLK_N_RST_DBG_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR
#define TX_CLK_N_RST_DBG_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_SET
#define TX_CLK_N_RST_DBG_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET
#define READ_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_CLK_N_RST_DBG_CTLr
#define WRITE_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr
#define MODIFY_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr
#define READLN_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr
#define WRITELN_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr
#define WRITEALL_TX_CLK_N_RST_DBG_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PMD_LN_MODE_STS
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b8
 * DEVAD:    1
 * DESC:     TX_PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_TX_LANE_MODE This indicates the status of the core input pin pmd_rx_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr (0x0001d1b8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_PMD_LN_MODE_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t tx_pmd_ln_mode_sts[1];
	uint32_t _tx_pmd_ln_mode_sts;
} BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_CLR(r) (r).tx_pmd_ln_mode_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_SET(r,d) (r).tx_pmd_ln_mode_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_GET(r) (r).tx_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET(r) (((r).tx_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET(r,f) (r).tx_pmd_ln_mode_sts[0]=(((r).tx_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_PMD_LN_MODE_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pmd_ln_mode_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr
#define TX_PMD_LN_MODE_STSr_SIZE BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_t TX_PMD_LN_MODE_STSr_t;
#define TX_PMD_LN_MODE_STSr_CLR BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_CLR
#define TX_PMD_LN_MODE_STSr_SET BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_SET
#define TX_PMD_LN_MODE_STSr_GET BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_GET
#define TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET
#define TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET
#define READ_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_READ_TX_PMD_LN_MODE_STSr
#define WRITE_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITE_TX_PMD_LN_MODE_STSr
#define MODIFY_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TX_PMD_LN_MODE_STSr
#define READLN_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_READLN_TX_PMD_LN_MODE_STSr
#define WRITELN_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TX_PMD_LN_MODE_STSr
#define WRITEALL_TX_PMD_LN_MODE_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1bc
 * DEVAD:    1
 * DESC:     TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_TX_PWRDN     Indicates the status of the afe_tx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_TX_RESET     Indicates the status of the afe_tx_reset signal to the AFE after frc/frc_val mux.
 */
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d1bc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t tx_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _tx_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET(r) ((((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET(r,f) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET(r) (((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET(r,f) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET
#define READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_CLK_N_RST_MISC_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1bd
 * DEVAD:    1
 * DESC:     TX_CLOCK_N_RESET_MISC_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 */
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr (0x0001d1bd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_MISC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_misc_ctl[1];
	uint32_t _tx_clk_n_rst_misc_ctl;
} BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR(r) (r).tx_clk_n_rst_misc_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_SET(r,d) (r).tx_clk_n_rst_misc_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_GET(r) (r).tx_clk_n_rst_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET(r) (((r).tx_clk_n_rst_misc_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).tx_clk_n_rst_misc_ctl[0]=(((r).tx_clk_n_rst_misc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_MISC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_misc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr
#define TX_CLK_N_RST_MISC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_t TX_CLK_N_RST_MISC_CTLr_t;
#define TX_CLK_N_RST_MISC_CTLr_CLR BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR
#define TX_CLK_N_RST_MISC_CTLr_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_SET
#define TX_CLK_N_RST_MISC_CTLr_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET
#define READ_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_READ_TX_CLK_N_RST_MISC_CTLr
#define WRITE_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr
#define MODIFY_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr
#define READLN_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr
#define WRITELN_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr
#define WRITEALL_TX_CLK_N_RST_MISC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_CLK_N_RST_MISC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_OSR_MODE_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c0
 * DEVAD:    1
 * DESC:     RXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     RX_PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     RX_PAM4_MODE_FRC PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode
 *     RX_OSR_MODE_FRC  NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr (0x0001d1c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_ctl[1];
	uint32_t _rxcom_osr_mode_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_CLR(r) (r).rxcom_osr_mode_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxcom_osr_mode_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_GET(r) (r).rxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET(r) (((r).rxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr
#define RXCOM_OSR_MODE_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_t RXCOM_OSR_MODE_CTLr_t;
#define RXCOM_OSR_MODE_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_CLR
#define RXCOM_OSR_MODE_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_SET
#define RXCOM_OSR_MODE_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET
#define READ_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_OSR_MODE_CTLr
#define WRITE_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_OSR_MODE_CTLr
#define MODIFY_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr
#define READLN_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_OSR_MODE_CTLr
#define WRITELN_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr
#define WRITEALL_RXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c1
 * DEVAD:    1
 * DESC:     RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET(r) (((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET(r,f) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET
#define READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c3
 * DEVAD:    1
 * DESC:     RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_RX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET(r) ((((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET(r) (((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET
#define READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c5
 * DEVAD:    1
 * DESC:     RXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     RX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr (0x0001d1c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_uc_ack_ln_ctl[1];
	uint32_t _rxcom_uc_ack_ln_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxcom_uc_ack_ln_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr
#define RXCOM_UC_ACK_LN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_t RXCOM_UC_ACK_LN_CTLr_t;
#define RXCOM_UC_ACK_LN_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR
#define RXCOM_UC_ACK_LN_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_SET
#define RXCOM_UC_ACK_LN_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_UC_ACK_LN_CTLr
#define WRITE_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr
#define READLN_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c6
 * DEVAD:    1
 * DESC:     RXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr (0x0001d1c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_occ_ctl[1];
	uint32_t _rxcom_ln_rst_occ_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxcom_ln_rst_occ_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxcom_ln_rst_occ_ctl[0]=(((r).rxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr
#define RXCOM_LN_RST_OCC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_t RXCOM_LN_RST_OCC_CTLr_t;
#define RXCOM_LN_RST_OCC_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR
#define RXCOM_LN_RST_OCC_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_SET
#define RXCOM_LN_RST_OCC_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_RST_OCC_CTLr
#define WRITE_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr
#define READLN_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_PLL_SEL_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c7
 * DEVAD:    1
 * DESC:     RXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PLL_SELECT    This register controls the selection of the PLL0 or PLL1 as clock source for the rx_ lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when rx_ lane datapath is in reset.0 - Select PLL0 as clock for rx_ lane.1 - Select PLL1 as clock for rx_ lane.This register bit also drive the AFE rx_ctrl[95] pin.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr (0x0001d1c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_pll_sel_ctl[1];
	uint32_t _rxcom_pll_sel_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_CLR(r) (r).rxcom_pll_sel_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_SET(r,d) (r).rxcom_pll_sel_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_GET(r) (r).rxcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET(r) (((r).rxcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET(r,f) (r).rxcom_pll_sel_ctl[0]=(((r).rxcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_PLL_SEL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr
#define RXCOM_PLL_SEL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_t RXCOM_PLL_SEL_CTLr_t;
#define RXCOM_PLL_SEL_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_CLR
#define RXCOM_PLL_SEL_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_SET
#define RXCOM_PLL_SEL_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_GET
#define RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET
#define RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET
#define READ_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_PLL_SEL_CTLr
#define WRITE_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_PLL_SEL_CTLr
#define MODIFY_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_PLL_SEL_CTLr
#define READLN_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_PLL_SEL_CTLr
#define WRITELN_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_PLL_SEL_CTLr
#define WRITEALL_RXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c9
 * DEVAD:    1
 * DESC:     RXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr (0x0001d1c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxcom_ln_dp_rst_st_sts;
} BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET(r) (((r).rxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET(r,f) (r).rxcom_ln_dp_rst_st_sts[0]=(((r).rxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr
#define RXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_t RXCOM_LN_DP_RST_ST_STSr_t;
#define RXCOM_LN_DP_RST_ST_STSr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR
#define RXCOM_LN_DP_RST_ST_STSr_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET
#define RXCOM_LN_DP_RST_ST_STSr_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET
#define READ_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr
#define READLN_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_MCST_MASK_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ca
 * DEVAD:    1
 * DESC:     RXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr (0x0001d1ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_mcst_mask_ctl[1];
	uint32_t _rxcom_mcst_mask_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_CLR(r) (r).rxcom_mcst_mask_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxcom_mcst_mask_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_GET(r) (r).rxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxcom_mcst_mask_ctl[0]=(((r).rxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_MCST_MASK_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr
#define RXCOM_MCST_MASK_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_t RXCOM_MCST_MASK_CTLr_t;
#define RXCOM_MCST_MASK_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_CLR
#define RXCOM_MCST_MASK_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_SET
#define RXCOM_MCST_MASK_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET
#define READ_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_MCST_MASK_CTLr
#define WRITE_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_MCST_MASK_CTLr
#define MODIFY_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr
#define READLN_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_MCST_MASK_CTLr
#define WRITELN_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr
#define WRITEALL_RXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1cb
 * DEVAD:    1
 * DESC:     RXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_OSR_MODE      OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     RX_PAM4_MODE     PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     RX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr (0x0001d1cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxcom_osr_mode_sts_mc_mask;
} BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET(r) ((((r).rxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET(r) (((r).rxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr
#define RXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t RXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET
#define READ_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1cc
 * DEVAD:    1
 * DESC:     RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_OSR_MODE_PIN  Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     RX_PAM4_MODE_PIN Indicates the status of the pmd_pam4_mode input pin.Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d1cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rxcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rxcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_GET(r) ((((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_SET(r,f) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET(r) (((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET(r,f) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_GET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_PAM4_MODE_PINf_SET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET
#define READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  RXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ce
 * DEVAD:    1
 * DESC:     RXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     RX_HW_FW_HANDSHAKE_DISABLE This register bit is unused in RX lane.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr (0x0001d1ce | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_s_rstb_ctl[1];
	uint32_t _rxcom_ln_s_rstb_ctl;
} BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxcom_ln_s_rstb_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).rxcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).rxcom_ln_s_rstb_ctl[0]=(((r).rxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET(r) (((r).rxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET(r,f) (r).rxcom_ln_s_rstb_ctl[0]=(((r).rxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr
#define RXCOM_LN_S_RSTB_CTLr_SIZE BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_t RXCOM_LN_S_RSTB_CTLr_t;
#define RXCOM_LN_S_RSTB_CTLr_CLR BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR
#define RXCOM_LN_S_RSTB_CTLr_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_SET
#define RXCOM_LN_S_RSTB_CTLr_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET
#define READ_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READ_RXCOM_LN_S_RSTB_CTLr
#define WRITE_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr
#define READLN_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_RXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_OSR_MODE_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d0
 * DEVAD:    1
 * DESC:     TXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     TX_PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     TX_PAM4_MODE_FRC PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode
 *     TX_OSR_MODE_FRC  NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr (0x0001d1d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_ctl[1];
	uint32_t _txcom_osr_mode_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_CLR(r) (r).txcom_osr_mode_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_SET(r,d) (r).txcom_osr_mode_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_GET(r) (r).txcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET(r) (((r).txcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr
#define TXCOM_OSR_MODE_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_t TXCOM_OSR_MODE_CTLr_t;
#define TXCOM_OSR_MODE_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_CLR
#define TXCOM_OSR_MODE_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_SET
#define TXCOM_OSR_MODE_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET
#define READ_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_OSR_MODE_CTLr
#define WRITE_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_OSR_MODE_CTLr
#define MODIFY_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr
#define READLN_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_OSR_MODE_CTLr
#define WRITELN_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr
#define WRITEALL_TXCOM_OSR_MODE_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d1
 * DEVAD:    1
 * DESC:     TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _txcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET(r) (((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET(r,f) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET
#define READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d3
 * DEVAD:    1
 * DESC:     TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_TX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _txcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET(r) ((((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET(r) (((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET
#define READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_UC_ACK_LN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d5
 * DEVAD:    1
 * DESC:     TXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     TX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr (0x0001d1d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_uc_ack_ln_ctl[1];
	uint32_t _txcom_uc_ack_ln_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR(r) (r).txcom_uc_ack_ln_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).txcom_uc_ack_ln_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_GET(r) (r).txcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).txcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).txcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr
#define TXCOM_UC_ACK_LN_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_t TXCOM_UC_ACK_LN_CTLr_t;
#define TXCOM_UC_ACK_LN_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR
#define TXCOM_UC_ACK_LN_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_SET
#define TXCOM_UC_ACK_LN_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_UC_ACK_LN_CTLr
#define WRITE_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr
#define MODIFY_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr
#define READLN_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr
#define WRITELN_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr
#define WRITEALL_TXCOM_UC_ACK_LN_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_LN_RST_OCC_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d6
 * DEVAD:    1
 * DESC:     TXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr (0x0001d1d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_occ_ctl[1];
	uint32_t _txcom_ln_rst_occ_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR(r) (r).txcom_ln_rst_occ_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).txcom_ln_rst_occ_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_GET(r) (r).txcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).txcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).txcom_ln_rst_occ_ctl[0]=(((r).txcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr
#define TXCOM_LN_RST_OCC_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_t TXCOM_LN_RST_OCC_CTLr_t;
#define TXCOM_LN_RST_OCC_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR
#define TXCOM_LN_RST_OCC_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_SET
#define TXCOM_LN_RST_OCC_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET
#define READ_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_RST_OCC_CTLr
#define WRITE_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr
#define MODIFY_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr
#define READLN_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr
#define WRITELN_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr
#define WRITEALL_TXCOM_LN_RST_OCC_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_PLL_SEL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d7
 * DEVAD:    1
 * DESC:     TXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PLL_SELECT    This register controls the selection of the PLL0 or PLL1 as clock source for the tx_ lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when tx_ lane datapath is in reset.0 - Select PLL0 as clock for tx_ lane.1 - Select PLL1 as clock for tx_ lane.This register bit also drive the AFE tx_ctrl[0] pin.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr (0x0001d1d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_pll_sel_ctl[1];
	uint32_t _txcom_pll_sel_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_CLR(r) (r).txcom_pll_sel_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_SET(r,d) (r).txcom_pll_sel_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_GET(r) (r).txcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET(r) (((r).txcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET(r,f) (r).txcom_pll_sel_ctl[0]=(((r).txcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_PLL_SEL_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_pll_sel_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr
#define TXCOM_PLL_SEL_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_t TXCOM_PLL_SEL_CTLr_t;
#define TXCOM_PLL_SEL_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_CLR
#define TXCOM_PLL_SEL_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_SET
#define TXCOM_PLL_SEL_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_GET
#define TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET
#define TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET
#define READ_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_PLL_SEL_CTLr
#define WRITE_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_PLL_SEL_CTLr
#define MODIFY_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_PLL_SEL_CTLr
#define READLN_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_PLL_SEL_CTLr
#define WRITELN_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_PLL_SEL_CTLr
#define WRITEALL_TXCOM_PLL_SEL_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d9
 * DEVAD:    1
 * DESC:     TXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr (0x0001d1d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t txcom_ln_dp_rst_st_sts[1];
	uint32_t _txcom_ln_dp_rst_st_sts;
} BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).txcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).txcom_ln_dp_rst_st_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET(r) (r).txcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET(r) (((r).txcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET(r,f) (r).txcom_ln_dp_rst_st_sts[0]=(((r).txcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr
#define TXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_t TXCOM_LN_DP_RST_ST_STSr_t;
#define TXCOM_LN_DP_RST_ST_STSr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR
#define TXCOM_LN_DP_RST_ST_STSr_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET
#define TXCOM_LN_DP_RST_ST_STSr_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET
#define READ_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr
#define WRITE_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr
#define MODIFY_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr
#define READLN_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr
#define WRITELN_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_TXCOM_LN_DP_RST_ST_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_MCST_MASK_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1da
 * DEVAD:    1
 * DESC:     TXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr (0x0001d1da | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_mcst_mask_ctl[1];
	uint32_t _txcom_mcst_mask_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_CLR(r) (r).txcom_mcst_mask_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_SET(r,d) (r).txcom_mcst_mask_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_GET(r) (r).txcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET(r) (((r).txcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).txcom_mcst_mask_ctl[0]=(((r).txcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_MCST_MASK_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr
#define TXCOM_MCST_MASK_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_t TXCOM_MCST_MASK_CTLr_t;
#define TXCOM_MCST_MASK_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_CLR
#define TXCOM_MCST_MASK_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_SET
#define TXCOM_MCST_MASK_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET
#define READ_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_MCST_MASK_CTLr
#define WRITE_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_MCST_MASK_CTLr
#define MODIFY_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr
#define READLN_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_MCST_MASK_CTLr
#define WRITELN_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr
#define WRITEALL_TXCOM_MCST_MASK_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1db
 * DEVAD:    1
 * DESC:     TXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE      OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     TX_PAM4_MODE     PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 *     TX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr (0x0001d1db | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_sts_mc_mask[1];
	uint32_t _txcom_osr_mode_sts_mc_mask;
} BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).txcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).txcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).txcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).txcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET(r) ((((r).txcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET(r) (((r).txcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr
#define TXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t TXCOM_OSR_MODE_STS_MC_MASKr_t;
#define TXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define TXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET
#define READ_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1dc
 * DEVAD:    1
 * DESC:     TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE_PIN  Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     TX_PAM4_MODE_PIN Indicates the status of the pmd_pam4_mode input pin.Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode)Reserved      3'd2:3d7
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d1dc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t txcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _txcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_GET(r) ((((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_SET(r,f) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET(r) (((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET(r,f) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_GET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_PAM4_MODE_PINf_SET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET
#define READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TXCOM_LN_S_RSTB_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1de
 * DEVAD:    1
 * DESC:     TXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     TX_HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once reset register/pin conditions are de-asserted.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr (0x0001d1de | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_s_rstb_ctl[1];
	uint32_t _txcom_ln_s_rstb_ctl;
} BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR(r) (r).txcom_ln_s_rstb_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).txcom_ln_s_rstb_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_GET(r) (r).txcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).txcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).txcom_ln_s_rstb_ctl[0]=(((r).txcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET(r) (((r).txcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET(r,f) (r).txcom_ln_s_rstb_ctl[0]=(((r).txcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr
#define TXCOM_LN_S_RSTB_CTLr_SIZE BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_t TXCOM_LN_S_RSTB_CTLr_t;
#define TXCOM_LN_S_RSTB_CTLr_CLR BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR
#define TXCOM_LN_S_RSTB_CTLr_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_SET
#define TXCOM_LN_S_RSTB_CTLr_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET
#define READ_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READ_TXCOM_LN_S_RSTB_CTLr
#define WRITE_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr
#define MODIFY_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr
#define READLN_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr
#define WRITELN_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr
#define WRITEALL_TXCOM_LN_S_RSTB_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_CFG0
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e0
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 0
 * RESETVAL: 0x2110 (8464)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_DEC_EN        Back Channel Decoder Enable.1 => enable  the Back Channel Decoder.0 => disable the Back Channel Decoder.
 *     BC_DEC_REFRAME_EN 1'b1 will enable re-framing to new frame length.
 *     BC_DEC_LOCK_CNT  Defines the number of bc_dec_lock_cnt+1 consecutive good BC frames of (good BC frames is defined as either no error or 1 bit correctable error if bc_dec_align_check_sec_en is 1'b1) to go to the BC frame lock. Valid values are 0 to 15. It is used in both ALIGN_FOUND and REFRAME_FOUND states.
 *     BC_DEC_ALIGN_TIMER_CNT Defines the timer duration to be used in the ALIGN_SEARCH state . Use it together with bc_dec_align_timer_mode.
 *     BC_DEC_ALIGN_CHECK_SEC_EN 1'b1 will allow 1 bit error correction during ALIGN_CHECK state.
 *     BC_DEC_ALIGN_TIMER_MODE Defines the timer modes for the ALIGN_SEARCH state.00 - use rclk                 (256  to 7936 rclk20 cycles)                                        .01 - use heartbeat_toggle_1us (16us to 496us)                                                     .10 - use heartbeat_toggle_1ms (1ms  to 31ms)                                                      .11 - create the timer_done manually using the self-clear control register bc_dec_align_timer_done .
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r (0x0001d1e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_CFG0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_cfg0[1];
	uint32_t _tlb_rx_b_tlb_rx_b_cfg0;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_CLR(r) (r).tlb_rx_b_tlb_rx_b_cfg0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_cfg0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_GET(r) (r).tlb_rx_b_tlb_rx_b_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg0[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg0[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg0[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg0[0]) >> 4) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_GET(r) (((r).tlb_rx_b_tlb_rx_b_cfg0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg0[0]=(((r).tlb_rx_b_tlb_rx_b_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_CFG0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r,(_r._tlb_rx_b_tlb_rx_b_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r,(_r._tlb_rx_b_tlb_rx_b_cfg0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r,(_r._tlb_rx_b_tlb_rx_b_cfg0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r
#define TLB_RX_B_TLB_RX_B_CFG0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_t TLB_RX_B_TLB_RX_B_CFG0r_t;
#define TLB_RX_B_TLB_RX_B_CFG0r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_CLR
#define TLB_RX_B_TLB_RX_B_CFG0r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_MODEf_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_CHECK_SEC_ENf_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ALIGN_TIMER_CNTf_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_LOCK_CNTf_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_REFRAME_ENf_SET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_GET
#define TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r_BC_DEC_ENf_SET
#define READ_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG0r
#define WRITE_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG0r
#define MODIFY_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG0r
#define READLN_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG0r
#define WRITELN_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG0r
#define WRITEALL_TLB_RX_B_TLB_RX_B_CFG0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_CFG1
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e1
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 1
 * RESETVAL: 0xf628 (63016)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_DEC_FRM_PAT   Defines the framing pattern which is compared to the received BC word bit [15:0] while decoderis trying to frame on the received data to acheive BC frame lock.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r (0x0001d1e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_CFG1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_cfg1[1];
	uint32_t _tlb_rx_b_tlb_rx_b_cfg1;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_CLR(r) (r).tlb_rx_b_tlb_rx_b_cfg1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_cfg1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_GET(r) (r).tlb_rx_b_tlb_rx_b_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_GET(r) (((r).tlb_rx_b_tlb_rx_b_cfg1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg1[0]=(((r).tlb_rx_b_tlb_rx_b_cfg1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_CFG1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r,(_r._tlb_rx_b_tlb_rx_b_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r,(_r._tlb_rx_b_tlb_rx_b_cfg1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r,(_r._tlb_rx_b_tlb_rx_b_cfg1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r
#define TLB_RX_B_TLB_RX_B_CFG1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_t TLB_RX_B_TLB_RX_B_CFG1r_t;
#define TLB_RX_B_TLB_RX_B_CFG1r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_CLR
#define TLB_RX_B_TLB_RX_B_CFG1r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_SET
#define TLB_RX_B_TLB_RX_B_CFG1r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_GET
#define TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_GET
#define TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r_BC_DEC_FRM_PATf_SET
#define READ_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG1r
#define WRITE_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG1r
#define MODIFY_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG1r
#define READLN_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG1r
#define WRITELN_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG1r
#define WRITEALL_TLB_RX_B_TLB_RX_B_CFG1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_CFG2
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e2
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 2
 * RESETVAL: 0x3a0 (928)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_DEC_MSG_TYPE_MODE It is a debug register bit to select the type of BC frames to be counted for analysis of type of errors in the BC frames.2'b00 - Count no error BC frames.2'b01 - Count 1 bit correctable error BC frames.2'b10 - Count 2 bit detectable  errors BC frames.2'b11 - Count 3 bit or more errors of un-correctable/un-detectable error BC frames.
 *     BC_DEC_MSG_CONS_CNT Defines the number of good consecutive BC frames with the consistent and different from the previously captured messages to accept as a new message in the bc_dec_msg_ms/lsb[15:0] registers.Value of 0 has special meaning where messages will be captured every frame irrespective of whether ECC is correctable or not. Value 0 should be only used for the debug mode.
 *     BC_DEC_OOL_CNT   Defines consecutive number of bad frames (i.e. BC frame ecc error >= 2) received by the framer to assert bc_dec_lol status and interrupt.
 *     BC_DEC_FRM_LEN_SEL Back Channel Decoder Frame Length Select Control. Determines the distance between 2 adjacent back channel frames.Following table explains the value of this register and BC frame length in multiples of 128 rclk20 cycles or 128*20 PAM4 symbols.bc_dec_frm_len_sel[2:0]            BC frame length in multiples of 128*20 PAM4 symbols.0                                      11                                      16*2^02                                      16*2^13                                      16*2^24                                      16*2^35                                      16*2^46                                      16*2^57                                      16*2^6
 *     BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONE Self clear regiter bit. Setting it to 1'b1 along with bc_dec_align_timer_mode=2'b11 will increment the sym_dly and search for alignment in new symbol rotate position.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r (0x0001d1e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_CFG2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_cfg2[1];
	uint32_t _tlb_rx_b_tlb_rx_b_cfg2;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_CLR(r) (r).tlb_rx_b_tlb_rx_b_cfg2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_cfg2[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_GET(r) (r).tlb_rx_b_tlb_rx_b_cfg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg2[0]=(((r).tlb_rx_b_tlb_rx_b_cfg2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg2[0]) >> 12) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg2[0]=(((r).tlb_rx_b_tlb_rx_b_cfg2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg2[0]) >> 7) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg2[0]=(((r).tlb_rx_b_tlb_rx_b_cfg2[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg2[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg2[0]=(((r).tlb_rx_b_tlb_rx_b_cfg2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg2[0]) >> 1) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg2[0]=(((r).tlb_rx_b_tlb_rx_b_cfg2[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1)) | (3 << (16 + 1))

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_CFG2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r,(_r._tlb_rx_b_tlb_rx_b_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r,(_r._tlb_rx_b_tlb_rx_b_cfg2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r,(_r._tlb_rx_b_tlb_rx_b_cfg2))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_cfg2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r
#define TLB_RX_B_TLB_RX_B_CFG2r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_t TLB_RX_B_TLB_RX_B_CFG2r_t;
#define TLB_RX_B_TLB_RX_B_CFG2r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_CLR
#define TLB_RX_B_TLB_RX_B_CFG2r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_SET
#define TLB_RX_B_TLB_RX_B_CFG2r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_ALIGN_SEARCH_MANUAL_TIMER_DONEf_SET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_FRM_LEN_SELf_SET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_OOL_CNTf_SET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_CONS_CNTf_SET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_GET
#define TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r_BC_DEC_MSG_TYPE_MODEf_SET
#define READ_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG2r
#define WRITE_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG2r
#define MODIFY_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG2r
#define READLN_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG2r
#define WRITELN_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG2r
#define WRITEALL_TLB_RX_B_TLB_RX_B_CFG2r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_CFG3
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e3
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 3
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/W
 * FIELDS:
 *     SYM_ROTATE_DLY_FRC_VAL Symbol rotate force value for debug mode. Valid values are 0 to 19.
 *     SYM_ROTATE_DLY_FRC Symbol rotate force control for debug mode.
 *     SYM_ROTATE_PRBS_AUTO_DETECT_EN Enable symbol rotate by PRBS auto-detect.
 *     SYM_ROTATE_BC_DEC_EN Enable symbol rotate by BC decoder.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r (0x0001d1e3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_CFG3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_cfg3[1];
	uint32_t _tlb_rx_b_tlb_rx_b_cfg3;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_CLR(r) (r).tlb_rx_b_tlb_rx_b_cfg3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_cfg3[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_GET(r) (r).tlb_rx_b_tlb_rx_b_cfg3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg3[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg3[0]=(((r).tlb_rx_b_tlb_rx_b_cfg3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg3[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg3[0]=(((r).tlb_rx_b_tlb_rx_b_cfg3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg3[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg3[0]=(((r).tlb_rx_b_tlb_rx_b_cfg3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_GET(r) (((r).tlb_rx_b_tlb_rx_b_cfg3[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg3[0]=(((r).tlb_rx_b_tlb_rx_b_cfg3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_CFG3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r,(_r._tlb_rx_b_tlb_rx_b_cfg3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r,(_r._tlb_rx_b_tlb_rx_b_cfg3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r,(_r._tlb_rx_b_tlb_rx_b_cfg3))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_cfg3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r
#define TLB_RX_B_TLB_RX_B_CFG3r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_t TLB_RX_B_TLB_RX_B_CFG3r_t;
#define TLB_RX_B_TLB_RX_B_CFG3r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_CLR
#define TLB_RX_B_TLB_RX_B_CFG3r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SET
#define TLB_RX_B_TLB_RX_B_CFG3r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_GET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_GET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_BC_DEC_ENf_SET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_GET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_PRBS_AUTO_DETECT_ENf_SET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_GET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRCf_SET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_GET
#define TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r_SYM_ROTATE_DLY_FRC_VALf_SET
#define READ_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG3r
#define WRITE_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG3r
#define MODIFY_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG3r
#define READLN_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG3r
#define WRITELN_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG3r
#define WRITEALL_TLB_RX_B_TLB_RX_B_CFG3r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_CFG4
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e4
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 4
 * RESETVAL: 0xf (15)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_DEC_INTR_MASK_LOCK 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin.
 *     BC_DEC_INTR_MASK_OOL 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin.
 *     BC_DEC_INTR_MASK_MSG_MSB_READY 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin.
 *     BC_DEC_INTR_MASK_MSG_LSB_READY 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin.
 *     BC_DEC_INTR_FRC_LOCK For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.
 *     BC_DEC_INTR_FRC_OOL For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.
 *     BC_DEC_INTR_FRC_MSG_MSB_READY For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.
 *     BC_DEC_INTR_FRC_MSG_LSB_READY For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r (0x0001d1e4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_CFG4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_cfg4[1];
	uint32_t _tlb_rx_b_tlb_rx_b_cfg4;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_CLR(r) (r).tlb_rx_b_tlb_rx_b_cfg4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_cfg4[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_GET(r) (r).tlb_rx_b_tlb_rx_b_cfg4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_cfg4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_GET(r) (((r).tlb_rx_b_tlb_rx_b_cfg4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_cfg4[0]=(((r).tlb_rx_b_tlb_rx_b_cfg4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_CFG4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r,(_r._tlb_rx_b_tlb_rx_b_cfg4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r,(_r._tlb_rx_b_tlb_rx_b_cfg4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r,(_r._tlb_rx_b_tlb_rx_b_cfg4))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_cfg4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_cfg4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r
#define TLB_RX_B_TLB_RX_B_CFG4r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_t TLB_RX_B_TLB_RX_B_CFG4r_t;
#define TLB_RX_B_TLB_RX_B_CFG4r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_CLR
#define TLB_RX_B_TLB_RX_B_CFG4r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_LSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_MSG_MSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_OOLf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_FRC_LOCKf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_LSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_MSG_MSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_OOLf_SET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_GET
#define TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r_BC_DEC_INTR_MASK_LOCKf_SET
#define READ_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_CFG4r
#define WRITE_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_CFG4r
#define MODIFY_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_CFG4r
#define READLN_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_CFG4r
#define WRITELN_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_CFG4r
#define WRITEALL_TLB_RX_B_TLB_RX_B_CFG4r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_CFG4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_CFG4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS7
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e7
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_AUTO_DETECT_STATE Indicates the live state of the PRBS Auto-Detect state machine.2'd0 = RESET         => Reset or unlock/search state.2'd1 = SEARCH_LOCK   => Inidcates that AUTO-DETECT is searching for the PRBS lock by changing the PRBS polynomials in round robin fashion.2'd2 = DONE          => Indicates that AUTO-DETECT is locked.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r (0x0001d1e7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS7.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts7[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts7;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts7[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts7[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts7[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts7[0]=(((r).tlb_rx_b_tlb_rx_b_sts7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r,(_r._tlb_rx_b_tlb_rx_b_sts7))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r,(_r._tlb_rx_b_tlb_rx_b_sts7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r,(_r._tlb_rx_b_tlb_rx_b_sts7))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r
#define TLB_RX_B_TLB_RX_B_STS7r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_t TLB_RX_B_TLB_RX_B_STS7r_t;
#define TLB_RX_B_TLB_RX_B_STS7r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_CLR
#define TLB_RX_B_TLB_RX_B_STS7r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_SET
#define TLB_RX_B_TLB_RX_B_STS7r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_GET
#define TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_GET
#define TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r_PRBS_CHK_AUTO_DETECT_STATEf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS7r
#define WRITE_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS7r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS7r
#define READLN_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS7r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS7r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS7r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS6
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e8
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_INTR      Status of the BC decoder active high interrupt pin. It is cleared upon read. This is the aggregate (i.e. ORed) of all the BC decoder interrupts. User needs to unmask the interrupt contributor events.1 - indicates interrupt is active.   This state can be forced by the unmasking the individual interrupts and then asserting one or more bc_dec_intr_frc* control regs for testing the ISRs withoutBC decoder is active. It is automatically asserted if any of the unmasked interrupt contributor events happen.0 - indicates interrupt is inactive. This state can be forced by making all the mask bits as '0' which is the default.
 *     BC_DEC_INTR_LOCK Status of the BC decoder Frame Lock event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.1 - indicates interrupt is active.   bc_dec_intr_mask_lock register must be 1'b0 for this bit to set. Once unmasked it is either set to 1'b1 by the frame lock event or by the bc_dec_intr_frc_lock bit.0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_lock register bit. This is the default state.
 *     BC_DEC_INTR_OOL  Status of the BC decoder Frame Lock event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.1 - indicates interrupt is active.   bc_dec_intr_mask_ool register must be 1'b0 for this bit to set. Once unmasked it is either set to 1'b1 by the frame ool event or by the bc_dec_intr_frc_ool bit.0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_ool register bit. This is the default state.
 *     BC_DEC_INTR_MSG_MSB_READY Status of the BC decoder MSB [31:16] message capture event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.1 - indicates interrupt is active.   bc_dec_intr_mask_msg_msb_ready register must be 1'b0 for this bit to set. Once unmasked it is either set to 1'b1 by the frame msg_msb_ready event or by the bc_dec_intr_frc_msg_msb_ready bit.0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_msg_msb_ready register bit. This is the default state.
 *     BC_DEC_INTR_MSG_LSB_READY Status of the BC decoder LSB [15:0] message capture event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.1 - indicates interrupt is active.   bc_dec_intr_mask_msg_lsb_ready register must be 1'b0 for this bit to set. Once unmasked it is either set to 1'b1 by the frame msg_lsb_ready event or by the bc_dec_intr_frc_msg_lsb_ready bit.0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_msg_lsb_ready register bit. This is the default state.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r (0x0001d1e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS6.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts6[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts6;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts6[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts6[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts6[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts6[0]=(((r).tlb_rx_b_tlb_rx_b_sts6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts6[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts6[0]=(((r).tlb_rx_b_tlb_rx_b_sts6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts6[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts6[0]=(((r).tlb_rx_b_tlb_rx_b_sts6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts6[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts6[0]=(((r).tlb_rx_b_tlb_rx_b_sts6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts6[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts6[0]=(((r).tlb_rx_b_tlb_rx_b_sts6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r,(_r._tlb_rx_b_tlb_rx_b_sts6))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r,(_r._tlb_rx_b_tlb_rx_b_sts6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r,(_r._tlb_rx_b_tlb_rx_b_sts6))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r
#define TLB_RX_B_TLB_RX_B_STS6r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_t TLB_RX_B_TLB_RX_B_STS6r_t;
#define TLB_RX_B_TLB_RX_B_STS6r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_CLR
#define TLB_RX_B_TLB_RX_B_STS6r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_SET
#define TLB_RX_B_TLB_RX_B_STS6r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_LSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_MSG_MSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_OOLf_SET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTR_LOCKf_SET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_GET
#define TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r_BC_DEC_INTRf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS6r
#define WRITE_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS6r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS6r
#define READLN_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS6r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS6r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS6r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS5
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1e9
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_MSG_TYPE_CNT This indicates the BC frame error type cnt within 15 consecutive frames. New 15 frame window is started upon read of this register. Used for debug and error analysis after BC decoder is locked.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r (0x0001d1e9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts5[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts5;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts5[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts5[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts5[0]=(((r).tlb_rx_b_tlb_rx_b_sts5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r,(_r._tlb_rx_b_tlb_rx_b_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r,(_r._tlb_rx_b_tlb_rx_b_sts5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r,(_r._tlb_rx_b_tlb_rx_b_sts5))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r
#define TLB_RX_B_TLB_RX_B_STS5r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_t TLB_RX_B_TLB_RX_B_STS5r_t;
#define TLB_RX_B_TLB_RX_B_STS5r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_CLR
#define TLB_RX_B_TLB_RX_B_STS5r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_SET
#define TLB_RX_B_TLB_RX_B_STS5r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_GET
#define TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_GET
#define TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r_BC_DEC_MSG_TYPE_CNTf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS5r
#define WRITE_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS5r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS5r
#define READLN_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS5r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS5r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS5r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS4
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1ea
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_MSG_LSB_READY 1'b1 indicates that a new LSB message is captured in the register bc_dec_msg_lsb and ready to be read. When LSB message is ready to be read the bc_dec_intr interrupt pin will also be asserted. This registeris cleared when LSB message register is read.
 *     BC_DEC_MSG_MSB_READY 1'b1 indicates that a new MSB message is captured in the register bc_dec_msg_msb and ready to be read. When MSB message is ready to be read the bc_dec_intr interrupt pin will also be asserted. This registeris cleared when MSB message register is read.
 *     BC_DEC_MSG_TYPE_CNT_READY 1'b1 indicates that bc_dec_msg_type_cnt is captured a new value and ready to be read. It is cleared upon read of bc_dec_msg_type_cnt registers.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r (0x0001d1ea | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts4[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts4;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts4[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts4[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts4[0]=(((r).tlb_rx_b_tlb_rx_b_sts4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts4[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts4[0]=(((r).tlb_rx_b_tlb_rx_b_sts4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts4[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts4[0]=(((r).tlb_rx_b_tlb_rx_b_sts4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r,(_r._tlb_rx_b_tlb_rx_b_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r,(_r._tlb_rx_b_tlb_rx_b_sts4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r,(_r._tlb_rx_b_tlb_rx_b_sts4))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r
#define TLB_RX_B_TLB_RX_B_STS4r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_t TLB_RX_B_TLB_RX_B_STS4r_t;
#define TLB_RX_B_TLB_RX_B_STS4r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_CLR
#define TLB_RX_B_TLB_RX_B_STS4r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_SET
#define TLB_RX_B_TLB_RX_B_STS4r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_GET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_GET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_TYPE_CNT_READYf_SET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_MSB_READYf_SET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_GET
#define TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r_BC_DEC_MSG_LSB_READYf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS4r
#define WRITE_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS4r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS4r
#define READLN_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS4r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS4r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS4r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS3
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1eb
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_MSG_LSB   This indicates the captured LSB message bits [15:0].Bits [12:0]  indicates the LSB bits [15:0] of the BC INFO field.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r (0x0001d1eb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts3[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts3;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts3[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts3[0]=(((r).tlb_rx_b_tlb_rx_b_sts3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r,(_r._tlb_rx_b_tlb_rx_b_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r,(_r._tlb_rx_b_tlb_rx_b_sts3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r,(_r._tlb_rx_b_tlb_rx_b_sts3))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r
#define TLB_RX_B_TLB_RX_B_STS3r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_t TLB_RX_B_TLB_RX_B_STS3r_t;
#define TLB_RX_B_TLB_RX_B_STS3r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_CLR
#define TLB_RX_B_TLB_RX_B_STS3r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_SET
#define TLB_RX_B_TLB_RX_B_STS3r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_GET
#define TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_GET
#define TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r_BC_DEC_MSG_LSBf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS3r
#define WRITE_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS3r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS3r
#define READLN_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS3r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS3r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS3r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS2
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1ec
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_MSG_MSB   This indicates the captured MSB message bits [31:16].Bits [15:13] indicates the BC frame length encoding.Bits [12:0]  indicates the MSB bits [28:16] of the BC INFO field.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r (0x0001d1ec | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts2[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts2;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts2[0]=(((r).tlb_rx_b_tlb_rx_b_sts2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r,(_r._tlb_rx_b_tlb_rx_b_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r,(_r._tlb_rx_b_tlb_rx_b_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r,(_r._tlb_rx_b_tlb_rx_b_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r
#define TLB_RX_B_TLB_RX_B_STS2r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_t TLB_RX_B_TLB_RX_B_STS2r_t;
#define TLB_RX_B_TLB_RX_B_STS2r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_CLR
#define TLB_RX_B_TLB_RX_B_STS2r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_SET
#define TLB_RX_B_TLB_RX_B_STS2r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_GET
#define TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_GET
#define TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r_BC_DEC_MSG_MSBf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS2r
#define WRITE_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS2r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS2r
#define READLN_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS2r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS2r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS1
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1ed
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_SM_STATE_ONE_HOT This indicates the One Hot indication of the BD decoder FSM states. It is cleared upon read. Following is the mapping of bits and FSM states.bit 0     =>      RESETbit 1     =>      ALIGN_SEARCHbit 2     =>      ALIGN_CHECKbit 3     =>      FRM_LOCK
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r (0x0001d1ed | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts1[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts1;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts1[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts1[0]=(((r).tlb_rx_b_tlb_rx_b_sts1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r,(_r._tlb_rx_b_tlb_rx_b_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r,(_r._tlb_rx_b_tlb_rx_b_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r,(_r._tlb_rx_b_tlb_rx_b_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r
#define TLB_RX_B_TLB_RX_B_STS1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_t TLB_RX_B_TLB_RX_B_STS1r_t;
#define TLB_RX_B_TLB_RX_B_STS1r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_CLR
#define TLB_RX_B_TLB_RX_B_STS1r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_SET
#define TLB_RX_B_TLB_RX_B_STS1r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_GET
#define TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_GET
#define TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r_BC_DEC_SM_STATE_ONE_HOTf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS1r
#define WRITE_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS1r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS1r
#define READLN_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS1r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS1r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_B_TLB_RX_B_STS0
 * BLOCKS:   TLB_RX_B
 * REGADDR:  0xd1ee
 * DEVAD:    1
 * DESC:     TLB_RX_B Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BC_DEC_LOCK      Back Channel Decoder LOCK Indication. This is a live indication of the status of the Back Channel Decoder LOCK.1 => BC decoder is in LOCKED state.0 => BC decoder is out of LOCK state and state machine is searching for a LOCK.
 *     BC_DEC_OOL       Back Channel Decoder out of LOCK Indication. This is a live indication of the status of the Back Channel Decoder out of LOCK.1 => BC decoder is in Out of LOCK state.  `0 => BC decoder is in LOCK state.
 *     BC_DEC_SM_STATE  Live indication of BC decoder state machine state status. These are the state encodings.2'd0     =>      RESET                => reset state when bc_dec_en=0 or datapath reset enabled2'd1     =>      ALIGN_SEARCH         => word align search where first framing candidate is found based upon no ECC error and 16 bits framing pattern match with 16 LSB bits of the received BC frame.2'd2     =>      ALIGN_CHECK          => word align found where framing candidate is checked for consistency.2'd3     =>      FRM_LOCK             => frame lock acheived state. Once in this state then only bc_dec_en=0 will reset the BC decoder otherwise it will flywheel based on the frame length accepted in the ALIGN_SEARCH.
 *     SYM_ROTATE_DLY   Live indication of symbol rotate or delay. Valid valid are 0 to 19.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r (0x0001d1ee | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_B_TLB_RX_B_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_b_tlb_rx_b_sts0[1];
	uint32_t _tlb_rx_b_tlb_rx_b_sts0;
} BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_CLR(r) (r).tlb_rx_b_tlb_rx_b_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SET(r,d) (r).tlb_rx_b_tlb_rx_b_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_GET(r) (r).tlb_rx_b_tlb_rx_b_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts0[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts0[0]=(((r).tlb_rx_b_tlb_rx_b_sts0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts0[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts0[0]=(((r).tlb_rx_b_tlb_rx_b_sts0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_GET(r) ((((r).tlb_rx_b_tlb_rx_b_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts0[0]=(((r).tlb_rx_b_tlb_rx_b_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_GET(r) (((r).tlb_rx_b_tlb_rx_b_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_SET(r,f) (r).tlb_rx_b_tlb_rx_b_sts0[0]=(((r).tlb_rx_b_tlb_rx_b_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_B_TLB_RX_B_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r,(_r._tlb_rx_b_tlb_rx_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r,(_r._tlb_rx_b_tlb_rx_b_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r,(_r._tlb_rx_b_tlb_rx_b_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_b_tlb_rx_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_b_tlb_rx_b_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r
#define TLB_RX_B_TLB_RX_B_STS0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_t TLB_RX_B_TLB_RX_B_STS0r_t;
#define TLB_RX_B_TLB_RX_B_STS0r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_CLR
#define TLB_RX_B_TLB_RX_B_STS0r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SET
#define TLB_RX_B_TLB_RX_B_STS0r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_GET
#define TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_GET
#define TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_SYM_ROTATE_DLYf_SET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_GET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_SM_STATEf_SET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_GET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_OOLf_SET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_GET
#define TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r_BC_DEC_LOCKf_SET
#define READ_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_B_TLB_RX_B_STS0r
#define WRITE_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_B_TLB_RX_B_STS0r
#define MODIFY_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_B_TLB_RX_B_STS0r
#define READLN_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_B_TLB_RX_B_STS0r
#define WRITELN_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_B_TLB_RX_B_STS0r
#define WRITEALL_TLB_RX_B_TLB_RX_B_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_B_TLB_RX_B_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_B_TLB_RX_B_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_TLB_RX_C_CFG0
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f0
 * DEVAD:    1
 * DESC:     TLB_RX_C Control 0
 * RESETVAL: 0x440c (17420)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_CLEAR_ERROR_ANALYZER_STATUS When a write is executed in this register, it will clear all the error analyzer registers.This register is self-clear.
 *     TLB_ERR_ERROR_COUNT_THRESH Error threshold number beyond which the error analyzer would count a bad frame.Valid values for this field are from 3-15
 *     TLB_ERR_IGNORE_BACK_CHANNEL By setting this bit, the frame counter in the error analyzer continues count when back channel word arrives.When back channel word arrives, the error analyzer treats it like a valid prbs code but assumes zero errors.This is a debug feature.
 *     TLB_ERR_FEC_L_EN If 1 implies that 20 MSBs of the 40 bit word are processed else 20 LSBs are processed.
 *     TLB_ERR_FEC_L_R_EN If 1 implies that two fecs are processing the rx data. The error analyzer looks at only 20 bits out of a 40 bit word.
 *     TLB_ERR_FEC_SIZE Defines the size of the FEC frame.Valid values for this field must be >= 6The frame size = (tlb_err_fec_size * 320) bitsTo get 5440 bits FEC, N = 5440/320 = 17.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r (0x0001d1f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_TLB_RX_C_CFG0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_tlb_rx_c_cfg0[1];
	uint32_t _tlb_rx_c_tlb_rx_c_cfg0;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_CLR(r) (r).tlb_rx_c_tlb_rx_c_cfg0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SET(r,d) (r).tlb_rx_c_tlb_rx_c_cfg0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_GET(r) (r).tlb_rx_c_tlb_rx_c_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 10) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 2) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TLB_RX_C_TLB_RX_C_CFG0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_tlb_rx_c_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r
#define TLB_RX_C_TLB_RX_C_CFG0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_t TLB_RX_C_TLB_RX_C_CFG0r_t;
#define TLB_RX_C_TLB_RX_C_CFG0r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_CLR
#define TLB_RX_C_TLB_RX_C_CFG0r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET
#define READ_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITE_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG0r
#define MODIFY_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG0r
#define READLN_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITELN_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_TLB_RX_C_CFG1
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f1
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 1
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_HISTOGRAM_ERROR_THRESH Counts the number of errors in frames for x, x+1,..,x+7 errors in the FEC framesValid values for this field are from 3-8
 *     TLB_ERR_CLEAR_STATUS_ON_READ Enables read on clear for all error status counters
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r (0x0001d1f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_TLB_RX_C_CFG1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_tlb_rx_c_cfg1[1];
	uint32_t _tlb_rx_c_tlb_rx_c_cfg1;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_CLR(r) (r).tlb_rx_c_tlb_rx_c_cfg1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SET(r,d) (r).tlb_rx_c_tlb_rx_c_cfg1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_GET(r) (r).tlb_rx_c_tlb_rx_c_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg1[0]=(((r).tlb_rx_c_tlb_rx_c_cfg1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET(r) (((r).tlb_rx_c_tlb_rx_c_cfg1[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg1[0]=(((r).tlb_rx_c_tlb_rx_c_cfg1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_C_TLB_RX_C_CFG1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_tlb_rx_c_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r
#define TLB_RX_C_TLB_RX_C_CFG1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_t TLB_RX_C_TLB_RX_C_CFG1r_t;
#define TLB_RX_C_TLB_RX_C_CFG1r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_CLR
#define TLB_RX_C_TLB_RX_C_CFG1r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SET
#define TLB_RX_C_TLB_RX_C_CFG1r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET
#define READ_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITE_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG1r
#define MODIFY_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG1r
#define READLN_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITELN_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_TLB_RX_C_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f5
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_ERROR_HI Top 4 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames.tlb_err_count_error_lo needs to be read before this status register to read the correct value
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr (0x0001d1f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_num_errs_in_fec_frames_sts_hi[1];
	uint32_t _tlb_rx_c_num_errs_in_fec_frames_sts_hi;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET(r,d) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET(r) (((r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET(r,f) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET
#define READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f6
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_ERROR_LO Bottom 16 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr (0x0001d1f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_num_errs_in_fec_frames_sts_lo[1];
	uint32_t _tlb_rx_c_num_errs_in_fec_frames_sts_lo;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET(r,d) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET(r) (((r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET(r,f) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]=(((r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET
#define READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f7
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r (0x0001d1f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs7[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs7;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs7[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs7[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs7[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs7[0]=(((r).tlb_rx_c_cnt_histogram_err_offs7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f8
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r (0x0001d1f8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs6[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs6;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs6[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs6[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs6[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs6[0]=(((r).tlb_rx_c_cnt_histogram_err_offs6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f9
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r (0x0001d1f9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs5[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs5;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs5[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs5[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs5[0]=(((r).tlb_rx_c_cnt_histogram_err_offs5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fa
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r (0x0001d1fa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs4[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs4;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs4[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs4[0]=(((r).tlb_rx_c_cnt_histogram_err_offs4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fb
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r (0x0001d1fb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs3[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs3;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs3[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs3[0]=(((r).tlb_rx_c_cnt_histogram_err_offs3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fc
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r (0x0001d1fc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs2[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs2;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs2[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs2[0]=(((r).tlb_rx_c_cnt_histogram_err_offs2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fd
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r (0x0001d1fd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs1[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs1;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs1[0]=(((r).tlb_rx_c_cnt_histogram_err_offs1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fe
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0 Number of times 'N' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r (0x0001d1fe | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs0[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs0;
} BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs0[0]=(((r).tlb_rx_c_cnt_histogram_err_offs0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_CLK_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd200
 * DEVAD:    1
 * DESC:     Clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_CLK_EN master clock enable:By default the clock to micro sub-system is disabled andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 enable the master clock0 - disabled1 - enables
 */
#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r (0x0001d200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CLK_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_clk_ctl0[1];
	uint32_t _uc_clk_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_CLR(r) (r).uc_clk_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_SET(r,d) (r).uc_clk_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_GET(r) (r).uc_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET(r) (((r).uc_clk_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CLK_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r
#define UC_CLK_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_t UC_CLK_CTL0r_t;
#define UC_CLK_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_CLR
#define UC_CLK_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_SET
#define UC_CLK_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET
#define READ_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_CLK_CTL0r
#define WRITE_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_CLK_CTL0r
#define MODIFY_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_CLK_CTL0r
#define READLN_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_CLK_CTL0r
#define WRITELN_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_CLK_CTL0r
#define WRITEALL_UC_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RST_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd201
 * DEVAD:    1
 * DESC:     Reset control registers 0
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_RSTB master reset :By default a reset to micro controller sub-system is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem0 - asserted1 - de-asserted
 *     MICRO_SW_TIMESTAMP_TIMER_RSTB Timestamp timer software resetThis field allows the chip firmware to reset the timestamp timers inall Serdes cores to be be with 1 or 2 time units.0 - asserted, Timestamp timer set 0.1 - de-asserted,  normal operation.
 *     MICRO_PRAM_IF_RSTB PRAM interface reset :By default a reset to the PRAM interface is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface0 - asserted1 - de-asserted
 */
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r (0x0001d201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RST_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rst_ctl0[1];
	uint32_t _uc_rst_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_CLR(r) (r).uc_rst_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_SET(r,d) (r).uc_rst_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_GET(r) (r).uc_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET(r) (((r).uc_rst_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RST_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r
#define UC_RST_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_t UC_RST_CTL0r_t;
#define UC_RST_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_CLR
#define UC_RST_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_SET
#define UC_RST_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET
#define UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET
#define READ_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RST_CTL0r
#define WRITE_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RST_CTL0r
#define MODIFY_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RST_CTL0r
#define READLN_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RST_CTL0r
#define WRITELN_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RST_CTL0r
#define WRITEALL_UC_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd202
 * DEVAD:    1
 * DESC:     rmi to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATASIZE write data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_RDDATASIZE read data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_INIT    Intialize code/data RAM2'b01: initailize code RAM - write zeroes to all locations2'b10: initialize data RAM - write zeroes to all loactions2'b00, 2'b11: ignored
 *     MICRO_AUTOINC_WRADDR_EN Automatic increment write address enable0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.the address automatically increments based on the micro_ra_wrdatasize field afterthe write has been performed
 *     MICRO_AUTOINC_RDADDR_EN Automatic increment read address enable0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw filedsthe address automatically increments based on the micro_ra_rddatasize field afterthe read has been performed
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r (0x0001d202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_ctl0[1];
	uint32_t _uc_ahb_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_CLR(r) (r).uc_ahb_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_SET(r,d) (r).uc_ahb_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_GET(r) (r).uc_ahb_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 4) & 0x3)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET(r) (((r).uc_ahb_ctl0[0]) & 0x3)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_AHB_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r
#define UC_AHB_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_t UC_AHB_CTL0r_t;
#define UC_AHB_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_CLR
#define UC_AHB_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_SET
#define UC_AHB_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_RA_INITf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET
#define UC_AHB_CTL0r_MICRO_RA_INITf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET
#define READ_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_AHB_CTL0r
#define WRITE_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_CTL0r
#define MODIFY_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_CTL0r
#define READLN_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_CTL0r
#define WRITELN_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_CTL0r
#define WRITEALL_UC_AHB_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_STS0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd203
 * DEVAD:    1
 * DESC:     rmi to ahb status registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_INITDONE When this bit is set, it indicate that code/data RAM initialization process is completeThis reamins set until
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r (0x0001d203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_sts0[1];
	uint32_t _uc_ahb_sts0;
} BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_CLR(r) (r).uc_ahb_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_SET(r,d) (r).uc_ahb_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_GET(r) (r).uc_ahb_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET(r) (((r).uc_ahb_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET(r,f) (r).uc_ahb_sts0[0]=(((r).uc_ahb_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_AHB_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r
#define UC_AHB_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_t UC_AHB_STS0r_t;
#define UC_AHB_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_CLR
#define UC_AHB_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_SET
#define UC_AHB_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET
#define READ_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_AHB_STS0r
#define WRITE_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_STS0r
#define MODIFY_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_STS0r
#define READLN_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_STS0r
#define WRITELN_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_STS0r
#define WRITEALL_UC_AHB_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd204
 * DEVAD:    1
 * DESC:     rmi to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr (0x0001d204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_lsw[1];
	uint32_t _uc_ahb_wraddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_CLR(r) (r).uc_ahb_wraddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_SET(r,d) (r).uc_ahb_wraddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_GET(r) (r).uc_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET(r) (((r).uc_ahb_wraddr_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET(r,f) (r).uc_ahb_wraddr_lsw[0]=(((r).uc_ahb_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr
#define UC_AHB_WRADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_t UC_AHB_WRADDR_LSWr_t;
#define UC_AHB_WRADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_CLR
#define UC_AHB_WRADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_SET
#define UC_AHB_WRADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET
#define READ_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRADDR_LSWr
#define WRITE_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRADDR_LSWr
#define MODIFY_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRADDR_LSWr
#define READLN_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRADDR_LSWr
#define WRITELN_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRADDR_LSWr
#define WRITEALL_UC_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd205
 * DEVAD:    1
 * DESC:     rmi to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr (0x0001d205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_msw[1];
	uint32_t _uc_ahb_wraddr_msw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_CLR(r) (r).uc_ahb_wraddr_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_SET(r,d) (r).uc_ahb_wraddr_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_GET(r) (r).uc_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET(r) (((r).uc_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET(r,f) (r).uc_ahb_wraddr_msw[0]=(((r).uc_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr
#define UC_AHB_WRADDR_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_t UC_AHB_WRADDR_MSWr_t;
#define UC_AHB_WRADDR_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_CLR
#define UC_AHB_WRADDR_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_SET
#define UC_AHB_WRADDR_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET
#define READ_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRADDR_MSWr
#define WRITE_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRADDR_MSWr
#define MODIFY_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRADDR_MSWr
#define READLN_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRADDR_MSWr
#define WRITELN_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRADDR_MSWr
#define WRITEALL_UC_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_WRDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd206
 * DEVAD:    1
 * DESC:     rmi to ahb write data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_LSW These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactionsWrite transaction on the AHB-Lite is initiated when this register is written
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr (0x0001d206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_lsw[1];
	uint32_t _uc_ahb_wrdata_lsw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_CLR(r) (r).uc_ahb_wrdata_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_SET(r,d) (r).uc_ahb_wrdata_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_GET(r) (r).uc_ahb_wrdata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET(r) (((r).uc_ahb_wrdata_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET(r,f) (r).uc_ahb_wrdata_lsw[0]=(((r).uc_ahb_wrdata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr
#define UC_AHB_WRDATA_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_t UC_AHB_WRDATA_LSWr_t;
#define UC_AHB_WRDATA_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_CLR
#define UC_AHB_WRDATA_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_SET
#define UC_AHB_WRDATA_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET
#define READ_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRDATA_LSWr
#define WRITE_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRDATA_LSWr
#define MODIFY_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRDATA_LSWr
#define READLN_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRDATA_LSWr
#define WRITELN_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRDATA_LSWr
#define WRITEALL_UC_AHB_WRDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_WRDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd207
 * DEVAD:    1
 * DESC:     rmi to ahb write data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_MSW These bits are used  to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr (0x0001d207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_msw[1];
	uint32_t _uc_ahb_wrdata_msw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_CLR(r) (r).uc_ahb_wrdata_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_SET(r,d) (r).uc_ahb_wrdata_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_GET(r) (r).uc_ahb_wrdata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET(r) (((r).uc_ahb_wrdata_msw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET(r,f) (r).uc_ahb_wrdata_msw[0]=(((r).uc_ahb_wrdata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr
#define UC_AHB_WRDATA_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_t UC_AHB_WRDATA_MSWr_t;
#define UC_AHB_WRDATA_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_CLR
#define UC_AHB_WRDATA_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_SET
#define UC_AHB_WRDATA_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET
#define READ_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_WRDATA_MSWr
#define WRITE_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_WRDATA_MSWr
#define MODIFY_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_WRDATA_MSWr
#define READLN_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_WRDATA_MSWr
#define WRITELN_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_WRDATA_MSWr
#define WRITEALL_UC_AHB_WRDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_WRDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_RDADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd208
 * DEVAD:    1
 * DESC:     rmi to ahb read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactionsRead transaction is initiated on the AHB-Lite when this register is written
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr (0x0001d208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_lsw[1];
	uint32_t _uc_ahb_rdaddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_CLR(r) (r).uc_ahb_rdaddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_SET(r,d) (r).uc_ahb_rdaddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_GET(r) (r).uc_ahb_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET(r) (((r).uc_ahb_rdaddr_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET(r,f) (r).uc_ahb_rdaddr_lsw[0]=(((r).uc_ahb_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr
#define UC_AHB_RDADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_t UC_AHB_RDADDR_LSWr_t;
#define UC_AHB_RDADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_CLR
#define UC_AHB_RDADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_SET
#define UC_AHB_RDADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET
#define READ_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDADDR_LSWr
#define WRITE_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDADDR_LSWr
#define MODIFY_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDADDR_LSWr
#define READLN_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDADDR_LSWr
#define WRITELN_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDADDR_LSWr
#define WRITEALL_UC_AHB_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_RDADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd209
 * DEVAD:    1
 * DESC:     rmi to ahb read address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_MSW These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr (0x0001d209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_msw[1];
	uint32_t _uc_ahb_rdaddr_msw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_CLR(r) (r).uc_ahb_rdaddr_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_SET(r,d) (r).uc_ahb_rdaddr_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_GET(r) (r).uc_ahb_rdaddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET(r) (((r).uc_ahb_rdaddr_msw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET(r,f) (r).uc_ahb_rdaddr_msw[0]=(((r).uc_ahb_rdaddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr
#define UC_AHB_RDADDR_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_t UC_AHB_RDADDR_MSWr_t;
#define UC_AHB_RDADDR_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_CLR
#define UC_AHB_RDADDR_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_SET
#define UC_AHB_RDADDR_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET
#define READ_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDADDR_MSWr
#define WRITE_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDADDR_MSWr
#define MODIFY_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDADDR_MSWr
#define READLN_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDADDR_MSWr
#define WRITELN_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDADDR_MSWr
#define WRITEALL_UC_AHB_RDADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_RDADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_RDDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20a
 * DEVAD:    1
 * DESC:     rmi to ahb read data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_LSW These are the lower 16-bits of the read data from the AHB-Lite slave deviceRead transaction is initiated on the AHB-Lite when this register is read
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr (0x0001d20a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_lsw[1];
	uint32_t _uc_ahb_rddata_lsw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_CLR(r) (r).uc_ahb_rddata_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_SET(r,d) (r).uc_ahb_rddata_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_GET(r) (r).uc_ahb_rddata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET(r) (((r).uc_ahb_rddata_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET(r,f) (r).uc_ahb_rddata_lsw[0]=(((r).uc_ahb_rddata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr
#define UC_AHB_RDDATA_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_t UC_AHB_RDDATA_LSWr_t;
#define UC_AHB_RDDATA_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_CLR
#define UC_AHB_RDDATA_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_SET
#define UC_AHB_RDDATA_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET
#define READ_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDDATA_LSWr
#define WRITE_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDDATA_LSWr
#define MODIFY_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDDATA_LSWr
#define READLN_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDDATA_LSWr
#define WRITELN_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDDATA_LSWr
#define WRITEALL_UC_AHB_RDDATA_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_AHB_RDDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20b
 * DEVAD:    1
 * DESC:     rmi to ahb read data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_MSW These are the upper 16-bits of the read data from the AHB-Lite slave device
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr (0x0001d20b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_msw[1];
	uint32_t _uc_ahb_rddata_msw;
} BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_CLR(r) (r).uc_ahb_rddata_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_SET(r,d) (r).uc_ahb_rddata_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_GET(r) (r).uc_ahb_rddata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET(r) (((r).uc_ahb_rddata_msw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET(r,f) (r).uc_ahb_rddata_msw[0]=(((r).uc_ahb_rddata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr
#define UC_AHB_RDDATA_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_t UC_AHB_RDDATA_MSWr_t;
#define UC_AHB_RDDATA_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_CLR
#define UC_AHB_RDDATA_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_SET
#define UC_AHB_RDDATA_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET
#define READ_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_AHB_RDDATA_MSWr
#define WRITE_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_AHB_RDDATA_MSWr
#define MODIFY_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_AHB_RDDATA_MSWr
#define READLN_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_AHB_RDDATA_MSWr
#define WRITELN_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_AHB_RDDATA_MSWr
#define WRITEALL_UC_AHB_RDDATA_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_AHB_RDDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_PRAMIF_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20c
 * DEVAD:    1
 * DESC:     pram i/f to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_EN  When this bit is set, pram if interface can generate write transactions on theAHB-Lite bus, the start address of the transaction is specifieldin the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r (0x0001d20c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_pramif_ctl0[1];
	uint32_t _uc_pramif_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_CLR(r) (r).uc_pramif_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_SET(r,d) (r).uc_pramif_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_GET(r) (r).uc_pramif_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET(r) (((r).uc_pramif_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET(r,f) (r).uc_pramif_ctl0[0]=(((r).uc_pramif_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_PRAMIF_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r
#define UC_PRAMIF_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_t UC_PRAMIF_CTL0r_t;
#define UC_PRAMIF_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_CLR
#define UC_PRAMIF_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_SET
#define UC_PRAMIF_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET
#define READ_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_CTL0r
#define WRITE_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_CTL0r
#define MODIFY_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_CTL0r
#define READLN_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_CTL0r
#define WRITELN_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_CTL0r
#define WRITEALL_UC_PRAMIF_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_PRAMIF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20d
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_LSW These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactionsbits[1:0] are not used for 32 transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr (0x0001d20d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_lsw[1];
	uint32_t _uc_pramif_ahb_wraddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR(r) (r).uc_pramif_ahb_wraddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET(r) (r).uc_pramif_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET(r) ((((r).uc_pramif_ahb_wraddr_lsw[0]) >> 2) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_lsw[0]=(((r).uc_pramif_ahb_wraddr_lsw[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr
#define UC_PRAMIF_AHB_WRADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t UC_PRAMIF_AHB_WRADDR_LSWr_t;
#define UC_PRAMIF_AHB_WRADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET
#define UC_PRAMIF_AHB_WRADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20e
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr (0x0001d20e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_msw[1];
	uint32_t _uc_pramif_ahb_wraddr_msw;
} BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR(r) (r).uc_pramif_ahb_wraddr_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET(r) (r).uc_pramif_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET(r) (((r).uc_pramif_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_msw[0]=(((r).uc_pramif_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr
#define UC_PRAMIF_AHB_WRADDR_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t UC_PRAMIF_AHB_WRADDR_MSWr_t;
#define UC_PRAMIF_AHB_WRADDR_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET
#define UC_PRAMIF_AHB_WRADDR_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_PVT_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd210
 * DEVAD:    1
 * DESC:     pvt temperature status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_RMI temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 */
#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r (0x0001d210 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PVT_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_s {
	uint32_t v[1];
	uint32_t uc_pvt_sts0[1];
	uint32_t _uc_pvt_sts0;
} BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_CLR(r) (r).uc_pvt_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_SET(r,d) (r).uc_pvt_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_GET(r) (r).uc_pvt_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET(r) (((r).uc_pvt_sts0[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET(r,f) (r).uc_pvt_sts0[0]=(((r).uc_pvt_sts0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_PVT_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_PVT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_PVT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pvt_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r
#define UC_PVT_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_t UC_PVT_STS0r_t;
#define UC_PVT_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_CLR
#define UC_PVT_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_SET
#define UC_PVT_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET
#define READ_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_PVT_STS0r
#define WRITE_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_PVT_STS0r
#define MODIFY_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_PVT_STS0r
#define READLN_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_PVT_STS0r
#define WRITELN_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_PVT_STS0r
#define WRITEALL_UC_PVT_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_PVT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_PVT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_AHB_CTL1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd211
 * DEVAD:    1
 * DESC:     ahb control register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_ACK_TIMEOUT_DIS pmi_hp_ack_timeout disableWhen micro initates a read/write transctions on the pmi_hp busit allows upto 256 clock cycles for pmi_hp_ack to be assertedIf pmi_hp_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp bus2. set the pmi_hp_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus when micro_m0p_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 *     MICRO_RA_ARG_MICROBLK_SEL select micro to access it's amba bus registers through the registers interface0 - select micro 0 amba registers1 - select micro 1 amba registers2 - select micro 2 amba registers3 - select micro 3 amba registers
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r (0x0001d211 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_ctl1[1];
	uint32_t _uc_rmi_ahb_ctl1;
} BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_CLR(r) (r).uc_rmi_ahb_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_SET(r,d) (r).uc_rmi_ahb_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_GET(r) (r).uc_rmi_ahb_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 4) & 0x7)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET(r) (((r).uc_rmi_ahb_ctl1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r
#define UC_RMI_AHB_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_t UC_RMI_AHB_CTL1r_t;
#define UC_RMI_AHB_CTL1r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_CLR
#define UC_RMI_AHB_CTL1r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_SET
#define UC_RMI_AHB_CTL1r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_GET
#define UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET
#define UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET
#define READ_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_AHB_CTL1r
#define WRITE_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_AHB_CTL1r
#define MODIFY_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_AHB_CTL1r
#define READLN_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_AHB_CTL1r
#define WRITELN_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_AHB_CTL1r
#define WRITEALL_UC_RMI_AHB_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_AHB_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_AHB_STS1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd212
 * DEVAD:    1
 * DESC:     ahb status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_DEFAULT_SLAVE_ERROR register interface default slave error detected. Register interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_PR_DEFAULT_SLAVE_ERROR PRAM interface default slave error detected. PRAM interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r (0x0001d212 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_sts1[1];
	uint32_t _uc_rmi_ahb_sts1;
} BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_CLR(r) (r).uc_rmi_ahb_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_SET(r,d) (r).uc_rmi_ahb_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_GET(r) (r).uc_rmi_ahb_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET(r) (((r).uc_rmi_ahb_sts1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r
#define UC_RMI_AHB_STS1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_t UC_RMI_AHB_STS1r_t;
#define UC_RMI_AHB_STS1r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_CLR
#define UC_RMI_AHB_STS1r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_SET
#define UC_RMI_AHB_STS1r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET
#define READ_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_AHB_STS1r
#define WRITE_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_AHB_STS1r
#define MODIFY_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_AHB_STS1r
#define READLN_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_AHB_STS1r
#define WRITELN_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_AHB_STS1r
#define WRITEALL_UC_RMI_AHB_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_AHB_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_AHB_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd213
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_LSW When the micro_autoinc_wraddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr (0x0001d213 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_wraddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_RDADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd214
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_RDADDR_LSW When the micro_autoinc_rdaddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr (0x0001d214 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_rdaddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_rdaddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_PR_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd215
 * DEVAD:    1
 * DESC:     pram i/f to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PR_AUTOINC_NXT_WRADDR_LSW When pram interface is used to write to the code/data RAMthen these bits indicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr (0x0001d215 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_pr_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_pr_ainc_nxt_wraddr_lsw;
} BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_PVT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd216
 * DEVAD:    1
 * DESC:     rmi pvt temperature control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_FRCVAL temperature data force valueWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *     MICRO_PVT_TEMPDATA_FRC temperature dat force enableWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r (0x0001d216 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PVT_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pvt_ctl0[1];
	uint32_t _uc_rmi_pvt_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_CLR(r) (r).uc_rmi_pvt_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_SET(r,d) (r).uc_rmi_pvt_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_GET(r) (r).uc_rmi_pvt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET(r) ((((r).uc_rmi_pvt_ctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET(r) (((r).uc_rmi_pvt_ctl0[0]) & 0x3ff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_RMI_PVT_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pvt_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r
#define UC_RMI_PVT_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_t UC_RMI_PVT_CTL0r_t;
#define UC_RMI_PVT_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_CLR
#define UC_RMI_PVT_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_SET
#define UC_RMI_PVT_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET
#define READ_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PVT_CTL0r
#define WRITE_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PVT_CTL0r
#define MODIFY_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PVT_CTL0r
#define READLN_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PVT_CTL0r
#define WRITELN_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PVT_CTL0r
#define WRITEALL_UC_RMI_PVT_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PVT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_PVT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_RAM_CR_CRCCTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd217
 * DEVAD:    1
 * DESC:     code ram crc control 0 register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_CRC_CALC_EN Calculate/Update Code RAM CRC16 CCITT checksum enable1: calculate new CRC16 CCITT checksum when code RAM is written0: do not calculate (or stop calculating) CRC16 CCITT checksum when code RAM is written
 *     MICRO_CR_CRC_INIT Code RAM CRC16 CCITT checksum initializeWhen thes micro_cr_crc_init is set to 1'b1, it initialize CRC16 CCITT checksum to 16'hFFFF{micro_cr_crc_init, micro_cr_crc_calc_en}2'b1x   - initialize crc checksum to 16'hFFFF2'b01   - update/calculate CRC upon writes to the code RAM
 *     MICRO_CR_CRC_PRTSEL This field selects the Code RAM port to be used for CRC calculation0 - Select Port A1 - Select Port B
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r (0x0001d217 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RAM_CR_CRCCTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ram_cr_crcctl0[1];
	uint32_t _uc_rmi_ram_cr_crcctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_CLR(r) (r).uc_rmi_ram_cr_crcctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SET(r,d) (r).uc_rmi_ram_cr_crcctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_GET(r) (r).uc_rmi_ram_cr_crcctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET(r) ((((r).uc_rmi_ram_cr_crcctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET(r) ((((r).uc_rmi_ram_cr_crcctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET(r) (((r).uc_rmi_ram_cr_crcctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_RAM_CR_CRCCTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RAM_CR_CRCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RAM_CR_CRCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ram_cr_crcctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r
#define UC_RMI_RAM_CR_CRCCTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_t UC_RMI_RAM_CR_CRCCTL0r_t;
#define UC_RMI_RAM_CR_CRCCTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_CLR
#define UC_RMI_RAM_CR_CRCCTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SET
#define UC_RMI_RAM_CR_CRCCTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET
#define READ_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RAM_CR_CRCCTL0r
#define WRITE_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RAM_CR_CRCCTL0r
#define MODIFY_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RAM_CR_CRCCTL0r
#define READLN_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RAM_CR_CRCCTL0r
#define WRITELN_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RAM_CR_CRCCTL0r
#define WRITEALL_UC_RMI_RAM_CR_CRCCTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_RAM_CR_CRCSTS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd218
 * DEVAD:    1
 * DESC:     code ram crc status 0 register
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CR_CRC_CHECKSUM This field indicate the current crc16 ccitt checksum.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r (0x0001d218 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RAM_CR_CRCSTS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ram_cr_crcsts0[1];
	uint32_t _uc_rmi_ram_cr_crcsts0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_CLR(r) (r).uc_rmi_ram_cr_crcsts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SET(r,d) (r).uc_rmi_ram_cr_crcsts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_GET(r) (r).uc_rmi_ram_cr_crcsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET(r) (((r).uc_rmi_ram_cr_crcsts0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET(r,f) (r).uc_rmi_ram_cr_crcsts0[0]=(((r).uc_rmi_ram_cr_crcsts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RAM_CR_CRCSTS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RAM_CR_CRCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RAM_CR_CRCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ram_cr_crcsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r
#define UC_RMI_RAM_CR_CRCSTS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_t UC_RMI_RAM_CR_CRCSTS0r_t;
#define UC_RMI_RAM_CR_CRCSTS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_CLR
#define UC_RMI_RAM_CR_CRCSTS0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SET
#define UC_RMI_RAM_CR_CRCSTS0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_GET
#define UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET
#define UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET
#define READ_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_RAM_CR_CRCSTS0r
#define WRITE_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_RAM_CR_CRCSTS0r
#define MODIFY_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_RAM_CR_CRCSTS0r
#define READLN_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_RAM_CR_CRCSTS0r
#define WRITELN_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_RAM_CR_CRCSTS0r
#define WRITEALL_UC_RMI_RAM_CR_CRCSTS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_RAM_CR_CRCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_HARDFAULT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd219
 * DEVAD:    1
 * DESC:     micro hard fault control 0 register
 * RESETVAL: 0xe01 (3585)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_ERROR_INTR_EN Enable interrupt on IRQ2 when pmi_hp_error signal is asserted by RMICduring pmi_hp bus tranactions1 - Enable0 - Disable
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_EN Enable interrupt on IRQ2 when M0P performs 32-bit operations to access on pmi_hp busOnly 8/16-bits operations are allowed1 - Enable interrupt on IRQ20 - Disable
 *     MICRO_PMI_HP_ACK_TIMEOUT_INTR_EN Enable interrupt on IRQ2 when pmi_hp_ack signal timeout on the pmi_hp busdoes not toggle within 256 clock cycle1 - Enable0 - Disable
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_EN Enable interrupt on IRQ2 when M0P detects default slave error.Default slave error are detected when M0P attempted to access un-used address1 - Enable0 - Disable
 *     MICRO_PMI_HP_ERROR_HRESP_EN Enable HRESP hard fault signaling when pmi_hp_error signal is asserted by RMICduring pmi_hp bus tranactions1 - Enable0 - Disable
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_EN Enable HRESP hard fault signaling when M0P performs 32-bit operations to access on pmi_hp busOnly 8/16-bits operations are allowed1 - Enable interrupt on IRQ20 - Disable
 *     MICRO_PMI_HP_ACK_TIMEOUT_HRESP_EN Enable HRESP hard fault signaling  when pmi_hp_ack signal timeout on the pmi_hp busdoes not toggle within 256 clock cycle1 - Enable0 - Disable
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_EN Enable HRESP hard fault signaling when M0P detects default slave error.Default slave error are detected when M0P attempted to access un-used address1 - Enable0 - Disable
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r (0x0001d219 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_HARDFAULT_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_hardfault_ctl0[1];
	uint32_t _uc_rmi_uc_hardfault_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_CLR(r) (r).uc_rmi_uc_hardfault_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SET(r,d) (r).uc_rmi_uc_hardfault_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_GET(r) (r).uc_rmi_uc_hardfault_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET(r) (((r).uc_rmi_uc_hardfault_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_HARDFAULT_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_hardfault_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r
#define UC_RMI_UC_HARDFAULT_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_t UC_RMI_UC_HARDFAULT_CTL0r_t;
#define UC_RMI_UC_HARDFAULT_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_CLR
#define UC_RMI_UC_HARDFAULT_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET
#define READ_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITE_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_HARDFAULT_CTL0r
#define MODIFY_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_HARDFAULT_CTL0r
#define READLN_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITELN_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_HARDFAULT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_SDK_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21a
 * DEVAD:    1
 * DESC:     micro SDK status 0 register
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_UC_ACTIVE_0 Indicates if micro core 0 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_1 Indicates if micro core 1 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_2 Indicates if micro core 2 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_3 Indicates if micro core 3 is active1 - active0 - not active
 *     MICRO_NUM_UC_CORES Number of micro cores in the micro controller subsystemrange is 1 to 15
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r (0x0001d21a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_SDK_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_sdk_sts0[1];
	uint32_t _uc_rmi_uc_sdk_sts0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_CLR(r) (r).uc_rmi_uc_sdk_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_SET(r,d) (r).uc_rmi_uc_sdk_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_GET(r) (r).uc_rmi_uc_sdk_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 12) & 0xf)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET(r) (((r).uc_rmi_uc_sdk_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_SDK_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_SDK_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_SDK_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_sdk_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r
#define UC_RMI_UC_SDK_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_t UC_RMI_UC_SDK_STS0r_t;
#define UC_RMI_UC_SDK_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_CLR
#define UC_RMI_UC_SDK_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_SET
#define UC_RMI_UC_SDK_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET
#define READ_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_SDK_STS0r
#define WRITE_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_SDK_STS0r
#define MODIFY_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_SDK_STS0r
#define READLN_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_SDK_STS0r
#define WRITELN_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_SDK_STS0r
#define WRITEALL_UC_RMI_UC_SDK_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_SDK_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_SDK_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_ID_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21b
 * DEVAD:    1
 * DESC:     micro debugger id bits [15:0]
 * RESETVAL: 0x617f (24959)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DEBUGGER_ID_LSW micro debugger id bits [15:0]32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]}Where:micro core instance id[3:0]  = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_coresprtad_strap[4:0]             = external input, shared with mdio controller. Maps to bits [27:23]revid0[10:0]                 = revid0 bits [10:0]. Map bits[22:12]BRCM jtag ID[11:0]           = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits [11:0]
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr (0x0001d21b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_ID_LSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_id_lsw[1];
	uint32_t _uc_rmi_uc_dbgger_id_lsw;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_CLR(r) (r).uc_rmi_uc_dbgger_id_lsw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SET(r,d) (r).uc_rmi_uc_dbgger_id_lsw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_GET(r) (r).uc_rmi_uc_dbgger_id_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET(r) (((r).uc_rmi_uc_dbgger_id_lsw[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET(r,f) (r).uc_rmi_uc_dbgger_id_lsw[0]=(((r).uc_rmi_uc_dbgger_id_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_ID_LSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_id_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr
#define UC_RMI_UC_DBGGER_ID_LSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_t UC_RMI_UC_DBGGER_ID_LSWr_t;
#define UC_RMI_UC_DBGGER_ID_LSWr_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_CLR
#define UC_RMI_UC_DBGGER_ID_LSWr_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SET
#define UC_RMI_UC_DBGGER_ID_LSWr_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_GET
#define UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET
#define UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET
#define READ_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITE_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_LSWr
#define MODIFY_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_LSWr
#define READLN_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITELN_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_ID_MSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21c
 * DEVAD:    1
 * DESC:     micro debugger id bits [27:16]
 * RESETVAL: 0x36 (54)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DEBUGGER_ID_MSW micro debugger id bits [27:16]32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]}Where:micro core instance id[3:0]  = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_coresprtad_strap[4:0]             = external input, shared with mdio controller. Maps to bits [27:23]revid0[10:0]                 = revid0 bits [10:0]. Map bits[22:12]BRCM jtag ID[11:0]           = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits [11:0]Note: the default value assue prtad_strap = 5'd0
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr (0x0001d21c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_ID_MSW.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_id_msw[1];
	uint32_t _uc_rmi_uc_dbgger_id_msw;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_CLR(r) (r).uc_rmi_uc_dbgger_id_msw[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SET(r,d) (r).uc_rmi_uc_dbgger_id_msw[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_GET(r) (r).uc_rmi_uc_dbgger_id_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET(r) (((r).uc_rmi_uc_dbgger_id_msw[0]) & 0xfff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET(r,f) (r).uc_rmi_uc_dbgger_id_msw[0]=(((r).uc_rmi_uc_dbgger_id_msw[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_ID_MSW.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_id_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr
#define UC_RMI_UC_DBGGER_ID_MSWr_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_t UC_RMI_UC_DBGGER_ID_MSWr_t;
#define UC_RMI_UC_DBGGER_ID_MSWr_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_CLR
#define UC_RMI_UC_DBGGER_ID_MSWr_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SET
#define UC_RMI_UC_DBGGER_ID_MSWr_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_GET
#define UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET
#define UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET
#define READ_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITE_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_MSWr
#define MODIFY_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_MSWr
#define READLN_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITELN_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_ID_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_MISC_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21d
 * DEVAD:    1
 * DESC:     micro misc status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_MSB When the micro_autoinc_wraddr_en is set to 1, then{micro_ra_autoinc_nxt_wraddr_msb, micro_ra_autoinc_nxt_wraddr_lsw[15:0]}indicate address that will be used during the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *     MICRO_RA_AUTOINC_NXT_RDADDR_MSB When the micro_autoinc_rdaddr_en is set, then{micro_ra_autoinc_nxt_rdaddr_msb, micro_ra_autoinc_nxt_rdaddr_lsw[15:0]} indicate{address that will be used during the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *     MICRO_PR_AUTOINC_NXT_WRADDR_MSB When pram interface is used to write to the code/data RAMthen {micro_pr_autoinc_nxt_wraddr_msb, micro_pr_autoinc_nxt_wraddr_lsw[15:0]}indicate the address that will be used during the next write transaction.These bits allow address tracking
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r (0x0001d21d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MISC_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_misc_sts0[1];
	uint32_t _uc_rmi_uc_misc_sts0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_CLR(r) (r).uc_rmi_uc_misc_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_SET(r,d) (r).uc_rmi_uc_misc_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_GET(r) (r).uc_rmi_uc_misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET(r) ((((r).uc_rmi_uc_misc_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET(r) ((((r).uc_rmi_uc_misc_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET(r) (((r).uc_rmi_uc_misc_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_MISC_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_misc_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_misc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r
#define UC_RMI_UC_MISC_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_t UC_RMI_UC_MISC_STS0r_t;
#define UC_RMI_UC_MISC_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_CLR
#define UC_RMI_UC_MISC_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_SET
#define UC_RMI_UC_MISC_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET
#define READ_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MISC_STS0r
#define WRITE_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MISC_STS0r
#define MODIFY_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MISC_STS0r
#define READLN_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MISC_STS0r
#define WRITELN_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MISC_STS0r
#define WRITEALL_UC_RMI_UC_MISC_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MISC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21e
 * DEVAD:    1
 * DESC:     micro debugger control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DEBUGGER_ID_FRCVAL micro debugger id bits [27:20] force valueThe micro debugger has 32bit id. Bit 27 to 20 can be forced to different valueusing micro_debugger_id_frc and micro_debugger_id_frcval fields i.e.micro_debugger_id[31:28]  = micro core instance id[3:0], i.e. 0,1,2,3 .... 15micro_debugger_id[27:23]  = micro_debugger_id_frc ? micro_debugger_id_frcval[7:3] : prtad_strap[4:0];micro_debugger_id[22:20]  = micro_debugger_id_frc ? micro_debugger_id_frcval[2:0] : revid0[10:8]micro_debugger_id[19:12]  = revid0[7:0]micro_debugger_id[19:12]  = BRCM jtag ID[11:0]
 *     MICRO_DEBUGGER_ID_FRC micro debugger id force enablemicro_debugger_id_frc and micro_debugger_id_frcval are used to override portion of the micro debugger IDPlease note that the debugger ID should only be changed while all of the micro cores are in reset i.e.micro_master_rstb = 1'b0 to avoid any problems
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r (0x0001d21e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_ctl0[1];
	uint32_t _uc_rmi_uc_dbgger_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_CLR(r) (r).uc_rmi_uc_dbgger_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_SET(r,d) (r).uc_rmi_uc_dbgger_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_GET(r) (r).uc_rmi_uc_dbgger_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET(r) ((((r).uc_rmi_uc_dbgger_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET(r,f) (r).uc_rmi_uc_dbgger_ctl0[0]=(((r).uc_rmi_uc_dbgger_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET(r) (((r).uc_rmi_uc_dbgger_ctl0[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET(r,f) (r).uc_rmi_uc_dbgger_ctl0[0]=(((r).uc_rmi_uc_dbgger_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r
#define UC_RMI_UC_DBGGER_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_t UC_RMI_UC_DBGGER_CTL0r_t;
#define UC_RMI_UC_DBGGER_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_CLR
#define UC_RMI_UC_DBGGER_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_SET
#define UC_RMI_UC_DBGGER_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET
#define READ_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_DBGGER_CTL0r
#define WRITE_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_DBGGER_CTL0r
#define MODIFY_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_DBGGER_CTL0r
#define READLN_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_DBGGER_CTL0r
#define WRITELN_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_DBGGER_CTL0r
#define WRITEALL_UC_RMI_UC_DBGGER_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_DBGGER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_DBGGER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_ECCCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd220
 * DEVAD:    1
 * DESC:     ram ecc control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_ECCG_MODE ecc code generation mode for code RAM0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_CR_ECC_FRC_DISABLE ecc force disable for code RAM0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_CR_ECC_CORRUPT This field allows the ecc codes to be corrupted in code RAM for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the code/data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 *     MICRO_CR_ECC_DEBUG_PRTSEL The field selects the RAM port to used for ECC debug and software ECC mode:0 - Select Port A1 - Select Port BAssumptions:a.  Only one RAM (code or data) is used during ECC debug, thereforemicro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are sharedbetween Code and Data RAMb.  Only one port RAM (port A or port B) used during ECC debug, thereforemicro_cr_ecc_err_addr, micro_cr_ecc_corr_err, and micro_cr_ecc_corr_errfields are shared between Port A and Port B
 *     MICRO_DR_ECCG_MODE ecc code generation mode for data RAM0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_DR_ECC_FRC_DISABLE ecc force disable for data RAM0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_DR_ECC_CORRUPT This field allows the ecc codes to be corrupted in data RAM for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 *     MICRO_DR_ECC_DEBUG_PRTSEL The field selects the RAM port to used for ECC debug and software ECC mode:0 - Select Port A1 - Select Port BAssumptions:a.  Only one RAM (code or data) is used during ECC debug, thereforemicro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are sharedbetween Code and Data RAMb.  Only one port RAM (port A or port B) used during ECC debug, thereforemicro_dr_ecc_err_addr, micro_dr_ecc_corr_err, and micro_dr_ecc_corr_errfields are shared between Port A and Port B
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r (0x0001d220 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCCTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccctl0[1];
	uint32_t _uc_ram_eccctl0;
} BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_CLR(r) (r).uc_ram_eccctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_SET(r,d) (r).uc_ram_eccctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_GET(r) (r).uc_ram_eccctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 10) & 0x3)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 2) & 0x3)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET(r) (((r).uc_ram_eccctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_ECCCTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r
#define UC_RAM_ECCCTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_t UC_RAM_ECCCTL0r_t;
#define UC_RAM_ECCCTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_CLR
#define UC_RAM_ECCCTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_SET
#define UC_RAM_ECCCTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET
#define READ_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCCTL0r
#define WRITE_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCCTL0r
#define MODIFY_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCCTL0r
#define READLN_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCCTL0r
#define WRITELN_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCCTL0r
#define WRITEALL_UC_RAM_ECCCTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_ECCCTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd221
 * DEVAD:    1
 * DESC:     ram ecc control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_ECC_WRDATA This foield is used to write the ECC codes into the code/data RAM when ECC software modes is enabled
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r (0x0001d221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCCTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccctl1[1];
	uint32_t _uc_ram_eccctl1;
} BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_CLR(r) (r).uc_ram_eccctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_SET(r,d) (r).uc_ram_eccctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_GET(r) (r).uc_ram_eccctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET(r) (((r).uc_ram_eccctl1[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET(r,f) (r).uc_ram_eccctl1[0]=(((r).uc_ram_eccctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_ECCCTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCCTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCCTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r
#define UC_RAM_ECCCTL1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_t UC_RAM_ECCCTL1r_t;
#define UC_RAM_ECCCTL1r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_CLR
#define UC_RAM_ECCCTL1r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_SET
#define UC_RAM_ECCCTL1r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_GET
#define UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET
#define UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET
#define READ_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCCTL1r
#define WRITE_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCCTL1r
#define MODIFY_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCCTL1r
#define READLN_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCCTL1r
#define WRITELN_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCCTL1r
#define WRITEALL_UC_RAM_ECCCTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_ECCCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_ECCSTS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd222
 * DEVAD:    1
 * DESC:     ram ecc status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_CR_ECC_ADDRESS_STATUS First ecc error address detected in the Code RAM
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r (0x0001d222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts0[1];
	uint32_t _uc_ram_eccsts0;
} BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_CLR(r) (r).uc_ram_eccsts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_SET(r,d) (r).uc_ram_eccsts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_GET(r) (r).uc_ram_eccsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET(r) ((((r).uc_ram_eccsts0[0]) >> 2) & 0x3fff)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET(r,f) (r).uc_ram_eccsts0[0]=(((r).uc_ram_eccsts0[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_ECCSTS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r
#define UC_RAM_ECCSTS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_t UC_RAM_ECCSTS0r_t;
#define UC_RAM_ECCSTS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_CLR
#define UC_RAM_ECCSTS0r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_SET
#define UC_RAM_ECCSTS0r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_GET
#define UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET
#define UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET
#define READ_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS0r
#define WRITE_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS0r
#define MODIFY_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS0r
#define READLN_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS0r
#define WRITELN_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS0r
#define WRITEALL_UC_RAM_ECCSTS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_ECCSTS1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd223
 * DEVAD:    1
 * DESC:     ram ecc status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_ECC_RDDATA When the register interface is used to read code/data RAM, then this field providesECC codes currently stored in the code/data RAM
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r (0x0001d223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts1[1];
	uint32_t _uc_ram_eccsts1;
} BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_CLR(r) (r).uc_ram_eccsts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_SET(r,d) (r).uc_ram_eccsts1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_GET(r) (r).uc_ram_eccsts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET(r) (((r).uc_ram_eccsts1[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET(r,f) (r).uc_ram_eccsts1[0]=(((r).uc_ram_eccsts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_ECCSTS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r
#define UC_RAM_ECCSTS1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_t UC_RAM_ECCSTS1r_t;
#define UC_RAM_ECCSTS1r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_CLR
#define UC_RAM_ECCSTS1r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_SET
#define UC_RAM_ECCSTS1r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_GET
#define UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET
#define UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET
#define READ_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS1r
#define WRITE_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS1r
#define MODIFY_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS1r
#define READLN_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS1r
#define WRITELN_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS1r
#define WRITEALL_UC_RAM_ECCSTS1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_ECCSTS2
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd224
 * DEVAD:    1
 * DESC:     ram ecc status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_DR_ECC_ADDRESS_STATUS First ecc error address detected in the Data RAM
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r (0x0001d224 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts2[1];
	uint32_t _uc_ram_eccsts2;
} BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_CLR(r) (r).uc_ram_eccsts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_SET(r,d) (r).uc_ram_eccsts2[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_GET(r) (r).uc_ram_eccsts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET(r) ((((r).uc_ram_eccsts2[0]) >> 2) & 0x1fff)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET(r,f) (r).uc_ram_eccsts2[0]=(((r).uc_ram_eccsts2[0] & ~((uint32_t)0x1fff << 2)) | ((((uint32_t)f) & 0x1fff) << 2)) | (8191 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_ECCSTS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r
#define UC_RAM_ECCSTS2r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_t UC_RAM_ECCSTS2r_t;
#define UC_RAM_ECCSTS2r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_CLR
#define UC_RAM_ECCSTS2r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_SET
#define UC_RAM_ECCSTS2r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_GET
#define UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET
#define UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET
#define READ_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_ECCSTS2r
#define WRITE_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_ECCSTS2r
#define MODIFY_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_ECCSTS2r
#define READLN_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_ECCSTS2r
#define WRITELN_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_ECCSTS2r
#define WRITEALL_UC_RAM_ECCSTS2r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_ECCSTS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_ECCSTS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_TESTIFCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd225
 * DEVAD:    1
 * DESC:     ram test interface control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_TM      Code RAM Test Mode.These pins are used to put Code RAM the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r (0x0001d225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_TESTIFCTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_testifctl0[1];
	uint32_t _uc_ram_testifctl0;
} BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_CLR(r) (r).uc_ram_testifctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_SET(r,d) (r).uc_ram_testifctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_GET(r) (r).uc_ram_testifctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET(r) (((r).uc_ram_testifctl0[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET(r,f) (r).uc_ram_testifctl0[0]=(((r).uc_ram_testifctl0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access UC_RAM_TESTIFCTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_testifctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r
#define UC_RAM_TESTIFCTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_t UC_RAM_TESTIFCTL0r_t;
#define UC_RAM_TESTIFCTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_CLR
#define UC_RAM_TESTIFCTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_SET
#define UC_RAM_TESTIFCTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_GET
#define UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET
#define UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET
#define READ_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_TESTIFCTL0r
#define WRITE_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_TESTIFCTL0r
#define MODIFY_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_TESTIFCTL0r
#define READLN_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_TESTIFCTL0r
#define WRITELN_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_TESTIFCTL0r
#define WRITEALL_UC_RAM_TESTIFCTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_TESTIFCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_TESTIFCTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd226
 * DEVAD:    1
 * DESC:     ram test interface control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DR_TM      Data RAM Test Mode.These pins are used to put Code RAM the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r (0x0001d226 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_TESTIFCTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_testifctl1[1];
	uint32_t _uc_ram_testifctl1;
} BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_CLR(r) (r).uc_ram_testifctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_SET(r,d) (r).uc_ram_testifctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_GET(r) (r).uc_ram_testifctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET(r) (((r).uc_ram_testifctl1[0]) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET(r,f) (r).uc_ram_testifctl1[0]=(((r).uc_ram_testifctl1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access UC_RAM_TESTIFCTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_TESTIFCTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_TESTIFCTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_testifctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r
#define UC_RAM_TESTIFCTL1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_t UC_RAM_TESTIFCTL1r_t;
#define UC_RAM_TESTIFCTL1r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_CLR
#define UC_RAM_TESTIFCTL1r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_SET
#define UC_RAM_TESTIFCTL1r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_GET
#define UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET
#define UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET
#define READ_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_TESTIFCTL1r
#define WRITE_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_TESTIFCTL1r
#define MODIFY_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_TESTIFCTL1r
#define READLN_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_TESTIFCTL1r
#define WRITELN_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_TESTIFCTL1r
#define WRITEALL_UC_RAM_TESTIFCTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_TESTIFCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_TESTIFCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd227
 * DEVAD:    1
 * DESC:     ram configuration register 0
 * RESETVAL: 0x8382 (33666)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_ACCESS_EN Code RAM access enable0 - Disabled. RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMThe API software should clear this field before loading the firmware and also re-starting the micro1 - Enabled.
 *     MICRO_CR_IGNORE_MICRO_CODE_WRITES Code RAM ignore micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 *     MICRO_CR_RAIF_PRTSEL Selects Code RAM Port to used when accessing the memory through the register interface0 - Port A1 - Port B
 *     MICRO_CR_PRIF_PRTSEL Selects Code RAM Port to used when writing memory through the PRAM interface0 - Port A1 - Port B
 *     MICRO_CR_LOWPOWER_EN Code RAM low power enable1 - Enabled. Gate of the chip select to the Code RAM when memory is not being acccessed to save dynamic power(i.e. mem_cs = ~rg_cr_lowpower_en & rg_master_rstb & rg_cr_access_en).0 - Disabled
 *     MICRO_DR_ACCESS_EN Data RAM access enable0 - Disabled. RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMThe API software should clear this field before loading the firmware and also re-starting the micro1 - Enabled.
 *     MICRO_DR_IGNORE_MICRO_CODE_WRITES Data RAM ignore micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 *     MICRO_DR_RAIF_PRTSEL Selects Data RAM Port to used when accessing the memory through the register interface0 - Port A1 - Port B
 *     MICRO_DR_PRIF_PRTSEL Selects Data RAM Port to used when writing memory through the PRAM interface0 - Port A1 - Port B
 *     MICRO_DR_LOWPOWER_EN Data RAM low power enable1 - Enabled. Gate of the chip select to the Data RAM when memory is not being acccessed to save dynamic power(i.e. mem_cs = ~rg_dr_lowpower_en & rg_master_rstb & rg_dr_access_en).0 - Disabled
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r (0x0001d227 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl0[1];
	uint32_t _uc_ram_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_CLR(r) (r).uc_ram_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_SET(r,d) (r).uc_ram_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_GET(r) (r).uc_ram_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 7) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET(r) (((r).uc_ram_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r
#define UC_RAM_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_t UC_RAM_CTL0r_t;
#define UC_RAM_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_CLR
#define UC_RAM_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_SET
#define UC_RAM_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_GET
#define UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET
#define UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET
#define UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET
#define UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET
#define UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET
#define UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET
#define READ_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL0r
#define WRITE_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL0r
#define MODIFY_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL0r
#define READLN_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL0r
#define WRITELN_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL0r
#define WRITEALL_UC_RAM_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_CTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd228
 * DEVAD:    1
 * DESC:     ram configuration register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_DATA_SIZE Code RAM - allocation for data storgaeThe CODE_RAM_SIZE=64KB and this field is used to allocate code RAM for data storgae on a 1KB granualarity7'd0  : code RAM allocation for data = 0KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd1  : code RAM allocation for data = 1KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd2  : code RAM allocation for data = 2KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data...   : code RAM allocation for data = .. ,  code RAM allocation for code = .....   : code RAM allocation for data = .. ,  code RAM allocation for code = ..7'd63 : code RAM allocation for data = 63KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd64 : code RAM allocation for data = 64KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data
 *     MICRO_DR_CODE_SIZE Data RAM - allocation for code storgaeThe DATA_RAM_SIZE=32KB and this field is used to allocate data RAM for code storgae on a 1KB granualarity7'd0  : data RAM allocation for code = 0KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd1  : data RAM allocation for code = 1KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd2  : data RAM allocation for code = 2KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code...   : data RAM allocation for code = .. ,  data RAM allocation for data = .....   : data RAM allocation for code = .. ,  data RAM allocation for data = ..7'd31 : data RAM allocation for code = 31KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd32 : data RAM allocation for code = 32KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r (0x0001d228 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl1[1];
	uint32_t _uc_ram_ctl1;
} BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_CLR(r) (r).uc_ram_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_SET(r,d) (r).uc_ram_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_GET(r) (r).uc_ram_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET(r) ((((r).uc_ram_ctl1[0]) >> 8) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET(r,f) (r).uc_ram_ctl1[0]=(((r).uc_ram_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET(r) (((r).uc_ram_ctl1[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET(r,f) (r).uc_ram_ctl1[0]=(((r).uc_ram_ctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r
#define UC_RAM_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_t UC_RAM_CTL1r_t;
#define UC_RAM_CTL1r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_CLR
#define UC_RAM_CTL1r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_SET
#define UC_RAM_CTL1r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_GET
#define UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET
#define UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET
#define UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET
#define UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET
#define READ_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL1r
#define WRITE_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL1r
#define MODIFY_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL1r
#define READLN_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL1r
#define WRITELN_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL1r
#define WRITEALL_UC_RAM_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd229
 * DEVAD:    1
 * DESC:     rmi external interrupt control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_CR_ECC_CORR_ERR_INTR_EN Code RAM ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_EN Code RAM ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_EN Code RAM ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_CORR_ERR_INTR_EN Data RAM ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_EN Data RAM ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_EN Data RAM ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0P_LOCKUP_INTR_EN M0P lockup interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0p_lockup_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_EN M0P systemresetreq interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_MBOX_MSGOUT_INTR_EN Mailbox memssage out Interrupt EnableWhen this field is set to 1'b1 then the micro_rmi_mbox_msgout_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r (0x0001d229 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_ctl0[1];
	uint32_t _uc_rmi_ext_intr_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR(r) (r).uc_rmi_ext_intr_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_SET(r,d) (r).uc_rmi_ext_intr_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_GET(r) (r).uc_rmi_ext_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET(r) (((r).uc_rmi_ext_intr_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r
#define UC_RMI_EXT_INTR_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_t UC_RMI_EXT_INTR_CTL0r_t;
#define UC_RMI_EXT_INTR_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR
#define UC_RMI_EXT_INTR_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_SET
#define UC_RMI_EXT_INTR_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET
#define READ_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_EXT_INTR_CTL0r
#define WRITE_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r
#define MODIFY_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r
#define READLN_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r
#define WRITELN_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r
#define WRITEALL_UC_RMI_EXT_INTR_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22a
 * DEVAD:    1
 * DESC:     rmi external interrupt status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_CR_ECC_CORR_ERR_STATUS Code RAM ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_CR_ECC_UNCORR_ERR_STATUS Code RAM ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUS Code RAM ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_CORR_ERR_STATUS Data RAM ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_UNCORR_ERR_STATUS Data RAM ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUS Data RAM ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_M0P_LOCKUP_STATUS_OR This is logic OR of the M0P lockup status from all micro cores in the designThis field is set to 1'b1 when any of the M0P "lockup" signal is set to 1'b1It will remain set until M0P "lockup" signal from all M0P cores are zero andm0p_lockup_status field for all micro cores are zero
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_OR This is logic OR of the M0P systemresetreq status field from all micro cores in the designThis field is set to 1'b1 when any of the M0P cores "systemresetreq" signal is set to 1'b 1It will remain set until "systemresetreq" signals from all M0P cores are zero andsystemresetreq status field for all micro cores are zero
 *     MICRO_RMI_MBOX_MSGOUT_STATUS_OR This is logic OR of the mbox_msgout_status field from all micro cores in the designIt will remain set until "mbox_msgout_status" field for all micro cores are zero
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r (0x0001d22a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_sts0[1];
	uint32_t _uc_rmi_ext_intr_sts0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_CLR(r) (r).uc_rmi_ext_intr_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_SET(r,d) (r).uc_rmi_ext_intr_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_GET(r) (r).uc_rmi_ext_intr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET(r) (((r).uc_rmi_ext_intr_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r
#define UC_RMI_EXT_INTR_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_t UC_RMI_EXT_INTR_STS0r_t;
#define UC_RMI_EXT_INTR_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_CLR
#define UC_RMI_EXT_INTR_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_SET
#define UC_RMI_EXT_INTR_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET
#define READ_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_EXT_INTR_STS0r
#define WRITE_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r
#define MODIFY_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r
#define READLN_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_EXT_INTR_STS0r
#define WRITELN_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r
#define WRITEALL_UC_RMI_EXT_INTR_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_EXT_INTR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_PMI_IF_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22b
 * DEVAD:    1
 * DESC:     pmi interface control register 0
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_FAST_READ_EN pmi hp interface fast read enable1 - use pmi_hp_read_vld during read0 - use pmi_hp_ack during read
 *     MICRO_PMI_HP_FAST_BKTOBK_EN pmi hp interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r (0x0001d22b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PMI_IF_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pmi_if_ctl0[1];
	uint32_t _uc_rmi_pmi_if_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_CLR(r) (r).uc_rmi_pmi_if_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_SET(r,d) (r).uc_rmi_pmi_if_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_GET(r) (r).uc_rmi_pmi_if_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET(r) (((r).uc_rmi_pmi_if_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_PMI_IF_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pmi_if_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r
#define UC_RMI_PMI_IF_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_t UC_RMI_PMI_IF_CTL0r_t;
#define UC_RMI_PMI_IF_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_CLR
#define UC_RMI_PMI_IF_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_SET
#define UC_RMI_PMI_IF_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET
#define READ_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_PMI_IF_CTL0r
#define WRITE_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r
#define MODIFY_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r
#define READLN_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_PMI_IF_CTL0r
#define WRITELN_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r
#define WRITEALL_UC_RMI_PMI_IF_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_PMI_IF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22c
 * DEVAD:    1
 * DESC:     Silicon debug control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUX_SEL This field is used to select the data to be muxed to rmi_silicon_debug_status0 registers0 - register interface - {5'd0, init_req,  wraddr_changed,  write_req,rdaddr_changed, read_req, ra_state[1:0],1'b0, ra_his_state[2:0]}1 - pram interface     - {1'b0, pif_state_status[1:0], pif_his_state_status[3:0],pr_hready, pr_dr_chipsel, pr_cr_chipsel, pr_state[1:0], 1'b0,pr_his_state[2:0]};2 - pmi_hp interface of micro_core 0  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}3 - pmi_hp interface of micro_core 1  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}4 - pmi_hp interface of micro_core 2  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}5 - pmi_hp interface of micro_core 3  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r (0x0001d22c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_ctl0[1];
	uint32_t _uc_rmi_silicon_dbg_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR(r) (r).uc_rmi_silicon_dbg_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET(r,d) (r).uc_rmi_silicon_dbg_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET(r) (r).uc_rmi_silicon_dbg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET(r) (((r).uc_rmi_silicon_dbg_ctl0[0]) & 0x7)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET(r,f) (r).uc_rmi_silicon_dbg_ctl0[0]=(((r).uc_rmi_silicon_dbg_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r
#define UC_RMI_SILICON_DBG_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_t UC_RMI_SILICON_DBG_CTL0r_t;
#define UC_RMI_SILICON_DBG_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR
#define UC_RMI_SILICON_DBG_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET
#define UC_RMI_SILICON_DBG_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET
#define READ_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r
#define WRITE_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r
#define MODIFY_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r
#define READLN_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r
#define WRITELN_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r
#define WRITEALL_UC_RMI_SILICON_DBG_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22d
 * DEVAD:    1
 * DESC:     Silicon debug status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUXED_DATA Muxed status data is made avaialable on this field.micro_silicon_debug_status_mux_sel is used to select the data source
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r (0x0001d22d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_sts0[1];
	uint32_t _uc_rmi_silicon_dbg_sts0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR(r) (r).uc_rmi_silicon_dbg_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_SET(r,d) (r).uc_rmi_silicon_dbg_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_GET(r) (r).uc_rmi_silicon_dbg_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET(r) (((r).uc_rmi_silicon_dbg_sts0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET(r,f) (r).uc_rmi_silicon_dbg_sts0[0]=(((r).uc_rmi_silicon_dbg_sts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r
#define UC_RMI_SILICON_DBG_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_t UC_RMI_SILICON_DBG_STS0r_t;
#define UC_RMI_SILICON_DBG_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR
#define UC_RMI_SILICON_DBG_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_SET
#define UC_RMI_SILICON_DBG_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET
#define READ_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_SILICON_DBG_STS0r
#define WRITE_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r
#define MODIFY_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r
#define READLN_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r
#define WRITELN_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r
#define WRITEALL_UC_RMI_SILICON_DBG_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_SILICON_DBG_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RAM_CTL2
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22e
 * DEVAD:    1
 * DESC:     ram configuration register 2
 * RESETVAL: 0x8400 (33792)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_STACK_SIZE Micro Core Stack SizeThis field is used to set the stack size for a micro core on a 4 byte granualarity.All of the micro cores (Cortex-M0P) use the same stack size. The total amount ofmemory allocated for stack = number of cores * micro_core_stack_size.For 32K Data RAM, limiting the stack size to 8K.
 *     MICRO_CORE_STACK_EN Micro Core Stack Enable1 - Enabled (default) - perform logical to physical address mapping un the data RAM for stack0 - Disabled
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r (0x0001d22e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl2[1];
	uint32_t _uc_ram_ctl2;
} BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_CLR(r) (r).uc_ram_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_SET(r,d) (r).uc_ram_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_GET(r) (r).uc_ram_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET(r) ((((r).uc_ram_ctl2[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET(r,f) (r).uc_ram_ctl2[0]=(((r).uc_ram_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET(r) ((((r).uc_ram_ctl2[0]) >> 2) & 0xfff)
#define BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET(r,f) (r).uc_ram_ctl2[0]=(((r).uc_ram_ctl2[0] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2)) | (4095 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r
#define UC_RAM_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_t UC_RAM_CTL2r_t;
#define UC_RAM_CTL2r_CLR BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_CLR
#define UC_RAM_CTL2r_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_SET
#define UC_RAM_CTL2r_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET
#define READ_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_READ_UC_RAM_CTL2r
#define WRITE_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_UC_RAM_CTL2r
#define MODIFY_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RAM_CTL2r
#define READLN_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_READLN_UC_RAM_CTL2r
#define WRITELN_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RAM_CTL2r
#define WRITEALL_UC_RAM_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RAM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RAM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL0
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd230
 * DEVAD:    1
 * DESC:     micro message control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG0       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r (0x0001d230 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl0[1];
	uint32_t _uc_rmi_uc_msg_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_CLR(r) (r).uc_rmi_uc_msg_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_SET(r,d) (r).uc_rmi_uc_msg_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_GET(r) (r).uc_rmi_uc_msg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET(r) (((r).uc_rmi_uc_msg_ctl0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET(r,f) (r).uc_rmi_uc_msg_ctl0[0]=(((r).uc_rmi_uc_msg_ctl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r
#define UC_RMI_UC_MSG_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_t UC_RMI_UC_MSG_CTL0r_t;
#define UC_RMI_UC_MSG_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_CLR
#define UC_RMI_UC_MSG_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_SET
#define UC_RMI_UC_MSG_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_GET
#define UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET
#define UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET
#define READ_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL0r
#define WRITE_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL0r
#define MODIFY_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL0r
#define READLN_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL0r
#define WRITELN_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL0r
#define WRITEALL_UC_RMI_UC_MSG_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL1
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd231
 * DEVAD:    1
 * DESC:     micro message control register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG1       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r (0x0001d231 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl1[1];
	uint32_t _uc_rmi_uc_msg_ctl1;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_CLR(r) (r).uc_rmi_uc_msg_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_SET(r,d) (r).uc_rmi_uc_msg_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_GET(r) (r).uc_rmi_uc_msg_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET(r) (((r).uc_rmi_uc_msg_ctl1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET(r,f) (r).uc_rmi_uc_msg_ctl1[0]=(((r).uc_rmi_uc_msg_ctl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r
#define UC_RMI_UC_MSG_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_t UC_RMI_UC_MSG_CTL1r_t;
#define UC_RMI_UC_MSG_CTL1r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_CLR
#define UC_RMI_UC_MSG_CTL1r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_SET
#define UC_RMI_UC_MSG_CTL1r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_GET
#define UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET
#define UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET
#define READ_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL1r
#define WRITE_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL1r
#define MODIFY_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL1r
#define READLN_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL1r
#define WRITELN_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL1r
#define WRITEALL_UC_RMI_UC_MSG_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL2
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd232
 * DEVAD:    1
 * DESC:     micro message control register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG2       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r (0x0001d232 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl2[1];
	uint32_t _uc_rmi_uc_msg_ctl2;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_CLR(r) (r).uc_rmi_uc_msg_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_SET(r,d) (r).uc_rmi_uc_msg_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_GET(r) (r).uc_rmi_uc_msg_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET(r) (((r).uc_rmi_uc_msg_ctl2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET(r,f) (r).uc_rmi_uc_msg_ctl2[0]=(((r).uc_rmi_uc_msg_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r
#define UC_RMI_UC_MSG_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_t UC_RMI_UC_MSG_CTL2r_t;
#define UC_RMI_UC_MSG_CTL2r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_CLR
#define UC_RMI_UC_MSG_CTL2r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_SET
#define UC_RMI_UC_MSG_CTL2r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_GET
#define UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET
#define UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET
#define READ_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL2r
#define WRITE_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL2r
#define MODIFY_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL2r
#define READLN_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL2r
#define WRITELN_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL2r
#define WRITEALL_UC_RMI_UC_MSG_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL3
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd233
 * DEVAD:    1
 * DESC:     micro message control register 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG3       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r (0x0001d233 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl3[1];
	uint32_t _uc_rmi_uc_msg_ctl3;
} BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_CLR(r) (r).uc_rmi_uc_msg_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_SET(r,d) (r).uc_rmi_uc_msg_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_GET(r) (r).uc_rmi_uc_msg_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET(r) (((r).uc_rmi_uc_msg_ctl3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET(r,f) (r).uc_rmi_uc_msg_ctl3[0]=(((r).uc_rmi_uc_msg_ctl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r
#define UC_RMI_UC_MSG_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_t UC_RMI_UC_MSG_CTL3r_t;
#define UC_RMI_UC_MSG_CTL3r_CLR BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_CLR
#define UC_RMI_UC_MSG_CTL3r_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_SET
#define UC_RMI_UC_MSG_CTL3r_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_GET
#define UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET
#define UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET
#define READ_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_READ_UC_RMI_UC_MSG_CTL3r
#define WRITE_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_UC_RMI_UC_MSG_CTL3r
#define MODIFY_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_UC_RMI_UC_MSG_CTL3r
#define READLN_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_READLN_UC_RMI_UC_MSG_CTL3r
#define WRITELN_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_UC_RMI_UC_MSG_CTL3r
#define WRITEALL_UC_RMI_UC_MSG_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_RMI_UC_MSG_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_CLK_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd240
 * DEVAD:    1
 * DESC:     micro core clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CLK_EN micro core clock enable for core:While the micro-code is being loaded into the code RAM, the clock tomicro_core is normally disabled and a reset is asserted0 - disabled1 - enables
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r (0x0001d240 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CLK_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_clk_ctl0[1];
	uint32_t _uc_uc_core_clk_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_CLR(r) (r).uc_uc_core_clk_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_SET(r,d) (r).uc_uc_core_clk_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_GET(r) (r).uc_uc_core_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET(r) (((r).uc_uc_core_clk_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET(r,f) (r).uc_uc_core_clk_ctl0[0]=(((r).uc_uc_core_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_CLK_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_clk_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r
#define UC_UC_CORE_CLK_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_t UC_UC_CORE_CLK_CTL0r_t;
#define UC_UC_CORE_CLK_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_CLR
#define UC_UC_CORE_CLK_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_SET
#define UC_UC_CORE_CLK_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_GET
#define UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET
#define UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET
#define READ_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CLK_CTL0r
#define WRITE_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CLK_CTL0r
#define MODIFY_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CLK_CTL0r
#define READLN_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CLK_CTL0r
#define WRITELN_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CLK_CTL0r
#define WRITEALL_UC_UC_CORE_CLK_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_RST_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd241
 * DEVAD:    1
 * DESC:     micro core reset control registers 0
 * RESETVAL: 0xc000 (49152)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_RSTB  micro core reset for core:While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted.Setting this field to 1'b1 de-asserts a reset to the micro.0 - disabled1 - enables
 *     MICRO_DAP_PORESET_S_RSTB micro core dap software por reset:A reset on the M0P DAP PORESET pin is asserted when:1) pmd_por_h_rstb pin = 0 (upon power-on) OR2) micro_dap_poreset_s_rstb register filed = 0 (software reset)0 - asserted1 - de-asserted
 *     MICRO_SW_PMI_HP_RSTB Software reset pmi_hp interface logicThis bit is to initialize the pmi_hp block0 - reset asserted1 - reset de-asserted
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r (0x0001d241 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_RST_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_rst_ctl0[1];
	uint32_t _uc_uc_core_rst_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_CLR(r) (r).uc_uc_core_rst_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_SET(r,d) (r).uc_uc_core_rst_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_GET(r) (r).uc_uc_core_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET(r) ((((r).uc_uc_core_rst_ctl0[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET(r) ((((r).uc_uc_core_rst_ctl0[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET(r) (((r).uc_uc_core_rst_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_RST_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_rst_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r
#define UC_UC_CORE_RST_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_t UC_UC_CORE_RST_CTL0r_t;
#define UC_UC_CORE_RST_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_CLR
#define UC_UC_CORE_RST_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_SET
#define UC_UC_CORE_RST_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET
#define UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET
#define UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET
#define READ_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_RST_CTL0r
#define WRITE_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_RST_CTL0r
#define MODIFY_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_RST_CTL0r
#define READLN_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_RST_CTL0r
#define WRITELN_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_RST_CTL0r
#define WRITEALL_UC_UC_CORE_RST_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_STS0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd242
 * DEVAD:    1
 * DESC:     rmi micro core status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PMI_HP_ERROR_STATUS pmi_hp_error signal statusThis field is set when pmi_hp_error signal is asserted by RMIC during pmi_hp bus tranactionsThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_STATUS This field is set when 32-bit operation is perform to generate transations on the pmi_hp busOnly 8/16-bits operations are allowedThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_PMI_HP_ACK_TIMEOUT_STATUS This field is set when pmi_hp_ack signal on the pmi_hp bus does not toggle within 256 clock cycleThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUS m0p default slave error detected. M0P attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r (0x0001d242 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts0[1];
	uint32_t _uc_uc_core_sts0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_CLR(r) (r).uc_uc_core_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_SET(r,d) (r).uc_uc_core_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_GET(r) (r).uc_uc_core_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET(r) (((r).uc_uc_core_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r
#define UC_UC_CORE_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_t UC_UC_CORE_STS0r_t;
#define UC_UC_CORE_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_CLR
#define UC_UC_CORE_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_SET
#define UC_UC_CORE_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_GET
#define UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET
#define READ_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS0r
#define WRITE_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS0r
#define MODIFY_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS0r
#define READLN_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS0r
#define WRITELN_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS0r
#define WRITEALL_UC_UC_CORE_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd243
 * DEVAD:    1
 * DESC:     rmi micro core control register 0
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_LN_SEL This field indicates lanes that are selected for micro_corePLEASE NOTE:The default value of this register field for each micro core is unique.the default values are:micro core 0 - 8'h3micro core 1 - 8'hCmicro core 2 - 8'h30micro core 3 - 8'hC0
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r (0x0001d243 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_ctl0[1];
	uint32_t _uc_uc_core_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_CLR(r) (r).uc_uc_core_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_SET(r,d) (r).uc_uc_core_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_GET(r) (r).uc_uc_core_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET(r) (((r).uc_uc_core_ctl0[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET(r,f) (r).uc_uc_core_ctl0[0]=(((r).uc_uc_core_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r
#define UC_UC_CORE_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_t UC_UC_CORE_CTL0r_t;
#define UC_UC_CORE_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_CLR
#define UC_UC_CORE_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_SET
#define UC_UC_CORE_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_GET
#define UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET
#define UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET
#define READ_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CTL0r
#define WRITE_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CTL0r
#define MODIFY_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CTL0r
#define READLN_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CTL0r
#define WRITELN_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CTL0r
#define WRITEALL_UC_UC_CORE_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_MBOX_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd244
 * DEVAD:    1
 * DESC:     rmi micro core mail box control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MBOX_MSGIN_INTR mailbox message in interrupt for microSet by the MDIO/PMI_LP, cleared by the micro via PMI HPDrive the micro interrupt pin
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r (0x0001d244 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_MBOX_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_mbox_ctl0[1];
	uint32_t _uc_uc_core_mbox_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_CLR(r) (r).uc_uc_core_mbox_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_SET(r,d) (r).uc_uc_core_mbox_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_GET(r) (r).uc_uc_core_mbox_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET(r) (((r).uc_uc_core_mbox_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET(r,f) (r).uc_uc_core_mbox_ctl0[0]=(((r).uc_uc_core_mbox_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_MBOX_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_MBOX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_mbox_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_MBOX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_mbox_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_mbox_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r
#define UC_UC_CORE_MBOX_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_t UC_UC_CORE_MBOX_CTL0r_t;
#define UC_UC_CORE_MBOX_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_CLR
#define UC_UC_CORE_MBOX_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_SET
#define UC_UC_CORE_MBOX_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_GET
#define UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET
#define UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET
#define READ_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_MBOX_CTL0r
#define WRITE_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_MBOX_CTL0r
#define MODIFY_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_MBOX_CTL0r
#define READLN_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_MBOX_CTL0r
#define WRITELN_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_MBOX_CTL0r
#define WRITEALL_UC_UC_CORE_MBOX_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_MBOX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_MBOX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_LOW_PWR_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd245
 * DEVAD:    1
 * DESC:     rmi micro core low power control register 0
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_WICENREQ   WIC-based Deep Sleep request for micro core1 - request for Deep Sleep0 - no request
 *     MICRO_SLEEPHOLDREQ_N Request to extend the processor sleeping state regardlessof wake-up events. If the processor acknowledges this requestdriving m0p_sleepholdack_n LOW, this guarantees the processorremains idle even on receipt of a wake-up event.This is used to safely shutdown the micro_core0 - request to extend deep sleep state1 - no request
 *     MICRO_M0P_GCLK_FRCVAL M0P core clock gate force valueThe clock to the M0P cores can be gated of in the low power modeusing GATEHCLK signals for M0P core. The micro_m0p_gclk_frc andmicro_m0p_gclk_frcval provides a mechanism override the clock gating{micro_m0p_gclk_frc, micro_m0p_gclk_frcval}2'b11 - GATEHCLK ignored. Clock gate bypass (default)2'b10 - GATEHCLK ignored. M0P hclk clock gated off2'b0X - GATEHCLK used to gate M0P hclk clock
 *     MICRO_M0P_GCLK_FRC M0P core clock gate force enableThe clock to the M0P core can be gated of in the low power modeusing GATEHCLK signals for M0P core. The micro_m0p_gclk_frc andmicro_m0p_gclk_frcval provides a mechanism override the clock gating{micro_m0p_gclk_frc, micro_m0p_gclk_frcval}2'b11 - GATEHCLK ignored. Clock gate bypass (default)2'b10 - GATEHCLK ignored. M0P hclk clock gated off2'b0X - GATEHCLK used to gate M0P hclk clock
 *     MICRO_M0P_WAKEUP M0P core wakeupThis is self-clearing field. When this set 1, it generate a pulseon the M0P core RXEV pin to wakeup M0P from WFE sleep state
 *     MICRO_DP_RCLK20_RST_WAKEUP_EN M0P core - Enable wakeup event upon detecting a change on the lane dp_rclk20_rstWhen this is set 1, and any bits in the micro_dp_rclk20_rst_status_LH are setthen M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state
 *     MICRO_PMD_SIGNAL_DETECT_WAKEUP_EN M0P core - Enable wakeup event upon detecting a change on the lane pmd_signal_detectWhen this is set 1, and any bits in the micro_pmd_signal_detect_status_LH are setthen M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r (0x0001d245 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_LOW_PWR_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_low_pwr_ctl0[1];
	uint32_t _uc_uc_core_low_pwr_ctl0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_CLR(r) (r).uc_uc_core_low_pwr_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SET(r,d) (r).uc_uc_core_low_pwr_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_GET(r) (r).uc_uc_core_low_pwr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET(r) (((r).uc_uc_core_low_pwr_ctl0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_LOW_PWR_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_low_pwr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r
#define UC_UC_CORE_LOW_PWR_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_t UC_UC_CORE_LOW_PWR_CTL0r_t;
#define UC_UC_CORE_LOW_PWR_CTL0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_CLR
#define UC_UC_CORE_LOW_PWR_CTL0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET
#define READ_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITE_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_LOW_PWR_CTL0r
#define MODIFY_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_CTL0r
#define READLN_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITELN_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_LOW_PWR_STS0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd246
 * DEVAD:    1
 * DESC:     rmi micro core low power status register 0
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_WICENACK   Active HIGH acknowledge signal for micro_wicenreq1 - Acknowledge0 - none
 *     MICRO_SLEEPHOLDACK_N Response to micro_sleepholdreq_n.If this signal is LOW, irrespective of the micro_sleepingsignal value, the processor does not advance in executionand does not perform any memory operations. This is used tosafely shutdown the micro_core0 - Acknowledge1 - none
 *     MICRO_SLEEPING   for micro1 - indicates the processor is idle, waiting for an interrupton the IRQ or internal SysTick.0 - indicates that the processor is running or wants to leave sleep modeIf micro_sleepholdack_n is 0, then the processordoes not perform any fetches until micro_sleepholdreq_n is 1
 *     MICRO_SLEEPDEEP  Active only when micro_sleeping is 1Indicates that the SLEEPDEEP bit in the NVIC is set to 1
 *     MICRO_SLEEPING_LH Latch high sleeping. This field is set to 1'b1 when micro_sleeping is 1It will remain set until micro_sleeping is set to 0 andand this register is readclear-on-read
 *     MICRO_SLEEPDEEP_LH Latch high sleepdeep. This field is set to 1'b1 when micro_sleepdeep is 1It will remain set until micro_sleepdeep is set to 0 andand this register is readclear-on-read
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r (0x0001d246 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_LOW_PWR_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_low_pwr_sts0[1];
	uint32_t _uc_uc_core_low_pwr_sts0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_CLR(r) (r).uc_uc_core_low_pwr_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SET(r,d) (r).uc_uc_core_low_pwr_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_GET(r) (r).uc_uc_core_low_pwr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET(r) (((r).uc_uc_core_low_pwr_sts0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_LOW_PWR_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_LOW_PWR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_low_pwr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r
#define UC_UC_CORE_LOW_PWR_STS0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_t UC_UC_CORE_LOW_PWR_STS0r_t;
#define UC_UC_CORE_LOW_PWR_STS0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_CLR
#define UC_UC_CORE_LOW_PWR_STS0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SET
#define UC_UC_CORE_LOW_PWR_STS0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET
#define READ_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_LOW_PWR_STS0r
#define WRITE_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_LOW_PWR_STS0r
#define MODIFY_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_STS0r
#define READLN_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_LOW_PWR_STS0r
#define WRITELN_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_STS0r
#define WRITEALL_UC_UC_CORE_LOW_PWR_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_LOW_PWR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_STS1
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd247
 * DEVAD:    1
 * DESC:     rmi micro core status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_M0P_LOCKUP_STATUS M0P lockup statusThis field is set to 1'b1 when M0P "lockup" signal is set to 1'b1 to indicate lockupIt will remain set until M0P "lockup" signal goes to 1'b0 and this filed is read
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS M0P systemresetreq statusThis field is set to 1'b1 when M0P "systemresetreq" signal is set to 1'b1It will remain set until systemresetreq is set to 1'b0 and this field is read
 *     MICRO_RMI_MBOX_MSGOUT_STATUS mailbox message out statusThis field is set to 1'b1 when the firmware set the ahbcommon_mbox_send_msgout to 1'b1to send a message outIt will remain set until this field is read
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r (0x0001d247 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts1[1];
	uint32_t _uc_uc_core_sts1;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_CLR(r) (r).uc_uc_core_sts1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_SET(r,d) (r).uc_uc_core_sts1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_GET(r) (r).uc_uc_core_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET(r) ((((r).uc_uc_core_sts1[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET(r) ((((r).uc_uc_core_sts1[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET(r) (((r).uc_uc_core_sts1[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r
#define UC_UC_CORE_STS1r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_t UC_UC_CORE_STS1r_t;
#define UC_UC_CORE_STS1r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_CLR
#define UC_UC_CORE_STS1r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_SET
#define UC_UC_CORE_STS1r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET
#define READ_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS1r
#define WRITE_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS1r
#define MODIFY_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS1r
#define READLN_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS1r
#define WRITELN_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS1r
#define WRITEALL_UC_UC_CORE_STS1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_STS2
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd248
 * DEVAD:    1
 * DESC:     rmi micro core status register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DP_RCLK20_RST_STATUS_LH Indicatees a change on rx lane datapath reset detected1 - change detected. This can be used to  generate wake-up eventif micro_dp_rclk20_rst_wakeup_en is set to 1'b10 - no changesclear-on-read
 *     MICRO_PMD_SIGNAL_DETECT_STATUS_LH Indicates a changes lane pmd_signal_detect detected1 - change detected. This can be used to  generate wake-up eventif micro_pmd_signal_detect_wakeup_en is set to 1'b10 - no changesclear-on-read
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r (0x0001d248 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts2[1];
	uint32_t _uc_uc_core_sts2;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_CLR(r) (r).uc_uc_core_sts2[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_SET(r,d) (r).uc_uc_core_sts2[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_GET(r) (r).uc_uc_core_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET(r) ((((r).uc_uc_core_sts2[0]) >> 8) & 0xff)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET(r,f) (r).uc_uc_core_sts2[0]=(((r).uc_uc_core_sts2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET(r) (((r).uc_uc_core_sts2[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET(r,f) (r).uc_uc_core_sts2[0]=(((r).uc_uc_core_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r
#define UC_UC_CORE_STS2r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_t UC_UC_CORE_STS2r_t;
#define UC_UC_CORE_STS2r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_CLR
#define UC_UC_CORE_STS2r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_SET
#define UC_UC_CORE_STS2r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_GET
#define UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET
#define UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET
#define UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET
#define UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET
#define READ_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_STS2r
#define WRITE_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_STS2r
#define MODIFY_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_STS2r
#define READLN_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_STS2r
#define WRITELN_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_STS2r
#define WRITEALL_UC_UC_CORE_STS2r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_CFG_FWAPI_DATA0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd24d
 * DEVAD:    1
 * DESC:     micro core firmware/api data registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CFG_FWAPI_DATA0 Micro core firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangemicro core configuration information
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r (0x0001d24d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CFG_FWAPI_DATA0.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_cfg_fwapi_data0[1];
	uint32_t _uc_uc_core_cfg_fwapi_data0;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_CLR(r) (r).uc_uc_core_cfg_fwapi_data0[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SET(r,d) (r).uc_uc_core_cfg_fwapi_data0[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_GET(r) (r).uc_uc_core_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET(r) (((r).uc_uc_core_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET(r,f) (r).uc_uc_core_cfg_fwapi_data0[0]=(((r).uc_uc_core_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CFG_FWAPI_DATA0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r
#define UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_t UC_UC_CORE_CFG_FWAPI_DATA0r_t;
#define UC_UC_CORE_CFG_FWAPI_DATA0r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_CLR
#define UC_UC_CORE_CFG_FWAPI_DATA0r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_GET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET
#define READ_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r
#define MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r
#define READLN_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  UC_UC_CORE_CFG_FW_API_DATA1
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd24e
 * DEVAD:    1
 * DESC:     micro core firmware/api data registers 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CFG_FWAPI_DATA1 Micro core firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangemicro core configuration information
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r (0x0001d24e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CFG_FW_API_DATA1.
 */
typedef union BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_cfg_fw_api_data1[1];
	uint32_t _uc_uc_core_cfg_fw_api_data1;
} BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_t;

#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_CLR(r) (r).uc_uc_core_cfg_fw_api_data1[0] = 0
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SET(r,d) (r).uc_uc_core_cfg_fw_api_data1[0] = d
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_GET(r) (r).uc_uc_core_cfg_fw_api_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET(r) (((r).uc_uc_core_cfg_fw_api_data1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET(r,f) (r).uc_uc_core_cfg_fw_api_data1[0]=(((r).uc_uc_core_cfg_fw_api_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CFG_FW_API_DATA1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_cfg_fw_api_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r
#define UC_UC_CORE_CFG_FW_API_DATA1r_SIZE BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_t UC_UC_CORE_CFG_FW_API_DATA1r_t;
#define UC_UC_CORE_CFG_FW_API_DATA1r_CLR BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_CLR
#define UC_UC_CORE_CFG_FW_API_DATA1r_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SET
#define UC_UC_CORE_CFG_FW_API_DATA1r_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_GET
#define UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET
#define UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET
#define READ_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_READ_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITE_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_WRITE_UC_UC_CORE_CFG_FW_API_DATA1r
#define MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r
#define READLN_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_READLN_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_BLACKHAWK_XGXS_WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA0
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd300
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_0 DAC Pattern Generator readback Word 0.This register holds bits 15-0 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r (0x0001d300 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data0[1];
	uint32_t _dac_test_com_readback_data0;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_CLR(r) (r).dac_test_com_readback_data0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_SET(r,d) (r).dac_test_com_readback_data0[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_GET(r) (r).dac_test_com_readback_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_GET(r) (((r).dac_test_com_readback_data0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_SET(r,f) (r).dac_test_com_readback_data0[0]=(((r).dac_test_com_readback_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r,(_r._dac_test_com_readback_data0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r,(_r._dac_test_com_readback_data0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r,(_r._dac_test_com_readback_data0))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r
#define DAC_TEST_COM_READBACK_DATA0r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_t DAC_TEST_COM_READBACK_DATA0r_t;
#define DAC_TEST_COM_READBACK_DATA0r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_CLR
#define DAC_TEST_COM_READBACK_DATA0r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_SET
#define DAC_TEST_COM_READBACK_DATA0r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_GET
#define DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_GET
#define DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r_DAC_TEST_READBACK_DATA_0f_SET
#define READ_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA0r
#define WRITE_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA0r
#define MODIFY_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA0r
#define READLN_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA0r
#define WRITELN_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA0r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA0r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA1
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd301
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_1 DAC Pattern Generator readback Word 1.This register holds bits 31-16 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r (0x0001d301 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data1[1];
	uint32_t _dac_test_com_readback_data1;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_CLR(r) (r).dac_test_com_readback_data1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_SET(r,d) (r).dac_test_com_readback_data1[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_GET(r) (r).dac_test_com_readback_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_GET(r) (((r).dac_test_com_readback_data1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_SET(r,f) (r).dac_test_com_readback_data1[0]=(((r).dac_test_com_readback_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r,(_r._dac_test_com_readback_data1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r,(_r._dac_test_com_readback_data1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r,(_r._dac_test_com_readback_data1))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r
#define DAC_TEST_COM_READBACK_DATA1r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_t DAC_TEST_COM_READBACK_DATA1r_t;
#define DAC_TEST_COM_READBACK_DATA1r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_CLR
#define DAC_TEST_COM_READBACK_DATA1r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_SET
#define DAC_TEST_COM_READBACK_DATA1r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_GET
#define DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_GET
#define DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r_DAC_TEST_READBACK_DATA_1f_SET
#define READ_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA1r
#define WRITE_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA1r
#define MODIFY_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA1r
#define READLN_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA1r
#define WRITELN_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA1r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA1r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA2
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd302
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_2 DAC Pattern Generator readback Word 2.This register holds bits 47-32 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r (0x0001d302 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data2[1];
	uint32_t _dac_test_com_readback_data2;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_CLR(r) (r).dac_test_com_readback_data2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_SET(r,d) (r).dac_test_com_readback_data2[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_GET(r) (r).dac_test_com_readback_data2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_GET(r) (((r).dac_test_com_readback_data2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_SET(r,f) (r).dac_test_com_readback_data2[0]=(((r).dac_test_com_readback_data2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r,(_r._dac_test_com_readback_data2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r,(_r._dac_test_com_readback_data2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r,(_r._dac_test_com_readback_data2))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r
#define DAC_TEST_COM_READBACK_DATA2r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_t DAC_TEST_COM_READBACK_DATA2r_t;
#define DAC_TEST_COM_READBACK_DATA2r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_CLR
#define DAC_TEST_COM_READBACK_DATA2r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_SET
#define DAC_TEST_COM_READBACK_DATA2r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_GET
#define DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_GET
#define DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r_DAC_TEST_READBACK_DATA_2f_SET
#define READ_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA2r
#define WRITE_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA2r
#define MODIFY_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA2r
#define READLN_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA2r
#define WRITELN_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA2r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA2r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA3
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd303
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_3 DAC Pattern Generator readback Word 3.This register holds bits 63-48 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r (0x0001d303 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data3[1];
	uint32_t _dac_test_com_readback_data3;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_CLR(r) (r).dac_test_com_readback_data3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_SET(r,d) (r).dac_test_com_readback_data3[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_GET(r) (r).dac_test_com_readback_data3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_GET(r) (((r).dac_test_com_readback_data3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_SET(r,f) (r).dac_test_com_readback_data3[0]=(((r).dac_test_com_readback_data3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r,(_r._dac_test_com_readback_data3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r,(_r._dac_test_com_readback_data3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r,(_r._dac_test_com_readback_data3))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r
#define DAC_TEST_COM_READBACK_DATA3r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_t DAC_TEST_COM_READBACK_DATA3r_t;
#define DAC_TEST_COM_READBACK_DATA3r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_CLR
#define DAC_TEST_COM_READBACK_DATA3r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_SET
#define DAC_TEST_COM_READBACK_DATA3r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_GET
#define DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_GET
#define DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r_DAC_TEST_READBACK_DATA_3f_SET
#define READ_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA3r
#define WRITE_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA3r
#define MODIFY_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA3r
#define READLN_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA3r
#define WRITELN_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA3r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA3r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA4
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd304
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_4 DAC Pattern Generator readback Word 4.This register holds bits 79-64 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r (0x0001d304 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data4[1];
	uint32_t _dac_test_com_readback_data4;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_CLR(r) (r).dac_test_com_readback_data4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_SET(r,d) (r).dac_test_com_readback_data4[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_GET(r) (r).dac_test_com_readback_data4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_GET(r) (((r).dac_test_com_readback_data4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_SET(r,f) (r).dac_test_com_readback_data4[0]=(((r).dac_test_com_readback_data4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r,(_r._dac_test_com_readback_data4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r,(_r._dac_test_com_readback_data4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r,(_r._dac_test_com_readback_data4))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r
#define DAC_TEST_COM_READBACK_DATA4r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_t DAC_TEST_COM_READBACK_DATA4r_t;
#define DAC_TEST_COM_READBACK_DATA4r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_CLR
#define DAC_TEST_COM_READBACK_DATA4r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_SET
#define DAC_TEST_COM_READBACK_DATA4r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_GET
#define DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_GET
#define DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r_DAC_TEST_READBACK_DATA_4f_SET
#define READ_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA4r
#define WRITE_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA4r
#define MODIFY_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA4r
#define READLN_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA4r
#define WRITELN_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA4r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA4r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA5
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd305
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_5 DAC Pattern Generator readback Word 5.This register holds bits 95-80 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r (0x0001d305 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data5[1];
	uint32_t _dac_test_com_readback_data5;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_CLR(r) (r).dac_test_com_readback_data5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_SET(r,d) (r).dac_test_com_readback_data5[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_GET(r) (r).dac_test_com_readback_data5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_GET(r) (((r).dac_test_com_readback_data5[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_SET(r,f) (r).dac_test_com_readback_data5[0]=(((r).dac_test_com_readback_data5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r,(_r._dac_test_com_readback_data5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r,(_r._dac_test_com_readback_data5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r,(_r._dac_test_com_readback_data5))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r
#define DAC_TEST_COM_READBACK_DATA5r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_t DAC_TEST_COM_READBACK_DATA5r_t;
#define DAC_TEST_COM_READBACK_DATA5r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_CLR
#define DAC_TEST_COM_READBACK_DATA5r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_SET
#define DAC_TEST_COM_READBACK_DATA5r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_GET
#define DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_GET
#define DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r_DAC_TEST_READBACK_DATA_5f_SET
#define READ_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA5r
#define WRITE_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA5r
#define MODIFY_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA5r
#define READLN_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA5r
#define WRITELN_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA5r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA5r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA6
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd306
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_6 DAC Pattern Generator readback Word 6.This register holds bits 111-96 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r (0x0001d306 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA6.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data6[1];
	uint32_t _dac_test_com_readback_data6;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_CLR(r) (r).dac_test_com_readback_data6[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_SET(r,d) (r).dac_test_com_readback_data6[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_GET(r) (r).dac_test_com_readback_data6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_GET(r) (((r).dac_test_com_readback_data6[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_SET(r,f) (r).dac_test_com_readback_data6[0]=(((r).dac_test_com_readback_data6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r,(_r._dac_test_com_readback_data6))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r,(_r._dac_test_com_readback_data6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r,(_r._dac_test_com_readback_data6))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r
#define DAC_TEST_COM_READBACK_DATA6r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_t DAC_TEST_COM_READBACK_DATA6r_t;
#define DAC_TEST_COM_READBACK_DATA6r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_CLR
#define DAC_TEST_COM_READBACK_DATA6r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_SET
#define DAC_TEST_COM_READBACK_DATA6r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_GET
#define DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_GET
#define DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r_DAC_TEST_READBACK_DATA_6f_SET
#define READ_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA6r
#define WRITE_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA6r
#define MODIFY_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA6r
#define READLN_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA6r
#define WRITELN_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA6r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA6r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA7
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd307
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_7 DAC Pattern Generator readback Word 7.This register holds bits 127-112 of the 140 bits read from the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r (0x0001d307 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA7.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data7[1];
	uint32_t _dac_test_com_readback_data7;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_CLR(r) (r).dac_test_com_readback_data7[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_SET(r,d) (r).dac_test_com_readback_data7[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_GET(r) (r).dac_test_com_readback_data7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_GET(r) (((r).dac_test_com_readback_data7[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_SET(r,f) (r).dac_test_com_readback_data7[0]=(((r).dac_test_com_readback_data7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r,(_r._dac_test_com_readback_data7))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r,(_r._dac_test_com_readback_data7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r,(_r._dac_test_com_readback_data7))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r
#define DAC_TEST_COM_READBACK_DATA7r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_t DAC_TEST_COM_READBACK_DATA7r_t;
#define DAC_TEST_COM_READBACK_DATA7r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_CLR
#define DAC_TEST_COM_READBACK_DATA7r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_SET
#define DAC_TEST_COM_READBACK_DATA7r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_GET
#define DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_GET
#define DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r_DAC_TEST_READBACK_DATA_7f_SET
#define READ_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA7r
#define WRITE_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA7r
#define MODIFY_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA7r
#define READLN_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA7r
#define WRITELN_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA7r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA7r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_DATA8
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd308
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Data Word 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_DATA_8 DAC Pattern Generator readback Word 8.This register holds bits 139-128 of the 140 bits read from the 140x50 memoryWhen the address match occurs for this register, the memory address pointer will automatically increment to the next address
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r (0x0001d308 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_DATA8.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_data8[1];
	uint32_t _dac_test_com_readback_data8;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_CLR(r) (r).dac_test_com_readback_data8[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_SET(r,d) (r).dac_test_com_readback_data8[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_GET(r) (r).dac_test_com_readback_data8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_GET(r) (((r).dac_test_com_readback_data8[0]) & 0xfff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_SET(r,f) (r).dac_test_com_readback_data8[0]=(((r).dac_test_com_readback_data8[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_DATA8.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r,(_r._dac_test_com_readback_data8))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r,(_r._dac_test_com_readback_data8)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r,(_r._dac_test_com_readback_data8))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data8))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_data8))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_data8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r
#define DAC_TEST_COM_READBACK_DATA8r_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_t DAC_TEST_COM_READBACK_DATA8r_t;
#define DAC_TEST_COM_READBACK_DATA8r_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_CLR
#define DAC_TEST_COM_READBACK_DATA8r_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_SET
#define DAC_TEST_COM_READBACK_DATA8r_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_GET
#define DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_GET
#define DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r_DAC_TEST_READBACK_DATA_8f_SET
#define READ_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_DATA8r
#define WRITE_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_DATA8r
#define MODIFY_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_DATA8r
#define READLN_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_DATA8r
#define WRITELN_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_DATA8r
#define WRITEALL_DAC_TEST_COM_READBACK_DATA8r BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_DATA8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_DATA8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_READBACK_ADDR
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd309
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Readback Address
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DAC_TEST_READBACK_ADDRESS This register holds 6 bits current address of the 140x50 memory
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr (0x0001d309 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_READBACK_ADDR.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_s {
	uint32_t v[1];
	uint32_t dac_test_com_readback_addr[1];
	uint32_t _dac_test_com_readback_addr;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_CLR(r) (r).dac_test_com_readback_addr[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_SET(r,d) (r).dac_test_com_readback_addr[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_GET(r) (r).dac_test_com_readback_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_GET(r) (((r).dac_test_com_readback_addr[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_SET(r,f) (r).dac_test_com_readback_addr[0]=(((r).dac_test_com_readback_addr[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DAC_TEST_COM_READBACK_ADDR.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_ADDRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr,(_r._dac_test_com_readback_addr))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr,(_r._dac_test_com_readback_addr)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr,(_r._dac_test_com_readback_addr))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_addr))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_readback_addr))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_readback_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr
#define DAC_TEST_COM_READBACK_ADDRr_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_t DAC_TEST_COM_READBACK_ADDRr_t;
#define DAC_TEST_COM_READBACK_ADDRr_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_CLR
#define DAC_TEST_COM_READBACK_ADDRr_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_SET
#define DAC_TEST_COM_READBACK_ADDRr_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_GET
#define DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_GET
#define DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr_DAC_TEST_READBACK_ADDRESSf_SET
#define READ_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_READBACK_ADDRr
#define WRITE_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_READBACK_ADDRr
#define MODIFY_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_READBACK_ADDRr
#define READLN_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_READBACK_ADDRr
#define WRITELN_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_READBACK_ADDRr
#define WRITEALL_DAC_TEST_COM_READBACK_ADDRr BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_READBACK_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_READBACK_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_DAC_TEST_CTL
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd30a
 * DEVAD:    1
 * DESC:     DAC Pattern Generator Control Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DAC_TEST_LANE_SEL_EN DAC Pattern Generator Lane Select Enable.Set 1 bit only from bit 7 to bit 0.
 *     DAC_TEST_TEST_EN DAC Pattern Generator Block Enable.
 *     DAC_TEST_READ_EN DAC Pattern Generator Read Enable.
 *     DAC_TEST_READBACK_EN DAC Pattern Generator Readback Enable.
 *     DAC_TEST_MEM_WRITE_PULSE Self Clearing bitDAC Pattern Generator Memory Write pulse.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr (0x0001d30a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_DAC_TEST_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_s {
	uint32_t v[1];
	uint32_t dac_test_com_dac_test_ctl[1];
	uint32_t _dac_test_com_dac_test_ctl;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_CLR(r) (r).dac_test_com_dac_test_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_SET(r,d) (r).dac_test_com_dac_test_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_GET(r) (r).dac_test_com_dac_test_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_GET(r) ((((r).dac_test_com_dac_test_ctl[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_SET(r,f) (r).dac_test_com_dac_test_ctl[0]=(((r).dac_test_com_dac_test_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_GET(r) ((((r).dac_test_com_dac_test_ctl[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_SET(r,f) (r).dac_test_com_dac_test_ctl[0]=(((r).dac_test_com_dac_test_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_GET(r) ((((r).dac_test_com_dac_test_ctl[0]) >> 9) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_SET(r,f) (r).dac_test_com_dac_test_ctl[0]=(((r).dac_test_com_dac_test_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_GET(r) ((((r).dac_test_com_dac_test_ctl[0]) >> 8) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_SET(r,f) (r).dac_test_com_dac_test_ctl[0]=(((r).dac_test_com_dac_test_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_GET(r) (((r).dac_test_com_dac_test_ctl[0]) & 0xff)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_SET(r,f) (r).dac_test_com_dac_test_ctl[0]=(((r).dac_test_com_dac_test_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DAC_TEST_COM_DAC_TEST_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr,(_r._dac_test_com_dac_test_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr,(_r._dac_test_com_dac_test_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr,(_r._dac_test_com_dac_test_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_dac_test_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_dac_test_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_DAC_TEST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_dac_test_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr
#define DAC_TEST_COM_DAC_TEST_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_t DAC_TEST_COM_DAC_TEST_CTLr_t;
#define DAC_TEST_COM_DAC_TEST_CTLr_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_CLR
#define DAC_TEST_COM_DAC_TEST_CTLr_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_SET
#define DAC_TEST_COM_DAC_TEST_CTLr_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_MEM_WRITE_PULSEf_SET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READBACK_ENf_SET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_READ_ENf_SET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_TEST_ENf_SET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_GET
#define DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr_DAC_TEST_LANE_SEL_ENf_SET
#define READ_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_DAC_TEST_CTLr
#define WRITE_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_DAC_TEST_CTLr
#define MODIFY_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_DAC_TEST_CTLr
#define READLN_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_DAC_TEST_CTLr
#define WRITELN_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_DAC_TEST_CTLr
#define WRITEALL_DAC_TEST_COM_DAC_TEST_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_DAC_TEST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DAC_TEST_COM_DAC_TEST_MEM_TEST
 * BLOCKS:   DAC_TEST_COM
 * REGADDR:  0xd30b
 * DEVAD:    1
 * DESC:     DAC Test Memory Test Rgister
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DAC_TEST_MEM_TM  DAC Test Memory tm registers.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr (0x0001d30b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_SIZE 4

/*
 * This structure should be used to declare and program DAC_TEST_COM_DAC_TEST_MEM_TEST.
 */
typedef union BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_s {
	uint32_t v[1];
	uint32_t dac_test_com_dac_test_mem_test[1];
	uint32_t _dac_test_com_dac_test_mem_test;
} BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_t;

#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_CLR(r) (r).dac_test_com_dac_test_mem_test[0] = 0
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_SET(r,d) (r).dac_test_com_dac_test_mem_test[0] = d
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_GET(r) (r).dac_test_com_dac_test_mem_test[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_GET(r) (((r).dac_test_com_dac_test_mem_test[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_SET(r,f) (r).dac_test_com_dac_test_mem_test[0]=(((r).dac_test_com_dac_test_mem_test[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DAC_TEST_COM_DAC_TEST_MEM_TEST.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr,(_r._dac_test_com_dac_test_mem_test))
#define BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr,(_r._dac_test_com_dac_test_mem_test)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr,(_r._dac_test_com_dac_test_mem_test))
#define BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_dac_test_mem_test))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dac_test_com_dac_test_mem_test))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_DAC_TEST_MEM_TESTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dac_test_com_dac_test_mem_test))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_SIZE BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_t DAC_TEST_COM_DAC_TEST_MEM_TESTr_t;
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_CLR BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_CLR
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_SET
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_GET
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_GET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_GET
#define DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_SET BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr_DAC_TEST_MEM_TMf_SET
#define READ_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_READ_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define WRITE_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_WRITE_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define MODIFY_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_MODIFY_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define READLN_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_READLN_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define WRITELN_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_WRITELN_DAC_TEST_COM_DAC_TEST_MEM_TESTr
#define WRITEALL_DAC_TEST_COM_DAC_TEST_MEM_TESTr BCMI_BLACKHAWK_XGXS_WRITEALL_DAC_TEST_COM_DAC_TEST_MEM_TESTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DAC_TEST_COM_DAC_TEST_MEM_TESTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd310
 * DEVAD:    1
 * DESC:     tlb_err_aggr Control 0
 * RESETVAL: 0xc (12)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_AGGR_EN  Enables the multi lane error aggregation to start perfoming error analysis
 *     TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUS When a write is executed in this register, it will clear all the error analyzer registers.This register is self-clear.
 *     TLB_ERR_AGGR_ERROR_COUNT_THRESH Error threshold number beyond which the error analyzer would count a bad frame.Valid values for this field are from 3-15
 *     TLB_ERR_AGGR_LANES_ACTIVE Out of lanes 0-7, which lanes are chosen for aggregation00000001 - lane 0 active, 11111111 - all lanes activeFor a quad lane core, top 4 bits should be 0000For a bi lane core, top 4 bits should be 000000
 *     TLB_ERR_AGGR_MODE Defines how many lanes are being aggregated00-not active (clock gated), 01 - bi lane, 10 - quad, 11 - octalAll the registers in this block required lane 0 TX in OSR1 mode
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r (0x0001d310 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_tlb_err_aggr_cfg0[1];
	uint32_t _tlb_err_aggr_tlb_err_aggr_cfg0;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR(r) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET(r,d) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET(r) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 14) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 6) & 0xff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 2) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET(r) (((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t;
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET
#define READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd311
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 1
 * RESETVAL: 0xa3 (163)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESH Counts the number of errors in frames for x, x+1,..,x+7 errors in the FEC framesValid values for this field are from 3-8
 *     TLB_ERR_AGGR_CLEAR_STATUS_ON_READ Enables read on clear for all error status counters
 *     TLB_ERR_AGGR_GCLK_DIV2_EN_IGNORE When this bit is unset, it slows down the sampling of lane stable single from each lane by half - clk_32.This mode should only be used in PAM4 OS2 mode. This is a debug feature.
 *     TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTH These bits define the depth of pattern recognition for enabling the tlb error aggregation block0 - Detects 9'bxxxxxxx10, 1 - Detects 9'bxxxxxx100, 2 - Detects 9'bxxxxx1000, 3 - Detects 9'bxxxx10000.4 - Detects 9'bxxx100000, 5 - Detects 9'bxx1000000, 6 - Detects 9'bx10000000, 7 - Detects 9'b100000000.0 - This is a debug feature
 *     TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTH These bits define the depth of pattern recognition for enabling the tlb error aggregation block0 - Out of sync 4 clk_16s, 1 - Out of sync 5 clk_16s, 2 - Out of sync 6 clk_16s, 3 - Out of sync 7 clk_16s4 - Out of sync 8 clk_16s, 5 - Out of sync 9 clk_16s, 6 - Out of sync 10 clk_16s, 7 - Out of sync 11 clk_16s0 - This is a debug feature
 *     TLB_ERR_AGGR_DELAY_DATA_CAPTURE From when the error data launches, delay the capturing of data0 - 3 clks, 1 - 4 clks, 2 - 5 clks, 3 - 6 clks0 - clk by default is clk16. There is a feature to make the clock clk320 - This is a debug feature
 *     TLB_ERR_AGGR_EN_FORCE Enables the aggregation block by force even when the pattern is not matched0 - This is a debug feature
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r (0x0001d311 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_tlb_err_aggr_cfg1[1];
	uint32_t _tlb_err_aggr_tlb_err_aggr_cfg1;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR(r) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET(r,d) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET(r) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 12) & 0x3)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 9) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 6) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET(r) (((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t;
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET
#define READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd315
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_ERROR_HI Top 4 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames.tlb_err_aggr_count_error_lo needs to be read before this status register to read the correct value
 *     TLB_ERR_AGGR_ACTIVE_STATUS This bit is set when the tlb error aggregation feature is enabled after pattern recognition
 *     TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUS This bit indicates that a clocks out of sync scenario is detected due to clock wander
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr (0x0001d315 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_num_errs_in_fec_frames_sts_hi[1];
	uint32_t _tlb_err_aggr_num_errs_in_fec_frames_sts_hi;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET(r,d) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET(r) ((((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET(r) ((((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET(r) (((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET
#define READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd316
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_ERROR_LO Bottom 16 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr (0x0001d316 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_num_errs_in_fec_frames_sts_lo[1];
	uint32_t _tlb_err_aggr_num_errs_in_fec_frames_sts_lo;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET(r,d) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET(r) (((r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET
#define READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd317
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r (0x0001d317 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs7[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs7;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs7[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs7[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs7[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs7[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd318
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r (0x0001d318 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs6[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs6;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs6[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs6[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs6[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs6[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd319
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r (0x0001d319 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs5[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs5;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs5[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs5[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs5[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs5[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31a
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r (0x0001d31a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs4[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs4;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs4[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs4[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs4[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs4[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31b
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r (0x0001d31b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs3[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs3;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs3[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs3[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs3[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs3[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31c
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r (0x0001d31c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs2[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs2;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs2[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs2[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs2[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs2[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31d
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r (0x0001d31d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs1[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs1;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs1[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs1[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs1[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs1[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31e
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0 Number of times 'N' errors occurr in FEC frames, where N is defined by the register hist_start_error_count.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r (0x0001d31e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs0[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs0;
} BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t;

#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs0[0] = 0
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs0[0] = d
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs0[0]) & 0xffff)
#define BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs0[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_BLACKHAWK_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXA_FFE_TAP
 * BLOCKS:   DSC_G
 * REGADDR:  0xd410
 * DEVAD:    1
 * DESC:     rx_ffe_tap register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_FFE_TAP2_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 *     RXA_FFE_TAP1_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr (0x0001d410 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_FFE_TAP.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_s {
	uint32_t v[1];
	uint32_t dsc_rxa_ffe_tap[1];
	uint32_t _dsc_rxa_ffe_tap;
} BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_CLR(r) (r).dsc_rxa_ffe_tap[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_SET(r,d) (r).dsc_rxa_ffe_tap[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_GET(r) (r).dsc_rxa_ffe_tap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_GET(r) ((((r).dsc_rxa_ffe_tap[0]) >> 7) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_SET(r,f) (r).dsc_rxa_ffe_tap[0]=(((r).dsc_rxa_ffe_tap[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_GET(r) (((r).dsc_rxa_ffe_tap[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_SET(r,f) (r).dsc_rxa_ffe_tap[0]=(((r).dsc_rxa_ffe_tap[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RXA_FFE_TAP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr,(_r._dsc_rxa_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr,(_r._dsc_rxa_ffe_tap)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr,(_r._dsc_rxa_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_ffe_tap))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr
#define DSC_RXA_FFE_TAPr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_t DSC_RXA_FFE_TAPr_t;
#define DSC_RXA_FFE_TAPr_CLR BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_CLR
#define DSC_RXA_FFE_TAPr_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_SET
#define DSC_RXA_FFE_TAPr_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_GET
#define DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_GET
#define DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP1_VALf_SET
#define DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_GET
#define DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr_RXA_FFE_TAP2_VALf_SET
#define READ_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_READ_DSC_RXA_FFE_TAPr
#define WRITE_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXA_FFE_TAPr
#define MODIFY_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXA_FFE_TAPr
#define READLN_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_READLN_DSC_RXA_FFE_TAPr
#define WRITELN_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXA_FFE_TAPr
#define WRITEALL_DSC_RXA_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXA_FFE_TAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXA_FFE_TAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXB_FFE_TAP
 * BLOCKS:   DSC_G
 * REGADDR:  0xd411
 * DEVAD:    1
 * DESC:     rx_ffe_tap register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_FFE_TAP2_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 *     RXB_FFE_TAP1_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr (0x0001d411 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_FFE_TAP.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_s {
	uint32_t v[1];
	uint32_t dsc_rxb_ffe_tap[1];
	uint32_t _dsc_rxb_ffe_tap;
} BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_CLR(r) (r).dsc_rxb_ffe_tap[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_SET(r,d) (r).dsc_rxb_ffe_tap[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_GET(r) (r).dsc_rxb_ffe_tap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_GET(r) ((((r).dsc_rxb_ffe_tap[0]) >> 7) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_SET(r,f) (r).dsc_rxb_ffe_tap[0]=(((r).dsc_rxb_ffe_tap[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_GET(r) (((r).dsc_rxb_ffe_tap[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_SET(r,f) (r).dsc_rxb_ffe_tap[0]=(((r).dsc_rxb_ffe_tap[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RXB_FFE_TAP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr,(_r._dsc_rxb_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr,(_r._dsc_rxb_ffe_tap)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr,(_r._dsc_rxb_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_ffe_tap))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr
#define DSC_RXB_FFE_TAPr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_t DSC_RXB_FFE_TAPr_t;
#define DSC_RXB_FFE_TAPr_CLR BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_CLR
#define DSC_RXB_FFE_TAPr_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_SET
#define DSC_RXB_FFE_TAPr_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_GET
#define DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_GET
#define DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP1_VALf_SET
#define DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_GET
#define DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr_RXB_FFE_TAP2_VALf_SET
#define READ_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_READ_DSC_RXB_FFE_TAPr
#define WRITE_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXB_FFE_TAPr
#define MODIFY_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXB_FFE_TAPr
#define READLN_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_READLN_DSC_RXB_FFE_TAPr
#define WRITELN_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXB_FFE_TAPr
#define WRITEALL_DSC_RXB_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXB_FFE_TAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXB_FFE_TAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXC_FFE_TAP
 * BLOCKS:   DSC_G
 * REGADDR:  0xd412
 * DEVAD:    1
 * DESC:     rx_ffe_tap register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_FFE_TAP2_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 *     RXC_FFE_TAP1_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr (0x0001d412 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_FFE_TAP.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_s {
	uint32_t v[1];
	uint32_t dsc_rxc_ffe_tap[1];
	uint32_t _dsc_rxc_ffe_tap;
} BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_CLR(r) (r).dsc_rxc_ffe_tap[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_SET(r,d) (r).dsc_rxc_ffe_tap[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_GET(r) (r).dsc_rxc_ffe_tap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_GET(r) ((((r).dsc_rxc_ffe_tap[0]) >> 7) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_SET(r,f) (r).dsc_rxc_ffe_tap[0]=(((r).dsc_rxc_ffe_tap[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_GET(r) (((r).dsc_rxc_ffe_tap[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_SET(r,f) (r).dsc_rxc_ffe_tap[0]=(((r).dsc_rxc_ffe_tap[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RXC_FFE_TAP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr,(_r._dsc_rxc_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr,(_r._dsc_rxc_ffe_tap)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr,(_r._dsc_rxc_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_ffe_tap))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr
#define DSC_RXC_FFE_TAPr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_t DSC_RXC_FFE_TAPr_t;
#define DSC_RXC_FFE_TAPr_CLR BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_CLR
#define DSC_RXC_FFE_TAPr_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_SET
#define DSC_RXC_FFE_TAPr_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_GET
#define DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_GET
#define DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP1_VALf_SET
#define DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_GET
#define DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr_RXC_FFE_TAP2_VALf_SET
#define READ_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_READ_DSC_RXC_FFE_TAPr
#define WRITE_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXC_FFE_TAPr
#define MODIFY_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXC_FFE_TAPr
#define READLN_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_READLN_DSC_RXC_FFE_TAPr
#define WRITELN_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXC_FFE_TAPr
#define WRITEALL_DSC_RXC_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXC_FFE_TAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXC_FFE_TAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RXD_FFE_TAP
 * BLOCKS:   DSC_G
 * REGADDR:  0xd413
 * DEVAD:    1
 * DESC:     rx_ffe_tap register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_FFE_TAP2_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 *     RXD_FFE_TAP1_VAL +/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr (0x0001d413 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_FFE_TAP.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_s {
	uint32_t v[1];
	uint32_t dsc_rxd_ffe_tap[1];
	uint32_t _dsc_rxd_ffe_tap;
} BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_CLR(r) (r).dsc_rxd_ffe_tap[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_SET(r,d) (r).dsc_rxd_ffe_tap[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_GET(r) (r).dsc_rxd_ffe_tap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_GET(r) ((((r).dsc_rxd_ffe_tap[0]) >> 7) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_SET(r,f) (r).dsc_rxd_ffe_tap[0]=(((r).dsc_rxd_ffe_tap[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_GET(r) (((r).dsc_rxd_ffe_tap[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_SET(r,f) (r).dsc_rxd_ffe_tap[0]=(((r).dsc_rxd_ffe_tap[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RXD_FFE_TAP.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr,(_r._dsc_rxd_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr,(_r._dsc_rxd_ffe_tap)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr,(_r._dsc_rxd_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_FFE_TAPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_ffe_tap))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_FFE_TAPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_ffe_tap))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr
#define DSC_RXD_FFE_TAPr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_t DSC_RXD_FFE_TAPr_t;
#define DSC_RXD_FFE_TAPr_CLR BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_CLR
#define DSC_RXD_FFE_TAPr_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_SET
#define DSC_RXD_FFE_TAPr_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_GET
#define DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_GET
#define DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP1_VALf_SET
#define DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_GET
#define DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr_RXD_FFE_TAP2_VALf_SET
#define READ_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_READ_DSC_RXD_FFE_TAPr
#define WRITE_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RXD_FFE_TAPr
#define MODIFY_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RXD_FFE_TAPr
#define READLN_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_READLN_DSC_RXD_FFE_TAPr
#define WRITELN_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RXD_FFE_TAPr
#define WRITEALL_DSC_RXD_FFE_TAPr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RXD_FFE_TAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RXD_FFE_TAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd414
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXB_DFE_TAP2_VAL signed 2's complement  +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_WRITE write strobe for writing to rxa_dfe_tap2
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr (0x0001d414 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_ctl[1];
	uint32_t _dsc_rx_dfe_tap2_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_CLR(r) (r).dsc_rx_dfe_tap2_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_SET(r,d) (r).dsc_rx_dfe_tap2_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_GET(r) (r).dsc_rx_dfe_tap2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET(r) (((r).dsc_rx_dfe_tap2_ctl[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr
#define DSC_RX_DFE_TAP2_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_t DSC_RX_DFE_TAP2_CTLr_t;
#define DSC_RX_DFE_TAP2_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_CLR
#define DSC_RX_DFE_TAP2_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_SET
#define DSC_RX_DFE_TAP2_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET
#define READ_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_CTLr
#define WRITE_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_CTLr
#define MODIFY_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_CTLr
#define READLN_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_CTLr
#define WRITELN_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_CTLr
#define WRITEALL_DSC_RX_DFE_TAP2_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_3_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd415
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_3_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_WRITE write strobe for writing to rxd_dfe_tap2
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr (0x0001d415 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_3_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_3_ctl[1];
	uint32_t _dsc_rx_dfe_tap2_3_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_CLR(r) (r).dsc_rx_dfe_tap2_3_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SET(r,d) (r).dsc_rx_dfe_tap2_3_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_GET(r) (r).dsc_rx_dfe_tap2_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET(r) (((r).dsc_rx_dfe_tap2_3_ctl[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_3_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_3_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr
#define DSC_RX_DFE_TAP2_3_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_t DSC_RX_DFE_TAP2_3_CTLr_t;
#define DSC_RX_DFE_TAP2_3_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_CLR
#define DSC_RX_DFE_TAP2_3_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SET
#define DSC_RX_DFE_TAP2_3_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET
#define READ_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP2_3_CTLr
#define WRITE_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP2_3_CTLr
#define MODIFY_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_CTLr
#define READLN_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP2_3_CTLr
#define WRITELN_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_CTLr
#define WRITEALL_DSC_RX_DFE_TAP2_3_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP2_3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd416
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP3_WRITE write strobe for writing to rxd_dfe_tap3
 *     RXC_DFE_TAP3_WRITE write strobe for writing to rxc_dfe_tap3
 *     RXB_DFE_TAP3_WRITE write strobe for writing to rxb_dfe_tap3
 *     RXA_DFE_TAP3_WRITE write strobe for writing to rxa_dfe_tap3
 *     RXC_DFE_TAP2_WRITE write strobe for writing to rxc_dfe_tap2
 *     RXB_DFE_TAP2_WRITE write strobe for writing to rxb_dfe_tap2
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr (0x0001d416 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_ctl[1];
	uint32_t _dsc_rx_dfe_tap3_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_CLR(r) (r).dsc_rx_dfe_tap3_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_SET(r,d) (r).dsc_rx_dfe_tap3_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_GET(r) (r).dsc_rx_dfe_tap3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 12) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 11) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 10) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 5) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET(r) (((r).dsc_rx_dfe_tap3_ctl[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr
#define DSC_RX_DFE_TAP3_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_t DSC_RX_DFE_TAP3_CTLr_t;
#define DSC_RX_DFE_TAP3_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_CLR
#define DSC_RX_DFE_TAP3_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_SET
#define DSC_RX_DFE_TAP3_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET
#define READ_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_DFE_TAP3_CTLr
#define WRITE_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_DFE_TAP3_CTLr
#define MODIFY_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_DFE_TAP3_CTLr
#define READLN_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_DFE_TAP3_CTLr
#define WRITELN_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_DFE_TAP3_CTLr
#define WRITEALL_DSC_RX_DFE_TAP3_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_DFE_TAP3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DFE_TAP2_AB
 * BLOCKS:   DSC_G
 * REGADDR:  0xd417
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_ab rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP2_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap2_numerator2 rclk cycles on average
 *     RXB_DFE_TAP2_LEFT_NUM_CHANGE if this bit is set, rxb_dfe_tap2 rate change update will occur after the update count has reached floor(rxb_dfe_tap2_thresh_step_size/2) else ceil()
 *     RXA_DFE_TAP2_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap2_numerator2 rclk cycles on average
 *     RXA_DFE_TAP2_LEFT_NUM_CHANGE if this bit is set, rxa_dfe_tap2 rate change update will occur after the update count has reached floor(rxa_dfe_tap2_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr (0x0001d417 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DFE_TAP2_AB.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_dfe_tap2_ab[1];
	uint32_t _dsc_rx_auto_rate_mod_dfe_tap2_ab;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_CLR(r) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SET(r,d) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_GET(r) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_ab[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DFE_TAP2_AB.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_dfe_tap2_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_t DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_t;
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_CLR
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXA_DFE_TAP2_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr_RXB_DFE_TAP2_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CD
 * BLOCKS:   DSC_G
 * REGADDR:  0xd418
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_cd rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP2_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap2_numerator2 rclk cycles on average
 *     RXD_DFE_TAP2_LEFT_NUM_CHANGE if this bit is set, rxd_dfe_tap2 rate change update will occur after the update count has reached floor(rxd_dfe_tap2_thresh_step_size/2) else ceil()
 *     RXC_DFE_TAP2_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap2_numerator2 rclk cycles on average
 *     RXC_DFE_TAP2_LEFT_NUM_CHANGE if this bit is set, rxc_dfe_tap2 rate change update will occur after the update count has reached floor(rxc_dfe_tap2_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr (0x0001d418 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_dfe_tap2_cd[1];
	uint32_t _dsc_rx_auto_rate_mod_dfe_tap2_cd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_CLR(r) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SET(r,d) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_GET(r) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap2_cd[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_dfe_tap2_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_t DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_t;
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_CLR
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXC_DFE_TAP2_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr_RXD_DFE_TAP2_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP2_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DFE_TAP3_AB
 * BLOCKS:   DSC_G
 * REGADDR:  0xd419
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_ab rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap3_numerator2 rclk cycles on average
 *     RXB_DFE_TAP3_LEFT_NUM_CHANGE if this bit is set, rxb_dfe_tap3 rate change update will occur after the update count has reached floor(rxb_dfe_tap3_thresh_step_size/2) else ceil()
 *     RXA_DFE_TAP3_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap3_numerator2 rclk cycles on average
 *     RXA_DFE_TAP3_LEFT_NUM_CHANGE if this bit is set, rxa_dfe_tap3 rate change update will occur after the update count has reached floor(rxa_dfe_tap3_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr (0x0001d419 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DFE_TAP3_AB.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_dfe_tap3_ab[1];
	uint32_t _dsc_rx_auto_rate_mod_dfe_tap3_ab;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_CLR(r) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SET(r,d) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_GET(r) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_ab[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DFE_TAP3_AB.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_dfe_tap3_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_t DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_t;
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_CLR
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXA_DFE_TAP3_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr_RXB_DFE_TAP3_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CD
 * BLOCKS:   DSC_G
 * REGADDR:  0xd41a
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_cd rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap3_numerator2 rclk cycles on average
 *     RXD_DFE_TAP3_LEFT_NUM_CHANGE if this bit is set, rxd_dfe_tap3 rate change update will occur after the update count has reached floor(rxd_dfe_tap3_thresh_step_size/2) else ceil()
 *     RXC_DFE_TAP3_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap3_numerator2 rclk cycles on average
 *     RXC_DFE_TAP3_LEFT_NUM_CHANGE if this bit is set, rxc_dfe_tap3 rate change update will occur after the update count has reached floor(rxc_dfe_tap3_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr (0x0001d41a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CD.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_dfe_tap3_cd[1];
	uint32_t _dsc_rx_auto_rate_mod_dfe_tap3_cd;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_CLR(r) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SET(r,d) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_GET(r) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0]=(((r).dsc_rx_auto_rate_mod_dfe_tap3_cd[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CD.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr,(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_dfe_tap3_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_t DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_t;
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_CLR
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXC_DFE_TAP3_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr_RXD_DFE_TAP3_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DFE_TAP3_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DATA23_14
 * BLOCKS:   DSC_G
 * REGADDR:  0xd41b
 * DEVAD:    1
 * DESC:     rx_data23_14 rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DATA14_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rx_data14_numerator2 rclk cycles on average
 *     RX_DATA14_LEFT_NUM_CHANGE if this bit is set, data14 rate change update will occur after the update count has reached floor(rx_data14_thresh_step_size/2) else ceil()
 *     RX_DATA23_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rx_data23_numerator2 rclk cycles on average
 *     RX_DATA23_LEFT_NUM_CHANGE if this bit is set, data23 rate change update will occur after the update count has reached floor(rx_data23_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r (0x0001d41b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DATA23_14.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_data23_14[1];
	uint32_t _dsc_rx_auto_rate_mod_data23_14;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_CLR(r) (r).dsc_rx_auto_rate_mod_data23_14[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_SET(r,d) (r).dsc_rx_auto_rate_mod_data23_14[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_GET(r) (r).dsc_rx_auto_rate_mod_data23_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_data23_14[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_data23_14[0]=(((r).dsc_rx_auto_rate_mod_data23_14[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_data23_14[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_data23_14[0]=(((r).dsc_rx_auto_rate_mod_data23_14[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_data23_14[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_data23_14[0]=(((r).dsc_rx_auto_rate_mod_data23_14[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_data23_14[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_data23_14[0]=(((r).dsc_rx_auto_rate_mod_data23_14[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DATA23_14.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r,(_r._dsc_rx_auto_rate_mod_data23_14))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r,(_r._dsc_rx_auto_rate_mod_data23_14)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r,(_r._dsc_rx_auto_rate_mod_data23_14))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_data23_14))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_data23_14))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA23_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_data23_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_t DSC_RX_AUTO_RATE_MOD_DATA23_14r_t;
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_CLR
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_SET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_GET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA23_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r_RX_DATA14_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define WRITE_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define READLN_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DATA23_14r
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA23_14r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA23_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA23_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_PHASE02_1
 * BLOCKS:   DSC_G
 * REGADDR:  0xd41c
 * DEVAD:    1
 * DESC:     rx_phase02_1 rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PHASE02_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxd_phase02_numerator2 rclk cycles on average
 *     RX_PHASE02_LEFT_NUM_CHANGE if this bit is set, phase02 rate change update will occur after the update count has reached floor(rx_phase02_thresh_step_size/2) else ceil()
 *     RX_PHASE1_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rxc_phase1_numerator2 rclk cycles on average
 *     RX_PHASE1_LEFT_NUM_CHANGE if this bit is set, phase1 rate change update will occur after the update count has reached floor(rx_phase1_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r (0x0001d41c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_PHASE02_1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_phase02_1[1];
	uint32_t _dsc_rx_auto_rate_mod_phase02_1;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_CLR(r) (r).dsc_rx_auto_rate_mod_phase02_1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SET(r,d) (r).dsc_rx_auto_rate_mod_phase02_1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_GET(r) (r).dsc_rx_auto_rate_mod_phase02_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_phase02_1[0]) >> 13) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_phase02_1[0]=(((r).dsc_rx_auto_rate_mod_phase02_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_GET(r) ((((r).dsc_rx_auto_rate_mod_phase02_1[0]) >> 7) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_phase02_1[0]=(((r).dsc_rx_auto_rate_mod_phase02_1[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_phase02_1[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_phase02_1[0]=(((r).dsc_rx_auto_rate_mod_phase02_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_phase02_1[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_phase02_1[0]=(((r).dsc_rx_auto_rate_mod_phase02_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_PHASE02_1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r,(_r._dsc_rx_auto_rate_mod_phase02_1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r,(_r._dsc_rx_auto_rate_mod_phase02_1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r,(_r._dsc_rx_auto_rate_mod_phase02_1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_phase02_1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_phase02_1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_PHASE02_1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_phase02_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_t DSC_RX_AUTO_RATE_MOD_PHASE02_1r_t;
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_CLR
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_SET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_GET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE1_NUMERATOR2f_SET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r_RX_PHASE02_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define WRITE_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define MODIFY_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define READLN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define WRITELN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_PHASE02_1r
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_PHASE02_1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_PHASE02_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_PHASE02_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_AUTO_RATE_MOD_DATA05
 * BLOCKS:   DSC_G
 * REGADDR:  0xd41d
 * DEVAD:    1
 * DESC:     rx_data05 rate change
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DATA05_NUMERATOR2 the value of slicer will update at rx_slicer_denominator/rx_data05_numerator2 rclk cycles on average
 *     RX_DATA05_LEFT_NUM_CHANGE if this bit is set, data05 rate change update will occur after the update count has reached floor(rx_data05_thresh_step_size/2) else ceil()
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r (0x0001d41d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_AUTO_RATE_MOD_DATA05.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_s {
	uint32_t v[1];
	uint32_t dsc_rx_auto_rate_mod_data05[1];
	uint32_t _dsc_rx_auto_rate_mod_data05;
} BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_CLR(r) (r).dsc_rx_auto_rate_mod_data05[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_SET(r,d) (r).dsc_rx_auto_rate_mod_data05[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_GET(r) (r).dsc_rx_auto_rate_mod_data05[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_GET(r) ((((r).dsc_rx_auto_rate_mod_data05[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_SET(r,f) (r).dsc_rx_auto_rate_mod_data05[0]=(((r).dsc_rx_auto_rate_mod_data05[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_GET(r) (((r).dsc_rx_auto_rate_mod_data05[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_SET(r,f) (r).dsc_rx_auto_rate_mod_data05[0]=(((r).dsc_rx_auto_rate_mod_data05[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_AUTO_RATE_MOD_DATA05.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r,(_r._dsc_rx_auto_rate_mod_data05))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r,(_r._dsc_rx_auto_rate_mod_data05)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r,(_r._dsc_rx_auto_rate_mod_data05))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_data05))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_auto_rate_mod_data05))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA05r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_auto_rate_mod_data05))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r
#define DSC_RX_AUTO_RATE_MOD_DATA05r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_t DSC_RX_AUTO_RATE_MOD_DATA05r_t;
#define DSC_RX_AUTO_RATE_MOD_DATA05r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_CLR
#define DSC_RX_AUTO_RATE_MOD_DATA05r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_SET
#define DSC_RX_AUTO_RATE_MOD_DATA05r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_GET
#define DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_GET
#define DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_LEFT_NUM_CHANGEf_SET
#define DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_GET
#define DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r_RX_DATA05_NUMERATOR2f_SET
#define READ_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_AUTO_RATE_MOD_DATA05r
#define WRITE_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_AUTO_RATE_MOD_DATA05r
#define MODIFY_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_AUTO_RATE_MOD_DATA05r
#define READLN_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_AUTO_RATE_MOD_DATA05r
#define WRITELN_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_AUTO_RATE_MOD_DATA05r
#define WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA05r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_AUTO_RATE_MOD_DATA05r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_AUTO_RATE_MOD_DATA05r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_DATA23_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd420
 * DEVAD:    1
 * DESC:     data23 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DATA23_NUMERATOR the value of slicer will update at rx_slicer_denominator/rx_data23_numerator rclk cycles on average
 *     RX_DATA23_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data23
 *     RX_DATA23_INIT_PHASE When the front end signals that require auto slicer adjustment change, the slicer data23 value will change after (rx_data23_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr (0x0001d420 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_DATA23_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_data23_upd_ctl[1];
	uint32_t _dsc_auto_data23_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_CLR(r) (r).dsc_auto_data23_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_SET(r,d) (r).dsc_auto_data23_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_GET(r) (r).dsc_auto_data23_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_GET(r) ((((r).dsc_auto_data23_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_SET(r,f) (r).dsc_auto_data23_upd_ctl[0]=(((r).dsc_auto_data23_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_data23_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_data23_upd_ctl[0]=(((r).dsc_auto_data23_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_GET(r) (((r).dsc_auto_data23_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_SET(r,f) (r).dsc_auto_data23_upd_ctl[0]=(((r).dsc_auto_data23_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_DATA23_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA23_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr,(_r._dsc_auto_data23_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA23_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr,(_r._dsc_auto_data23_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA23_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr,(_r._dsc_auto_data23_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA23_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data23_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA23_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data23_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA23_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_data23_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr
#define DSC_AUTO_DATA23_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_t DSC_AUTO_DATA23_UPD_CTLr_t;
#define DSC_AUTO_DATA23_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_CLR
#define DSC_AUTO_DATA23_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_SET
#define DSC_AUTO_DATA23_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_GET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_GET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_INIT_PHASEf_SET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_GET
#define DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr_RX_DATA23_NUMERATORf_SET
#define READ_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA23_UPD_CTLr
#define WRITE_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA23_UPD_CTLr
#define MODIFY_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA23_UPD_CTLr
#define READLN_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA23_UPD_CTLr
#define WRITELN_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA23_UPD_CTLr
#define WRITEALL_DSC_AUTO_DATA23_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA23_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA23_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_DATA14_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd421
 * DEVAD:    1
 * DESC:     data14 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DATA14_NUMERATOR the value of slicer will update at rx_slicer_denominator/rx_data14_numerator rclk cycles on average
 *     RX_DATA14_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data14
 *     RX_DATA14_INIT_PHASE When the front end signals that require auto slicer adjustment change, the slicer data14 value will change after (rx_data14_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr (0x0001d421 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_DATA14_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_data14_upd_ctl[1];
	uint32_t _dsc_auto_data14_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_CLR(r) (r).dsc_auto_data14_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_SET(r,d) (r).dsc_auto_data14_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_GET(r) (r).dsc_auto_data14_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_GET(r) ((((r).dsc_auto_data14_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_SET(r,f) (r).dsc_auto_data14_upd_ctl[0]=(((r).dsc_auto_data14_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_data14_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_data14_upd_ctl[0]=(((r).dsc_auto_data14_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_GET(r) (((r).dsc_auto_data14_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_SET(r,f) (r).dsc_auto_data14_upd_ctl[0]=(((r).dsc_auto_data14_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_DATA14_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA14_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr,(_r._dsc_auto_data14_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA14_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr,(_r._dsc_auto_data14_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA14_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr,(_r._dsc_auto_data14_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA14_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data14_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA14_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data14_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA14_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_data14_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr
#define DSC_AUTO_DATA14_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_t DSC_AUTO_DATA14_UPD_CTLr_t;
#define DSC_AUTO_DATA14_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_CLR
#define DSC_AUTO_DATA14_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_SET
#define DSC_AUTO_DATA14_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_GET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_GET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_INIT_PHASEf_SET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_GET
#define DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr_RX_DATA14_NUMERATORf_SET
#define READ_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA14_UPD_CTLr
#define WRITE_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA14_UPD_CTLr
#define MODIFY_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA14_UPD_CTLr
#define READLN_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA14_UPD_CTLr
#define WRITELN_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA14_UPD_CTLr
#define WRITEALL_DSC_AUTO_DATA14_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA14_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA14_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_DATA05_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd422
 * DEVAD:    1
 * DESC:     data05 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DATA05_NUMERATOR the value of slicer will update at rx_slicer_denominator/rx_data05_numerator rclk cycles on average
 *     RX_DATA05_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data05
 *     RX_DATA05_INIT_PHASE When the front end signals that require auto slicer adjustment change, the slicer data05 value will change after (rx_data05_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr (0x0001d422 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_DATA05_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_data05_upd_ctl[1];
	uint32_t _dsc_auto_data05_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_CLR(r) (r).dsc_auto_data05_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_SET(r,d) (r).dsc_auto_data05_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_GET(r) (r).dsc_auto_data05_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_GET(r) ((((r).dsc_auto_data05_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_SET(r,f) (r).dsc_auto_data05_upd_ctl[0]=(((r).dsc_auto_data05_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_data05_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_data05_upd_ctl[0]=(((r).dsc_auto_data05_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_GET(r) (((r).dsc_auto_data05_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_SET(r,f) (r).dsc_auto_data05_upd_ctl[0]=(((r).dsc_auto_data05_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_DATA05_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA05_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr,(_r._dsc_auto_data05_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA05_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr,(_r._dsc_auto_data05_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA05_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr,(_r._dsc_auto_data05_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA05_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data05_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA05_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_data05_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA05_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_data05_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr
#define DSC_AUTO_DATA05_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_t DSC_AUTO_DATA05_UPD_CTLr_t;
#define DSC_AUTO_DATA05_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_CLR
#define DSC_AUTO_DATA05_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_SET
#define DSC_AUTO_DATA05_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_GET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_GET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_INIT_PHASEf_SET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_GET
#define DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr_RX_DATA05_NUMERATORf_SET
#define READ_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_DATA05_UPD_CTLr
#define WRITE_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_DATA05_UPD_CTLr
#define MODIFY_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_DATA05_UPD_CTLr
#define READLN_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_DATA05_UPD_CTLr
#define WRITELN_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_DATA05_UPD_CTLr
#define WRITEALL_DSC_AUTO_DATA05_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_DATA05_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_DATA05_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_PHASE1_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd423
 * DEVAD:    1
 * DESC:     phase1 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PHASE1_NUMERATOR the value of slicer will update at rx_slicer_denominator/rx_phase1_numerator rclk cycles on average
 *     RX_PHASE1_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold phase1
 *     RX_PHASE1_INIT_PHASE When the front end signals that require auto slicer adjustment change, the slicer phase1 value will change after (rx_phase1_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr (0x0001d423 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_PHASE1_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_phase1_upd_ctl[1];
	uint32_t _dsc_auto_phase1_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_CLR(r) (r).dsc_auto_phase1_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_SET(r,d) (r).dsc_auto_phase1_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_GET(r) (r).dsc_auto_phase1_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_GET(r) ((((r).dsc_auto_phase1_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_SET(r,f) (r).dsc_auto_phase1_upd_ctl[0]=(((r).dsc_auto_phase1_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_phase1_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_phase1_upd_ctl[0]=(((r).dsc_auto_phase1_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_GET(r) (((r).dsc_auto_phase1_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_SET(r,f) (r).dsc_auto_phase1_upd_ctl[0]=(((r).dsc_auto_phase1_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_PHASE1_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr,(_r._dsc_auto_phase1_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr,(_r._dsc_auto_phase1_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr,(_r._dsc_auto_phase1_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_phase1_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_phase1_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_PHASE1_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_phase1_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr
#define DSC_AUTO_PHASE1_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_t DSC_AUTO_PHASE1_UPD_CTLr_t;
#define DSC_AUTO_PHASE1_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_CLR
#define DSC_AUTO_PHASE1_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_SET
#define DSC_AUTO_PHASE1_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_GET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_GET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_INIT_PHASEf_SET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_GET
#define DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr_RX_PHASE1_NUMERATORf_SET
#define READ_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_PHASE1_UPD_CTLr
#define WRITE_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_PHASE1_UPD_CTLr
#define MODIFY_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_PHASE1_UPD_CTLr
#define READLN_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_PHASE1_UPD_CTLr
#define WRITELN_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_PHASE1_UPD_CTLr
#define WRITEALL_DSC_AUTO_PHASE1_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_PHASE1_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE1_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_PHASE02_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd424
 * DEVAD:    1
 * DESC:     phase02 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PHASE02_NUMERATOR the value of slicer will update at rx_slicer_denominator/rx_phase02_numerator rclk cycles on average
 *     RX_PHASE02_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold phase02
 *     RX_PHASE02_INIT_PHASE When the front end signals that require auto slicer adjustment change, the slicer phase02 value will change after (rx_phase02_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr (0x0001d424 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_PHASE02_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_phase02_upd_ctl[1];
	uint32_t _dsc_auto_phase02_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_CLR(r) (r).dsc_auto_phase02_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_SET(r,d) (r).dsc_auto_phase02_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_GET(r) (r).dsc_auto_phase02_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_GET(r) ((((r).dsc_auto_phase02_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_SET(r,f) (r).dsc_auto_phase02_upd_ctl[0]=(((r).dsc_auto_phase02_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_phase02_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_phase02_upd_ctl[0]=(((r).dsc_auto_phase02_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_GET(r) (((r).dsc_auto_phase02_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_SET(r,f) (r).dsc_auto_phase02_upd_ctl[0]=(((r).dsc_auto_phase02_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_PHASE02_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr,(_r._dsc_auto_phase02_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr,(_r._dsc_auto_phase02_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr,(_r._dsc_auto_phase02_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_phase02_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_phase02_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_PHASE02_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_phase02_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr
#define DSC_AUTO_PHASE02_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_t DSC_AUTO_PHASE02_UPD_CTLr_t;
#define DSC_AUTO_PHASE02_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_CLR
#define DSC_AUTO_PHASE02_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_SET
#define DSC_AUTO_PHASE02_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_GET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_GET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_INIT_PHASEf_SET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_GET
#define DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr_RX_PHASE02_NUMERATORf_SET
#define READ_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_PHASE02_UPD_CTLr
#define WRITE_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_PHASE02_UPD_CTLr
#define MODIFY_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_PHASE02_UPD_CTLr
#define READLN_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_PHASE02_UPD_CTLr
#define WRITELN_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_PHASE02_UPD_CTLr
#define WRITEALL_DSC_AUTO_PHASE02_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_PHASE02_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_PHASE02_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXA_DFE_TAP2_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd425
 * DEVAD:    1
 * DESC:     rxa_dfe_tap2 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_DFE_TAP2_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap2_numerator rclk cycles on average
 *     RXA_DFE_TAP2_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxa_dfe_tap2_numerator
 *     RXA_DFE_TAP2_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxa_dfe_tap2 value will change after (rxa_dfe_tap2_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr (0x0001d425 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXA_DFE_TAP2_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxa_dfe_tap2_upd_ctl[1];
	uint32_t _dsc_auto_rxa_dfe_tap2_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_CLR(r) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SET(r,d) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_GET(r) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_GET(r) (((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_SET(r,f) (r).dsc_auto_rxa_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXA_DFE_TAP2_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap2_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxa_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxa_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxa_dfe_tap2_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_t DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_t;
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_CLR
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_SET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_GET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_GET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_INIT_PHASEf_SET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_GET
#define DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr_RXA_DFE_TAP2_NUMERATORf_SET
#define READ_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define WRITE_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define MODIFY_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define READLN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define WRITELN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP2_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXB_DFE_TAP2_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd426
 * DEVAD:    1
 * DESC:     rxb_dfe_tap2 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP2_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap2_numerator rclk cycles on average
 *     RXB_DFE_TAP2_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxb_dfe_tap2_numerator
 *     RXB_DFE_TAP2_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxb_dfe_tap2 value will change after (rxb_dfe_tap2_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr (0x0001d426 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXB_DFE_TAP2_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxb_dfe_tap2_upd_ctl[1];
	uint32_t _dsc_auto_rxb_dfe_tap2_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_CLR(r) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SET(r,d) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_GET(r) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_GET(r) (((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_SET(r,f) (r).dsc_auto_rxb_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXB_DFE_TAP2_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap2_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxb_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxb_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxb_dfe_tap2_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_t DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_t;
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_CLR
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_SET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_GET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_GET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_INIT_PHASEf_SET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_GET
#define DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr_RXB_DFE_TAP2_NUMERATORf_SET
#define READ_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define WRITE_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define MODIFY_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define READLN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define WRITELN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP2_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXC_DFE_TAP2_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd427
 * DEVAD:    1
 * DESC:     rxc_dfe_tap2 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_DFE_TAP2_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap2_numerator rclk cycles on average
 *     RXC_DFE_TAP2_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxc_dfe_tap2_numerator
 *     RXC_DFE_TAP2_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxc_dfe_tap2 value will change after (rxc_dfe_tap2_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr (0x0001d427 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXC_DFE_TAP2_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxc_dfe_tap2_upd_ctl[1];
	uint32_t _dsc_auto_rxc_dfe_tap2_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_CLR(r) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SET(r,d) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_GET(r) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_GET(r) (((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_SET(r,f) (r).dsc_auto_rxc_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXC_DFE_TAP2_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap2_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxc_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxc_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxc_dfe_tap2_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_t DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_t;
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_CLR
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_SET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_GET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_GET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_INIT_PHASEf_SET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_GET
#define DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr_RXC_DFE_TAP2_NUMERATORf_SET
#define READ_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define WRITE_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define MODIFY_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define READLN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define WRITELN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP2_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXD_DFE_TAP2_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd428
 * DEVAD:    1
 * DESC:     rxd_dfe_tap2 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP2_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap2_numerator rclk cycles on average
 *     RXD_DFE_TAP2_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxd_dfe_tap2_numerator
 *     RXD_DFE_TAP2_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxd_dfe_tap2 value will change after (rxd_dfe_tap2_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr (0x0001d428 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXD_DFE_TAP2_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxd_dfe_tap2_upd_ctl[1];
	uint32_t _dsc_auto_rxd_dfe_tap2_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_CLR(r) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SET(r,d) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_GET(r) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_GET(r) (((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_SET(r,f) (r).dsc_auto_rxd_dfe_tap2_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap2_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXD_DFE_TAP2_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap2_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxd_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxd_dfe_tap2_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxd_dfe_tap2_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_t DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_t;
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_CLR
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_SET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_GET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_GET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_INIT_PHASEf_SET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_GET
#define DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr_RXD_DFE_TAP2_NUMERATORf_SET
#define READ_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define WRITE_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define MODIFY_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define READLN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define WRITELN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP2_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXA_DFE_TAP3_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd429
 * DEVAD:    1
 * DESC:     rxa_dfe_tap3 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_DFE_TAP3_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap3_numerator rclk cycles on average
 *     RXA_DFE_TAP3_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxa_dfe_tap3_numerator
 *     RXA_DFE_TAP3_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxa_dfe_tap3 value will change after (rxa_dfe_tap3_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr (0x0001d429 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXA_DFE_TAP3_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxa_dfe_tap3_upd_ctl[1];
	uint32_t _dsc_auto_rxa_dfe_tap3_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_CLR(r) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SET(r,d) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_GET(r) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_GET(r) (((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_SET(r,f) (r).dsc_auto_rxa_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxa_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXA_DFE_TAP3_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap3_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxa_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxa_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxa_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxa_dfe_tap3_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_t DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_t;
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_CLR
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_SET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_GET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_GET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_INIT_PHASEf_SET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_GET
#define DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr_RXA_DFE_TAP3_NUMERATORf_SET
#define READ_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define WRITE_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define MODIFY_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define READLN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define WRITELN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXA_DFE_TAP3_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXB_DFE_TAP3_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42a
 * DEVAD:    1
 * DESC:     rxb_dfe_tap3 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap3_numerator rclk cycles on average
 *     RXB_DFE_TAP3_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxb_dfe_tap3_numerator
 *     RXB_DFE_TAP3_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxb_dfe_tap3 value will change after (rxb_dfe_tap3_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr (0x0001d42a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXB_DFE_TAP3_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxb_dfe_tap3_upd_ctl[1];
	uint32_t _dsc_auto_rxb_dfe_tap3_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_CLR(r) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SET(r,d) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_GET(r) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_GET(r) (((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_SET(r,f) (r).dsc_auto_rxb_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxb_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXB_DFE_TAP3_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap3_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxb_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxb_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxb_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxb_dfe_tap3_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_t DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_t;
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_CLR
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_SET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_GET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_GET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_INIT_PHASEf_SET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_GET
#define DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr_RXB_DFE_TAP3_NUMERATORf_SET
#define READ_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define WRITE_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define MODIFY_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define READLN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define WRITELN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXB_DFE_TAP3_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXC_DFE_TAP3_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42b
 * DEVAD:    1
 * DESC:     rxc_dfe_tap3 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_DFE_TAP3_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap3_numerator rclk cycles on average
 *     RXC_DFE_TAP3_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxc_dfe_tap3_numerator
 *     RXC_DFE_TAP3_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxc_dfe_tap3 value will change after (rxc_dfe_tap3_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr (0x0001d42b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXC_DFE_TAP3_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxc_dfe_tap3_upd_ctl[1];
	uint32_t _dsc_auto_rxc_dfe_tap3_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_CLR(r) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SET(r,d) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_GET(r) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_GET(r) (((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_SET(r,f) (r).dsc_auto_rxc_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxc_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXC_DFE_TAP3_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap3_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxc_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxc_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxc_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxc_dfe_tap3_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_t DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_t;
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_CLR
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_SET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_GET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_GET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_INIT_PHASEf_SET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_GET
#define DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr_RXC_DFE_TAP3_NUMERATORf_SET
#define READ_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define WRITE_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define MODIFY_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define READLN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define WRITELN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXC_DFE_TAP3_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_AUTO_RXD_DFE_TAP3_UPD_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42c
 * DEVAD:    1
 * DESC:     rxd_dfe_tap3 auto update register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3_NUMERATOR the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap3_numerator rclk cycles on average
 *     RXD_DFE_TAP3_THRESH_STEP_SIZE -15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxd_dfe_tap3_numerator
 *     RXD_DFE_TAP3_INIT_PHASE When the front end signals that require auto slicer adjustment change, the rxd_dfe_tap3 value will change after (rxd_dfe_tap3_init_phase+2) rclk cycles
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr (0x0001d42c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_AUTO_RXD_DFE_TAP3_UPD_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_auto_rxd_dfe_tap3_upd_ctl[1];
	uint32_t _dsc_auto_rxd_dfe_tap3_upd_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_CLR(r) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SET(r,d) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_GET(r) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_GET(r) ((((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]) >> 11) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_SET(r,f) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]) >> 6) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_GET(r) (((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_SET(r,f) (r).dsc_auto_rxd_dfe_tap3_upd_ctl[0]=(((r).dsc_auto_rxd_dfe_tap3_upd_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_AUTO_RXD_DFE_TAP3_UPD_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap3_upd_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr,(_r._dsc_auto_rxd_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxd_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_auto_rxd_dfe_tap3_upd_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_auto_rxd_dfe_tap3_upd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_t DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_t;
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_CLR
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_SET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_GET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_GET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_INIT_PHASEf_SET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_GET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_THRESH_STEP_SIZEf_SET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_GET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_GET
#define DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_SET BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr_RXD_DFE_TAP3_NUMERATORf_SET
#define READ_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define WRITE_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define MODIFY_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define READLN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define WRITELN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr
#define WRITEALL_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_AUTO_RXD_DFE_TAP3_UPD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SLCR_DFE_TAPS_CTL
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42d
 * DEVAD:    1
 * DESC:     slicer and dfe ctrls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ANA_TIMER_T2     ANA timed write. Wait for  (1,2, ...32,64) cyclesThis timer is used to set the values of vga, ffe_taps, dfe taps2,3 and pf_ctrls and rx_ctrl[175:160] (ana_timer_t2+1) rclk cycles after the value is written
 *     RX_SLICER_DENOMINATOR delta sigma denominator that makes the update of slicers on fractional rclk on average
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr (0x0001d42d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SLCR_DFE_TAPS_CTL.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_slcr_dfe_taps_ctl[1];
	uint32_t _dsc_slcr_dfe_taps_ctl;
} BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_CLR(r) (r).dsc_slcr_dfe_taps_ctl[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_SET(r,d) (r).dsc_slcr_dfe_taps_ctl[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_GET(r) (r).dsc_slcr_dfe_taps_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_GET(r) ((((r).dsc_slcr_dfe_taps_ctl[0]) >> 6) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_SET(r,f) (r).dsc_slcr_dfe_taps_ctl[0]=(((r).dsc_slcr_dfe_taps_ctl[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6)) | (63 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_GET(r) (((r).dsc_slcr_dfe_taps_ctl[0]) & 0x3f)
#define BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_SET(r,f) (r).dsc_slcr_dfe_taps_ctl[0]=(((r).dsc_slcr_dfe_taps_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_SLCR_DFE_TAPS_CTL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SLCR_DFE_TAPS_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr,(_r._dsc_slcr_dfe_taps_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SLCR_DFE_TAPS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr,(_r._dsc_slcr_dfe_taps_ctl)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SLCR_DFE_TAPS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr,(_r._dsc_slcr_dfe_taps_ctl))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SLCR_DFE_TAPS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcr_dfe_taps_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SLCR_DFE_TAPS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcr_dfe_taps_ctl))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SLCR_DFE_TAPS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_slcr_dfe_taps_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr
#define DSC_SLCR_DFE_TAPS_CTLr_SIZE BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_t DSC_SLCR_DFE_TAPS_CTLr_t;
#define DSC_SLCR_DFE_TAPS_CTLr_CLR BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_CLR
#define DSC_SLCR_DFE_TAPS_CTLr_SET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_SET
#define DSC_SLCR_DFE_TAPS_CTLr_GET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_GET
#define DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_GET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_GET
#define DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_SET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_RX_SLICER_DENOMINATORf_SET
#define DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_GET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_GET
#define DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_SET BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr_ANA_TIMER_T2f_SET
#define READ_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_READ_DSC_SLCR_DFE_TAPS_CTLr
#define WRITE_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_WRITE_DSC_SLCR_DFE_TAPS_CTLr
#define MODIFY_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SLCR_DFE_TAPS_CTLr
#define READLN_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_READLN_DSC_SLCR_DFE_TAPS_CTLr
#define WRITELN_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SLCR_DFE_TAPS_CTLr
#define WRITEALL_DSC_SLCR_DFE_TAPS_CTLr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SLCR_DFE_TAPS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SLCR_DFE_TAPS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PF_CTL_DC_OFFS_AND_VGA
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42e
 * DEVAD:    1
 * DESC:     rx_pf_ctrl_dc_offset_and_vga register.
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_VGA_THRESH_SEL this is the value of vga that sets the final vga value
 *     RX_PF2_CTRL_VAL  DC cut (Low PF),  This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 *     RX_PF_CTRL_VAL   Main Peaking Filter This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr (0x0001d42e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PF_CTL_DC_OFFS_AND_VGA.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pf_ctl_dc_offs_and_vga[1];
	uint32_t _dsc_rx_pf_ctl_dc_offs_and_vga;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR(r) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET(r,d) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET(r) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) >> 10) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) >> 7) & 0x7)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_GET(r) (((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PF_CTL_DC_OFFS_AND_VGA.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t;
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_THRESH_SELf_SET
#define READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  TX_PI_B_CTL_12
 * BLOCKS:   TX_PI_B_8X_PLL2X_V1P0
 * REGADDR:  0xd43e
 * DEVAD:    1
 * DESC:     TXPI INLC Control 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JITTER_FILTER_EN_S1 This enables the First Stage Jitter filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_FREQ_OVERRIDE_EN_S1 Enable for the frequency override mode for  First Stage Jitter filter.
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG_S1 First order bandwidth control.3'd0 - 110 KHz3'd1 - 220 KHz3'd2 - 440 KHz3'd3 - 880 KHz3'd4 - 1.7 MHz3'd5 -  55 KHz>= 3'd6 is unused and reserved for future use.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r (0x0001d43e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_B_CTL_12.
 */
typedef union BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_s {
	uint32_t v[1];
	uint32_t tx_pi_b_ctl_12[1];
	uint32_t _tx_pi_b_ctl_12;
} BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_t;

#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_CLR(r) (r).tx_pi_b_ctl_12[0] = 0
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_SET(r,d) (r).tx_pi_b_ctl_12[0] = d
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_GET(r) (r).tx_pi_b_ctl_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_GET(r) ((((r).tx_pi_b_ctl_12[0]) >> 8) & 0x7)
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_SET(r,f) (r).tx_pi_b_ctl_12[0]=(((r).tx_pi_b_ctl_12[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_GET(r) ((((r).tx_pi_b_ctl_12[0]) >> 1) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_SET(r,f) (r).tx_pi_b_ctl_12[0]=(((r).tx_pi_b_ctl_12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_GET(r) (((r).tx_pi_b_ctl_12[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_SET(r,f) (r).tx_pi_b_ctl_12[0]=(((r).tx_pi_b_ctl_12[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_B_CTL_12.
 */
#define BCMI_BLACKHAWK_XGXS_READ_TX_PI_B_CTL_12r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r,(_r._tx_pi_b_ctl_12))
#define BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_B_CTL_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r,(_r._tx_pi_b_ctl_12)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_B_CTL_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r,(_r._tx_pi_b_ctl_12))
#define BCMI_BLACKHAWK_XGXS_READLN_TX_PI_B_CTL_12r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_b_ctl_12))
#define BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_B_CTL_12r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_b_ctl_12))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_B_CTL_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_b_ctl_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r
#define TX_PI_B_CTL_12r_SIZE BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_SIZE
typedef BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_t TX_PI_B_CTL_12r_t;
#define TX_PI_B_CTL_12r_CLR BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_CLR
#define TX_PI_B_CTL_12r_SET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_SET
#define TX_PI_B_CTL_12r_GET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_GET
#define TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_GET
#define TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FIRST_ORDER_BWSEL_INTEG_S1f_SET
#define TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_GET
#define TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_FREQ_OVERRIDE_EN_S1f_SET
#define TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_GET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_GET
#define TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_SET BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r_TX_PI_JITTER_FILTER_EN_S1f_SET
#define READ_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_READ_TX_PI_B_CTL_12r
#define WRITE_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_WRITE_TX_PI_B_CTL_12r
#define MODIFY_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_MODIFY_TX_PI_B_CTL_12r
#define READLN_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_READLN_TX_PI_B_CTL_12r
#define WRITELN_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_WRITELN_TX_PI_B_CTL_12r
#define WRITEALL_TX_PI_B_CTL_12r BCMI_BLACKHAWK_XGXS_WRITEALL_TX_PI_B_CTL_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_TX_PI_B_CTL_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL0
 * BLOCKS:   DSC_I
 * REGADDR:  0xd440
 * DEVAD:    1
 * DESC:     RXPI INLC Control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_0 RXPI INL Canceller table look up 0. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_1 RXPI INL Canceller table look up 1. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r (0x0001d440 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl0[1];
	uint32_t _dsc_rx_pi_b_ctl0;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_CLR(r) (r).dsc_rx_pi_b_ctl0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_SET(r,d) (r).dsc_rx_pi_b_ctl0[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_GET(r) (r).dsc_rx_pi_b_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_GET(r) ((((r).dsc_rx_pi_b_ctl0[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_SET(r,f) (r).dsc_rx_pi_b_ctl0[0]=(((r).dsc_rx_pi_b_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_GET(r) (((r).dsc_rx_pi_b_ctl0[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_SET(r,f) (r).dsc_rx_pi_b_ctl0[0]=(((r).dsc_rx_pi_b_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r,(_r._dsc_rx_pi_b_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r,(_r._dsc_rx_pi_b_ctl0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r,(_r._dsc_rx_pi_b_ctl0))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r
#define DSC_RX_PI_B_CTL0r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_t DSC_RX_PI_B_CTL0r_t;
#define DSC_RX_PI_B_CTL0r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_CLR
#define DSC_RX_PI_B_CTL0r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_SET
#define DSC_RX_PI_B_CTL0r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_GET
#define DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_GET
#define DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_1f_SET
#define DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_GET
#define DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r_RX_PI_INLC_LUT_0f_SET
#define READ_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL0r
#define WRITE_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL0r
#define MODIFY_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL0r
#define READLN_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL0r
#define WRITELN_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL0r
#define WRITEALL_DSC_RX_PI_B_CTL0r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL1
 * BLOCKS:   DSC_I
 * REGADDR:  0xd441
 * DEVAD:    1
 * DESC:     RXPI INLC Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_2 RXPI INL Canceller table look up 2. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_3 RXPI INL Canceller table look up 3. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r (0x0001d441 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL1.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl1[1];
	uint32_t _dsc_rx_pi_b_ctl1;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_CLR(r) (r).dsc_rx_pi_b_ctl1[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_SET(r,d) (r).dsc_rx_pi_b_ctl1[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_GET(r) (r).dsc_rx_pi_b_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_GET(r) ((((r).dsc_rx_pi_b_ctl1[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_SET(r,f) (r).dsc_rx_pi_b_ctl1[0]=(((r).dsc_rx_pi_b_ctl1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_GET(r) (((r).dsc_rx_pi_b_ctl1[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_SET(r,f) (r).dsc_rx_pi_b_ctl1[0]=(((r).dsc_rx_pi_b_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL1.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r,(_r._dsc_rx_pi_b_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r,(_r._dsc_rx_pi_b_ctl1)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r,(_r._dsc_rx_pi_b_ctl1))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl1))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r
#define DSC_RX_PI_B_CTL1r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_t DSC_RX_PI_B_CTL1r_t;
#define DSC_RX_PI_B_CTL1r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_CLR
#define DSC_RX_PI_B_CTL1r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_SET
#define DSC_RX_PI_B_CTL1r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_GET
#define DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_GET
#define DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_3f_SET
#define DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_GET
#define DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r_RX_PI_INLC_LUT_2f_SET
#define READ_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL1r
#define WRITE_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL1r
#define MODIFY_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL1r
#define READLN_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL1r
#define WRITELN_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL1r
#define WRITEALL_DSC_RX_PI_B_CTL1r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL2
 * BLOCKS:   DSC_I
 * REGADDR:  0xd442
 * DEVAD:    1
 * DESC:     RXPI INLC Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_4 RXPI INL Canceller table look up 4. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_5 RXPI INL Canceller table look up 5. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r (0x0001d442 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL2.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl2[1];
	uint32_t _dsc_rx_pi_b_ctl2;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_CLR(r) (r).dsc_rx_pi_b_ctl2[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_SET(r,d) (r).dsc_rx_pi_b_ctl2[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_GET(r) (r).dsc_rx_pi_b_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_GET(r) ((((r).dsc_rx_pi_b_ctl2[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_SET(r,f) (r).dsc_rx_pi_b_ctl2[0]=(((r).dsc_rx_pi_b_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_GET(r) (((r).dsc_rx_pi_b_ctl2[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_SET(r,f) (r).dsc_rx_pi_b_ctl2[0]=(((r).dsc_rx_pi_b_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL2.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r,(_r._dsc_rx_pi_b_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r,(_r._dsc_rx_pi_b_ctl2)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r,(_r._dsc_rx_pi_b_ctl2))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl2))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r
#define DSC_RX_PI_B_CTL2r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_t DSC_RX_PI_B_CTL2r_t;
#define DSC_RX_PI_B_CTL2r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_CLR
#define DSC_RX_PI_B_CTL2r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_SET
#define DSC_RX_PI_B_CTL2r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_GET
#define DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_GET
#define DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_5f_SET
#define DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_GET
#define DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r_RX_PI_INLC_LUT_4f_SET
#define READ_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL2r
#define WRITE_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL2r
#define MODIFY_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL2r
#define READLN_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL2r
#define WRITELN_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL2r
#define WRITEALL_DSC_RX_PI_B_CTL2r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL3
 * BLOCKS:   DSC_I
 * REGADDR:  0xd443
 * DEVAD:    1
 * DESC:     RXPI INLC Control 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_6 RXPI INL Canceller table look up 6. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_7 RXPI INL Canceller table look up 7. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r (0x0001d443 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL3.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl3[1];
	uint32_t _dsc_rx_pi_b_ctl3;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_CLR(r) (r).dsc_rx_pi_b_ctl3[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_SET(r,d) (r).dsc_rx_pi_b_ctl3[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_GET(r) (r).dsc_rx_pi_b_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_GET(r) ((((r).dsc_rx_pi_b_ctl3[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_SET(r,f) (r).dsc_rx_pi_b_ctl3[0]=(((r).dsc_rx_pi_b_ctl3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_GET(r) (((r).dsc_rx_pi_b_ctl3[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_SET(r,f) (r).dsc_rx_pi_b_ctl3[0]=(((r).dsc_rx_pi_b_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL3.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r,(_r._dsc_rx_pi_b_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r,(_r._dsc_rx_pi_b_ctl3)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r,(_r._dsc_rx_pi_b_ctl3))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl3))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r
#define DSC_RX_PI_B_CTL3r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_t DSC_RX_PI_B_CTL3r_t;
#define DSC_RX_PI_B_CTL3r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_CLR
#define DSC_RX_PI_B_CTL3r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_SET
#define DSC_RX_PI_B_CTL3r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_GET
#define DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_GET
#define DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_7f_SET
#define DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_GET
#define DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r_RX_PI_INLC_LUT_6f_SET
#define READ_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL3r
#define WRITE_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL3r
#define MODIFY_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL3r
#define READLN_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL3r
#define WRITELN_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL3r
#define WRITEALL_DSC_RX_PI_B_CTL3r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL4
 * BLOCKS:   DSC_I
 * REGADDR:  0xd444
 * DEVAD:    1
 * DESC:     RXPI INLC Control 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_8 RXPI INL Canceller table look up 8. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_9 RXPI INL Canceller table look up 9. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r (0x0001d444 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL4.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl4[1];
	uint32_t _dsc_rx_pi_b_ctl4;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_CLR(r) (r).dsc_rx_pi_b_ctl4[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_SET(r,d) (r).dsc_rx_pi_b_ctl4[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_GET(r) (r).dsc_rx_pi_b_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_GET(r) ((((r).dsc_rx_pi_b_ctl4[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_SET(r,f) (r).dsc_rx_pi_b_ctl4[0]=(((r).dsc_rx_pi_b_ctl4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_GET(r) (((r).dsc_rx_pi_b_ctl4[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_SET(r,f) (r).dsc_rx_pi_b_ctl4[0]=(((r).dsc_rx_pi_b_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL4.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r,(_r._dsc_rx_pi_b_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r,(_r._dsc_rx_pi_b_ctl4)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r,(_r._dsc_rx_pi_b_ctl4))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl4))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r
#define DSC_RX_PI_B_CTL4r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_t DSC_RX_PI_B_CTL4r_t;
#define DSC_RX_PI_B_CTL4r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_CLR
#define DSC_RX_PI_B_CTL4r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_SET
#define DSC_RX_PI_B_CTL4r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_GET
#define DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_GET
#define DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_9f_SET
#define DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_GET
#define DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r_RX_PI_INLC_LUT_8f_SET
#define READ_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL4r
#define WRITE_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL4r
#define MODIFY_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL4r
#define READLN_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL4r
#define WRITELN_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL4r
#define WRITEALL_DSC_RX_PI_B_CTL4r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL5
 * BLOCKS:   DSC_I
 * REGADDR:  0xd445
 * DEVAD:    1
 * DESC:     RXPI INLC Control 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_10 RXPI INL Canceller table look up 10. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_11 RXPI INL Canceller table look up 11. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r (0x0001d445 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL5.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl5[1];
	uint32_t _dsc_rx_pi_b_ctl5;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_CLR(r) (r).dsc_rx_pi_b_ctl5[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_SET(r,d) (r).dsc_rx_pi_b_ctl5[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_GET(r) (r).dsc_rx_pi_b_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_GET(r) ((((r).dsc_rx_pi_b_ctl5[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_SET(r,f) (r).dsc_rx_pi_b_ctl5[0]=(((r).dsc_rx_pi_b_ctl5[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_GET(r) (((r).dsc_rx_pi_b_ctl5[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_SET(r,f) (r).dsc_rx_pi_b_ctl5[0]=(((r).dsc_rx_pi_b_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL5.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r,(_r._dsc_rx_pi_b_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r,(_r._dsc_rx_pi_b_ctl5)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r,(_r._dsc_rx_pi_b_ctl5))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl5))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r
#define DSC_RX_PI_B_CTL5r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_t DSC_RX_PI_B_CTL5r_t;
#define DSC_RX_PI_B_CTL5r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_CLR
#define DSC_RX_PI_B_CTL5r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_SET
#define DSC_RX_PI_B_CTL5r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_GET
#define DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_GET
#define DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_11f_SET
#define DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_GET
#define DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r_RX_PI_INLC_LUT_10f_SET
#define READ_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL5r
#define WRITE_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL5r
#define MODIFY_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL5r
#define READLN_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL5r
#define WRITELN_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL5r
#define WRITEALL_DSC_RX_PI_B_CTL5r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL6
 * BLOCKS:   DSC_I
 * REGADDR:  0xd446
 * DEVAD:    1
 * DESC:     RXPI INLC Control 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_12 RXPI INL Canceller table look up 12. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_13 RXPI INL Canceller table look up 13. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r (0x0001d446 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL6.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl6[1];
	uint32_t _dsc_rx_pi_b_ctl6;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_CLR(r) (r).dsc_rx_pi_b_ctl6[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_SET(r,d) (r).dsc_rx_pi_b_ctl6[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_GET(r) (r).dsc_rx_pi_b_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_GET(r) ((((r).dsc_rx_pi_b_ctl6[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_SET(r,f) (r).dsc_rx_pi_b_ctl6[0]=(((r).dsc_rx_pi_b_ctl6[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_GET(r) (((r).dsc_rx_pi_b_ctl6[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_SET(r,f) (r).dsc_rx_pi_b_ctl6[0]=(((r).dsc_rx_pi_b_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL6.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r,(_r._dsc_rx_pi_b_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r,(_r._dsc_rx_pi_b_ctl6)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r,(_r._dsc_rx_pi_b_ctl6))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl6))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r
#define DSC_RX_PI_B_CTL6r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_t DSC_RX_PI_B_CTL6r_t;
#define DSC_RX_PI_B_CTL6r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_CLR
#define DSC_RX_PI_B_CTL6r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_SET
#define DSC_RX_PI_B_CTL6r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_GET
#define DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_GET
#define DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_13f_SET
#define DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_GET
#define DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r_RX_PI_INLC_LUT_12f_SET
#define READ_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL6r
#define WRITE_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL6r
#define MODIFY_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL6r
#define READLN_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL6r
#define WRITELN_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL6r
#define WRITEALL_DSC_RX_PI_B_CTL6r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL7
 * BLOCKS:   DSC_I
 * REGADDR:  0xd447
 * DEVAD:    1
 * DESC:     RXPI INLC Control 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_LUT_14 RXPI INL Canceller table look up 14. Signed value. -15 to +15.
 *     RX_PI_INLC_LUT_15 RXPI INL Canceller table look up 15. Signed value. -15 to +15.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r (0x0001d447 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL7.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl7[1];
	uint32_t _dsc_rx_pi_b_ctl7;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_CLR(r) (r).dsc_rx_pi_b_ctl7[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_SET(r,d) (r).dsc_rx_pi_b_ctl7[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_GET(r) (r).dsc_rx_pi_b_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_GET(r) ((((r).dsc_rx_pi_b_ctl7[0]) >> 8) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_SET(r,f) (r).dsc_rx_pi_b_ctl7[0]=(((r).dsc_rx_pi_b_ctl7[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_GET(r) (((r).dsc_rx_pi_b_ctl7[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_SET(r,f) (r).dsc_rx_pi_b_ctl7[0]=(((r).dsc_rx_pi_b_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL7.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r,(_r._dsc_rx_pi_b_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r,(_r._dsc_rx_pi_b_ctl7)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r,(_r._dsc_rx_pi_b_ctl7))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl7))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r
#define DSC_RX_PI_B_CTL7r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_t DSC_RX_PI_B_CTL7r_t;
#define DSC_RX_PI_B_CTL7r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_CLR
#define DSC_RX_PI_B_CTL7r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_SET
#define DSC_RX_PI_B_CTL7r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_GET
#define DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_GET
#define DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_15f_SET
#define DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_GET
#define DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r_RX_PI_INLC_LUT_14f_SET
#define READ_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL7r
#define WRITE_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL7r
#define MODIFY_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL7r
#define READLN_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL7r
#define WRITELN_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL7r
#define WRITEALL_DSC_RX_PI_B_CTL7r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL9
 * BLOCKS:   DSC_I
 * REGADDR:  0xd448
 * DEVAD:    1
 * DESC:     RXPI INLC Control 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_OFFSET RXPI INL Canceller pointer offset. 0-127.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r (0x0001d448 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL9.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl9[1];
	uint32_t _dsc_rx_pi_b_ctl9;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_CLR(r) (r).dsc_rx_pi_b_ctl9[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_SET(r,d) (r).dsc_rx_pi_b_ctl9[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_GET(r) (r).dsc_rx_pi_b_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_GET(r) ((((r).dsc_rx_pi_b_ctl9[0]) >> 8) & 0x7f)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_SET(r,f) (r).dsc_rx_pi_b_ctl9[0]=(((r).dsc_rx_pi_b_ctl9[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))

/*
 * These macros can be used to access DSC_RX_PI_B_CTL9.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r,(_r._dsc_rx_pi_b_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r,(_r._dsc_rx_pi_b_ctl9)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r,(_r._dsc_rx_pi_b_ctl9))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl9))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r
#define DSC_RX_PI_B_CTL9r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_t DSC_RX_PI_B_CTL9r_t;
#define DSC_RX_PI_B_CTL9r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_CLR
#define DSC_RX_PI_B_CTL9r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_SET
#define DSC_RX_PI_B_CTL9r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_GET
#define DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_GET
#define DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r_RX_PI_INLC_OFFSETf_SET
#define READ_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL9r
#define WRITE_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL9r
#define MODIFY_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL9r
#define READLN_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL9r
#define WRITELN_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL9r
#define WRITEALL_DSC_RX_PI_B_CTL9r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_CTL_10
 * BLOCKS:   DSC_I
 * REGADDR:  0xd449
 * DEVAD:    1
 * DESC:     RXPI INLC Control 10
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_INLC_EN    RXPI INL Canceller enable control. 1 = enable INL canceller operation.
 *     RX_PI_INLC_K     RXPI INL Canceller k factor. k = 0,1,2,3. multiplies lut_out by 2^k.
 *     RX_PI_INLC_PHASE_DLY RXPI INL Canceller phase step delay.'0 = no delay, 1 = 1 clk delay, 2 = 2 clk delay, 3 = not used.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r (0x0001d449 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_CTL_10.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_ctl_10[1];
	uint32_t _dsc_rx_pi_b_ctl_10;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_CLR(r) (r).dsc_rx_pi_b_ctl_10[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_SET(r,d) (r).dsc_rx_pi_b_ctl_10[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_GET(r) (r).dsc_rx_pi_b_ctl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_GET(r) ((((r).dsc_rx_pi_b_ctl_10[0]) >> 8) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_SET(r,f) (r).dsc_rx_pi_b_ctl_10[0]=(((r).dsc_rx_pi_b_ctl_10[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_GET(r) ((((r).dsc_rx_pi_b_ctl_10[0]) >> 6) & 0x3)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_SET(r,f) (r).dsc_rx_pi_b_ctl_10[0]=(((r).dsc_rx_pi_b_ctl_10[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_GET(r) (((r).dsc_rx_pi_b_ctl_10[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_SET(r,f) (r).dsc_rx_pi_b_ctl_10[0]=(((r).dsc_rx_pi_b_ctl_10[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_CTL_10.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r,(_r._dsc_rx_pi_b_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r,(_r._dsc_rx_pi_b_ctl_10)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r,(_r._dsc_rx_pi_b_ctl_10))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_ctl_10))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_ctl_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r
#define DSC_RX_PI_B_CTL_10r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_t DSC_RX_PI_B_CTL_10r_t;
#define DSC_RX_PI_B_CTL_10r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_CLR
#define DSC_RX_PI_B_CTL_10r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_SET
#define DSC_RX_PI_B_CTL_10r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_GET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_GET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_PHASE_DLYf_SET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_GET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_Kf_SET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_GET
#define DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r_RX_PI_INLC_ENf_SET
#define READ_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_CTL_10r
#define WRITE_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_CTL_10r
#define MODIFY_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_CTL_10r
#define READLN_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_CTL_10r
#define WRITELN_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_CTL_10r
#define WRITEALL_DSC_RX_PI_B_CTL_10r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_CTL_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_CTL_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_SPARE_DSC_I
 * BLOCKS:   DSC_I
 * REGADDR:  0xd44a
 * DEVAD:    1
 * DESC:     Spare Reg DSC I
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE_DSC_I      Spare.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir (0x0001d44a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SIZE 4

/*
 * This structure should be used to declare and program DSC_SPARE_DSC_I.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_s {
	uint32_t v[1];
	uint32_t dsc_spare_dsc_i[1];
	uint32_t _dsc_spare_dsc_i;
} BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_t;

#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_CLR(r) (r).dsc_spare_dsc_i[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SET(r,d) (r).dsc_spare_dsc_i[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_GET(r) (r).dsc_spare_dsc_i[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SPARE_DSC_If_GET(r) (((r).dsc_spare_dsc_i[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SPARE_DSC_If_SET(r,f) (r).dsc_spare_dsc_i[0]=(((r).dsc_spare_dsc_i[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SPARE_DSC_I.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_SPARE_DSC_Ir(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir,(_r._dsc_spare_dsc_i))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_SPARE_DSC_Ir(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir,(_r._dsc_spare_dsc_i)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SPARE_DSC_Ir(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir,(_r._dsc_spare_dsc_i))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_SPARE_DSC_Ir(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_spare_dsc_i))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SPARE_DSC_Ir(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_spare_dsc_i))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SPARE_DSC_Ir(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_spare_dsc_i))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir
#define DSC_SPARE_DSC_Ir_SIZE BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_t DSC_SPARE_DSC_Ir_t;
#define DSC_SPARE_DSC_Ir_CLR BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_CLR
#define DSC_SPARE_DSC_Ir_SET BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SET
#define DSC_SPARE_DSC_Ir_GET BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_GET
#define DSC_SPARE_DSC_Ir_SPARE_DSC_If_GET BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SPARE_DSC_If_GET
#define DSC_SPARE_DSC_Ir_SPARE_DSC_If_SET BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir_SPARE_DSC_If_SET
#define READ_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_READ_DSC_SPARE_DSC_Ir
#define WRITE_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_WRITE_DSC_SPARE_DSC_Ir
#define MODIFY_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_MODIFY_DSC_SPARE_DSC_Ir
#define READLN_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_READLN_DSC_SPARE_DSC_Ir
#define WRITELN_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_WRITELN_DSC_SPARE_DSC_Ir
#define WRITEALL_DSC_SPARE_DSC_Ir BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_SPARE_DSC_Ir

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_SPARE_DSC_Ir'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  DSC_RX_PI_B_STS0
 * BLOCKS:   DSC_I
 * REGADDR:  0xd44c
 * DEVAD:    1
 * DESC:     RXPI INLC Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_INLC_OUT   RXPI INL Canceller output. Signed Value.
 *     RX_PI_INLC_RX_PHASE_POINTER RXPI INL Canceller RX phase pointer.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r (0x0001d44c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_B_STS0.
 */
typedef union BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_b_sts0[1];
	uint32_t _dsc_rx_pi_b_sts0;
} BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_t;

#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_CLR(r) (r).dsc_rx_pi_b_sts0[0] = 0
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_SET(r,d) (r).dsc_rx_pi_b_sts0[0] = d
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_GET(r) (r).dsc_rx_pi_b_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_GET(r) ((((r).dsc_rx_pi_b_sts0[0]) >> 7) & 0x1ff)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_SET(r,f) (r).dsc_rx_pi_b_sts0[0]=(((r).dsc_rx_pi_b_sts0[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_GET(r) (((r).dsc_rx_pi_b_sts0[0]) & 0xf)
#define BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_SET(r,f) (r).dsc_rx_pi_b_sts0[0]=(((r).dsc_rx_pi_b_sts0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_PI_B_STS0.
 */
#define BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r,(_r._dsc_rx_pi_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r,(_r._dsc_rx_pi_b_sts0)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r,(_r._dsc_rx_pi_b_sts0))
#define BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_b_sts0))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_b_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r
#define DSC_RX_PI_B_STS0r_SIZE BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_SIZE
typedef BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_t DSC_RX_PI_B_STS0r_t;
#define DSC_RX_PI_B_STS0r_CLR BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_CLR
#define DSC_RX_PI_B_STS0r_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_SET
#define DSC_RX_PI_B_STS0r_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_GET
#define DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_GET
#define DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_RX_PHASE_POINTERf_SET
#define DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_GET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_GET
#define DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_SET BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r_RX_PI_INLC_OUTf_SET
#define READ_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_READ_DSC_RX_PI_B_STS0r
#define WRITE_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_WRITE_DSC_RX_PI_B_STS0r
#define MODIFY_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_MODIFY_DSC_RX_PI_B_STS0r
#define READLN_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_READLN_DSC_RX_PI_B_STS0r
#define WRITELN_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_WRITELN_DSC_RX_PI_B_STS0r
#define WRITEALL_DSC_RX_PI_B_STS0r BCMI_BLACKHAWK_XGXS_WRITEALL_DSC_RX_PI_B_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_DSC_RX_PI_B_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdc
 * DEVAD:    1
 * DESC:     Broadcast Port Address
 * RESETVAL: 0x1f (31)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 *     MDIO_DRV_COMCLK  Debug control bit to select between mdio_clk and comclk to drive out mdio_out and mdio_oeb signals.0=mdio_clk, 1=comclk
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr (0x0001ffdc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 */
typedef union BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET(r) ((((r).mdio_bcst_port_addr[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 */
#define BCMI_BLACKHAWK_XGXS_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_BLACKHAWK_XGXS_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_BLACKHAWK_XGXS_READLN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_bcst_port_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr
#define READLN_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_READLN_MDIO_BCST_PORT_ADDRr
#define WRITELN_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr
#define WRITEALL_MDIO_BCST_PORT_ADDRr BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_MDIO_BCST_PORT_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdd
 * DEVAD:    1
 * DESC:     MMD Select
 * RESETVAL: 0x404d (16461)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEV_ID0_EN  When set and mdio_multi_mmds_en=1 then device id 0 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr (0x0001ffdd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 */
typedef union BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_t;

#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 */
#define BCMI_BLACKHAWK_XGXS_READ_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_BLACKHAWK_XGXS_WRITE_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_BLACKHAWK_XGXS_READLN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_mmd_sel))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_SIZE
typedef BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_MMD_SELr
#define READLN_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_READLN_MDIO_MMD_SELr
#define WRITELN_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_MMD_SELr
#define WRITEALL_MDIO_MMD_SELr BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_MMD_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_MDIO_MMD_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_BLACKHAWK_XGXS
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffde
 * DEVAD:    1
 * DESC:     AER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_AER         Provides 11-bits of 32-bit address for clause45 mdio transactions
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_AERr (0x0001ffde | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 */
typedef union BCMI_BLACKHAWK_XGXS_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_BLACKHAWK_XGXS_MDIO_AERr_t;

#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0x7ff)
#define BCMI_BLACKHAWK_XGXS_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access MDIO_AER.
 */
#define BCMI_BLACKHAWK_XGXS_READ_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_BLACKHAWK_XGXS_WRITE_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr,(_r._mdio_aer)&0xffff)
#define BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_BLACKHAWK_XGXS_READLN_MDIO_AERr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_AERr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_BLACKHAWK_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_aer))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_BLACKHAWK_XGXS_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_BLACKHAWK_XGXS_MDIO_AERr_SIZE
typedef BCMI_BLACKHAWK_XGXS_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_BLACKHAWK_XGXS_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_BLACKHAWK_XGXS_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_BLACKHAWK_XGXS_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_BLACKHAWK_XGXS_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_BLACKHAWK_XGXS_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_BLACKHAWK_XGXS_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_BLACKHAWK_XGXS_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_BLACKHAWK_XGXS_MODIFY_MDIO_AERr
#define READLN_MDIO_AERr BCMI_BLACKHAWK_XGXS_READLN_MDIO_AERr
#define WRITELN_MDIO_AERr BCMI_BLACKHAWK_XGXS_WRITELN_MDIO_AERr
#define WRITEALL_MDIO_AERr BCMI_BLACKHAWK_XGXS_WRITEALL_MDIO_AERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_BLACKHAWK_XGXS_MDIO_AERr'
 */




#endif /* __BCMI_BLACKHAWK_XGXS_DEFS_H__ */
