/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/flowtracker.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/property.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOWTRACKER

/*!
 * \brief Flowtracker ETRAP definitions.
 */
/*! Number of Bloom filter instances. */
#define FLOWTRACKER_ETRAP_BLOOM_FILTER_NUM_INSTANCES (4)

/*! Number of Elephant flow tables banks. */
#define FLOWTRACKER_ETRAP_FLOW_TABLE_NUM_BANKS (2)

/*! Default queue drain time. */
#define FLOWTRACKER_ETRAP_DEF_QUEUE_DRAIN_TIME_USECS (100)

/******************************************************************************
 * Private functions
 */


static int
ft_queue_drain_time_lt_encode(int unit, int drain_time, char *hw_value)
{
    SHR_FUNC_ENTER(unit);

    switch (drain_time) {
    case 50:
        sal_strcpy(hw_value, "TIME_50US");
        break;
    case 100:
        sal_strcpy(hw_value, "TIME_100US");
        break;
    case 150:
        sal_strcpy(hw_value, "TIME_150US");
        break;
    case 200:
        sal_strcpy(hw_value, "TIME_200US");
        break;
    case 250:
        sal_strcpy(hw_value, "TIME_250US");
        break;
    case 500:
        sal_strcpy(hw_value, "TIME_500US");
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_monitor_interval_lt_encode(int unit, int mon_interval, char *lt_field)
{
    SHR_FUNC_ENTER(unit);

    switch (mon_interval) {
    case 1000:
        sal_strcpy(lt_field, "TIME_1MS");
        break;
    case 2000:
        sal_strcpy(lt_field, "TIME_2MS");
        break;
    case 5000:
        sal_strcpy(lt_field, "TIME_5MS");
        break;
    case 10000:
        sal_strcpy(lt_field, "TIME_10MS");
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_monitor_interval_lt_decode(int unit, const char *lt_field, int *interval)
{
    SHR_FUNC_ENTER(unit);

    if (!sal_strcmp(lt_field, "TIME_1MS")) {
        *interval = 1000;
    } else if (!sal_strcmp(lt_field, "TIME_2MS")) {
        *interval = 2000;
    } else if (!sal_strcmp(lt_field, "TIME_5MS")) {
        *interval = 5000;
    } else if (!sal_strcmp(lt_field, "TIME_10MS")) {
        *interval = 10000;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_hw_etrap_detach(int unit)
{
    int dunit, num_pipes = 0, idx = 0;
    uint64_t val = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv = SHR_E_NONE;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    num_pipes = bcmi_ltsw_dev_max_pp_pipe_num(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CONTROLs, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    for (idx = 0; idx < num_pipes; idx++) {
        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, val));

        rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                  BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_hw_etrap_init(int unit)
{
    int dunit, num_pipes = 0;
    int idx = 0, drain_time = 0;
    uint64_t val = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    char critical_time[11] = "";
    const char *etrap_interval = "TIME_5MS";
    const char *hash_sel[] = {
        HASH0_INSTANCE0s,
        HASH0_INSTANCE1s,
        HASH1_INSTANCE0s,
        HASH1_INSTANCE1s
    };
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    num_pipes = bcmi_ltsw_dev_max_pp_pipe_num(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

    for (idx = 0; idx < FLOWTRACKER_ETRAP_BLOOM_FILTER_NUM_INSTANCES; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FILTER_HASH_SELECTs,
                                                idx, &hash_sel[idx], 1));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

    for (idx = 0; idx < FLOWTRACKER_ETRAP_FLOW_TABLE_NUM_BANKS; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FLOW_HASH_SELECTs,
                                                idx, &hash_sel[idx], 1));
    }

    /* Set ETRAP interval to 5ms. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_INTERVALs, etrap_interval));

    drain_time = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_FLOWTRACKER_ELEPHANT_EXPECTED_QUEUE_DRAIN_TIME_USECS,
                                        FLOWTRACKER_ETRAP_DEF_QUEUE_DRAIN_TIME_USECS);
    SHR_IF_ERR_VERBOSE_EXIT
        (ft_queue_drain_time_lt_encode(unit, drain_time, critical_time));

    /* Set critical time. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_CRITICAL_TIMEs, critical_time));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    /* Enable ETRAP using MON_ETRAP_CONTROL. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CONTROLs, &entry_hdl));

    val = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ETRAPs, val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    for (idx = 0; idx < num_pipes; idx++) {
        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_flowtracker_detach(int unit)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT(ft_hw_etrap_detach(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_init(int unit)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT(ft_hw_etrap_init(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_hash_config_set(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t hash_type,
    int right_rotate_bits)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;
    const char *hash_sel[] = {
        HASH0_INSTANCE0s,
        HASH0_INSTANCE1s,
        HASH1_INSTANCE0s,
        HASH1_INSTANCE1s
    };

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (hash_table == bcmFlowtrackerElephantHashTableBloomFilter) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

        val = hash_type;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FILTER_HASH_SELECTs,
                                                instance_num, &hash_sel[val], 1));

        val = right_rotate_bits;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, FILTER_HASH_ROTATE_BITSs, instance_num, &val, 1));

    } else if (hash_table == bcmFlowtrackerElephantHashTableFlowTable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        val = hash_type;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FLOW_HASH_SELECTs,
                                                bank_num, &hash_sel[val], 1));

        val = right_rotate_bits;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, FLOW_HASH_ROTATE_BITSs, bank_num, &val, 1));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_hash_config_get(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t *hash_type,
    int *right_rotate_bits)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint32_t count = 0;
    uint64_t val = 0;
    const char *hash_sel = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (hash_table == bcmFlowtrackerElephantHashTableBloomFilter) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, FILTER_HASH_SELECTs,
                                                instance_num, &hash_sel, 1, &count));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, FILTER_HASH_ROTATE_BITSs,
                                         instance_num, &val, 1, &count));
        *right_rotate_bits = val;
    } else if (hash_table == bcmFlowtrackerElephantHashTableFlowTable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, FLOW_HASH_SELECTs,
                                                bank_num, &hash_sel, 1, &count));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, FLOW_HASH_ROTATE_BITSs,
                                         bank_num, &val, 1, &count));
        *right_rotate_bits = val;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!sal_strcmp(hash_sel, HASH0_INSTANCE0s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField0Function0;
    } else if (!sal_strcmp(hash_sel, HASH0_INSTANCE1s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField0Function1;
    } else if (!sal_strcmp(hash_sel, HASH1_INSTANCE0s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField1Function0;
    } else {
        *hash_type = bcmFlowtrackerElephantHashTypeField1Function1;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_control_set(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;
    char mon_interval[10] = "";

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    if (type == bcmFlowtrackerElephantControlMonitorIntervalUsecs) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (ft_monitor_interval_lt_encode(unit, arg, mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_INTERVALs, mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_THRESHOLDs, &entry_hdl));

        val = arg;
        switch (type) {
        case bcmFlowtrackerElephantControlBloomFilterByteThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CANDIDATE_BYTESs, val));
            break;
        case bcmFlowtrackerElephantControlElephantThresholdBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ELEPHANT_GREEN_BYTESs, val));
            break;
        case bcmFlowtrackerElephantControlDemotionThresholdBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, RESET_BYTESs, val));
            break;
        case bcmFlowtrackerElephantControlYellowThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ELEPHANT_YELLOW_BYTESs, val));
            break;
        case bcmFlowtrackerElephantControlRedThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ELEPHANT_RED_BYTESs, val));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_control_get(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int *arg)
{
    int dunit;
    uint64_t val = 0;
    const char *mon_interval = NULL;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (type == bcmFlowtrackerElephantControlMonitorIntervalUsecs) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, ETRAP_INTERVALs, &mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (ft_monitor_interval_lt_decode(unit, mon_interval, arg));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_THRESHOLDs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        switch (type) {
        case bcmFlowtrackerElephantControlBloomFilterByteThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CANDIDATE_BYTESs, &val));
            break;
        case bcmFlowtrackerElephantControlElephantThresholdBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ELEPHANT_GREEN_BYTESs, &val));
            break;
        case bcmFlowtrackerElephantControlDemotionThresholdBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, RESET_BYTESs, &val));
            break;
        case bcmFlowtrackerElephantControlYellowThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ELEPHANT_YELLOW_BYTESs, &val));
            break;
        case bcmFlowtrackerElephantControlRedThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ELEPHANT_RED_BYTESs, &val));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        *arg = val;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_stats_set(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    int dunit, num_pipes = 0, idx = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    num_pipes = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    val = stats->num_candidates_detected;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CANDIDATE_FILTER_EXCEEDEDs, val));

    val = stats->num_elephants_detected;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, FLOW_ELEPHANTs, val));

    val = stats->num_flow_table_insert_success;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, FLOW_INSERT_SUCCESSs, val));

    val = stats->num_flow_table_insert_failures;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, FLOW_INSERT_FAILUREs, val));

    for (idx = 0; idx < num_pipes; idx++) {
        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flowtracker_elephant_stats_get(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    int dunit, num_pipes = 0, idx = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    num_pipes = bcmi_ltsw_dev_max_pp_pipe_num(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    stats->num_candidates_detected = 0;
    stats->num_elephants_detected = 0;
    stats->num_flow_table_insert_success = 0;
    stats->num_flow_table_insert_failures = 0;

    for (idx = 0; idx < num_pipes; idx++) {
        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, CANDIDATE_FILTER_EXCEEDEDs, &val));
        stats->num_candidates_detected += val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, FLOW_ELEPHANTs, &val));
        stats->num_elephants_detected += val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_SUCCESSs, &val));
        stats->num_flow_table_insert_success += val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_FAILUREs, &val));
        stats->num_flow_table_insert_failures += val;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

