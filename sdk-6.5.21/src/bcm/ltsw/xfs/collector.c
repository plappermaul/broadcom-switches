/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/collector.h>
#include <bcm_int/control.h>
#include <shr/shr_bitop.h>

#include <bcm_int/ltsw/xfs/collector.h>
#include <bcm_int/ltsw/collector.h>
#include <bcm_int/ltsw/collector_int.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/issu.h>

#include <sal/sal_types.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COLLECTOR

/******************************************************************************
 * Private functions
 */


static bcmint_collector_bookkeeping_info_t collector_bk[BCM_MAX_NUM_UNITS];

#define COL_BK(unit) collector_bk[unit].collector_info

#define COL_IPV4_ID_BMP(unit)               \
    (COL_BK(unit).ipv4_id_bitmap->w)
#define COL_IPV4_ID_BMP_SET(unit, id)       \
    SHR_BITSET(COL_IPV4_ID_BMP(unit),id)
#define COL_IPV4_ID_BMP_GET(unit, id)       \
    SHR_BITGET(COL_IPV4_ID_BMP(unit),id)
#define COL_IPV4_ID_BMP_CLEAR(unit, id)     \
    SHR_BITCLR(COL_IPV4_ID_BMP(unit),id)


#define COL_IPV6_ID_BMP(unit)               \
    (COL_BK(unit).ipv6_id_bitmap->w)
#define COL_IPV6_ID_BMP_SET(unit, id)       \
    SHR_BITSET(COL_IPV6_ID_BMP(unit),id)
#define COL_IPV6_ID_BMP_GET(unit, id)       \
    SHR_BITGET(COL_IPV6_ID_BMP(unit),id)
#define COL_IPV6_ID_BMP_CLEAR(unit, id)     \
    SHR_BITCLR(COL_IPV6_ID_BMP(unit),id)


#define COL_EXT_ID_BMP(unit)                \
    (COL_BK(unit).externel_id_bitmap->w)
#define COL_EXT_ID_BMP_SET(unit, id)        \
    SHR_BITSET(COL_EXT_ID_BMP(unit),id)
#define COL_EXT_ID_BMP_GET(unit, id)        \
    SHR_BITGET(COL_EXT_ID_BMP(unit),id)
#define COL_EXT_ID_BMP_CLEAR(unit, id)      \
    SHR_BITCLR(COL_EXT_ID_BMP(unit),id)
#define COL_EXT_ID_ITER(unit, id)           \
    SHR_BIT_ITER(COL_EXT_ID_BMP(unit), BCMINT_COLLECTOR_ID_MAX, id)

#define COL_MIRROR_DEST_ID(unit, id)        \
    (COL_BK(unit).mirror_dest_id[id].mirror_dest_id)

/*!
 * Mapping of collector ID to transport type and LT IDs.
 * Managed as two dimensional array [ID][TYPE]
 */
#define COL_INFO(unit,id)            \
    (COL_BK(unit).col_info[id])

/* Mapping of collector ID to LT IDs. */
#define COL_INT_ID_MAP(unit, id)            \
    (COL_INFO(unit,id).lt_id)

/* Mapping of collector ID to transport type. */
#define COL_TYPE_MAP(unit, id)              \
    (COL_INFO(unit,id).transport_type)

#define COL_REF_COUNT(unit, id)             \
    (COL_INFO(unit,id).ref_count)

#define COL_USER_UPDATE(unit,id)            \
    (COL_INFO(unit,id).user)

#define EXPORT_BK(unit) collector_bk[unit].export_profile_info

#define EXPORT_ID_BMP(unit)                 \
    EXPORT_BK(unit).export_profile_id_bmp->w

#define EXPORT_ID_BMP_SET(unit,id)          \
    SHR_BITSET(EXPORT_ID_BMP(unit),id)

#define EXPORT_ID_BMP_GET(unit,id)          \
    SHR_BITGET(EXPORT_ID_BMP(unit),id)

#define EXPORT_ID_BMP_CLEAR(unit,id)        \
    SHR_BITCLR(EXPORT_ID_BMP(unit),id)

#define EXPORT_REF_COUNT(unit,id)           \
    (EXPORT_BK(unit).ref_count[id].export_ref_count)


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_collector_export_profile_ref_count_update(
    int unit,
    int id,
    int update)
{
    SHR_FUNC_ENTER(unit);

    if (id >= BCMINT_COLLECTOR_EXPORT_PROFILE_ID_MAX) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (EXPORT_REF_COUNT(unit, id) < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    EXPORT_REF_COUNT(unit,id) += update;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_ref_count_update(
    int unit,
    bcm_collector_t id,
    int update)
{
    SHR_FUNC_ENTER(unit);

    if (id > BCMINT_COLLECTOR_ID_MAX) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (COL_REF_COUNT(unit, id) + update < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    COL_REF_COUNT(unit, id) += update;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_user_update(
    int unit,
    bcm_collector_t id,
    bcmi_ltsw_collector_export_app_t user)
{
    SHR_FUNC_ENTER(unit);

    if (id > BCMINT_COLLECTOR_ID_MAX) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    COL_USER_UPDATE(unit,id) = user;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_check_user_is_other(
    int unit,
    bcm_collector_t id,
    bcmi_ltsw_collector_export_app_t my_user)
{
    SHR_FUNC_ENTER(unit);

    if (id > BCMINT_COLLECTOR_ID_MAX) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((COL_USER_UPDATE(unit, id) != bcmiCollectorExportAppNone) &&
        (COL_USER_UPDATE(unit, id) != my_user)) {
        return 1;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_internal_id_get(
    int unit,
    bcm_collector_t id,
    uint32_t *internal_id,
    bcmi_ltsw_collector_transport_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    if (!COL_EXT_ID_BMP_GET(unit, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *internal_id = COL_INT_ID_MAP(unit, id);
    *type = COL_TYPE_MAP(unit, id);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_external_id_get(
    int unit,
    uint32_t internal_id,
    bcmi_ltsw_collector_transport_type_t type,
    bcm_collector_t *id)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiCollectorTransportTypeIpv4Udp:
            if (COL_IPV4_ID_BMP_GET(unit, internal_id) == 0) {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
            break;

        case bcmiCollectorTransportTypeIpv6Udp:
            if (COL_IPV6_ID_BMP_GET(unit, internal_id) == 0) {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
            break;

        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    rv = SHR_E_NOT_FOUND;
    *id = 0;
    COL_EXT_ID_ITER(unit, *id) {
        if ((COL_INT_ID_MAP(unit, *id) == internal_id) &&
            (COL_TYPE_MAP(unit, *id) == type)) {
            rv = SHR_E_NONE;
            break;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_mirror_dest_id_bk(
    int unit,
    bcm_collector_t id,
    bcm_gport_t mirror_dest_id)
{
    SHR_FUNC_ENTER(unit);

    if (id < 0 || id >= BCMINT_COLLECTOR_ID_MAX) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
            (BSL_META_U(unit,
                "Collector(unit %d) Error: Invalid collector ID\n"), unit));
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    COL_MIRROR_DEST_ID(unit, id) = mirror_dest_id;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_mirror_dest_id_get(
    int unit,
    bcm_collector_t id,
    bcm_gport_t *mirror_dest_id)
{
    SHR_FUNC_ENTER(unit);

    if (id < 0 || id >= BCMINT_COLLECTOR_ID_MAX) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
            (BSL_META_U(unit,
                "Collector(unit %d) Error: Invalid collector ID\n"), unit));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    *mirror_dest_id = COL_MIRROR_DEST_ID(unit, id);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_init(int unit)
{
    uint32_t ha_req_size, ha_alloc_size;
    uint32_t export_profile_id_bmp_size;
    uint32_t export_ref_count_size;
    uint32_t collector_id_bitmap_size;
    uint32_t externel_id_bitmap_size;
    uint32_t mirror_dest_id_size;
    uint32_t collector_info_size;
    uint32_t rv = SHR_E_NONE;
    int warmboot = false;
    void *ptr = NULL;

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);

    export_profile_id_bmp_size = sizeof(bcmint_export_profile_id_bmp_t);
    ha_req_size = export_profile_id_bmp_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXPORT_PROFILE_ID_BMP,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXPORT_PROFILE_ID_BMP,
                                           0,
                                           sizeof(bcmint_export_profile_id_bmp_t),
                                           1,
                                           BCMINT_EXPORT_PROFILE_ID_BMP_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }

    collector_bk[unit].export_profile_info.export_profile_id_bmp = ptr;
    ptr = NULL;

    collector_id_bitmap_size = sizeof(bcmint_collector_id_bmp_t);
    ha_req_size = collector_id_bitmap_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLLECTOR_IPV4_ID_BMP,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLLECTOR_IPV4_ID_BMP,
                                           0,
                                           sizeof(bcmint_collector_id_bmp_t),
                                           1,
                                           BCMINT_COLLECTOR_ID_BMP_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }
    collector_bk[unit].collector_info.ipv4_id_bitmap = ptr;
    ptr=NULL;

    collector_id_bitmap_size = sizeof(bcmint_collector_id_bmp_t);
    ha_req_size = collector_id_bitmap_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLLECTOR_IPV6_ID_BMP,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLLECTOR_IPV6_ID_BMP,
                                           0,
                                           sizeof(bcmint_collector_id_bmp_t),
                                           1,
                                           BCMINT_COLLECTOR_ID_BMP_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }
    collector_bk[unit].collector_info.ipv6_id_bitmap = ptr;
    ptr = NULL;
    export_ref_count_size = sizeof(bcmint_collector_export_ref_count_info_t) * BCMINT_COLLECTOR_ID_MAX;
    ha_req_size = export_ref_count_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXPORT_REF_COUNT,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXPORT_REF_COUNT,
                                           0,
                                           export_ref_count_size,
                                           1,
                                           BCMINT_COLLECTOR_EXPORT_REF_COUNT_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }
    collector_bk[unit].export_profile_info.ref_count = ptr;
    ptr = NULL;
    collector_info_size = sizeof(bcmint_collector_info_t) * BCMINT_COLLECTOR_ID_MAX;
    ha_req_size = collector_info_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLL_INFO,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLL_INFO,
                                           0,
                                           collector_info_size,
                                           1,
                                           BCMINT_COLLECTOR_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }

    collector_bk[unit].collector_info.col_info = ptr;
    ptr = NULL;
    externel_id_bitmap_size = sizeof(bcmint_collector_ext_id_bmp_t);
    ha_req_size = externel_id_bitmap_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXTERNAL_ID_BMP,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_EXTERNAL_ID_BMP,
                                           0,
                                           sizeof(bcmint_collector_ext_id_bmp_t),
                                           1,
                                           BCMINT_COLLECTOR_EXT_ID_BMP_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }
    collector_bk[unit].collector_info.externel_id_bitmap = ptr;
    ptr = NULL;
    collector_info_size = sizeof(bcmint_collector_info_t) * BCMINT_COLLECTOR_ID_MAX;
    ha_req_size = collector_info_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLL_INFO,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_COLL_INFO,
                                           0,
                                           collector_info_size,
                                           1,
                                           BCMINT_COLLECTOR_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }

    collector_bk[unit].collector_info.col_info = ptr;
    ptr = NULL;
    mirror_dest_id_size = sizeof(bcmint_collector_mirror_dest_id_info_t) * BCMINT_COLLECTOR_ID_MAX;

    ha_req_size = mirror_dest_id_size;
    ha_alloc_size = ha_req_size;

    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_COLLECTOR, BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_MIRROR_DEST_ID,
                                 "bcmCollector", &ha_alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    /* Report the structure array to ISSU. */
    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_COLLECTOR,
                                           BCMINT_COLLECTOR_SUB_COMP_ID_COLLECTOR_MIRROR_DEST_ID,
                                           0,
                                           mirror_dest_id_size,
                                           1,
                                           BCMINT_COLLECTOR_MIRROR_DEST_ID_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (!warmboot) {
        sal_memset(ptr, 0, ha_req_size);
    }

    collector_bk[unit].collector_info.mirror_dest_id = ptr;

exit:
    if (SHR_FUNC_ERR()) {
        if (!warmboot && collector_bk[unit].export_profile_info.export_profile_id_bmp) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].export_profile_info.export_profile_id_bmp);
            collector_bk[unit].export_profile_info.export_profile_id_bmp = NULL;
        }
        if (!warmboot && collector_bk[unit].collector_info.ipv4_id_bitmap) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].collector_info.ipv4_id_bitmap);
            collector_bk[unit].collector_info.ipv4_id_bitmap = NULL;
        }
        if (!warmboot && collector_bk[unit].collector_info.ipv6_id_bitmap) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].collector_info.ipv6_id_bitmap);
            collector_bk[unit].collector_info.ipv6_id_bitmap = NULL;
        }
        if (!warmboot && collector_bk[unit].collector_info.externel_id_bitmap) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].collector_info.externel_id_bitmap);
            collector_bk[unit].collector_info.externel_id_bitmap = NULL;
        }
        if (!warmboot && collector_bk[unit].export_profile_info.ref_count) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].export_profile_info.ref_count);
            collector_bk[unit].export_profile_info.ref_count = NULL;
        }
        if (!warmboot && collector_bk[unit].collector_info.col_info) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].collector_info.col_info);
            collector_bk[unit].collector_info.col_info = NULL;
        }
        if (!warmboot && collector_bk[unit].collector_info.mirror_dest_id) {
            (void)bcmi_ltsw_ha_mem_free(unit, collector_bk[unit].collector_info.mirror_dest_id);
            collector_bk[unit].collector_info.mirror_dest_id = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_export_profile_create(
    int unit,
    uint32_t options,
    bcm_collector_t *id,
    bcm_collector_export_profile_t *export_profile_info)
{
	int index = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bool id_found = FALSE;

    SHR_FUNC_ENTER(unit);

    if ((options & BCM_COLLECTOR_EXPORT_PROFILE_REPLACE) &&
       !(options & BCM_COLLECTOR_EXPORT_PROFILE_WITH_ID)) {
        return SHR_E_PARAM;
    }

    /* WITH_ID */
    if (!(options & BCM_COLLECTOR_EXPORT_PROFILE_REPLACE)) {
        if (options & BCM_COLLECTOR_EXPORT_PROFILE_WITH_ID) {
            if (EXPORT_ID_BMP_GET(unit, *id)) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                    (BSL_META_U(unit,
                        "Collector(unit %d) Error: Export Profile ID is already in use\n"), unit));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            id_found = TRUE;
        } else {
            for (index = 0; index < BCMINT_COLLECTOR_EXPORT_PROFILE_ID_MAX; index++) {
                if (!EXPORT_ID_BMP_GET(unit, index)) {
                    id_found = TRUE;
                    *id = index;
                    break;
                }
            }
        }
        if (id_found == FALSE) {
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                (BSL_META_U(unit,
                    "Collector(unit %d) Error: All Export Profile IDs are in use\n"), unit));
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    if ((options & BCM_COLLECTOR_EXPORT_PROFILE_WITH_ID)  &&
        (options & BCM_COLLECTOR_EXPORT_PROFILE_REPLACE)) {
        if (!EXPORT_ID_BMP_GET(unit, *id)) {
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                    (BSL_META_U(unit,
                        "Collector(unit %d) Error: Export Profile ID is already in use\n"), unit));
                SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(unit, MON_EXPORT_PROFILEs, &entry_hdl));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, MON_EXPORT_PROFILE_IDs, *id));


    if (export_profile_info->wire_format == bcmCollectorWireFormatIpfix) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, WIRE_FORMATs, "IPFIX"));
    } else if (export_profile_info->wire_format == bcmCollectorWireFormatProtoBuf) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, WIRE_FORMATs, "PROTOBUF"));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, INTERVALs, export_profile_info->export_interval));

    if (export_profile_info->flags & BCM_COLLECTOR_EXPORT_PROFILE_FLAGS_USE_NUM_RECORDS) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PACKET_LEN_INDICATORs,
                                          "NUM_RECORDS"));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, NUM_RECORDSs,
                                   export_profile_info->num_records));
    } else {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PACKET_LEN_INDICATORs,
                                          "MAX_PKT_LENGTH"));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MAX_PKT_LENGTHs,
                                   export_profile_info->max_packet_length));
    }
    if (id_found == TRUE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl,
                                  BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
        EXPORT_ID_BMP_SET(unit, *id);
    }

    if ((options & BCM_COLLECTOR_EXPORT_PROFILE_WITH_ID)  &&
        (options & BCM_COLLECTOR_EXPORT_PROFILE_REPLACE)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry_hdl));
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_export_profile_get(
    int unit,
    int id,
    bcm_collector_export_profile_t *export_profile_info)
{

    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    const char* symbol = NULL;

    SHR_FUNC_ENTER(unit);

    if (!EXPORT_ID_BMP_GET(unit, id)) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
        (BSL_META_U(unit,
                    "Collector(unit %d) Error: Export Profile ID does not exist\n"), unit));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(unit, MON_EXPORT_PROFILEs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, MON_EXPORT_PROFILE_IDs, id));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry, WIRE_FORMATs, &symbol));

    if (!sal_strcmp(symbol, "IPFIX")) {
        export_profile_info->wire_format = bcmCollectorWireFormatIpfix;
    } else if (!sal_strcmp(symbol, "PROTOBUF")) {
        export_profile_info->wire_format = bcmCollectorWireFormatProtoBuf;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry, INTERVALs, (uint64_t *)&export_profile_info->export_interval));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry, PACKET_LEN_INDICATORs, &symbol));

    if (!sal_strcmp(symbol, "MAX_PKT_LENGTH")) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry, MAX_PKT_LENGTHs, (uint64_t *)&export_profile_info->max_packet_length));
    } else if (!sal_strcmp(symbol, "NUM_RECORDS")) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry, NUM_RECORDSs, (uint64_t *)&export_profile_info->num_records));
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry));
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_export_profile_ids_get_all(
    int unit,
    int max_size,
    int *export_profile_ids_list,
    int *list_size)
{
	int i;
    int num_export_profiles = 0;

    SHR_FUNC_ENTER(unit);

    if (max_size != 0 && export_profile_ids_list == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    for (i = 0; i < BCMINT_COLLECTOR_EXPORT_PROFILE_ID_MAX; i++) {
        if (EXPORT_ID_BMP_GET(unit, i)) {
            num_export_profiles++;
            if (*list_size < max_size) {
                if (max_size != 0) {
                    export_profile_ids_list[*list_size] = i;
                }
                (*list_size)++;
            }
        }
    }

    /* If the max_size is 0 then return the number of collector export profiles
     * configured in list_size
     */
    if (max_size == 0) {
        *list_size = num_export_profiles;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_export_profile_destroy(
    int unit,
    int id)
{
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (EXPORT_REF_COUNT(unit,id) != 0) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
        (BSL_META_U(unit,
                    "Collector(unit %d) Error: Export Profile is in use\n"), unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(unit, MON_EXPORT_PROFILEs, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry, MON_EXPORT_PROFILE_IDs, id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry, BCMLT_OPCODE_DELETE,BCMLT_PRIORITY_NORMAL));

    EXPORT_ID_BMP_CLEAR(unit, id);

exit:
    if (BCMLT_INVALID_HDL != entry) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry));
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_create(
    int unit,
    uint32_t options,
    bcm_collector_t *id,
    bcm_collector_info_t *collector_info)
{
    int external_id = 0, internal_id = 0, i;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bool id_found = FALSE;
    uint64_t mac = 0, tmp_64_val;
    uint64_t src_ipv6_lower = 0, src_ipv6_upper = 0, dst_ipv6_lower = 0, dst_ipv6_upper = 0;

    SHR_FUNC_ENTER(unit);

    if ((options & BCM_COLLECTOR_EXPORT_PROFILE_REPLACE) &&
        !(options & BCM_COLLECTOR_EXPORT_PROFILE_WITH_ID)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Validate ETH header */
    switch (collector_info->eth.vlan_tag_structure) {
        case BCM_COLLECTOR_ETH_HDR_UNTAGGED:
            /* Nothing to validate */
            break;

        case BCM_COLLECTOR_ETH_HDR_SINGLE_TAGGED:
            if (collector_info->eth.outer_vlan_tag > BCM_VLAN_MAX) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "COLLECTOR(unit %d) Error: Invalid outer_vlan_tag=%d\n"),
                           unit, collector_info->eth.outer_vlan_tag));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;

        case BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED:
            if ((collector_info->eth.outer_vlan_tag > BCM_VLAN_MAX) ||
                (collector_info->eth.inner_vlan_tag > BCM_VLAN_MAX)) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "COLLECTOR(unit %d) Error: Invalid outer_vlan_tag(%d)"
                                      " or inner_vlan_tag(%d) \n"),
                           unit, collector_info->eth.outer_vlan_tag,
                           collector_info->eth.inner_vlan_tag));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;

        default:
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                      (BSL_META_U(unit,
                                  "COLLECTOR(unit %d) Error: Invalid vlan_tag_structure=%d\n"),
                       unit, collector_info->eth.vlan_tag_structure));
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Check collector transport type is valid or not */
    if ((collector_info->transport_type < bcmCollectorTransportTypeIpv4Udp) ||
        (collector_info->transport_type >= bcmCollectorTransportTypeCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
        if((collector_info->ipv4.src_ip == 0) ||
           (collector_info->ipv4.dst_ip == 0))
        {
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                  (BSL_META_U(unit,
                  "COLLECTOR(unit %d) Error: Invalid IP configuration"), unit));
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if((collector_info->udp.src_port == 0) ||
           (collector_info->udp.dst_port == 0))
        {
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                 (BSL_META_U(unit,
                 "COLLECTOR(unit %d) Error: Invalid UDP configuration"), unit));
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    /* WITH_ID */
    if (!(options & BCM_COLLECTOR_REPLACE)) {
        if (options & BCM_COLLECTOR_WITH_ID) {
            /* Check the global array if the id is available .*/
            if (COL_EXT_ID_BMP_GET(unit, *id)) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                    (BSL_META_U(unit,
                        "Collector(unit %d) Error: Collector ID is already in use\n"), unit));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            external_id = *id;
        } else {
            for (external_id = 0; external_id < BCMINT_COLLECTOR_ID_MAX; external_id++) {
                if (!COL_EXT_ID_BMP_GET(unit, external_id)) {
                    id_found = TRUE;
                    *id = external_id;
                    break;
                }
            }

            if (id_found == FALSE) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                    (BSL_META_U(unit,
                    "Collector(unit %d) Error: All Collector IDs are in use\n"), unit));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        /* Reserve the index in respective transport type LT. */
        if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
            for (internal_id = 0;
                 internal_id < BCMINT_COLLECTOR_ID_MAX_PER_TYPE;
                 internal_id++) {
                if (!COL_IPV4_ID_BMP_GET(unit, internal_id)) {
                    COL_TYPE_MAP(unit, external_id) = bcmiCollectorTransportTypeIpv4Udp;
                    COL_INT_ID_MAP(unit, external_id) = internal_id;
                    COL_IPV4_ID_BMP_SET(unit, internal_id);
                    id_found = TRUE;
                    break;
                }
            }
        }
        if (collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp) {
            for (internal_id = 0;
                 internal_id < BCMINT_COLLECTOR_ID_MAX_PER_TYPE;
                 internal_id++) {
                if (!COL_IPV6_ID_BMP_GET(unit, internal_id)) {
                    COL_TYPE_MAP(unit, external_id) = bcmiCollectorTransportTypeIpv6Udp;
                    COL_INT_ID_MAP(unit, external_id) = internal_id;
                    COL_IPV6_ID_BMP_SET(unit, internal_id);
                    id_found = TRUE;
                    break;
                }
            }
        }
        COL_EXT_ID_BMP_SET(unit, external_id);
    }

    /* Collector update */
    if ((options & BCM_COLLECTOR_WITH_ID) && (options & BCM_COLLECTOR_REPLACE)) {
        if (!COL_EXT_ID_BMP_GET(unit, *id)) {
            LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                (BSL_META_U(unit,
                "Collector(unit %d) Error: Collector ID does not exist\n"), unit));
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV4s, &entry_hdl));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV4_IDs, internal_id));
    } else if (collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp){
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV6s, &entry_hdl));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV6_IDs, internal_id));

    }

    /* WITH_ID and replace, lookup the entry */
    if ((options & BCM_COLLECTOR_WITH_ID)  && (options & BCM_COLLECTOR_REPLACE)) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));
    }
    if (collector_info->eth.vlan_tag_structure == BCM_COLLECTOR_ETH_HDR_UNTAGGED) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TAG_STRUCTUREs, "UNTAGGED"));
    } else if (collector_info->eth.vlan_tag_structure == BCM_COLLECTOR_ETH_HDR_SINGLE_TAGGED) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TAG_STRUCTUREs, "SINGLE_TAGGED"));
    } else if (collector_info->eth.vlan_tag_structure == BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TAG_STRUCTUREs, "DOUBLE_TAGGED"));
    }
    bcmi_ltsw_util_mac_to_uint64(&mac, collector_info->eth.dst_mac);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_MACs, mac));

    bcmi_ltsw_util_mac_to_uint64(&mac, collector_info->eth.src_mac);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, SRC_MACs, mac));

    if (collector_info->eth.vlan_tag_structure != BCM_COLLECTOR_ETH_HDR_UNTAGGED) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, VLAN_IDs, collector_info->eth.outer_vlan_tag));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, TPIDs, collector_info->eth.outer_tpid));
    }

    if (collector_info->eth.vlan_tag_structure == BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, INNER_TPIDs, collector_info->eth.inner_tpid));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, INNER_VLAN_IDs, collector_info->eth.inner_vlan_tag));
    }

    if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, TOSs, collector_info->ipv4.dscp));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, TTLs, collector_info->ipv4.ttl));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, SRC_IPV4s, collector_info->ipv4.src_ip));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, DST_IPV4s, collector_info->ipv4.dst_ip));

    } else if (collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, TOSs,
                                   collector_info->ipv6.traffic_class));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, TTLs,
                                   collector_info->ipv6.hop_limit));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, FLOW_LABELs,
                                   collector_info->ipv6.flow_label));

        sal_memcpy(&src_ipv6_lower, collector_info->ipv6.src_ip, 8);
        sal_memcpy(&src_ipv6_upper, &(collector_info->ipv6.src_ip[8]), 8);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_LOWERs, src_ipv6_lower));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_UPPERs, src_ipv6_upper));

        sal_memcpy(&dst_ipv6_lower, collector_info->ipv6.dst_ip, 8);
        sal_memcpy(&dst_ipv6_upper, &(collector_info->ipv6.dst_ip[8]), 8);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, DST_IPV6_LOWERs, dst_ipv6_lower));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, DST_IPV6_UPPERs, dst_ipv6_upper));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_L4_UDP_PORTs,
                               collector_info->udp.dst_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, SRC_L4_UDP_PORTs,
                               collector_info->udp.src_port));

    if (collector_info->udp.flags & BCM_COLLECTOR_UDP_FLAGS_CHECKSUM_ENABLE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, UDP_CHKSUMs, 1));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, SYSTEM_ID_LENs,
                               collector_info->protobuf.system_id_length));

    for (i = 0; i < collector_info->protobuf.system_id_length; i++) {
        tmp_64_val = collector_info->protobuf.system_id[i];
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, SYSTEM_IDs, i, &tmp_64_val, 1));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, COMPONENT_IDs,
                               collector_info->protobuf.component_id));

    /* IPFIX header */
    COMPILER_64_SET(tmp_64_val, 0, collector_info->ipfix.observation_domain_id);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, OBSERVATION_DOMAINs, tmp_64_val));

    COMPILER_64_SET(tmp_64_val, 0, collector_info->ipfix.enterprise_number);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, IPFIX_ENTERPRISE_NUMBERs, tmp_64_val));

    COMPILER_64_SET(tmp_64_val, 0, collector_info->ipfix.initial_sequence_num);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, INITIAL_SEQUENCE_NUMBERs, tmp_64_val));

    COMPILER_64_SET(tmp_64_val, 0, collector_info->ipfix.version);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, VERSIONs, tmp_64_val));

    if (id_found == TRUE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl,
                BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL));
    }
    if ((options & BCM_COLLECTOR_WITH_ID)  &&
        (options & BCM_COLLECTOR_REPLACE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl,
                BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry_hdl));
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_get(
    int unit,
    bcm_collector_t id,
    bcm_collector_info_t *collector_info)
{
    int internal_id = 0, transport_type = 0, i;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    const char* symbol;
    uint32_t r_cnt;

    SHR_FUNC_ENTER(unit);

    if (!COL_EXT_ID_BMP_GET(unit, id)) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
            (BSL_META_U(unit,
            "Collector(unit %d) Error: Collector ID does not exist\n"), unit));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    internal_id = COL_INT_ID_MAP(unit,id);
    transport_type = COL_TYPE_MAP(unit, id);
    if (transport_type == bcmiCollectorTransportTypeIpv4Udp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV4s, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV4_IDs, internal_id));
        collector_info->transport_type = bcmCollectorTransportTypeIpv4Udp;
    }

    if (transport_type == bcmiCollectorTransportTypeIpv6Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV6s, &entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV6_IDs, internal_id));
        collector_info->transport_type = bcmCollectorTransportTypeIpv6Udp;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, TAG_STRUCTUREs, &symbol));

    if (!sal_strcmp(symbol, "UNTAGGED")) {
        collector_info->eth.vlan_tag_structure = BCM_COLLECTOR_ETH_HDR_UNTAGGED;
    } else if (!sal_strcmp(symbol, "SINGLE_TAGGED")) {
        collector_info->eth.vlan_tag_structure = BCM_COLLECTOR_ETH_HDR_SINGLE_TAGGED;
    } else if (!sal_strcmp(symbol, "DOUBLE_TAGGED")) {
        collector_info->eth.vlan_tag_structure = BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_MACs, &value));
    bcmi_ltsw_util_uint64_to_mac(collector_info->eth.dst_mac, &value);


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_MACs, &value));
    bcmi_ltsw_util_uint64_to_mac(collector_info->eth.src_mac, &value);

    if (collector_info->eth.vlan_tag_structure == BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, INNER_VLAN_IDs, &value));
        collector_info->eth.inner_vlan_tag = value;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, INNER_TPIDs, &value));
        collector_info->eth.inner_tpid = value;
    }

    if (collector_info->eth.vlan_tag_structure != BCM_COLLECTOR_ETH_HDR_UNTAGGED) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, VLAN_IDs, &value));
        collector_info->eth.outer_vlan_tag = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TPIDs, &value));
        collector_info->eth.outer_tpid = value;
    }

    if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, TOSs, &value));
        collector_info->ipv4.dscp = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, TTLs, &value));
        collector_info->ipv4.ttl = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV4s, &value));
        collector_info->ipv4.src_ip = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV4s, &value));
        collector_info->ipv4.dst_ip = value;
    } else if (collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, TOSs, &value));
        collector_info->ipv6.traffic_class = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, TTLs, &value));
        collector_info->ipv6.hop_limit = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, FLOW_LABELs, &value));
        collector_info->ipv6.flow_label = value;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_LOWERs, &value));
        sal_memcpy(&collector_info->ipv6.src_ip, &value, 8);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_UPPERs, &value));
        sal_memcpy(&collector_info->ipv6.src_ip[8], &value, 8);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV6_LOWERs, &value));
        sal_memcpy(&collector_info->ipv6.dst_ip, &value, 8);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV6_UPPERs, &value));
        sal_memcpy(&collector_info->ipv6.dst_ip[8], &value, 8);
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_L4_UDP_PORTs, &value));
    collector_info->udp.dst_port = value;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_L4_UDP_PORTs, &value));
    collector_info->udp.src_port= value;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, UDP_CHKSUMs, &value));
    if (value != 0) {
        collector_info->udp.flags |= BCM_COLLECTOR_UDP_FLAGS_CHECKSUM_ENABLE;
    }


    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, SYSTEM_ID_LENs, &value));
    collector_info->protobuf.system_id_length = value;

    for (i = 0; i < collector_info->protobuf.system_id_length; i++) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, SYSTEM_IDs, i, &value, 1, &r_cnt));
        collector_info->protobuf.system_id[i] = value;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, COMPONENT_IDs, &value));
    collector_info->protobuf.component_id = value;

    /* IPFIX header */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, OBSERVATION_DOMAINs, &value));
    COMPILER_64_TO_32_LO(collector_info->ipfix.observation_domain_id, value);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPFIX_ENTERPRISE_NUMBERs, &value));
    COMPILER_64_TO_32_LO(collector_info->ipfix.enterprise_number, value);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, INITIAL_SEQUENCE_NUMBERs, &value));
    COMPILER_64_TO_32_LO(collector_info->ipfix.initial_sequence_num, value);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, VERSIONs, &value));
    COMPILER_64_TO_32_LO(collector_info->ipfix.version, value);

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry_hdl));
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_get_all(
    int unit,
    int max_size,
    bcm_collector_t *collector_list,
    int *list_size)
{
    int i;
    int num_collectors;

    SHR_FUNC_ENTER(unit);

    if (max_size != 0 && collector_list == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    num_collectors = 0;
    *list_size = 0;

    for (i = 0;  i < BCMINT_COLLECTOR_ID_MAX; i++) {
        if (COL_EXT_ID_BMP_GET(unit, i)) {
            num_collectors++;
            if (*list_size < max_size) {
                if (max_size != 0) {
                    collector_list[*list_size] = i;
                }
                (*list_size)++;
            }
        }
    }

    if (max_size == 0) {
        *list_size = num_collectors;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_collector_destroy(
    int unit,
    bcm_collector_t id)
{
    int internal_id , transport_type;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (!COL_EXT_ID_BMP_GET(unit, id)) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
            (BSL_META_U(unit,
                "Collector(unit %d) Error: Collector ID is not in use\n"), unit));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (COL_REF_COUNT(unit, id) != 0) {
        LOG_ERROR(BSL_LS_BCM_COLLECTOR,
            (BSL_META_U(unit,
                "Collector(unit %d) Error: Collector in use\n"), unit));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    internal_id = COL_INT_ID_MAP(unit, id);
    transport_type = COL_TYPE_MAP(unit, id);

    if (transport_type == bcmiCollectorTransportTypeIpv4Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV4s, &entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV4_IDs, internal_id));

    } else if (transport_type == bcmiCollectorTransportTypeIpv6Udp) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(unit, MON_COLLECTOR_IPV6s, &entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, MON_COLLECTOR_IPV6_IDs, internal_id));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));
    if (transport_type == bcmiCollectorTransportTypeIpv4Udp) {
        COL_IPV4_ID_BMP_CLEAR(unit, internal_id);
    } else if (transport_type == bcmiCollectorTransportTypeIpv6Udp) {
        COL_IPV6_ID_BMP_CLEAR(unit, internal_id);
    }
    COL_EXT_ID_BMP_CLEAR(unit, id);

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        SHR_IF_ERR_EXIT(bcmlt_entry_free(entry_hdl));
    }
    SHR_FUNC_EXIT();
}

