/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/ipmc.h>
#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/ipmc.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/ipmc.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/xfs/types.h>

#include <sal/sal_mutex.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_IPMC

/******************************************************************************
 * Private functions
 */

/* Encoding for misc_ctrl_0:
 *      misc_ctrl_0[0:0]: If set, entry is valid;
 *      misc_ctrl_0[1:1]: If set, my_station is hit (applies to L2 HOST table);
 *      misc_ctrl_0[3:2]: Opaque info;
 */
#define L2_MISC_CTRL_0_OPQ_CTRL_ID_MAX (0x3)
#define L2_MISC_CTRL_0_OPQ_CTRL_ID(_c) (((_c) >> 2) & 0x3)
#define L2_MISC_CTRL_0(_opaque) (((_opaque & 0x3) << 2) | 1)

/* Encoding for misc_ctrl_1:
 *      misc_ctrl_1[0:0]: If set, packet discard;
 *      misc_ctrl_1[1:1]: If set, packet copy to CPU;
 *      misc_ctrl_1[3:2]: Unused;
 */
#define L2_MISC_CTRL_1_DISCARD(_c) ((_c) & 0x1)
#define L2_MISC_CTRL_1_COPY_TO_CPU(_c) (((_c) >> 1) & 0x1)
#define L2_MISC_CTRL_1(_discard, _cp2cpu)   \
    (((_discard) & 0x1) | (((_cp2cpu) & 0x1) << 1))

/* Generic data structure for L2 IPMC entry info. */
typedef struct ipmc_l2_cfg_s {
    /* Bitmap of fields to be operated. */
    uint64_t fld_bmp;

    /* Fields array. */
    uint64_t flds[XFS_LTSW_IPMC_L2_FLD_CNT];
} ipmc_l2_cfg_t;

/* L2 IPMC traverse control info. */
typedef struct ipmc_l2_trav_s {

    /* Traverse operation. */
    uint32_t op;
#define L2MC_TRAV_OP_DEL      1

    /* User callback function */
    bcm_ipmc_traverse_cb ipmc_trav_cb;

    /* Data provided by the user, cookie */
    void *user_data;
} ipmc_l2_trav_t;

/* IPMC manager info. */
typedef struct ipmc_info_s {
    /* IPMC manager initialized. */
    uint8_t inited;

    /* Mutex */
    sal_mutex_t mutex;

    /* L2 IPMC Flexctr enabled. */
    bool l2_flexctr_en;
} ipmc_info_t;

static ipmc_info_t ipmc_info[BCM_MAX_NUM_UNITS] = {{0}};

#define IPMC_INITED(_u) (ipmc_info[_u].inited)
#define IPMC_LOCK(_u) sal_mutex_take(ipmc_info[_u].mutex, SAL_MUTEX_FOREVER)
#define IPMC_UNLOCK(_u) sal_mutex_give(ipmc_info[_u].mutex)
#define IPMC_L2_FLEXCTR_EN(_u) (ipmc_info[_u].l2_flexctr_en)

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Fill LT entry handle.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] ti LT info.
 * \param [in] cfg Data of L2MC entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_eh_fill(int unit, bcmlt_entry_handle_t eh, const bcmint_ipmc_l2_tbl_t *ti,
           ipmc_l2_cfg_t *cfg)
{
    const bcmint_ipmc_l2_fld_t *fi = ti->flds;
    const char *sym_val;
    uint32_t i;
    int rv = SHR_E_NONE;

    for (i = 0; i < XFS_LTSW_IPMC_L2_FLD_CNT; i++) {
        /* Skip fields that are invalid for the given LT. */
        if (!(ti->fld_bmp & (1 << i))) {
            continue;
        }

        /*
         * Skip fields that are not intended to be operated.
         * Key fields are always required.
         */
        if (!(cfg->fld_bmp & (1 << i)) && !fi[i].key) {
            continue;
        }

        if (fi[i].symbol) {
            rv = fi[i].scalar_to_symbol(unit, cfg->flds[i], &sym_val);
            if (SHR_SUCCESS(rv)) {
                rv = bcmlt_entry_field_symbol_add_by_id(eh, fi[i].fld_id,
                                                        sym_val);
            }
        } else {
            if (fi[i].elements) {
                rv = bcmlt_entry_field_array_add_by_id(eh,
                                                       fi[i].fld_id,
                                                       0,
                                                       &cfg->flds[i],
                                                       fi[i].elements);
            } else {
                rv = bcmlt_entry_field_add_by_id(eh, fi[i].fld_id,
                                                 cfg->flds[i]);
            }
        }
    }

    return rv;
}

/*!
 * \brief Parse entry handle of logical tables.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] ti LT info.
 * \param [out] cfg Data of L2MC entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_eh_parse(int unit, bcmlt_entry_handle_t eh, const bcmint_ipmc_l2_tbl_t *ti,
            ipmc_l2_cfg_t *cfg)
{
    const bcmint_ipmc_l2_fld_t *fi = ti->flds;
    uint32_t i, sz;
    const char *sym_val;
    int rv = SHR_E_NONE;

    for (i = 0; i < XFS_LTSW_IPMC_L2_FLD_CNT; i++) {
        /* Skip fields that are invalid for the given LT. */
        if (!(ti->fld_bmp & (1 << i))) {
            continue;
        }

        /*
         * Skip fields that are not intended to be operated.
         * Key fields are always required.
         */
        if (!(cfg->fld_bmp & (1 << i)) && !fi[i].key) {
            continue;
        }

        if (fi[i].symbol) {
            rv = bcmlt_entry_field_symbol_get_by_id(eh, fi[i].fld_id,
                                                    &sym_val);
            if (SHR_SUCCESS(rv)) {
                rv = fi[i].symbol_to_scalar(unit, sym_val, &cfg->flds[i]);
            }
        } else {
            if (fi[i].elements) {
                rv = bcmlt_entry_field_array_get_by_id(eh,
                                                       fi[i].fld_id,
                                                       0,
                                                       &cfg->flds[i],
                                                       fi[i].elements,
                                                       &sz);
            } else {
                rv = bcmlt_entry_field_get_by_id(eh, fi[i].fld_id,
                                                 &cfg->flds[i]);
            }
        }
    }

    return rv;
}

/*!
 * \brief Promgram R_L2_IPV4_MULTICAST_CONFIG.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_config_init(int unit)
{
    int dunit, rv;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    const bcmint_ipmc_l2_tbl_t *ti;

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        return SHR_E_NONE;
    }

    rv = bcmint_ipmc_l2_tbl_get(unit, XFS_LTSW_IPMC_L2_TBL_IPV4_CONFIG, &ti);
    if (SHR_FAILURE(rv)) {
        return rv;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    rv = bcmlt_entry_allocate_by_id(dunit, ti->tbl_id, ti->fld_cnt, &eh);
    if (SHR_FAILURE(rv)) {
        return rv;
    }

    rv = bcmlt_entry_field_add_by_id(eh,
                         ti->flds[XFS_LTSW_IPMC_L2_FLD_WIDE_VIEW_EN].fld_id,
                         1);
    if (SHR_FAILURE(rv)) {
        (void)bcmlt_entry_free(eh);
        return rv;
    }

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_EXISTS) {
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL);
    }

    (void)bcmlt_entry_free(eh);

    return rv;
}

/*!
 * \brief Construct key feild in ipmc_l2_cfg_t from bcm_ipmc_addr_t.
 *
 * \param [in] unit Unit number.
 * \param [in] data IPMC entry information.
 * \param [out] cfg L2MC cfg information.
 * \param [out] tbl_id L2MC table ID.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_info_to_cfg_key(int unit, bcm_ipmc_addr_t *data, ipmc_l2_cfg_t *cfg,
                        xfs_ltsw_ipmc_l2_tbl_id_t *tbl_id)
{
    uint32_t vfi = 0;
    uint64_t *fv = cfg->flds;
    int rv = SHR_E_NONE;

    if (data->flags & BCM_IPMC_IP6) {
        if (!BCM_IP6_MULTICAST(data->mc_ip6_addr)) {
            return SHR_E_PARAM;
        }

        bcmi_ltsw_util_ip6_to_uint64(&fv[XFS_LTSW_IPMC_L2_FLD_DIP_0],
                                     &(data->mc_ip6_addr));

        bcmi_ltsw_util_ip6_to_uint64(&fv[XFS_LTSW_IPMC_L2_FLD_SIP_0],
                                     &(data->s_ip6_addr));

        if (fv[XFS_LTSW_IPMC_L2_FLD_SIP_0] ||
            fv[XFS_LTSW_IPMC_L2_FLD_SIP_1]) {
            *tbl_id = XFS_LTSW_IPMC_L2_TBL_IPV6_SG;
        } else {
            *tbl_id = XFS_LTSW_IPMC_L2_TBL_IPV6;
        }

    } else {
        if (!BCM_IP4_MULTICAST(data->mc_ip_addr)) {
            return SHR_E_PARAM;
        }

        fv[XFS_LTSW_IPMC_L2_FLD_DIP_0] = data->mc_ip_addr;

        if (data->s_ip_addr != 0) {
            fv[XFS_LTSW_IPMC_L2_FLD_SIP_0] = data->s_ip_addr;
            *tbl_id = XFS_LTSW_IPMC_L2_TBL_IPV4_SG;
        } else {
            if (IPMC_L2_FLEXCTR_EN(unit)) {
                *tbl_id = XFS_LTSW_IPMC_L2_TBL_IPV4_WIDE;
            } else {
                *tbl_id = XFS_LTSW_IPMC_L2_TBL_IPV4;
            }
        }

    }

    rv = bcmi_ltsw_virtual_vfi_idx_get(unit, data->vid, &vfi);
    if (SHR_SUCCESS(rv)) {
        fv[XFS_LTSW_IPMC_L2_FLD_VFI] = vfi;
    }

    return rv;
}

/*!
 * \brief Construct data field in ipmc_l2_cfg_t from bcm_ipmc_addr_t.
 *
 * \param [in] unit Unit number.
 * \param [in] ti Table info.
 * \param [in] data IPMC entry information.
 * \param [out] cfg L2MC cfg information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_info_to_cfg_data(int unit, const bcmint_ipmc_l2_tbl_t *ti,
                         bcm_ipmc_addr_t *data, ipmc_l2_cfg_t *cfg)
{
    int dest, dest_type, discard, cp2cpu, rv = SHR_E_NONE;
    int str_prof_idx, used = 0;
    uint64_t *fv = cfg->flds;
    bcmi_ltsw_sbr_profile_tbl_hdl_t tbl_hdl;
    bcm_multicast_t mc = 0;

    if (data->opaque_ctrl_id > L2_MISC_CTRL_0_OPQ_CTRL_ID_MAX) {
        return SHR_E_PARAM;
    }

    if (_BCM_MULTICAST_IS_L3(data->group_l2) ||
        _BCM_MULTICAST_IS_VPLS(data->group_l2) ||
        _BCM_MULTICAST_IS_FLOW(data->group_l2)) {
        dest = _BCM_MULTICAST_ID_GET(data->group_l2);
        dest_type = BCMI_XFS_DEST_TYPE_L3MC_GROUP;
        rv = bcmi_ltsw_multicast_l3_grp_id_get(unit, dest, &mc);
        if (SHR_FAILURE(rv)) {
            return rv;
        } else if (mc != data->group_l2) {
            return SHR_E_PARAM;
        }
    } else if (_BCM_MULTICAST_IS_L2(data->group_l2)) {
        dest = _BCM_MULTICAST_ID_GET(data->group_l2);
        dest_type = BCMI_XFS_DEST_TYPE_L2MC_GROUP;
        rv = bcmi_ltsw_multicast_l2_grp_validate(unit, dest, &used);
        if (SHR_FAILURE(rv)) {
            return rv;
        } else if (!used) {
            return SHR_E_NOT_FOUND;
        }
    } else {
        return SHR_E_PARAM;
    }
    fv[XFS_LTSW_IPMC_L2_FLD_DEST] = dest;
    fv[XFS_LTSW_IPMC_L2_FLD_DEST_TYPE] = dest_type;

    if (ti->attr & XFS_LTSW_IPMC_L2_TBL_ATTR_V6) {
        if (ti->attr & XFS_LTSW_IPMC_L2_TBL_ATTR_SG) {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV6_MULTICAST_SG;
        } else {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV6_MULTICAST;
        }
    } else {
        if (ti->attr & XFS_LTSW_IPMC_L2_TBL_ATTR_SG) {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV4_MULTICAST_SG;
        } else {
            if (IPMC_L2_FLEXCTR_EN(unit)) {
                tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV4_MULTICAST_WIDE;
            } else {
                tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV4_MULTICAST;
            }
        }
    }
    rv = bcmi_ltsw_sbr_profile_ent_index_get(unit,
                                             tbl_hdl,
                                             BCMI_LTSW_SBR_PET_DEF,
                                             &str_prof_idx);
    if (SHR_FAILURE(rv)) {
        return rv;
    }
    fv[XFS_LTSW_IPMC_L2_FLD_STRENGTH_PROF_IDX] = str_prof_idx;

    fv[XFS_LTSW_IPMC_L2_FLD_CLASS_ID] = data->lookup_class;
    fv[XFS_LTSW_IPMC_L2_FLD_MISC_0] = L2_MISC_CTRL_0(data->opaque_ctrl_id);

    discard = (data->flags & BCM_IPMC_DISCARD) ? 1 : 0;
    cp2cpu = (data->flags & BCM_IPMC_COPYTOCPU) ? 1 : 0;
    fv[XFS_LTSW_IPMC_L2_FLD_MISC_1] = L2_MISC_CTRL_1(discard, cp2cpu);

    return rv;
}

/*!
 * \brief Construct bcm_ipmc_addr_t from ipmc_l2_cfg_t.
 *
 * \param [in] unit Unit number.
 * \param [in] ti LT info.
 * \param [in] cfg L2MC cfg information.
 * \param [out] data IPMC entry information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_cfg_to_info(int unit, const bcmint_ipmc_l2_tbl_t *ti,
                    ipmc_l2_cfg_t *cfg, bcm_ipmc_addr_t *data)
{
    uint64_t value = 0;
    int dest_type, dest, rv = SHR_E_NONE;

    if (ti->attr & XFS_LTSW_IPMC_L2_TBL_ATTR_V6) {
        bcmi_ltsw_util_uint64_to_ip6(&(data->s_ip6_addr),
                                     &cfg->flds[XFS_LTSW_IPMC_L2_FLD_SIP_0]);
        bcmi_ltsw_util_uint64_to_ip6(&(data->mc_ip6_addr),
                                     &cfg->flds[XFS_LTSW_IPMC_L2_FLD_DIP_0]);
        data->flags |= BCM_IPMC_IP6;
    } else {
        data->s_ip_addr = (bcm_ip_t)cfg->flds[XFS_LTSW_IPMC_L2_FLD_SIP_0];
        data->mc_ip_addr = (bcm_ip_t)cfg->flds[XFS_LTSW_IPMC_L2_FLD_DIP_0];
    }

    /* Transform VFI to VPN/vlan */
    rv = bcmi_ltsw_virtual_vpnid_get(unit, cfg->flds[XFS_LTSW_IPMC_L2_FLD_VFI],
                                     &(data->vid));
    if (SHR_FAILURE(rv)) {
        return rv;
    }

    data->flags |= BCM_IPMC_L2;
    data->lookup_class = cfg->flds[XFS_LTSW_IPMC_L2_FLD_CLASS_ID];

    dest_type = cfg->flds[XFS_LTSW_IPMC_L2_FLD_DEST_TYPE];
    dest = cfg->flds[XFS_LTSW_IPMC_L2_FLD_DEST];

    if (dest_type == BCMI_XFS_DEST_TYPE_L3MC_GROUP) {
        rv = bcmi_ltsw_multicast_l3_grp_id_get(unit, dest, &(data->group_l2));
        if (SHR_FAILURE(rv)) {
            return rv;
        }
    } else {
        _BCM_MULTICAST_GROUP_SET(data->group_l2, _BCM_MULTICAST_TYPE_L2, dest);
    }

    value = cfg->flds[XFS_LTSW_IPMC_L2_FLD_MISC_0];
    data->opaque_ctrl_id = L2_MISC_CTRL_0_OPQ_CTRL_ID(value);

    value = cfg->flds[XFS_LTSW_IPMC_L2_FLD_MISC_1];
    data->flags |= L2_MISC_CTRL_1_DISCARD(value) ? BCM_IPMC_DISCARD : 0;
    data->flags |= L2_MISC_CTRL_1_COPY_TO_CPU(value) ? BCM_IPMC_COPYTOCPU : 0;

    return rv;
}

/*!
 * \brief Decrease the reference count for the MC entry.
 *
 * Decrease the reference of Flexctr action.
 *
 * \param [in] unit Unit number.
 * \param [in] ti Logical table info.
 * \param [in] cfg Multicast route entry data.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_refcnt_decr(int unit, const bcmint_ipmc_l2_tbl_t *ti, ipmc_l2_cfg_t *cfg)
{
    bcmi_ltsw_flexctr_counter_info_t ci = {0};
    uint32_t ctr_id;
    int rv;

    /* Flexctr action de-reference. */
    ci.action_index = cfg->flds[XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION];
    if (ci.action_index != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        ci.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;

        rv = bcmi_ltsw_flexctr_counter_id_get(unit, &ci, &ctr_id);
        if (SHR_SUCCESS(rv)) {
            rv = bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                                   ctr_id);
            if (SHR_FAILURE(rv)) {
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit,
                                     "Failed to detach flex counter.\n")));
            }
        }
    }
    return SHR_E_NONE;
}

/*!
 * \brief Operate on LT L2 IPV4/IPV6 MULTICAST Table.
 *
 * \param [in] unit Unit number.
 * \param [in] ti LT info.
 * \param [in] opcode Operation code.
 * \param [in] data IPMC entry information.
 *
 * The reference update is out of scope of this function.
 * The caller MUST handle reference increase/decrease after LT operation.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_lt_op(int unit, const bcmint_ipmc_l2_tbl_t *ti, bcmlt_opcode_t op,
              ipmc_l2_cfg_t *cfg)
{
    int dunit, rv;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    uint64_t fld_bmp = cfg->fld_bmp;

    dunit = bcmi_ltsw_dev_dunit(unit);

    rv = bcmlt_entry_allocate_by_id(dunit, ti->tbl_id, ti->fld_cnt, &eh);
    if (SHR_FAILURE(rv)) {
        return rv;
    }

    if (op == BCMLT_OPCODE_LOOKUP)  {
        /* Not fill in data fields for LOOKUP operation. */
        cfg->fld_bmp = 0;
    }

    rv = lt_eh_fill(unit, eh, ti, cfg);
    if (SHR_FAILURE(rv)) {
        goto exit;
    }

    rv = bcmi_lt_entry_commit(unit, eh, op, BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv)) {
        goto exit;
    }

    if (op == BCMLT_OPCODE_LOOKUP) {
        /* Set bitmap of data fields to be parsed. */
        cfg->fld_bmp = fld_bmp;
        rv = lt_eh_parse(unit, eh, ti, cfg);
    }

exit:
      if (eh != BCMLT_INVALID_HDL) {
          (void)bcmlt_entry_free(eh);
      }
      return rv;
}

/*!
 * \brief Traverse an L2 IPV4/IPV6 MULTICAST Table.
 *
 * \param [in] unit Unit number.
 * \param [in] tbl_id Table ID.
 * \param [in] trav_info Traverse control info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_traverse(int unit, xfs_ltsw_ipmc_l2_tbl_id_t tbl_id,
                 ipmc_l2_trav_t *trav_info)
{
    const bcmint_ipmc_l2_tbl_t *ti;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_del = BCMLT_INVALID_HDL;
    ipmc_l2_cfg_t cfg, next_cfg;
    int dunit, rv, rv1, del;
    bcm_ipmc_addr_t data;
    uint32 inuse_cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_inuse_cnt_get(unit, ti->name, &inuse_cnt));
    if (!inuse_cnt) {
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, ti->tbl_id, ti->fld_cnt, &eh));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, ti->tbl_id, ti->fld_cnt, &eh_del));

    /* Get the first entry. */
    rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        sal_memset(&next_cfg, 0, sizeof(ipmc_l2_cfg_t));
        next_cfg.fld_bmp = ti->fld_bmp;
        SHR_IF_ERR_EXIT
            (lt_eh_parse(unit, eh, ti, &next_cfg));
    }

    while (rv == SHR_E_NONE) {
        del = (trav_info->op == L2MC_TRAV_OP_DEL) ? true : false;

        sal_memcpy(&cfg, &next_cfg, sizeof(ipmc_l2_cfg_t));

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);
        if (SHR_SUCCESS(rv)) {
            /* Save the info in next_cfg, to be operated in next cycle. */
            sal_memset(&next_cfg, 0, sizeof(ipmc_l2_cfg_t));
            next_cfg.fld_bmp = ti->fld_bmp;
            SHR_IF_ERR_EXIT
                (lt_eh_parse(unit, eh, ti, &next_cfg));
        }

        if (del) {
            cfg.fld_bmp = 0;
            SHR_IF_ERR_EXIT
                (lt_eh_fill(unit, eh_del, ti, &cfg));
            SHR_IF_ERR_EXIT
                (bcmlt_entry_commit(eh_del, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_EXIT
                (ipmc_l2_refcnt_decr(unit, ti, &cfg));
        }

        if (trav_info->ipmc_trav_cb) {
            bcm_ipmc_addr_t_init(&data);
            SHR_IF_ERR_EXIT
                (ipmc_l2_cfg_to_info(unit, ti, &cfg, &data));
            rv1 = trav_info->ipmc_trav_cb(unit, &data, trav_info->user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    if (eh_del != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh_del);
    }
    SHR_FUNC_EXIT();
}

static int
ipmc_l2_tables_clear(int unit)
{
    ipmc_l2_trav_t trav = {0};
    int i;

    SHR_FUNC_ENTER(unit);

    trav.op = L2MC_TRAV_OP_DEL;

    for (i = 0; i< XFS_LTSW_IPMC_L2_TBL_CNT; i++) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (ipmc_l2_traverse(unit, i, &trav), SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_ipmc_init(int unit)
{
    ipmc_info_t *info = &ipmc_info[unit];

    SHR_FUNC_ENTER(unit);

    if (info->inited) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_ipmc_detach(unit));
    }

    sal_memset(info, 0, sizeof(ipmc_info_t));

    info->mutex = sal_mutex_create("xfsltswl2mcInfo");
    SHR_NULL_CHECK(info->mutex, SHR_E_MEMORY);

    if (ltsw_feature(unit, LTSW_FT_FLEXCTR_L2_IPMC)) {
        info->l2_flexctr_en = bcmi_ltsw_property_get(unit,
                                             BCMI_CPN_L2_IPMC_FLEXCTR_ENABLE,
                                             0);
        SHR_IF_ERR_EXIT
            (ipmc_l2_config_init(unit));
    }

    info->inited = 1;

exit:
    if (SHR_FUNC_ERR()) {
        if (info->mutex) {
            sal_mutex_destroy(info->mutex);
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_detach(int unit)
{
    ipmc_info_t *info = &ipmc_info[unit];

    SHR_FUNC_ENTER(unit);

    if (!info->inited || !info->mutex) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    sal_mutex_take(info->mutex, SAL_MUTEX_FOREVER);

    info->inited = 0;

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_EXIT
            (ipmc_l2_tables_clear(unit));
    }

    sal_mutex_give(info->mutex);
    sal_mutex_destroy(info->mutex);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_pub_info_get(
    int unit,
    bcmint_ipmc_pub_info_t *mc_pub)
{
    uint32_t width = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
          (bcmi_lt_field_width_get(unit, ING_L3_IIF_TABLEs, RPA_ID_PROFILEs,
                                   &width));

    mc_pub->rp_min = 1;
    mc_pub->rp_max = width - 1;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_add(
    int unit,
    bcm_ipmc_addr_t *data)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};
    bcmlt_opcode_t op;
    bool locked = false;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(data, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, data, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    IPMC_LOCK(unit);
    locked = true;

    op = BCMLT_OPCODE_INSERT;

    if (data->flags & BCM_IPMC_REPLACE) {
        cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION);
        rv = ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_LOOKUP, &cfg);
        if (rv == SHR_E_NOT_FOUND) {
            /* Insert the entry when try to replace a non-existing entry. */
            op = BCMLT_OPCODE_INSERT;
        } else if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(rv);
        } else {
            if (cfg.flds[XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION] !=
                BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
                LOG_ERROR(SHR_E_BUSY,
                          (BSL_META_U(unit,
                                      "Can't replace the entry which "
                                      "has flexctr running.\n")));
                SHR_ERR_EXIT(SHR_E_BUSY);
            }
            op = BCMLT_OPCODE_UPDATE;
        }
    }

    cfg.fld_bmp = ti->fld_bmp;

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_data(unit, ti, data, &cfg));

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, op, &cfg));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_remove(
    int unit,
    bcm_ipmc_addr_t *data)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(data, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, data, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    IPMC_LOCK(unit);
    locked = true;

    /* Get L2 MC entry. */
    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION);
    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_LOOKUP, &cfg));

    /* Delete the L2 MC entry. */
    cfg.fld_bmp = 0;
    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_DELETE, &cfg));

    /* Decrease the reference. */
    SHR_IF_ERR_EXIT
        (ipmc_l2_refcnt_decr(unit, ti, &cfg));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_find(
    int unit,
    bcm_ipmc_addr_t *data)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(data, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, data, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = ti->fld_bmp;
    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_LOOKUP, &cfg));

    SHR_IF_ERR_EXIT
        (ipmc_l2_cfg_to_info(unit, ti, &cfg, data));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_traverse(
    int unit,
    uint32_t flags,
    bcm_ipmc_traverse_cb cb,
    void *user_data)
{
    ipmc_l2_trav_t trav = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    trav.ipmc_trav_cb = cb;
    trav.user_data = user_data;

    IPMC_LOCK(unit);
    locked = true;

    if (flags & BCM_IPMC_IP6) {
        SHR_IF_ERR_EXIT
            (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV6, &trav));

        SHR_IF_ERR_EXIT
            (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV6_SG, &trav));
    } else {
        if (IPMC_L2_FLEXCTR_EN(unit)) {
            SHR_IF_ERR_EXIT
                (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4_WIDE, &trav));
        } else {
            SHR_IF_ERR_EXIT
                (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4, &trav));
        }

        SHR_IF_ERR_EXIT
            (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4_SG, &trav));
    }

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_delete_all(int unit)
{
    ipmc_l2_trav_t trav = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    trav.op = L2MC_TRAV_OP_DEL;

    IPMC_LOCK(unit);
    locked = true;

    if (IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_IF_ERR_EXIT
            (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4_WIDE, &trav));
    } else {
        SHR_IF_ERR_EXIT
            (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4, &trav));
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV4_SG, &trav));

    SHR_IF_ERR_EXIT
        (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV6, &trav));

    SHR_IF_ERR_EXIT
        (ipmc_l2_traverse(unit, XFS_LTSW_IPMC_L2_TBL_IPV6_SG, &trav));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_flexctr_attach(
    int unit,
    bcm_ipmc_addr_t *info,
    bcmi_ltsw_flexctr_counter_info_t *ci)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, info, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION);
    cfg.flds[XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION] = ci->action_index;

    IPMC_LOCK(unit);
    locked = true;

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_UPDATE, &cfg));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_flexctr_detach(
    int unit,
    bcm_ipmc_addr_t *info)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, info, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION);

    IPMC_LOCK(unit);
    locked = true;

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_UPDATE, &cfg));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_flexctr_info_get(
    int unit,
    bcm_ipmc_addr_t *info,
    bcmi_ltsw_flexctr_counter_info_t *ci)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, info, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION);

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_LOOKUP, &cfg));

    ci->stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ci->action_index = cfg.flds[XFS_LTSW_IPMC_L2_FLD_FLEXCTR_ACTION];
    ci->table_name = ti->name;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_flexctr_object_set(
    int unit,
    bcm_ipmc_addr_t *info,
    uint32_t value)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, info, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_OPQ_OBJ);
    cfg.flds[XFS_LTSW_IPMC_L2_FLD_OPQ_OBJ] = value;

    IPMC_LOCK(unit);
    locked = true;

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_UPDATE, &cfg));

exit:
    if (locked) {
        IPMC_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_l2_flexctr_object_get(
    int unit,
    bcm_ipmc_addr_t *info,
    uint32_t *value)
{
    xfs_ltsw_ipmc_l2_tbl_id_t tbl_id;
    const bcmint_ipmc_l2_tbl_t *ti;
    ipmc_l2_cfg_t cfg = {0};

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    if (!IPMC_INITED(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (!IPMC_L2_FLEXCTR_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT
        (ipmc_l2_info_to_cfg_key(unit, info, &cfg, &tbl_id));

    SHR_IF_ERR_EXIT
        (bcmint_ipmc_l2_tbl_get(unit, tbl_id, &ti));

    cfg.fld_bmp = (1ULL << XFS_LTSW_IPMC_L2_FLD_OPQ_OBJ);

    SHR_IF_ERR_EXIT
        (ipmc_l2_lt_op(unit, ti, BCMLT_OPCODE_LOOKUP, &cfg));

    *value = cfg.flds[XFS_LTSW_IPMC_L2_FLD_OPQ_OBJ];

exit:
    SHR_FUNC_EXIT();
}

