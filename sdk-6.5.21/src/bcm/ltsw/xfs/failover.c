/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/failover.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/failover_int.h>
#include <bcm_int/ltsw/property.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FAILOVER

/******************************************************************************
 * Private functions
 */

/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_failover_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    /* Clear L3_PROTECTION_ENABLE table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, L3_PROTECTION_ENABLEs));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_failover_init(int unit)
{
    uint16_t prot_offset;
    uint32_t nh_tbl_size;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    if (bcmi_ltsw_property_get(unit, BCMI_FAILOVER_FIXED_NH_OFFSET_ENABLE, 0)) {
        /* Set NH offset to half size of NEXT_HOP_TABLE_SIZE */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, EGR_L3_NEXT_HOP_1s, &nh_tbl_size));
        prot_offset = nh_tbl_size / 2;
    } else {
        prot_offset = 0;
    }

    /* Set fixed protection NH offset */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_failover_prot_offset_set(unit, prot_offset));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_failover_egress_status_set(
    int unit,
    int nh_idx,
    int enable)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_PROTECTION_ENABLEs, &ent_hdl));

    /* Set NH ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, NHOP_IDs, nh_idx));

    /* Set enable status */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, PROTECTIONs, enable));

    /* Update LT entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_failover_egress_status_get(
    int unit,
    int nh_idx,
    int *enable)
{
    uint64_t value;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_PROTECTION_ENABLEs, &ent_hdl));

    /* Set NH ID*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, NHOP_IDs, nh_idx));

    /* Lookup LT entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    /* Get enable status */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, PROTECTIONs, &value));

    *enable = (int)value;

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

