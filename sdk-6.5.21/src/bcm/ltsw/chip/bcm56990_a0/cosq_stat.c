/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/cosq_stat.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/tm/cosq_stat.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/port.h>

#include <sal/sal_libc.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


#define SYNC_ENABLE                     0x1

#define LTSW_COMPILER_64_UMUL_32(dst, src)    ((dst) *= (src))

static int
is_cpu_port(int unit, bcm_port_t lport)
{
    return bcmi_ltsw_port_is_type(unit, lport,  BCMI_LTSW_PORT_TYPE_CPU);
}


static int
bcm56990_a0_ltsw_cosq_stat_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_stat_t stat,
    int sync_mode,
    uint64_t *value)
{
    int sync = sync_mode ? SYNC_ENABLE : 0;
    bcmi_ltsw_cosq_device_info_t device_info = {0};
    uint64_t packet, byte, wred_pkt;
    uint64_t uc_pkt, mc_pkt;
    uint64_t red_pkt, yellow_pkt;
    uint64_t uc_red_pkt, uc_yellow_pkt;
    uint64_t mc_red_pkt, mc_yellow_pkt;
    uint64_t wred_red_pkt, wred_yellow_pkt;
    uint64_t min, shared, headroom, total;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    switch (stat) {
        case bcmCosqStatDroppedPackets:
        case bcmCosqStatDroppedBytes:
        case bcmCosqStatEgressCongestionDroppedPackets:
        case bcmCosqStatTotalDiscardDroppedPackets:
        case bcmCosqStatDiscardUCDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_port_queue_drop_counter_get(unit, gport, cosq, stat,
                                                       &packet, &byte, &wred_pkt, sync));
            if (stat == bcmCosqStatDroppedPackets) {
                *value = packet;
                *value += wred_pkt;
            } else if (stat == bcmCosqStatDroppedBytes) {
                *value = byte;
            } else if (stat == bcmCosqStatEgressCongestionDroppedPackets) {
                *value = packet;
            } else if ((stat == bcmCosqStatTotalDiscardDroppedPackets) ||
                (stat == bcmCosqStatDiscardUCDroppedPackets)) {
                *value = wred_pkt;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            break;
        case bcmCosqStatGreenDiscardDroppedPackets:
        case bcmCosqStatYellowDiscardDroppedPackets:
        case bcmCosqStatRedDiscardDroppedPackets:
        case bcmCosqStatYellowCongestionDroppedPackets:
        case bcmCosqStatRedCongestionDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_port_queue_color_drop_get(unit, gport, cosq,
                                                             &uc_red_pkt, &uc_yellow_pkt,
                                                             &mc_red_pkt, &mc_yellow_pkt,
                                                             &wred_red_pkt, &wred_yellow_pkt,
                                                             &wred_pkt, sync));
            if (stat == bcmCosqStatGreenDiscardDroppedPackets) {
                *value = wred_pkt;
                *value -= wred_red_pkt;
                *value -= wred_yellow_pkt;
            } else if (stat == bcmCosqStatYellowDiscardDroppedPackets) {
                *value = wred_yellow_pkt;
            } else if (stat == bcmCosqStatRedDiscardDroppedPackets) {
                *value = wred_red_pkt;
            } else if (stat == bcmCosqStatYellowCongestionDroppedPackets) {
                *value = uc_yellow_pkt;
                *value += mc_yellow_pkt;
            } else {
                *value = uc_red_pkt;
                *value += mc_red_pkt;
            }
            break;
        case bcmCosqStatEgressUCQueueMinBytesCurrent:
        case bcmCosqStatEgressMCQueueMinBytesCurrent:
        case bcmCosqStatEgressUCQueueBytesCurrent:
        case bcmCosqStatEgressMCQueueBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_current_usage_get(unit, gport, cosq, stat,
                                                     value, sync));
            LTSW_COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatIngressPortPGMinBytesCurrent:
        case bcmCosqStatIngressPortPGSharedBytesCurrent:
        case bcmCosqStatIngressPortPGHeadroomBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_pg_current_usage_get(unit, gport, cosq, &min,
                                                        &shared, &headroom, sync));
            if (stat == bcmCosqStatIngressPortPGMinBytesCurrent) {
                *value = min;
            } else if (stat == bcmCosqStatIngressPortPGSharedBytesCurrent) {
                *value = shared;
            } else {
                *value = headroom;
            }
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatIngressPortPoolSharedBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_sp_current_usage_get(unit, gport, cosq,
                                                value, sync));

            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatHdrmPoolDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_hp_drop_counter_get(unit, gport, cosq, value, sync));
            break;
        case bcmCosqStatSourcePortDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_ing_port_drop_counter_get(unit, gport, cosq,
                                                     value, sync));
            break;
        case bcmCosqStatRQETotalDroppedPackets:
        case bcmCosqStatRQETotalDroppedBytes:
        case bcmCosqStatRQEGreenDroppedPackets:
        case bcmCosqStatRQEYellowDroppedPackets:
        case bcmCosqStatRQERedDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_rqe_drop_counter_get(unit, gport, cosq, &packet,
                                                        &byte, &red_pkt, &yellow_pkt,
                                                        sync));
            if (stat == bcmCosqStatRQETotalDroppedPackets) {
                *value = packet;
            } else if (stat == bcmCosqStatRQETotalDroppedBytes) {
                *value = byte;
            } else if (stat == bcmCosqStatRQEGreenDroppedPackets) {
                *value = packet - red_pkt;
                *value -= yellow_pkt;
            } else if (stat == bcmCosqStatRQEYellowDroppedPackets) {
                *value = yellow_pkt;
            } else {
                *value = red_pkt;
            }
            break;
        case bcmCosqStatHighPriDroppedPackets:
        case bcmCosqStatOBMLossyHighPriDroppedPackets:
        case bcmCosqStatLowPriDroppedPackets:
        case bcmCosqStatOBMLossyLowPriDroppedPackets:
        case bcmCosqStatHighPriDroppedBytes:
        case bcmCosqStatOBMLossyHighPriDroppedBytes:
        case bcmCosqStatLowPriDroppedBytes:
        case bcmCosqStatOBMLossyLowPriDroppedBytes:
        case bcmCosqStatOBMLossless0DroppedPackets:
        case bcmCosqStatOBMLossless1DroppedPackets:
        case bcmCosqStatOBMLossless0DroppedBytes:
        case bcmCosqStatOBMLossless1DroppedBytes:
        case bcmCosqStatOBMFlowControlEvents:
        case bcmCosqStatOBMHighWatermark:
        case bcmCosqStatOBMLossyBufferBytes:
        case bcmCosqStatOBMLossless0BufferBytes:
        case bcmCosqStatOBMLossless1BufferBytes:
        case bcmCosqStatOBMBufferBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_obm_get(unit, gport, cosq, stat, sync, value));
            break;
        case bcmCosqStatEgressPortUCPacketsCurrent:
        case bcmCosqStatEgressPortMCPacketsCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_port_total_current_usage_get(unit, gport, cosq,
                                                                &uc_pkt, &mc_pkt, sync));
            if (stat == bcmCosqStatEgressPortUCPacketsCurrent) {
                *value = uc_pkt;
            } else {
                *value = mc_pkt;
            }
            break;
        case bcmCosqStatEgressPoolSharedUCBytesCurrent:
        case bcmCosqStatEgressPoolSharedMCBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_egr_sp_shared_current_usage_get(unit, gport, cosq,
                                                                stat, value, sync));
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatHeadroomPoolBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_hp_current_usage_get(unit, gport, cosq, stat,
                                                        value, sync));
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatIngressPoolSharedBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_ing_sp_current_usage_get(unit, gport, cosq,
                                                            stat, value, sync));
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatRQEQueueMinBytesCurrent:
        case bcmCosqStatRQEQueueSharedBytesCurrent:
        case bcmCosqStatRQEQueueTotalBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_rqe_current_usage_get(unit, gport, cosq, &min,
                                                         &shared, &total, sync));
            if (stat == bcmCosqStatRQEQueueMinBytesCurrent) {
                *value = min;
            } else if (stat == bcmCosqStatRQEQueueSharedBytesCurrent) {
                *value = shared;
            } else {
                *value = total;
            }
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatRQEPoolSharedBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_rqe_pool_current_usage_get(unit, gport, cosq,
                                                              stat, value, sync));
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatAdtAlpha0AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha1AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha2AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha3AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha4AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha5AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha6AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha7AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha8AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha9AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha10AdmittedLowPriPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_adt_low_pri_pkt_get(unit, gport, cosq,
                                                       stat, value, sync));
            break;
        case bcmCosqStatEgressPoolAdtAdmittedHighPriBytes:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_adt_high_pri_pkt_get(unit, gport, cosq,
                                                       stat, value, sync));
            COMPILER_64_UMUL_32(*value, device_info.mmu_cell_size);
            break;
        case bcmCosqStatDebugSaf0Packets:
        case bcmCosqStatDebugSaf1Packets:
        case bcmCosqStatDebugSaf2Packets:
        case bcmCosqStatDebugSaf3Packets:
        case bcmCosqStatDebugSaf4Packets:
        case bcmCosqStatDebugSaf5Packets:
        case bcmCosqStatDebugSaf6Packets:
        case bcmCosqStatDebugSaf7Packets:
        case bcmCosqStatDebugCt0Packets:
        case bcmCosqStatDebugCt1Packets:
        case bcmCosqStatDebugCt2Packets:
        case bcmCosqStatDebugCt3Packets:
        case bcmCosqStatDebugCt4Packets:
        case bcmCosqStatDebugCt5Packets:
        case bcmCosqStatDebugCt6Packets:
        case bcmCosqStatDebugCt7Packets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_debug_stat_pkt_get(unit, gport, cosq,
                                                      stat, value, sync));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_stat_t stat,
    uint64_t value)
{
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    switch (stat) {
        case bcmCosqStatDroppedPackets:
        case bcmCosqStatDroppedBytes:
        case bcmCosqStatEgressCongestionDroppedPackets:
        case bcmCosqStatTotalDiscardDroppedPackets:
        case bcmCosqStatDiscardUCDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_port_queue_drop_counter_set(unit, gport, cosq, stat,
                                                       value));
            break;
        case bcmCosqStatGreenDiscardDroppedPackets:
        case bcmCosqStatYellowDiscardDroppedPackets:
        case bcmCosqStatRedDiscardDroppedPackets:
        case bcmCosqStatYellowCongestionDroppedPackets:
        case bcmCosqStatRedCongestionDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_port_queue_color_drop_set(unit, gport, cosq, stat,
                                                     value));
            break;
        case bcmCosqStatHdrmPoolDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_hp_drop_counter_set(unit, gport, cosq, value));
            break;
        case bcmCosqStatSourcePortDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_ing_port_drop_counter_set(unit, gport, cosq, value));
            break;
        case bcmCosqStatRQETotalDroppedPackets:
        case bcmCosqStatRQETotalDroppedBytes:
        case bcmCosqStatRQEGreenDroppedPackets:
        case bcmCosqStatRQEYellowDroppedPackets:
        case bcmCosqStatRQERedDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_rqe_drop_counter_set(unit, gport, cosq, stat,
                                                value));
            break;
        case bcmCosqStatHighPriDroppedPackets:
        case bcmCosqStatOBMLossyHighPriDroppedPackets:
        case bcmCosqStatLowPriDroppedPackets:
        case bcmCosqStatOBMLossyLowPriDroppedPackets:
        case bcmCosqStatHighPriDroppedBytes:
        case bcmCosqStatOBMLossyHighPriDroppedBytes:
        case bcmCosqStatLowPriDroppedBytes:
        case bcmCosqStatOBMLossyLowPriDroppedBytes:
        case bcmCosqStatOBMLossless0DroppedPackets:
        case bcmCosqStatOBMLossless1DroppedPackets:
        case bcmCosqStatOBMLossless0DroppedBytes:
        case bcmCosqStatOBMLossless1DroppedBytes:
        case bcmCosqStatOBMFlowControlEvents:
        case bcmCosqStatOBMHighWatermark:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_obm_set(unit, gport, cosq, stat, value));
            break;
        case bcmCosqStatAdtAlpha0AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha1AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha2AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha3AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha4AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha5AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha6AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha7AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha8AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha9AdmittedLowPriPackets:
        case bcmCosqStatAdtAlpha10AdmittedLowPriPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_adt_low_pri_pkt_set(unit, gport, cosq, stat, value));
            break;
        case bcmCosqStatEgressPoolAdtAdmittedHighPriBytes:
            /* coverity[divide_by_zero] */
            COMPILER_64_UDIV_64(value, device_info.mmu_cell_size);
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_adt_high_pri_pkt_set(unit, gport, cosq, stat, value));
            break;
        case bcmCosqStatDebugSaf0Packets:
        case bcmCosqStatDebugSaf1Packets:
        case bcmCosqStatDebugSaf2Packets:
        case bcmCosqStatDebugSaf3Packets:
        case bcmCosqStatDebugSaf4Packets:
        case bcmCosqStatDebugSaf5Packets:
        case bcmCosqStatDebugSaf6Packets:
        case bcmCosqStatDebugSaf7Packets:
        case bcmCosqStatDebugCt0Packets:
        case bcmCosqStatDebugCt1Packets:
        case bcmCosqStatDebugCt2Packets:
        case bcmCosqStatDebugCt3Packets:
        case bcmCosqStatDebugCt4Packets:
        case bcmCosqStatDebugCt5Packets:
        case bcmCosqStatDebugCt6Packets:
        case bcmCosqStatDebugCt7Packets:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_stat_debug_stat_pkt_set(unit, gport, cosq, stat, value));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_clear(
    int unit,
    int port)
{
    int num_ucq, num_mcq;
    int qid, itm;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    for (itm = 0; itm < device_info.num_itm; itm++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_port_queue_color_drop_clear(unit, port, itm));

        if (is_cpu_port(unit, port)) {
            for (qid = 0; qid < device_info.num_cpu_queue; qid++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_stat_port_queue_drop_counter_clear(unit,
                                                                     port,
                                                                     itm,
                                                                     qid,
                                                                     FALSE));
            }
        } else {
            for (qid = 0; qid < num_ucq; qid++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_stat_port_queue_drop_counter_clear(unit,
                                                                     port,
                                                                     itm,
                                                                     qid,
                                                                     TRUE));
            }

            for (qid = 0; qid < num_mcq; qid++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_stat_port_queue_drop_counter_clear(unit,
                                                                     port,
                                                                     itm,
                                                                     qid,
                                                                     FALSE));
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_stat_ing_port_drop_counter_clear(unit, port));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_debug_stat_match_get(
    int unit,
    bcm_port_t port,
    bcm_cosq_stat_t stat,
    bcm_cosq_debug_stat_match_t *match)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_stat_debug_stat_match_get(unit, port, stat, match));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_debug_stat_match_set(
    int unit,
    bcm_port_t port,
    bcm_cosq_stat_t stat,
    bcm_cosq_debug_stat_match_t *match)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_stat_debug_stat_match_set(unit, port, stat, match));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_sync_multi_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    int nstat,
    bcm_cosq_stat_t *stat_arr,
    uint64_t *value_arr)
{
    int stix;
    int rv;

    for (stix = 0; stix < nstat; stix++) {
        rv = bcm_ltsw_cosq_stat_sync_get(unit, gport, cosq, stat_arr[stix],
                                         &(value_arr[stix]));
        if (SHR_FAILURE(rv)) {
            return rv;
        }
    }

    return SHR_E_NONE;
}

static int
bcm56990_a0_ltsw_cosq_stat_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_obm_counter_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_rqe_drop_counter_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_port_queue_color_drop_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_port_queue_drop_counter_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_hp_drop_counter_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_ing_port_drop_counter_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_adt_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_debug_stat_init(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_stat_detach(int unit)
{
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_obm_counter_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_rqe_drop_counter_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_port_queue_color_drop_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_port_queue_drop_counter_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_hp_drop_counter_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_ing_port_drop_counter_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_adt_detach(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_stat_debug_stat_detach(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Cosq_stat driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_cosq_stat_drv_t bcm56990_a0_ltsw_cosq_stat_drv = {
    .cosq_stat_get = bcm56990_a0_ltsw_cosq_stat_get,
    .cosq_stat_set = bcm56990_a0_ltsw_cosq_stat_set,
    .cosq_stat_clear = bcm56990_a0_ltsw_cosq_stat_clear,
    .cosq_stat_debug_stat_match_get = bcm56990_a0_ltsw_cosq_stat_debug_stat_match_get,
    .cosq_stat_debug_stat_match_set = bcm56990_a0_ltsw_cosq_stat_debug_stat_match_set,
    .cosq_stat_sync_multi_get = bcm56990_a0_ltsw_cosq_stat_sync_multi_get,
    .cosq_stat_init = bcm56990_a0_ltsw_cosq_stat_init,
    .cosq_stat_detach = bcm56990_a0_ltsw_cosq_stat_detach
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_cosq_stat_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_cosq_stat_drv_set(unit, &bcm56990_a0_ltsw_cosq_stat_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_cosq_stat_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_cosq_stat_drv_set(unit, &bcm56990_a0_ltsw_cosq_stat_drv)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
