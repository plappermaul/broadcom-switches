/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/flexstate.h>

#include <bcm_int/ltsw/flexstate_int.h>
#include <bcm_int/ltsw/mbcm/flexstate.h>
#include <bcm_int/ltsw/chip/bcm56880_a0/variant_dispatch.h>
#include <bcm_int/ltsw/flexstate.h>
#include <bcm_int/ltsw/profile_mgmt.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLEXSTATE

/*!
 * \brief Flex state action mode enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_action_mode_enum[] = {
    { NORMALs, bcmFlexstateCounterModeNormal },
    { WIDEs, bcmFlexstateCounterModeWide },
};

/*!
 * \brief Flex state action source enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_action_source_enum[] = {
    { NOOPs, bcmFlexstateValueSelectCounterValue },
    { USE_PAIRED_COUNTERs, bcmFlexstateValueSelectPairedCounter },
};

/*!
 * \brief Flex state action scale enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_action_scale_enum[] = {
    { SCALE_INFINITEs, bcmFlexstateTriggerIntervalUnlimited },
    { SCALE_128_NSECs, bcmFlexstateTriggerInterval100ns },
    { SCALE_512_NSECs, bcmFlexstateTriggerInterval500ns },
    { SCALE_1024_NSECs, bcmFlexstateTriggerInterval1us },
    { SCALE_8_USECs, bcmFlexstateTriggerInterval10us },
    { SCALE_131_USECs, bcmFlexstateTriggerInterval100us },
    { SCALE_1_MSECs, bcmFlexstateTriggerInterval1ms },
    { SCALE_8_MSECs, bcmFlexstateTriggerInterval10ms },
};

/*!
 * \brief Flex state quantization object enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_quant_object_enum[] = {
    { USE_RANGE_CHK_1s, 0x0 },
    { USE_RANGE_CHK_2s, 0x1 },
    { USE_RANGE_CHK_3s, 0x2 },
    { USE_RANGE_CHK_4s, 0x3 },
};

/*!
 * \brief Flex state value update compare enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_update_comp_enum[] = {
    { ALWAYS_TRUEs, bcmFlexstateUpdateCompareAlwaysTrue },
    { EQUALSs, bcmFlexstateUpdateCompareEqual },
    { LESSs, bcmFlexstateUpdateCompareLess },
};

/*!
 * \brief Flex state value update mode enumeration mapping.
 */
static bcmint_flexstate_enum_map_t bcm56880_a0_ltsw_flexstate_update_mode_enum[] = {
    { NOOPs, bcmFlexstateValueOperationTypeNoop },
    { SETs, bcmFlexstateValueOperationTypeSet },
    { INCs, bcmFlexstateValueOperationTypeInc },
    { DECs, bcmFlexstateValueOperationTypeDec },
    { MAXs, bcmFlexstateValueOperationTypeMax },
    { MINs, bcmFlexstateValueOperationTypeMin },
    { AVGs, bcmFlexstateValueOperationTypeAverage },
    { SETBITs, bcmFlexstateValueOperationTypeSetBit },
    { REV_DECs, bcmFlexstateValueOperationTypeRdec },
    { XORs, bcmFlexstateValueOperationTypeXor },
};

/******************************************************************************
 * Private functions
 */


static bcmint_flexstate_stage_info_t bcm56880_a0_st_info[BCMI_LTSW_FLEXSTATE_STAGE_COUNT] = {
    {
        .stage = BCMI_LTSW_FLEXSTATE_STAGE_ING_LKUP,
        .name = "ing flexstate lookup",
        .dir = BCMI_LTSW_FLEXSTATE_DIR_INGRESS,
        .ha_pool_id = BCMINT_FLEXSTATE_ING_LKUP_POOL_SUB_COMP_ID,
        .ha_quant_id = BCMINT_FLEXSTATE_ING_LKUP_QUANT_SUB_COMP_ID,
        .ha_action_id = BCMINT_FLEXSTATE_ING_LKUP_ACTION_SUB_COMP_ID,
        .ha_grp_act_id = BCMINT_FLEXSTATE_ING_LKUP_GRP_ACTION_SUB_COMP_ID,
        .ph = {
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE0,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE1,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE2,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE3,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE4,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE5,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE6,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_LKUP_PIPE7,
        },
        .obj_quant_cfg = FLEX_STATE_ING_OBJ_QUANTIZATIONs,
        .range_chk_profile = FLEX_STATE_ING_RANGE_CHK_PROFILEs,
        .range_chk_profile_id = FLEX_STATE_ING_RANGE_CHK_PROFILE_IDs,
        .act_profile = FLEX_STATE_ING_ACTION_PROFILEs,
        .act_profile_id = FLEX_STATE_ING_ACTION_PROFILE_IDs,
        .act_index = INDEX_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_comp = VAL_A_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_true = VAL_A_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_false = VAL_A_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_comp = VAL_B_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_true = VAL_B_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_false = VAL_B_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .grp_act_profile = FLEX_STATE_ING_GROUP_ACTION_PROFILEs,
        .grp_act_profile_id = FLEX_STATE_ING_GROUP_ACTION_PROFILE_IDs,
        .operand_profile = FLEX_STATE_ING_OPERAND_PROFILEs,
        .operand_profile_id = FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .stats = FLEX_STATE_ING_STATSs,
        .trigger = FLEX_STATE_ING_TRIGGERs,
        .err_stats = FLEX_STATE_ING_ERROR_STATSs,
        .inst = ING_POST_LKUP_INSTs,
    },
    {
        .stage = BCMI_LTSW_FLEXSTATE_STAGE_ING_FWD,
        .name = "ing flexstate forward",
        .dir = BCMI_LTSW_FLEXSTATE_DIR_INGRESS,
        .ha_pool_id = BCMINT_FLEXSTATE_ING_FWD_POOL_SUB_COMP_ID,
        .ha_quant_id = BCMINT_FLEXSTATE_ING_FWD_QUANT_SUB_COMP_ID,
        .ha_action_id = BCMINT_FLEXSTATE_ING_FWD_ACTION_SUB_COMP_ID,
        .ha_grp_act_id = BCMINT_FLEXSTATE_ING_FWD_GRP_ACTION_SUB_COMP_ID,
        .ph = {
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE0,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE1,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE2,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE3,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE4,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE5,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE6,
            BCMI_LTSW_PROFILE_FLEXSTATE_ING_FWD_PIPE7,
        },
        .obj_quant_cfg = FLEX_STATE_ING_OBJ_QUANTIZATIONs,
        .range_chk_profile = FLEX_STATE_ING_RANGE_CHK_PROFILEs,
        .range_chk_profile_id = FLEX_STATE_ING_RANGE_CHK_PROFILE_IDs,
        .act_profile = FLEX_STATE_ING_ACTION_PROFILEs,
        .act_profile_id = FLEX_STATE_ING_ACTION_PROFILE_IDs,
        .act_index = INDEX_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_comp = VAL_A_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_true = VAL_A_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_a_false = VAL_A_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_comp = VAL_B_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_true = VAL_B_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .act_value_b_false = VAL_B_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .grp_act_profile = FLEX_STATE_ING_GROUP_ACTION_PROFILEs,
        .grp_act_profile_id = FLEX_STATE_ING_GROUP_ACTION_PROFILE_IDs,
        .operand_profile = FLEX_STATE_ING_OPERAND_PROFILEs,
        .operand_profile_id = FLEX_STATE_ING_OPERAND_PROFILE_IDs,
        .stats = FLEX_STATE_ING_STATSs,
        .trigger = FLEX_STATE_ING_TRIGGERs,
        .err_stats = FLEX_STATE_ING_ERROR_STATSs,
        .inst = ING_POST_FWD_INSTs,
    },
    {
        .stage = BCMI_LTSW_FLEXSTATE_STAGE_EGR,
        .name = "egr flexstate",
        .dir = BCMI_LTSW_FLEXSTATE_DIR_EGRESS,
        .ha_pool_id = BCMINT_FLEXSTATE_EGR_POOL_SUB_COMP_ID,
        .ha_quant_id = BCMINT_FLEXSTATE_EGR_QUANT_SUB_COMP_ID,
        .ha_action_id = BCMINT_FLEXSTATE_EGR_ACTION_SUB_COMP_ID,
        .ha_grp_act_id = BCMINT_FLEXSTATE_EGR_GRP_ACTION_SUB_COMP_ID,
        .ph = {
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE0,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE1,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE2,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE3,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE4,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE5,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE6,
            BCMI_LTSW_PROFILE_FLEXSTATE_EGR_PIPE7,
        },
        .obj_quant_cfg = FLEX_STATE_EGR_OBJ_QUANTIZATIONs,
        .range_chk_profile = FLEX_STATE_EGR_RANGE_CHK_PROFILEs,
        .range_chk_profile_id = FLEX_STATE_EGR_RANGE_CHK_PROFILE_IDs,
        .act_profile = FLEX_STATE_EGR_ACTION_PROFILEs,
        .act_profile_id = FLEX_STATE_EGR_ACTION_PROFILE_IDs,
        .act_index = INDEX_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_a_comp = VAL_A_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_a_true = VAL_A_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_a_false = VAL_A_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_b_comp = VAL_B_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_b_true = VAL_B_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .act_value_b_false = VAL_B_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .grp_act_profile = FLEX_STATE_EGR_GROUP_ACTION_PROFILEs,
        .grp_act_profile_id = FLEX_STATE_EGR_GROUP_ACTION_PROFILE_IDs,
        .operand_profile = FLEX_STATE_EGR_OPERAND_PROFILEs,
        .operand_profile_id = FLEX_STATE_EGR_OPERAND_PROFILE_IDs,
        .stats = FLEX_STATE_EGR_STATSs,
        .trigger = FLEX_STATE_EGR_TRIGGERs,
        .err_stats = FLEX_STATE_EGR_ERROR_STATSs,
        .inst = NULL,
    },
};


static int
bcm56880_a0_ltsw_flexstate_stage_info_get(
    int unit,
    bcmint_flexstate_stage_info_t **stage_info)
{
    *stage_info = bcm56880_a0_st_info;
    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_action_mode_validate(
    int unit,
    int val)
{
    bcmint_flexstate_enum_map_t *action_mode_db, *em;
    size_t i, count;

    count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_mode_enum);
    action_mode_db = bcm56880_a0_ltsw_flexstate_action_mode_enum;

    if (val < bcmFlexstateCounterModeNormal ||
        val >= bcmFlexstateCounterModeCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid action mode %d\n"), val));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        em = &(action_mode_db[i]);
        if (val == em->val) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex state aciton mode %d "
                                   "not found\n"), val));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_action_mode_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_action_mode_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_mode_enum);

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_action_source_validate(
    int unit,
    int val)
{
    bcmint_flexstate_enum_map_t *action_source_db, *em;
    size_t i, count;

    count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_source_enum);
    action_source_db = bcm56880_a0_ltsw_flexstate_action_source_enum;

    if (val < bcmFlexstateValueSelectCounterValue ||
        val >= bcmFlexstateValueSelectCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid value op select %d\n"), val));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        em = &(action_source_db[i]);
        if (val == em->val) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex state value op select %d "
                                   "not found\n"), val));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_action_source_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_action_source_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_source_enum);

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_trigger_interval_validate(
    int unit,
    int val)
{
    bcmint_flexstate_enum_map_t *interval_db, *em;
    size_t i, count;

    count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_scale_enum);
    interval_db = bcm56880_a0_ltsw_flexstate_action_scale_enum;

    if (val < bcmFlexstateTriggerIntervalUnlimited ||
        val >= bcmFlexstateTriggerIntervalCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid trigger interval %d\n"), val));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        em = &(interval_db[i]);
        if (val == em->val) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex state interval %d not found\n"),
                  val));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_action_scale_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_action_scale_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_action_scale_enum);
    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_quant_object_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_quant_object_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_quant_object_enum);

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_update_comp_validate(
    int unit,
    int val)
{
    bcmint_flexstate_enum_map_t *update_comp_db, *em;
    size_t i, count;

    count = COUNTOF(bcm56880_a0_ltsw_flexstate_update_comp_enum);
    update_comp_db = bcm56880_a0_ltsw_flexstate_update_comp_enum;

    if (val < bcmFlexstateUpdateCompareAlwaysTrue ||
        val >= bcmFlexstateUpdateCompareCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid value update compare %d\n"),
                   val));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        em = &(update_comp_db[i]);
        if (val == em->val) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex state value update compare %d "
                                   "not found\n"), val));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_update_comp_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_update_comp_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_update_comp_enum);

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_update_mode_validate(
    int unit,
    int val)
{
    bcmint_flexstate_enum_map_t *update_mode_db, *em;
    size_t i, count;

    count = COUNTOF(bcm56880_a0_ltsw_flexstate_update_mode_enum);
    update_mode_db = bcm56880_a0_ltsw_flexstate_update_mode_enum;

    if (val < bcmFlexstateValueOperationTypeNoop ||
        val >= bcmFlexstateValueOperationTypeCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid value op type %d\n"),
                   val));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        em = &(update_mode_db[i]);
        if (val == em->val) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex state value op type %d "
                                   "not found\n"), val));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_flexstate_update_mode_enum_map_get(
    int unit,
    const bcmint_flexstate_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56880_a0_ltsw_flexstate_update_mode_enum;
    *count = COUNTOF(bcm56880_a0_ltsw_flexstate_update_mode_enum);

    return SHR_E_NONE;
}

/*!
 * \brief Flexstate driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_flexstate_drv_t bcm56880_a0_ltsw_flexstate_drv = {
    .flexstate_stage_info_get = bcm56880_a0_ltsw_flexstate_stage_info_get,
    .flexstate_action_mode_validate = bcm56880_a0_ltsw_flexstate_action_mode_validate,
    .flexstate_action_mode_enum_map_get = bcm56880_a0_ltsw_flexstate_action_mode_enum_map_get,
    .flexstate_action_source_validate = bcm56880_a0_ltsw_flexstate_action_source_validate,
    .flexstate_action_source_enum_map_get = bcm56880_a0_ltsw_flexstate_action_source_enum_map_get,
    .flexstate_trigger_interval_validate = bcm56880_a0_ltsw_flexstate_trigger_interval_validate,
    .flexstate_action_scale_enum_map_get = bcm56880_a0_ltsw_flexstate_action_scale_enum_map_get,
    .flexstate_quant_object_enum_map_get = bcm56880_a0_ltsw_flexstate_quant_object_enum_map_get,
    .flexstate_update_comp_validate = bcm56880_a0_ltsw_flexstate_update_comp_validate,
    .flexstate_update_comp_enum_map_get = bcm56880_a0_ltsw_flexstate_update_comp_enum_map_get,
    .flexstate_update_mode_validate = bcm56880_a0_ltsw_flexstate_update_mode_validate,
    .flexstate_update_mode_enum_map_get = bcm56880_a0_ltsw_flexstate_update_mode_enum_map_get,
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_flexstate_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexstate_drv_set(unit, &bcm56880_a0_ltsw_flexstate_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_ltsw_variant_drv_attach(unit, BCM56880_A0_LTSW_VARIANT_FLEXSTATE));

exit:
    SHR_FUNC_EXIT();
}

