/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/collector.h>
#include <bcm/mirror.h>
#include <shr/shr_bitop.h>

#include <bcm_int/ltsw/mbcm/collector.h>
#include <bcm_int/ltsw/xfs/collector.h>
#include <bcm_int/ltsw/collector_int.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/switch_int.h>
#include <bcm_int/ltsw/property.h>

#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COLLECTOR

/******************************************************************************
 * Private functions
 */


/* 1st reserved EP Recirculate profile ID for MOD. */
#define COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_1 1

/* 2nd reserved EP Recirculate profile ID for MOD. */
#define COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_2 2

/* Maximum number of mirror destinations. */
#define COL_MIRROR_DEST_NUM 120

static int
collector_mirror_dest_id_validate(
    int unit,
    bcm_gport_t mirror_dest_id,
    bool *dest_id_is_valid)
{
    int dest_id = 0;

    SHR_FUNC_ENTER(unit);
    *dest_id_is_valid = FALSE;

    if (BCM_GPORT_IS_MIRROR(mirror_dest_id)) {
        dest_id = BCM_GPORT_MIRROR_GET(mirror_dest_id);
        /* Check Mirror destination id. */
        if (dest_id < 0 || dest_id >= COL_MIRROR_DEST_NUM) {
            SHR_ERR_EXIT(SHR_E_BADID);
        }
        *dest_id_is_valid = TRUE;
    }

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_collector_export_profile_ref_count_update(
    int unit,
    int id,
    int update)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_export_profile_ref_count_update(unit, id, update));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_ref_count_update(
    int unit,
    bcm_collector_t id,
    int update)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_ref_count_update(unit, id, update));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_user_update(
    int unit,
    bcm_collector_t id,
    bcmi_ltsw_collector_export_app_t user)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_user_update(unit, id, user));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_check_user_is_other(
    int unit,
    bcm_collector_t id,
    bcmi_ltsw_collector_export_app_t my_user)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_check_user_is_other(unit, id, my_user));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_internal_id_get(
    int unit,
    bcm_collector_t id,
    uint32_t *internal_id,
    bcmi_ltsw_collector_transport_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_internal_id_get(unit, id, internal_id, type));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_external_id_get(
    int unit,
    uint32_t internal_id,
    bcmi_ltsw_collector_transport_type_t type,
    bcm_collector_t *id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_external_id_get(unit, internal_id, type, id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_mirror_dest_id_bk(
    int unit,
    bcm_collector_t id,
    bcm_gport_t mirror_dest_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_mirror_dest_id_bk(unit, id, mirror_dest_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_mirror_dest_id_get(
    int unit,
    bcm_collector_t id,
    bcm_gport_t *mirror_dest_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_mirror_dest_id_get(unit, id, mirror_dest_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_export_profile_create(
    int unit,
    uint32_t options,
    bcm_collector_t *id,
    bcm_collector_export_profile_t *export_profile_info)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_collector_export_profile_get(
    int unit,
    int id,
    bcm_collector_export_profile_t *export_profile_info)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_collector_export_profile_ids_get_all(
    int unit,
    int max_size,
    int *export_profile_ids_list,
    int *list_size)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_collector_export_profile_destroy(
    int unit,
    int id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_collector_create(
    int unit,
    uint32_t options,
    bcm_collector_t *id,
    bcm_collector_info_t *collector_info)
{
    bool inited = FALSE, dest_id_is_valid = FALSE;
    int mod_enable = 0;

    bcm_mirror_destination_t mirror_dest;
    bcm_mirror_source_t source;

    SHR_FUNC_ENTER(unit);

    /* Check whether the EP Recirculate profiles are inited. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_switch_init_status_get(unit, &inited));
    mod_enable = bcmi_ltsw_property_get
                    (unit, BCMI_CPN_FLOWTRACKER_DROP_MONITOR_ENABLE, 0);

    if (!inited || !mod_enable) {
        SHR_IF_ERR_MSG_EXIT
            (SHR_E_UNAVAIL,
             (BSL_META_U(unit, "MOD EP RECIRC configuration not inited.\n")));
    }

    /* Check if a valid mirror_dest_id is given. */
    SHR_IF_ERR_VERBOSE_EXIT
        (collector_mirror_dest_id_validate(unit, collector_info->mirror_dest_id,
                                           &dest_id_is_valid));

    if (dest_id_is_valid) {
        bcm_mirror_destination_t_init(&mirror_dest);

        /* Retrieve previous configuration. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_mirror_destination_get(
                unit, collector_info->mirror_dest_id, &mirror_dest));

        /* Use parameters from collector to replace those in mirror destination. */
        mirror_dest.flags |= (BCM_MIRROR_DEST_WITH_ID | BCM_MIRROR_DEST_REPLACE);

        /* Ethernet header. */
        sal_memcpy(mirror_dest.dst_mac, collector_info->eth.dst_mac, 6);
        sal_memcpy(mirror_dest.src_mac, collector_info->eth.src_mac, 6);
        switch (collector_info->eth.vlan_tag_structure) {
            case BCM_COLLECTOR_ETH_HDR_UNTAGGED:
                mirror_dest.vlan_id  = 0;
                mirror_dest.int_pri  = 0;
                mirror_dest.pkt_prio = 0;
                mirror_dest.tpid     = 0;
                break;
            case BCM_COLLECTOR_ETH_HDR_SINGLE_TAGGED:
                mirror_dest.tpid = collector_info->eth.outer_tpid;
                mirror_dest.vlan_id = collector_info->eth.outer_vlan_tag;
                break;
            case BCM_COLLECTOR_ETH_HDR_DOUBLE_TAGGED:
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "Mirror destination does not support"
                                      " double tag configuration.\n")));
                SHR_ERR_EXIT(SHR_E_PARAM);
                break;
            default:
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "Invalid vlan_tag_structure=%d\n"),
                                      collector_info->eth.vlan_tag_structure));
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp) {
            /* IPv4 header. */
            mirror_dest.version    = 4;
            mirror_dest.src_addr   = collector_info->ipv4.src_ip;
            mirror_dest.dst_addr   = collector_info->ipv4.dst_ip;
            mirror_dest.tos        = collector_info->ipv4.dscp;
            mirror_dest.ttl        = collector_info->ipv4.ttl;
        } else if (collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp) {
            /* IPv6 header. */
            mirror_dest.version    = 6;
            sal_memcpy(mirror_dest.src6_addr, collector_info->ipv6.src_ip, 16);
            sal_memcpy(mirror_dest.dst6_addr, collector_info->ipv6.dst_ip, 16);
            mirror_dest.tos        = collector_info->ipv6.traffic_class;
            mirror_dest.flow_label = collector_info->ipv6.flow_label;
            mirror_dest.ttl        = collector_info->ipv6.hop_limit;
        } else if (collector_info->transport_type == bcmCollectorTransportTypeRaw) {
            mirror_dest.version    = 0;
            mirror_dest.src_addr   = 0;
            mirror_dest.dst_addr   = 0;
            sal_memset(mirror_dest.src6_addr, 0, 16);
            sal_memset(mirror_dest.dst6_addr, 0, 16);
            mirror_dest.tos        = 0;
            mirror_dest.flow_label = 0;
            mirror_dest.ttl        = 0;
        }

        /* UDP header. */
        if (collector_info->transport_type == bcmCollectorTransportTypeIpv4Udp ||
            collector_info->transport_type == bcmCollectorTransportTypeIpv6Udp) {
            if((collector_info->udp.src_port == 0) ||
               (collector_info->udp.dst_port == 0))
            {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                     (BSL_META_U(unit, "Invalid UDP configuration.\n")));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            mirror_dest.udp_src_port = collector_info->udp.src_port;
            mirror_dest.udp_dst_port = collector_info->udp.dst_port;
            if (collector_info->udp.flags & BCM_COLLECTOR_UDP_FLAGS_CHECKSUM_ENABLE) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "Mirror destination does not support"
                                      " UDP checksum configuration.\n")));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        /* IPFIX header. */
        {
            mirror_dest.ipfix_version = collector_info->ipfix.version;
            mirror_dest.initial_seq_number = collector_info->ipfix.initial_sequence_num;
            mirror_dest.observation_domain = collector_info->ipfix.observation_domain_id;
            if (collector_info->ipfix.enterprise_number != 0) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "Mirror destination does not support"
                                      " ipfix.enterprise_number configuration.\n")));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        /* Protobuf header. */
        {
            if (collector_info->protobuf.system_id_length != 0 ||
                collector_info->protobuf.component_id != 0) {
                LOG_ERROR(BSL_LS_BCM_COLLECTOR,
                          (BSL_META_U(unit,
                                      "Mirror destination does not support"
                                      " protobuf header configuration.\n")));
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        /* Timestamp source info. */
        {
            if (collector_info->src_ts == bcmCollectorTimestampSourceNTP) {
                mirror_dest.timestamp_mode = bcmMirrorTimestampModeNTP;
            } else if (collector_info->src_ts == bcmCollectorTimestampSourcePTP) {
                mirror_dest.timestamp_mode = bcmMirrorTimestampModePTP;
            }
        }

        mirror_dest.mirror_dest_id = collector_info->mirror_dest_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_mirror_destination_create(unit, &mirror_dest));

        /* Attach mirror config to EP Recirculate profiles. */
        bcm_mirror_source_t_init(&source);
        source.type = bcmMirrorSourceTypeEpRecirc;
        source.ep_recirc_profile_id = COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_1;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_mirror_source_dest_add(unit, &source,
                                             mirror_dest.mirror_dest_id));

        bcm_mirror_source_t_init(&source);
        source.type = bcmMirrorSourceTypeEpRecirc;
        source.ep_recirc_profile_id = COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_2;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_mirror_source_dest_add(unit, &source,
                                             mirror_dest.mirror_dest_id));

    }

    /* Save collector information to collector LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_create(unit, options, id, collector_info));

    if (dest_id_is_valid) {
        /* Bookkeeping mirror_dest_id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56780_a0_ltsw_collector_mirror_dest_id_bk
                (unit, *id, mirror_dest.mirror_dest_id));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_get(
    int unit,
    bcm_collector_t id,
    bcm_collector_info_t *collector_info)
{
    bcm_gport_t mirror_dest_id;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_get(unit, id, collector_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56780_a0_ltsw_collector_mirror_dest_id_get(unit, id,
                                                       &mirror_dest_id));

    collector_info->mirror_dest_id = mirror_dest_id;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_get_all(
    int unit,
    int max_size,
    bcm_collector_t *collector_list,
    int *list_size)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_get_all(unit, max_size, collector_list, list_size));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_collector_destroy(
    int unit,
    bcm_collector_t id)
{
    int rv;
    bool dest_id_is_valid = FALSE;
    bcm_gport_t mirror_dest_id;
    bcm_mirror_source_t source;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56780_a0_ltsw_collector_mirror_dest_id_get(unit, id,
                                                       &mirror_dest_id));

    /* Check if a valid mirror_dest_id was given. */
    SHR_IF_ERR_VERBOSE_EXIT
        (collector_mirror_dest_id_validate(unit, mirror_dest_id,
                                           &dest_id_is_valid));

    if (dest_id_is_valid) {
        bcm_mirror_source_t_init(&source);
        source.type = bcmMirrorSourceTypeEpRecirc;
        source.ep_recirc_profile_id = COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_1;

        rv = bcm_ltsw_mirror_source_dest_delete(unit, &source, mirror_dest_id);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_EXIT(rv);
        }

        bcm_mirror_source_t_init(&source);
        source.type = bcmMirrorSourceTypeEpRecirc;
        source.ep_recirc_profile_id = COL_EP_RECIRC_PROFILE_MOD_RESERVED_ID_2;

        rv = bcm_ltsw_mirror_source_dest_delete(unit, &source, mirror_dest_id);

        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_EXIT(rv);
        }
    }

    /* Clear collector information from collector LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_collector_destroy(unit, id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Collector driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_collector_drv_t bcm56780_a0_ltsw_collector_drv = {
    .collector_export_profile_ref_count_update = bcm56780_a0_ltsw_collector_export_profile_ref_count_update,
    .collector_ref_count_update = bcm56780_a0_ltsw_collector_ref_count_update,
    .collector_user_update = bcm56780_a0_ltsw_collector_user_update,
    .collector_check_user_is_other = bcm56780_a0_ltsw_collector_check_user_is_other,
    .collector_internal_id_get = bcm56780_a0_ltsw_collector_internal_id_get,
    .collector_external_id_get = bcm56780_a0_ltsw_collector_external_id_get,
    .collector_mirror_dest_id_bk = bcm56780_a0_ltsw_collector_mirror_dest_id_bk,
    .collector_mirror_dest_id_get = bcm56780_a0_ltsw_collector_mirror_dest_id_get,
    .collector_init = bcm56780_a0_ltsw_collector_init,
    .collector_export_profile_create = bcm56780_a0_ltsw_collector_export_profile_create,
    .collector_export_profile_get = bcm56780_a0_ltsw_collector_export_profile_get,
    .collector_export_profile_ids_get_all = bcm56780_a0_ltsw_collector_export_profile_ids_get_all,
    .collector_export_profile_destroy = bcm56780_a0_ltsw_collector_export_profile_destroy,
    .collector_create = bcm56780_a0_ltsw_collector_create,
    .collector_get = bcm56780_a0_ltsw_collector_get,
    .collector_get_all = bcm56780_a0_ltsw_collector_get_all,
    .collector_destroy = bcm56780_a0_ltsw_collector_destroy
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_collector_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_collector_drv_set(unit, &bcm56780_a0_ltsw_collector_drv));

exit:
    SHR_FUNC_EXIT();
}

