/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/ltsw/mbcm/flowtracker.h>
#include <bcm_int/ltsw/xfs/flowtracker.h>
#include <bcm_int/ltsw/lt_intf.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcm/flexctr.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/flowtracker_int.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOWTRACKER

/******************************************************************************
 * Private functions
 */

static int
bcm56780_a0_ltsw_flowtracker_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_hash_config_set(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t hash_type,
    int right_rotate_bits)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_hash_config_set(unit, hash_table, instance_num, bank_num, hash_type, right_rotate_bits));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_hash_config_get(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t *hash_type,
    int *right_rotate_bits)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_hash_config_get(unit, hash_table, instance_num, bank_num, hash_type, right_rotate_bits));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_control_set(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_control_set(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_control_get(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_control_get(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_stats_set(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_stats_set(unit, stats));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_stats_get(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_stats_get(unit, stats));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_default_grp_supported(
    int unit,
    bool *supported)
{
    *supported = false;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_group_tracking_params_validate(
    int unit,
    bcm_flowtracker_group_t id,
    int num_tracking_params,
    bcm_flowtracker_tracking_param_info_t *list_of_tracking_params)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_group_export_triggers_validate(
    int unit,
    bcm_flowtracker_group_t id,
    bcm_flowtracker_export_trigger_info_t *export_trigger_info)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_group_actions_validate(
    int unit,
    bcm_flowtracker_group_t id,
    uint32 flags,
    uint8_t hw_learn_en,
    int num_actions,
    bcm_flowtracker_group_action_info_t *action_list)
{
    int i;
    bool actn_valid = false;
    SHR_FUNC_ENTER(unit);

    if (hw_learn_en == FT_HW_LEARN_ENABLE_WO_EAPP) {
        for (i = 0; i < num_actions; i++) {
            actn_valid = false;
            switch (action_list[i].action) {
                case bcmFlowtrackerGroupActionOpaqueObject:
                case bcmFlowtrackerGroupActionFlexCtrAssign:
                case bcmFlowtrackerGroupActionVxlanGbpEnable:
                case bcmFlowtrackerGroupActionCopyToCpu:
                case bcmFlowtrackerGroupActionDrop:
                case bcmFlowtrackerGroupActionDropCancel:
                case bcmFlowtrackerGroupActionRedirectPort:
                case bcmFlowtrackerGroupActionRedirectIpmc:
                case bcmFlowtrackerGroupActionRedirectMcast:
                case bcmFlowtrackerGroupActionL3Switch:
                case bcmFlowtrackerGroupActionDestinationType:
                case bcmFlowtrackerGroupActionMirrorIndex:
                    actn_valid = true;
                    break;
                default:
                    break;
            }
            if (actn_valid == false) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_EXIT();
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve(
    int unit,
    int max_flows,
    uint8_t hw_learn_en,
    uint32_t *flex_ctr_stat_id,
    uint32_t *flex_ctr_lt_id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_hit_bit_reserve(
    int unit,
    int hitbit_type,
    int max_flows,
    uint8_t hw_learn_en,
    uint32_t *flex_ctr_stat_id,
    uint32_t *flex_ctr_lt_id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_max_flows_per_pipe_get(
    int unit,
    uint8_t uft_mode,
    uint32_t *max_flows_per_pipe)
{
    bcm_switch_hash_table_t hash_table = bcmHashTableFlowtrackerEntry;
    bcm_switch_hash_bank_t hash_bank_array[16];
    int array_size = 16;
    int num_banks = 0;
    int i = 0;
    bcm_switch_hash_bank_info_t bank_info[8];
    int num_base_entries_count = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(hash_bank_array, 0, sizeof(hash_bank_array));
    SHR_IF_ERR_VERBOSE_EXIT(bcm_ltsw_switch_hash_bank_multi_get(unit,
        hash_table, array_size, hash_bank_array, &num_banks));

    for (i = 0; i < num_banks; i++) {
        bcm_switch_hash_bank_info_init(&bank_info[i]);
        bank_info[i].bank_num = hash_bank_array[i];
        SHR_IF_ERR_VERBOSE_EXIT(bcm_ltsw_switch_hash_bank_info_get(unit,
            &(bank_info[i])));
        num_base_entries_count += bank_info[i].num_base_entries;
    }
    /*
     * NOTE: HW learning currently is without EAPP. So single wide entries
     * are used when calculating the max scale.
     * There are 32K single wide entries per IFTA80_E2T tile.
     */
    *max_flows_per_pipe = num_base_entries_count;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_global_enable_reg_field_name_get(
    int unit,
    char **reg_str,
    char **field_str)
{
    *reg_str = R_FT_CONFIGs;
    *field_str = FT_ENABLEs;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_action_group(
    int unit,
    uint32_t main_ctr_stat_id,
    uint32_t hitbit_ctr_stat_id,
    uint32_t *group_action_stat_id,
    uint32_t *group_action_hw_idx)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_sw_learn_max_flows_per_pipe_get(
    int unit,
    uint32_t *max_flows_per_pipe)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_is_supported_uft_mode(
    int unit,
    uint8_t uft_mode,
    bool *supported)
{
    if (uft_mode == 8 || uft_mode == 9 || uft_mode == 11) {
        *supported = false;
    } else {
        *supported = true;
    }
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_sw_learn_is_supported_uft_mode(
    int unit,
    uint8_t uft_mode,
    bool *supported)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_num_em_groups_get(
    int unit,
    uint32_t *num_em_grps)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit,
                              DT_EM_FT_GRP_TEMPLATEs,
                              num_em_grps));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_base_entry_info_get(
    int unit,
    uint16_t *base_entry_size,
    uint16_t *key_space_avl,
    uint16_t *key_type_base_valid_size)
{
    int i;
    *base_entry_size = 120;
    for (i = 0; i < FT_EM_KEY_MAX_NUM_BASE_ENTRIES; i++) {
        if (i == 0) {
            /*
             * First base entry - key_type (4 bits) + base_valid(3 bits)
             */
            key_type_base_valid_size[i] = 7;
        } else {
            /*
             * Other base entries - base_valid(3 bits)
             */
            key_type_base_valid_size[i] = 3;
        }
        key_space_avl[i] = *base_entry_size - key_type_base_valid_size[i];
    }
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_ft_learn_fail_count_supported(
    int unit,
    bool *is_supported)
{
    *is_supported = true;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve_wo_eapp(
    int unit,
    int max_flows,
    uint32_t *flex_ctr_stat_id,
    uint32_t *flex_ctr_lt_id)
{
    bcm_flexctr_action_t action = {0};
    bcm_flexctr_index_operation_t *index_op = NULL;
    bcm_flexctr_value_operation_t *value_a_op = NULL;
    bcm_flexctr_value_operation_t *value_b_op = NULL;
    uint32_t stat_counter_id[BCM_PIPES_MAX];
    int group_id = 0;
    /*
     * The reason we have WITH_ID is to make sure same HW action index is
     * allocated for all different pipes. We are using the last HW action index
     * so that it is not allocated already. And also it would be documented
     * that the index 0xf is used exclusively for flowtracker.
     */
    int options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL | BCM_FLEXCTR_OPTIONS_WITH_ID;
    bcmi_ltsw_flexctr_counter_info_t ctr_info = {0};
    bcm_port_config_t pc;
    int i;
    SHR_FUNC_ENTER(unit);


    action.source = bcmFlexctrSourceExactMatchFlowtracker;
    action.mode = bcmFlexctrCounterModeNormal; /* CTR_A and CTR_B */
    action.hint = group_id;
    action.index_num = max_flows;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;

    /*
     * Counter index is derived from
     * HT_LPM_HIT_INDEX (HW learning)
     * We need 17 bits to represent the 128K single wide entries
     * per pipe.
     * 16 bits from EM_FT_HIT_INDEX_0
     * and 1 bit from EM_FT_HIT_INDEX_1
     * NOTE: This happens due to compaction of hit index. Check the
     * bcm56780_a0_ltsw_flowtracker_hit_index_compaction_ctrl_set function
     * below.
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngEmFtHitIndex0;
    index_op->mask_size[0] = 16;
    index_op->shift[0] = 0; /* Shift by 0 since we are starting from 0 */

    index_op->object[1] = bcmFlexctrObjectIngEmFtHitIndex1;
    index_op->mask_size[1] = 1;
    index_op->shift[1] = 16;

    /* Increase counter per packet. */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectConstOne;
    value_a_op->mask_size[0] = 1;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectConstZero;
    value_a_op->mask_size[1] = 1;
    value_a_op->shift[1] = 0;
    value_a_op->type = bcmFlexctrValueOperationTypeInc;

    /* Increase counter per packet bytes. */
    value_b_op = &action.operation_b;
    value_b_op->select = bcmFlexctrValueSelectPacketLength;
    value_b_op->type = bcmFlexctrValueOperationTypeInc;

    SHR_IF_ERR_VERBOSE_EXIT(bcm_ltsw_port_config_get(unit, &pc));

    /* Allocate flex counters at pipe level */
    for (i = 0 ; i < 2; i++) {
        sal_memset(&(action.ports), 0, sizeof(bcm_pbmp_t));
        BCM_PBMP_ASSIGN(action.ports, pc.per_pp_pipe[i]);
        stat_counter_id[i] = 0xf;
        SHR_IF_ERR_VERBOSE_EXIT(
                bcm_ltsw_flexctr_action_create(unit, options, &action,
                                                &stat_counter_id[i]));
        flex_ctr_stat_id[i] = stat_counter_id[i];
    }


    /*
     * Sending one pipe's LT ID is enough since we have ensured the HW action
     * index is same for all pipes above.
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id[0], &ctr_info));

    *flex_ctr_lt_id = ctr_info.action_profile_id;
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_hit_index_compaction_ctrl_set(int unit)
{
    /*
     * We need following bits from FORMAT HT_LPM_HIT_INDEX.
     * Bits 0,1(ENTRY_NUMBER) -> since we have only max 4 entries
     *                           within a bucket.
     * Bits 5 to 16 (BUCKET_NUMBER) -> Since we have max 4K buckets,
     *                                 12 bits are required.
     * Bits 20 to 22(TABLE_ID) -> Since we can have 8 banks.
     */
    uint8_t bit_map[BCMI_LTSW_FLEXCTR_HITIDX_BIT_MAP_MAX] = {
        /* 0 to 1 */
        0,1,
        /* 5 to 16 */
        5,6,7,8,9,10,11,12,13,14,15,16,
        /* 20 to 22 */
        20,21,22,
        /* Rest dont care */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    };
    int i;
    bcmi_ltsw_flexctr_hitidx_compact_ctrl_t idx_ctrl;
    SHR_FUNC_ENTER(unit);
    sal_memset(&idx_ctrl, 0, sizeof(bcmi_ltsw_flexctr_hitidx_compact_ctrl_t));
    idx_ctrl.op = bcmiFlexCtrHitIdxOpSet;
    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjEmft;

    for (i = 0; i < BCMI_LTSW_FLEXCTR_HITIDX_BIT_MAP_MAX; i++) {
        idx_ctrl.bit_map[i] = bit_map[i];
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_hit_index_compaction_ctrl_delete(int unit)
{
    bcmi_ltsw_flexctr_hitidx_compact_ctrl_t idx_ctrl;
    SHR_FUNC_ENTER(unit);
    sal_memset(&idx_ctrl, 0, sizeof(bcmi_ltsw_flexctr_hitidx_compact_ctrl_t));
    idx_ctrl.op = bcmiFlexCtrHitIdxOpDelete;
    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjEmft;
    SHR_IF_ERR_VERBOSE_EXIT(
        bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_flow_limit_config_supported(
    int unit,
    bcm_flowtracker_group_t id)
{
    /*
     * Group ID 1 flow threshold setting is not supported in HW due to
     * workaround added in HW as part of JIRA TD4X9-1357.
     */
    if (id == 1) {
        LOG_ERROR(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                "FT(unit %d) Error: Group (ID:%d) does not support flow limit configuration.\n"),
                 unit, id));
        return SHR_E_CONFIG;
    }

    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_with_exact_match_supported(
    int unit,
    bool *is_supported)
{
    *is_supported = true;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_per_pipe_em_mode_validate(
    int unit,
    int num_pipe,
    bcm_flowtracker_group_info_t *flow_group_info)
{
    int i = 0;

    for (i = 1; i < num_pipe; ++i) {
        if (flow_group_info->field_group[i] !=
                flow_group_info->field_group[0]) {
            LOG_ERROR(BSL_LOG_MODULE, (BSL_META_U(unit,
                            "FT(unit %d) Error: Per pipe EM mode\
                            not supported.\n"), unit));
            return SHR_E_CONFIG;
        }
    }
    return SHR_E_NONE;
}

/*!
 * \brief Flowtracker driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_flowtracker_drv_t bcm56780_a0_ltsw_flowtracker_drv = {
    .flowtracker_detach = bcm56780_a0_ltsw_flowtracker_detach,
    .flowtracker_init = bcm56780_a0_ltsw_flowtracker_init,
    .flowtracker_elephant_hash_config_set = bcm56780_a0_ltsw_flowtracker_elephant_hash_config_set,
    .flowtracker_elephant_hash_config_get = bcm56780_a0_ltsw_flowtracker_elephant_hash_config_get,
    .flowtracker_elephant_control_set = bcm56780_a0_ltsw_flowtracker_elephant_control_set,
    .flowtracker_elephant_control_get = bcm56780_a0_ltsw_flowtracker_elephant_control_get,
    .flowtracker_elephant_stats_set = bcm56780_a0_ltsw_flowtracker_elephant_stats_set,
    .flowtracker_elephant_stats_get = bcm56780_a0_ltsw_flowtracker_elephant_stats_get,
    .flowtracker_default_grp_supported = bcm56780_a0_ltsw_flowtracker_default_grp_supported,
    .flowtracker_group_tracking_params_validate = bcm56780_a0_ltsw_flowtracker_group_tracking_params_validate,
    .flowtracker_group_export_triggers_validate = bcm56780_a0_ltsw_flowtracker_group_export_triggers_validate,
    .flowtracker_group_actions_validate = bcm56780_a0_ltsw_flowtracker_group_actions_validate,
    .flowtracker_flex_ctr_pkt_byte_reserve = bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve,
    .flowtracker_flex_ctr_hit_bit_reserve = bcm56780_a0_ltsw_flowtracker_flex_ctr_hit_bit_reserve,
    .flowtracker_hw_learn_max_flows_per_pipe_get = bcm56780_a0_ltsw_flowtracker_hw_learn_max_flows_per_pipe_get,
    .flowtracker_hw_learn_global_enable_reg_field_name_get = bcm56780_a0_ltsw_flowtracker_hw_learn_global_enable_reg_field_name_get,
    .flowtracker_flex_ctr_action_group = bcm56780_a0_ltsw_flowtracker_flex_ctr_action_group,
    .flowtracker_sw_learn_max_flows_per_pipe_get = bcm56780_a0_ltsw_flowtracker_sw_learn_max_flows_per_pipe_get,
    .flowtracker_hw_learn_is_supported_uft_mode = bcm56780_a0_ltsw_flowtracker_hw_learn_is_supported_uft_mode,
    .flowtracker_sw_learn_is_supported_uft_mode = bcm56780_a0_ltsw_flowtracker_sw_learn_is_supported_uft_mode,
    .flowtracker_num_em_groups_get = bcm56780_a0_ltsw_flowtracker_num_em_groups_get,
    .flowtracker_base_entry_info_get = bcm56780_a0_ltsw_flowtracker_base_entry_info_get,
    .flowtracker_ft_learn_fail_count_supported = bcm56780_a0_ltsw_flowtracker_ft_learn_fail_count_supported,
    .flowtracker_flex_ctr_pkt_byte_reserve_wo_eapp = bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve_wo_eapp,
    .flowtracker_hit_index_compaction_ctrl_set = bcm56780_a0_ltsw_flowtracker_hit_index_compaction_ctrl_set,
    .flowtracker_hit_index_compaction_ctrl_delete = bcm56780_a0_ltsw_flowtracker_hit_index_compaction_ctrl_delete,
    .flowtracker_flow_limit_config_supported = bcm56780_a0_ltsw_flowtracker_flow_limit_config_supported,
    .flowtracker_with_exact_match_supported = bcm56780_a0_ltsw_flowtracker_with_exact_match_supported,
    .flowtracker_per_pipe_em_mode_validate = bcm56780_a0_ltsw_flowtracker_per_pipe_em_mode_validate
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_flowtracker_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flowtracker_drv_set(unit, &bcm56780_a0_ltsw_flowtracker_drv));

exit:
    SHR_FUNC_EXIT();
}

