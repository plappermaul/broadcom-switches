/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/flexctr.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw/generated/l2_ha.h>

#include <bcm_int/ltsw/mbcm/l2.h>
#include <bcm_int/ltsw/xfs/l2.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/uft.h>
#include <bcm_int/ltsw/chip/bcm56780_a0/variant_dispatch.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_L2

/******************************************************************************
 * Private functions
 */

static int
bcm56780_a0_ltsw_l2_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_add(
    int unit,
    bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_add(unit, l2addr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_get(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid,
    bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_get(unit, mac, vid, l2addr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_delete(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_delete(unit, mac, vid));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_replace(
    int unit,
    bcmint_l2_replace_t *rep_st)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_replace(unit, rep_st));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_traverse(
    int unit,
    bcm_l2_traverse_cb trav_fn,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_traverse(unit, trav_fn, user_data));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_addr_del_by_tuple(
    int unit,
    bcmint_l2_tuple_ctrl_t *tuple_ctrl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_del_by_tuple(unit, tuple_ctrl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_station_size_get(
    int unit,
    uint32_t *tbl_sz)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_size_get(unit, tbl_sz));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_age(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_age(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_station_add(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_add(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_station_get(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_get(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_station_delete(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_delete(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_force_vlan_set(
    int unit,
    bcm_port_t port,
    bcm_vlan_t vlan,
    uint32_t flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_force_vlan_set(unit, port, vlan, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_learn_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_learn_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_learn_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_learn_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_station_vlan_update(
    int unit,
    int vid,
    int flags,
    bcmi_ltsw_l2_station_vlan_t *vlan_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_vlan_update(unit, vid, flags, vlan_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_size_get(
    int unit,
    int *size)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_size_get(unit, size));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_count_get(
    int unit,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_count_get(unit, count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_view_vlan_update(
    int unit,
    bcmi_ltsw_l2_view_vlan_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_view_vlan_update(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static void
bcm56780_a0_ltsw_l2_sw_dump(int unit)
{
    xfs_ltsw_l2_sw_dump(unit);
}

static int
bcm56780_a0_ltsw_l2_virtual_info_update(
    int unit,
    bcmi_ltsw_l2_virtual_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_virtual_info_update(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_hitbit_index_num_get(
    int unit,
    bcmi_ltsw_uft_mode_t uft_mode,
    int single_wide)
{
    int index_num = 0;

    /*
     * For double-wide,
     * the max bit of the hit index[18:20] = (#tiles - 1)
     * index_num = ((#tiles) << 18)/64
     * For single-wide,
     * the max bit of the hit index[19:21] = (#tiles - 1)
     * index_num = ((#tiles) << 19)/64
     */
    switch (uft_mode) {
        case bcmiUftMode8:
            /* 6 tiles */
            index_num = 24576;
            break;
        case bcmiUftMode16:
        case bcmiUftMode17:
            /* 5 tiles */
            index_num = 20480;
            break;
        case bcmiUftMode20:
            /* 4 tiles */
            index_num = 16384;
            break;
        case bcmiUftMode3:
        case bcmiUftMode12:
        case bcmiUftMode18:
        case bcmiUftMode19:
            /* 2 tiles */
            index_num = 8192;
            break;
        default:
            /* 1 tile */
            index_num = 4096;
            break;
    };

    if (single_wide) {
        index_num <<= 1;
    }
    return index_num;
}

static int
bcm56780_a0_ltsw_l2_hitbit_detach(
    int unit,
    void *info)
{
    uint32_t counter_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    bcmi_ltsw_flexctr_hit_ctrl_t ctrl;
    bcmi_ltsw_flexctr_mode_t mode = bcmiFlexctrModeGlobal;
    bcmi_ltsw_flexctr_hitidx_compact_ctrl_t idx_ctrl;
    bcmint_l2_flexctr_ext_info_t *flexctr_info = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);
    flexctr_info = (bcmint_l2_flexctr_ext_info_t *)info;

    sal_memset(&ctrl, 0, sizeof(bcmi_ltsw_flexctr_hit_ctrl_t));
    ctrl.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ctrl.tbl_name = L2_HOST_TABLEs;
    ctrl.dst_act_profile_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    ctrl.src_act_profile_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_mode_get(unit, 0, &mode));
    if (mode == bcmiFlexctrModePipeUnique) {
        ctrl.global = true;
    }

    /* Delete CTR_ING_EFLEX_HITBIT_CONTROL LT. */
    (void)bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl);

    ctrl.tbl_name = L2_HOST_NARROW_TABLEs;
    (void)bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl);

    sal_memset(&idx_ctrl, 0, sizeof(bcmi_ltsw_flexctr_hitidx_compact_ctrl_t));
    idx_ctrl.op = bcmiFlexCtrHitIdxOpDelete;
    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjL2Src;
    (void)bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl);

    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjL2Dst;
    (void)bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl);

    /* Destroy flexctr actions. */
    counter_id = flexctr_info->dst_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        flexctr_info->dst_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = flexctr_info->src_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        flexctr_info->src_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = flexctr_info->narrow_dst_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        flexctr_info->narrow_dst_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = flexctr_info->narrow_src_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        flexctr_info->narrow_src_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_hitbit_init(
    int unit,
    void *info)
{
    bcm_flexctr_action_t action = {0};
    bcm_flexctr_index_operation_t *index_op = NULL;
    bcm_flexctr_value_operation_t *value_a_op = NULL;
    uint32_t dst_id, src_id, narrow_dst_id, narrow_src_id;
    int options = 0;
    bcmi_ltsw_flexctr_hit_ctrl_t ctrl;
    bcmint_l2_flexctr_ext_info_t *flexctr_info = NULL;
    bcmi_ltsw_flexctr_mode_t mode = bcmiFlexctrModeGlobal;
    bcmi_ltsw_flexctr_hitidx_compact_ctrl_t idx_ctrl;
    int i;
    bcmi_ltsw_uft_mode_t uft_mode;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);
    flexctr_info = (bcmint_l2_flexctr_ext_info_t *)info;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_uft_mode_get(unit, &uft_mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_mode_get(unit, 0, &mode));

    /* Dest hit action for L2_HOST_TABLE (double-wide view)*/
    action.source = bcmiFlexctrSourceL2Dst;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num  =
        bcm56780_a0_ltsw_l2_hitbit_index_num_get(unit, uft_mode, 0);
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }

    /*
    * The joint formulation:
    *      Obj0 = HIT_INDEX[15:0].
    *      Index[0] = (obj0 >> 10) & 0x3F
    *      Obj1 = HIT_INDEX[31:16].
    *      Index[1] = ((obj1 >> 0) & 0x3F) << 6
    *      obj2 = HIT_INDEX[31:16].
    *      Index[2] = ((obj2 >> 10) & 0x1F) << 12
    *      Index = Index[2] | Index[1] | Index[0].
    */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    index_op->mask_size[0] = 6;
    index_op->shift[0] = 10;
    index_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[1] = 6;
    index_op->shift[1] = 6;
    index_op->shift[2] = 0;
    index_op->object[2] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[2] = 5;
    index_op->shift[3] = 12;
    index_op->shift[4] = 10;

    /*
     * The value calculation required 6 bits (bits 0:5).
     * Since in double mode the entry position is 1 bit
     * we will need another 5 bits from the bucket value (bits 5:19).
     * i.e (((v_2 >> 5) & 0x1F) << 1) | ((v_1 >> 1) & 0x1)
     * The joint formulation:
     *      Obj0 = HIT_INDEX[15:0].
     *      Index[0] = (obj0 >> 1) & 0x1
     *      Obj1 = HIT_INDEX[15:0].
     *      Index[1] = ((obj1 >> 5) & 0x1F) << 1
     *      Index = Index[2] | Index[1] | Index[0].
     */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[0] = 1;
    value_a_op->shift[0] = 1;
    value_a_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[1] = 5;
    value_a_op->shift[1] = 1;
    value_a_op->shift[2] = 5;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &dst_id));
    flexctr_info->dst_id = dst_id;

    /* Src hit action. */
    action.source = bcmiFlexctrSourceL2Src;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num  =
        bcm56780_a0_ltsw_l2_hitbit_index_num_get(unit, uft_mode, 0);
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }
    /*
     * (((v_3 >> 10) & 0x1F) << 12) | (((v_2 >> 0) & 0x3F) << 6) |
     * ((v_1 >> 10) & 0x3F)
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    index_op->mask_size[0] = 6;
    index_op->shift[0] = 10;
    index_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[1] = 6;
    index_op->shift[1] = 6;
    index_op->shift[2] = 0;
    index_op->object[2] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[2] = 5;
    index_op->shift[3] = 12;
    index_op->shift[4] = 10;

    /* (((v_2 >> 5) & 0x1F) << 1) | ((v_1 >> 1) & 0x1)  */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[0] = 1;
    value_a_op->shift[0] = 1;
    value_a_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[1] = 5;
    value_a_op->shift[1] = 1;
    value_a_op->shift[2] = 5;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* Src hit action must be adjacent of dst hit action. */
    options = BCM_FLEXCTR_OPTIONS_WITH_ID | BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    src_id = dst_id + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &src_id));
    flexctr_info->src_id = src_id;

    /* Dest hit action for L2_HOST_NARROW_TABLE (single-wide view)*/
    action.source = bcmiFlexctrSourceL2Dst;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num  =
        bcm56780_a0_ltsw_l2_hitbit_index_num_get(unit, uft_mode, 1);
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }
    /*
     * The joint formulation:
     *      Obj0 = HIT_INDEX[15:0].
     *      Index[0] = (obj0 >> 9) & 0x7F
     *      Obj1 = HIT_INDEX[31:16].
     *      Index[1] = ((obj1 >> 0) & 0x3F) << 7
     *      obj2 = HIT_INDEX[31:16].
     *      Index[2] = ((obj2 >> 10) & 0x1F) << 13
     *      Index = Index[2] | Index[1] | Index[0].
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    index_op->mask_size[0] = 7;
    index_op->shift[0] = 9;
    index_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[1] = 6;
    index_op->shift[1] = 7;
    index_op->shift[2] = 0;
    index_op->object[2] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[2] = 5;
    index_op->shift[3] = 13;
    index_op->shift[4] = 10;

    /*
     * The joint formulation:
     *      Obj0 = HIT_INDEX[15:0].
     *      Index[0] = (obj0 >> 0) & 0x3
     *      Obj1 = HIT_INDEX[15:0].
     *      Index[1] = ((obj1 >> 5) & 0xF) << 2
     *      Index = Index[2] | Index[1] | Index[0].
     */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[0] = 2;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[1] = 4;
    value_a_op->shift[1] = 2;
    value_a_op->shift[2] = 5;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options,
                                        &action, &narrow_dst_id));
    flexctr_info->narrow_dst_id = narrow_dst_id;

    /* Src hit action. */
    action.source = bcmiFlexctrSourceL2Src;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num  =
        bcm56780_a0_ltsw_l2_hitbit_index_num_get(unit, uft_mode, 1);
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }
    /*
     * (((v_3 >> 10) & 0x1F) << 13) | (((v_2 >> 0) & 0x3F) << 7) |
     * ((v_1 >> 9) & 0x7F)
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    index_op->mask_size[0] = 7;
    index_op->shift[0] = 9;
    index_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[1] = 6;
    index_op->shift[1] = 7;
    index_op->shift[2] = 0;
    index_op->object[2] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[2] = 5;
    index_op->shift[3] = 13;
    index_op->shift[4] = 10;

    /* (((v_2 >> 5) & 0xF) << 2) | ((v_1 >> 0) & 0x3) */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[0] = 2;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[1] = 4;
    value_a_op->shift[1] = 2;
    value_a_op->shift[2] = 5;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* Src hit action must be adjacent of dst hit action. */
    options = BCM_FLEXCTR_OPTIONS_WITH_ID | BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    narrow_src_id = narrow_dst_id + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options,
                                        &action, &narrow_src_id));
    flexctr_info->narrow_src_id = narrow_src_id;

    sal_memset(&ctrl, 0, sizeof(bcmi_ltsw_flexctr_hit_ctrl_t));
    ctrl.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ctrl.tbl_name = L2_HOST_TABLEs;
    ctrl.dst_act_profile_id = dst_id;
    ctrl.src_act_profile_id = src_id;
    if (mode == bcmiFlexctrModePipeUnique) {
        ctrl.global = true;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl));

    sal_memset(&ctrl, 0, sizeof(bcmi_ltsw_flexctr_hit_ctrl_t));
    ctrl.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ctrl.tbl_name = L2_HOST_NARROW_TABLEs;
    ctrl.dst_act_profile_id = narrow_dst_id;
    ctrl.src_act_profile_id = narrow_src_id;
    if (mode == bcmiFlexctrModePipeUnique) {
        ctrl.global = true;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl));

    sal_memset(&idx_ctrl, 0, sizeof(bcmi_ltsw_flexctr_hitidx_compact_ctrl_t));
    idx_ctrl.op = bcmiFlexCtrHitIdxOpSet;
    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjL2Src;
    for (i = 0; i < 32; i++) {
        idx_ctrl.bit_map[i] = i;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl));

    idx_ctrl.hit_obj = bcmiFlexCtrHitIdxObjL2Dst;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hitidx_compact_ctrl(unit, &idx_ctrl));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56780_a0_ltsw_l2_hitbit_detach(unit, flexctr_info);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_l2_ctrl_info_init(
    int unit,
    bcmint_l2_ctrl_info_t *l2_ctrl)
{
    /*
     * Misc control 0 for ECMP_MEMBER is used to carry the
     * ECMP_MEMBER0 index to read the ECMP member table.
     */
    l2_ctrl->misc_ctrl_0_ecmp_member_is_valid = true;

    return SHR_E_NONE;
}

/*!
 * \brief L2 driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_l2_drv_t bcm56780_a0_ltsw_l2_drv = {
    .l2_init = bcm56780_a0_ltsw_l2_init,
    .l2_detach = bcm56780_a0_ltsw_l2_detach,
    .l2_addr_add = bcm56780_a0_ltsw_l2_addr_add,
    .l2_addr_get = bcm56780_a0_ltsw_l2_addr_get,
    .l2_addr_delete = bcm56780_a0_ltsw_l2_addr_delete,
    .l2_addr_replace = bcm56780_a0_ltsw_l2_addr_replace,
    .l2_addr_traverse = bcm56780_a0_ltsw_l2_addr_traverse,
    .l2_addr_del_by_tuple = bcm56780_a0_ltsw_l2_addr_del_by_tuple,
    .l2_station_size_get = bcm56780_a0_ltsw_l2_station_size_get,
    .l2_age = bcm56780_a0_ltsw_l2_age,
    .l2_station_add = bcm56780_a0_ltsw_l2_station_add,
    .l2_station_get = bcm56780_a0_ltsw_l2_station_get,
    .l2_station_delete = bcm56780_a0_ltsw_l2_station_delete,
    .l2_force_vlan_set = bcm56780_a0_ltsw_l2_force_vlan_set,
    .l2_learn_set = bcm56780_a0_ltsw_l2_learn_set,
    .l2_learn_get = bcm56780_a0_ltsw_l2_learn_get,
    .l2_station_vlan_update = bcm56780_a0_ltsw_l2_station_vlan_update,
    .l2_size_get = bcm56780_a0_ltsw_l2_size_get,
    .l2_count_get = bcm56780_a0_ltsw_l2_count_get,
    .l2_view_vlan_update = bcm56780_a0_ltsw_l2_view_vlan_update,
    .l2_sw_dump = bcm56780_a0_ltsw_l2_sw_dump,
    .l2_virtual_info_update = bcm56780_a0_ltsw_l2_virtual_info_update,
    .l2_hitbit_detach = bcm56780_a0_ltsw_l2_hitbit_detach,
    .l2_hitbit_init = bcm56780_a0_ltsw_l2_hitbit_init,
    .l2_ctrl_info_init = bcm56780_a0_ltsw_l2_ctrl_info_init
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_l2_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l2_drv_set(unit, &bcm56780_a0_ltsw_l2_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56780_a0_ltsw_variant_drv_attach(unit, BCM56780_A0_LTSW_VARIANT_L2));

exit:
    SHR_FUNC_EXIT();
}

