/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/hash_output_selection.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/mbcm/hash_output_selection.h>

#include <shr/shr_bitop.h>
#include <sal/sal_types.h>
#include <sal/sal_mutex.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_HASH

/*!
 * \brief The max available instance identifier.
 */
/*! Instance identifier 0. */
#define HOS_INSTANCE_ID_0 0

/*! Instance identifier 1. */
#define HOS_INSTANCE_ID_1 1

/*!
 * \brief Instance pre-definition type.
 */
/*! Used flow based hashing. */
#define HOS_INSTANCE_FLOW_BASED_HASH 0

/*! Used port based hashing. */
#define HOS_INSTANCE_PORT_BASED_HASH 1

/*!
 * \brief The profile of Hash Output Selection functionality.
 */
typedef struct hos_profile_s {

    /*! Profile identifier maximum count. */
    int id_count;

    /*! Profile identifier bitmap. */
    SHR_BITDCL *id_bitmap;

    /*! Profile description. */
    char *desc;

    /*! Profile recover function. */
    int (*recover)(int unit, struct hos_profile_s *profile);

    /*! Profile dump function. */
    int (*dump)(int unit, int profile_id);

} hos_profile_t;

/*!
 * \brief Generic database of Hash Output Selection.
 */
typedef struct hos_db_s {

    /*! Initialization signal. */
    bool initialized;

    /*! Module lock. */
    sal_mutex_t lock;

    /*! Chip-specific sub-features for HOS. */
    uint32_t features;

    /*! Hash Output Selection profile. */
    hos_profile_t profile;

    /*! Hash Output Selection instance. */
    hos_profile_t instance;

} hos_db_t;

/*!
 * \brief The Hos database.
 */
static hos_db_t bcmi_ltsw_hos_db[BCM_MAX_NUM_UNITS];

/******************************************************************************
 * Private functions
 */


/*! Hash Output Selection profile is not initialized. */
#define HOS_PROFILE_NOT_INIT(_prof) \
    ((_prof)->id_count > 0 && (_prof)->id_bitmap == NULL && (_prof)->desc)

/*! The valid Hash Output Selection profile. */
#define HOS_PROFILE_VALID(_prof) \
    ((_prof)->id_count > 0 && (_prof)->id_bitmap && (_prof)->desc)

/*! The invalid Hash Output Selection profile. */
#define HOS_PROFILE_INVALID(_prof) \
    (!HOS_PROFILE_VALID(_prof))

/*! Hash Output Selection profile identifier validate. */
#define HOS_PROFILE_ID_VALID(_prof, _id) \
    ((_id) >= 0 && (_id) < (_prof)->id_count)

/*! Invalid Hash Output Selection profile identifier. */
#define HOS_PROFILE_ID_INVALID(_prof, _id) \
    (!HOS_PROFILE_ID_VALID(_prof, _id))

/*! Test Hash Output Selection profile identifer. */
#define HOS_PROFILE_ID_TEST(_prof, _id) \
    (SHR_BITGET((_prof)->id_bitmap,(_id)))

/*! Add Hash Output Selection profile identifer. */
#define HOS_PROFILE_ID_ADD(_prof, _id) \
    (SHR_BITSET((_prof)->id_bitmap,(_id)))

/*! Remove Hash Output Selection profile identifer. */
#define HOS_PROFILE_ID_REMOVE(_prof, _id) \
    (SHR_BITCLR((_prof)->id_bitmap,(_id)))

/*! Hash Output Selection profile identifer iteration. */
#define HOS_PROFILE_ID_ITER(_prof, _id) \
    for ((_id) = 0; (_id) < (_prof)->id_count; (_id)++)

/*! Hash Output Selection profile identifer iteration done. */
#define HOS_PROFILE_ID_ITER_LAST(_prof, _id) \
        ((_id) == (_prof)->id_count)

/*!
 * \brief Create protection mutex for Hash Output Selection.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_lock_create(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];

    SHR_FUNC_ENTER(unit);

    if (hos_db->lock == NULL) {
        hos_db->lock = sal_mutex_create("bcmiHosMutex");
        SHR_NULL_CHECK(hos_db->lock, SHR_E_MEMORY);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy protection mutex for Hash Output Selection.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 */
static int
hos_lock_destroy(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];

    SHR_FUNC_ENTER(unit);

    if (hos_db->lock != NULL) {
        sal_mutex_destroy(hos_db->lock);
        hos_db->lock = NULL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash Output Selection mutax lock.
 *
 * \param [in] unit Unit Number.
 */
static void
hos_lock(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];

    if (hos_db->lock) {
        sal_mutex_take(hos_db->lock, SAL_MUTEX_FOREVER);
    }
}

/*!
 * \brief Hash Output Selection mutax unlock.
 *
 * \param [in] unit Unit Number.
 */
static void
hos_unlock(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];

    if (hos_db->lock) {
        sal_mutex_give(hos_db->lock);
    }
}

/*!
 * \brief Validate the hash output selection profile feature.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_validate_feature_profile(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_HASH_OUTPUT_SELECTION_PROFILE)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the hash output selection profile identifer.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_validate_profile_id(
    int unit,
    int profile_id)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;

    SHR_FUNC_ENTER(unit);

    if (HOS_PROFILE_INVALID(profile)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!HOS_PROFILE_ID_VALID(profile, profile_id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (!HOS_PROFILE_ID_TEST(profile, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the hash output selection profile parameters.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 * \param [in] type The hash output selection type.
 * \param [in] array_size controlling configuration array size.
 * \param [in] ctrl_type The hash output selection profile control type array.
 * \param [in] value The hash output selection profile control value array.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_validate_profile_params(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    int array_size,
    bcmi_ltsw_hos_profile_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_profile_id(unit, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_validate_profile_params(unit, profile_id, type, array_size, ctrl_type, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the hash output selection profile parameters.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 * \param [in] inst_id Instance identifier.
 * \param [in] flow_id Flow identifier.
 * \param [in] array_size Controlling configuration array size.
 * \param [in] ctrl_type The hash output selection instance control type array.
 * \param [in] value The hash output selection instance control value array.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_validate_instance_params(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    int array_size,
    bcmi_ltsw_hos_instance_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_validate_instance_params(unit, type, inst_id, flow_id, array_size, ctrl_type, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize a hash output selection profile.
 *
 * \param [in] profile The Hash Output Selection profile.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_init(hos_profile_t *profile)
{
    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (HOS_PROFILE_NOT_INIT(profile)) {
        SHR_BITDCL *id_bitmap = NULL;
        SHR_ALLOC(id_bitmap,
                  SHR_BITALLOCSIZE(profile->id_count),
                  profile->desc);
        SHR_NULL_CHECK(id_bitmap, SHR_E_MEMORY);
        sal_memset(id_bitmap, 0, SHR_BITALLOCSIZE(profile->id_count));
        profile->id_bitmap = id_bitmap;
        id_bitmap = NULL;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-init a hash output selection profile.
 *
 * \param [in] profile The Hash Output Selection profile.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_deinit(hos_profile_t *profile)
{
    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (HOS_PROFILE_VALID(profile)) {
        SHR_FREE(profile->id_bitmap);
        profile->id_count = 0;
        profile->desc = NULL;
        profile->recover = NULL;
        profile->dump = NULL;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a profile identifier.
 *
 * \param [in] profile The Hash Output Selection profile.
 * \param [in] option Create option. See BCMI_LTSW_HOS_PROFILE_CREATE_OPTION_xxx
 * \param [in/out] id Profile Identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_create(
    int unit,
    uint32_t option,
    int *id)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);
    SHR_NULL_CHECK(id, SHR_E_PARAM);

    if (HOS_PROFILE_INVALID(profile)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (option & BCMI_LTSW_HOS_PROFILE_CREATE_OPTION_WITH_ID) {
        if (id == NULL) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (HOS_PROFILE_ID_INVALID(profile, *id)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (HOS_PROFILE_ID_TEST(profile, *id)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
        HOS_PROFILE_ID_ADD(profile, *id);
    } else {
        int i;
        HOS_PROFILE_ID_ITER(profile, i) {
            if (HOS_PROFILE_ID_TEST(profile, i)) {
                continue;
            }
            HOS_PROFILE_ID_ADD(profile, i);
            *id = i;
            break;
        }
        if (HOS_PROFILE_ID_ITER_LAST(profile, i)) {
            SHR_ERR_EXIT(SHR_E_RESOURCE);
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_profile_create(unit, option, id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a profile identifier.
 *
 * \param [in] profile The Hash Output Selection profile.
 * \param [in] id Profile Identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_destory(
    int unit,
    int id)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (HOS_PROFILE_INVALID(profile)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (HOS_PROFILE_ID_INVALID(profile, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (HOS_PROFILE_ID_TEST(profile, id)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_hos_profile_destroy(unit, id));
        HOS_PROFILE_ID_REMOVE(profile, id);
    } else {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Multi-control the hash output selection profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 * \param [in] type The hash output selection type.
 * \param [in] array_size controlling configuration array size.
 * \param [in] ctrl_type The hash output selection profile control type array.
 * \param [in] value The hash output selection profile control value array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_multi_set(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    int array_size,
    bcmi_ltsw_hos_profile_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_feature_profile(unit));

    if (array_size > 0 && (!ctrl_type || !value)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_profile_params(unit, profile_id, type, array_size, ctrl_type, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_profile_set(unit, profile_id, type, array_size, ctrl_type, value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Control the hash output selection profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 * \param [in] type The hash output selection type.
 * \param [in] ctrl_type The hash output selection profile control type array.
 * \param [in] value The hash output selection profile control value array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_set(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_profile_control_t ctrl_type,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_multi_set(unit, profile_id, type, 1, &ctrl_type, &value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the hash output selection profile configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile identifier.
 * \param [in] type The hash output selection type.
 * \param [in] ctrl_type The hash output selection profile control type.
 * \param [out] value The hash output selection profile control value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_get(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_profile_control_t ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_feature_profile(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_profile_params(unit, profile_id, type, 1, &ctrl_type, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_profile_get(unit, profile_id, type, ctrl_type, value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover software information saved in a specified profile.
 *
 * \param [in] unit Unit number.
 * \param [in] profile The Hash Output Selection profile.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_recover(int unit, hos_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (HOS_PROFILE_VALID(profile) && profile->recover) {
        SHR_IF_ERR_VERBOSE_EXIT
            (profile->recover(unit, profile));
    } else {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief dump the configuration saved in profile.
 *
 * \param [in] unit Unit number.
 * \param [in] profile The Hash Output Selection profile.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_profile_dump(int unit, hos_profile_t *profile)
{
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (HOS_PROFILE_VALID(profile) && profile->dump) {
        LOG_CLI((BSL_META_U(unit, "\t%s(%d):\n"),
                            profile->desc, profile->id_count));
        for (i = 0; i < profile->id_count; i++) {
            if (HOS_PROFILE_ID_TEST(profile, i)) {
                if (profile->dump) {
                    profile->dump(unit, i);
                }
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Multi-control the hash output selection instance.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] flow_id Flow identifier.
 * \param [in] array_size Controlling configuration array size.
 * \param [in] ctrl_type The hash output selection instance control type array.
 * \param [in] value The hash output selection instance control value array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_multi_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    int array_size,
    bcmi_ltsw_hos_instance_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    if (array_size < 0 || !ctrl_type || !value) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_instance_params(unit, type, inst_id, flow_id, array_size, ctrl_type, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_set(unit, type, inst_id, flow_id, array_size, ctrl_type, value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the hash output selection instance configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] flow_id Flow identifier.
 * \param [in] array_size Controlling configuration array size.
 * \param [in] ctrl_type The hash output selection instance control type.
 * \param [out] value The hash output selection instance control value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_multi_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    int array_size,
    bcmi_ltsw_hos_instance_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    if (array_size < 0 || !ctrl_type || !value) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_instance_params(unit, type, inst_id, flow_id, array_size, ctrl_type, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_get(unit, type, inst_id, flow_id, array_size, ctrl_type, value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Control the hash output selection instance.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] flow_id Flow identifier.
 * \param [in] ctrl_type The hash output selection instance control type array.
 * \param [in] value The hash output selection instance control value array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    bcmi_ltsw_hos_instance_control_t ctrl_type,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_set(unit, type, inst_id, flow_id, 1, &ctrl_type, &value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the hash output selection instance configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] flow_id Flow identifier.
 * \param [in] ctrl_type The hash output selection instance control type.
 * \param [out] value The hash output selection instance control value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    bcmi_ltsw_hos_instance_control_t ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_get(unit, type, inst_id, flow_id, 1, &ctrl_type, value));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the maximum of hashing value offset.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] concat Concatenation mode.
 * \param [out] max_offset The maximum of hashing value offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_max_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int concat,
    int *max_offset)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_offset_max_get(unit, type, concat, max_offset));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Instance offset decode.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] concat Concatenation mode.
 * \param [in] offset Hashing value offset.
 * \param [out] sub_sel The sub-selection of hashing value offset.
 * \param [out] sub_offset The sub-offset of hashing value offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_decode(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int concat,
    int offset,
    int *sub_sel,
    int *sub_offset)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_offset_decode(unit, type, concat, offset, sub_sel, sub_offset));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Instance offset encode.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] concat Concatenation mode.
 * \param [in] sub_sel The sub-selection of hashing value offset.
 * \param [in] sub_offset The sub-offset of hashing value offset.
 * \param [out] offset Hashing value offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_encode(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int concat,
    int sub_sel,
    int sub_offset,
    int *offset)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_offset_encode(unit, type, concat, sub_sel, sub_offset, offset));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set hash output selection instance subsel and offset through random seed.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] concat Concatenation mode.
 * \param [in] seed Random seed
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_seed_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int concat,
    uint32_t seed)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_offset_seed_set(unit, type, inst_id, concat, seed));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set hash output selection instance subsel and offset through min, max and stride.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] concat Concatenation mode.
 * \param [in] min The minimum of offset.
 * \param [in] max The maximum of offset.
 * \param [in] stride The stride of offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_stride_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int concat,
    int min,
    int max,
    int stride)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_instance_offset_stride_set(unit, type, inst_id, concat, min, max, stride));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get hash output selection instance subsel and offset through min, max and stride.
 *
 * \param [in] unit Unit Number.
 * \param [in] type The hash output selection type.
 * \param [in] inst_id Instance identifier.
 * \param [in] concat Concatenation mode.
 * \param [out] min The minimum of offset.
 * \param [out] max The maximum of offset.
 * \param [out] stride The stride of offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_instance_offset_stride_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int concat,
    int *min,
    int *max,
    int *stride)
{
    bcmi_ltsw_hos_instance_control_t ctype[2] = {
        bcmiHosInstaceControlSubSelect,
        bcmiHosInstaceControlOffset
    };
    int val0[2], val1[2], val[2];
    int offset0, offset1, offset;
    int min_offset, max_offset, stride_offset;
    int flow_id, flow_id_count;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_info_get(unit, bcmiHosInfoNumFlowIds,
                                &flow_id_count));
    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_get(unit, type, inst_id, 0, 2,
                                ctype, val0));
    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_offset_encode(unit, type, concat, val0[0], val0[1],
                                    &offset0));
    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_get(unit, type, inst_id, 1, 2,
                                ctype, val1));
    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_offset_encode(unit, type, concat, val1[0], val1[1],
                                    &offset1));
    min_offset = offset0;
    max_offset = offset1;
    stride_offset = max_offset - min_offset;
    if (stride_offset != 0) {
        for (flow_id = 2; flow_id < flow_id_count; flow_id++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_multi_get(unit, type, inst_id, flow_id, 2,
                                        ctype, val));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_encode(unit, type, concat,
                                            val[0], val[1],
                                            &offset));
            if (offset != max_offset + stride_offset) {
                break;
            }
            max_offset = offset;
        }
    }
    if (min) {
        *min = min_offset;
    }
    if (max) {
        *max = max_offset;
    }
    if (stride) {
        *stride = stride_offset;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Judge the hash output selection db is initialized or not.
 *
 * \param [in] unit Unit Number.
 *
 * \retval true initialized.
 * \retval false non-initialized.
 */
static bool
hos_db_is_initialized(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    return hos_db->initialized;
}

/*!
 * \brief Recover the hash output selection profile configuration saved in database.
 *
 * \param [in] unit Unit number.
 * \param [inout] profile_id The Hash Output Selection profile identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_db_profile_recover(int unit, hos_profile_t *profile)
{
    int i, rv;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    HOS_PROFILE_ID_ITER(profile, i) {
        rv = mbcm_ltsw_hos_profile_configured(unit, i);
        if (SHR_FAILURE(rv)) {
            continue;
        }
        HOS_PROFILE_ID_ADD(profile, i);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief dump the configuration saved in profile.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id The Hash Output Selection profile identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_db_profile_dump(int unit, int profile_id)
{
    int i, j, value;
    char *type_str[] = BCMI_LTSW_HOS_TYPE_STR;
    char *ctrl_str[] = BCMI_LTSW_HOS_PROFILE_CONTROL_STR;

    SHR_FUNC_ENTER(unit);

    LOG_CLI((BSL_META_U(unit, "\t %d):\n"), profile_id));
    for (i = 0; i < bcmiHosTypeCount; i++) {
        LOG_CLI((BSL_META_U(unit, "\t\t%s:\n"), type_str[i]));
        for (j = 0; j < bcmiHosProfileControlCount; j++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_profile_get(unit, profile_id, i, j, &value));
            LOG_CLI((BSL_META_U(unit, "\t\t\t%s: %d\n"), ctrl_str[j], value));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover the hash output selection configurations during WarmBoot.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_db_recover(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-init the hash output selection software database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 */
static int
hos_db_deinit(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;

    SHR_FUNC_ENTER(unit);

    hos_db->initialized = false;

    if (ltsw_feature(unit, LTSW_FT_HASH_OUTPUT_SELECTION_PROFILE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_profile_deinit(profile));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_db_deinit(unit));

    hos_db->features = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the hash output selection software database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_db_init(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_hos_db_init(unit, warm));

    if (ltsw_feature(unit, LTSW_FT_HASH_OUTPUT_SELECTION_PROFILE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_hos_info_get(unit,
                                    bcmiHosInfoNumProfiles,
                                    &profile->id_count));
        profile->desc = "bcmHashOutputSelectionProfile";
        profile->recover = &hos_db_profile_recover;
        profile->dump = &hos_db_profile_dump;
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_profile_init(profile));
        if (warm) {
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_profile_recover(unit, profile));
        }
    }

    hos_db->initialized = true;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the hash output selection module.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_init(int unit)
{
    int profile_id;
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_db_init(unit));

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_db_recover(unit));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_hos_init(unit));
        if (ltsw_feature(unit, LTSW_FT_HASH_OUTPUT_SELECTION_PROFILE)) {
            for (profile_id = 0; profile_id < profile->id_count; profile_id++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (hos_profile_create(
                        unit, BCMI_LTSW_HOS_PROFILE_CREATE_OPTION_WITH_ID,
                        &profile_id));
            }
        }
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-init the hash output selection module.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
hos_deinit(int unit)
{
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_hos_deinit(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_db_deinit(unit));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
bcmi_ltsw_hos_control_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_control_t ctrl_type,
    int value)
{
    int profile_id, rv;
    int inst;
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    for (profile_id = 0; profile_id < profile->id_count; profile_id++) {

        /* In case some applications do not support profile_id up to id_count. */
        rv = hos_profile_get(unit, profile_id, type,
                             bcmiHosProfileControlInstance,
                             &inst);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);

        switch(ctrl_type) {
        case bcmiHosControlUseFlowSel:
            {
                int inst_new = (value == bcmiHosFlowIdSrcBusHashIndex) ?
                        HOS_INSTANCE_PORT_BASED_HASH : HOS_INSTANCE_FLOW_BASED_HASH;
                if (inst != inst_new) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (hos_profile_set(unit, profile_id, type,
                                         bcmiHosProfileControlInstance, inst_new));
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (hos_profile_set(unit, profile_id, type,
                                     bcmiHosProfileControlFlowIdSrc, value));
            }
            break;
        case bcmiHosControlUseHigig3Entropy:
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_profile_set(unit, profile_id, type,
                                 bcmiHosProfileControlUseHigig3Entropy, value));
            break;
        case bcmiHosControlBitCountSelect:
            {
                int inst_count;
                SHR_IF_ERR_VERBOSE_EXIT
                    (mbcm_ltsw_hos_info_get(unit, bcmiHosInfoNumInstances,
                                            &inst_count));
                for (inst = 0; inst < inst_count; inst++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (hos_instance_set(unit, type, inst, -1,
                                          bcmiHosInstaceControlResultSize,
                                          value));
                }
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }
exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_control_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_control_t ctrl_type,
    int *value)
{
    int profile_id = BCMI_LTSW_HOS_PROFILE_ID_0;
    int inst;

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_get(unit, profile_id, type,
                         bcmiHosProfileControlInstance,
                         &inst));
    switch(ctrl_type) {
    case bcmiHosControlUseFlowSel:
        {
            int FlowIdSrc;
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_profile_get(unit, profile_id, type,
                                 bcmiHosProfileControlFlowIdSrc,
                                 &FlowIdSrc));
            switch (inst) {
            case HOS_INSTANCE_PORT_BASED_HASH:
                if (FlowIdSrc != bcmiHosFlowIdSrcBusHashIndex) {
                    SHR_ERR_EXIT(SHR_E_INTERNAL);
                }
                break;
            default:
                if (FlowIdSrc == bcmiHosFlowIdSrcBusHashIndex) {
                    SHR_ERR_EXIT(SHR_E_INTERNAL);
                }
                break;
            }
            *value = FlowIdSrc;
        }
        break;
    case bcmiHosControlUseHigig3Entropy:
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_profile_get(unit, profile_id, type,
                             bcmiHosProfileControlUseHigig3Entropy, value));
        break;
    case bcmiHosControlBitCountSelect:
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_instance_get(unit, type, inst, 0,
                              bcmiHosInstaceControlResultSize, value));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_control_port_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcm_port_t port,
    bcmi_ltsw_hos_control_t ctrl_type,
    int value)
{
    int inst = HOS_INSTANCE_PORT_BASED_HASH;

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    switch(ctrl_type) {
    case bcmiHosControlOffset:
        {
            bcmi_ltsw_hos_instance_control_t ictrl_type[3] = {
                bcmiHosInstaceControlConcat,
                bcmiHosInstaceControlSubSelect,
                bcmiHosInstaceControlOffset
            };
            int val[3];
            int max_offset;

            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_max_get(unit, type, 0, &max_offset));

            if (value >= max_offset) {
                val[0] = 1;
                value -= max_offset;
            } else {
                val[0] = 0;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_decode(unit, type, val[0], value,
                                            &val[1], &val[2]));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_multi_set(unit, type, inst, port, 3,
                                        ictrl_type, val));
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_control_port_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcm_port_t port,
    bcmi_ltsw_hos_control_t ctrl_type,
    int *value)
{
    int inst = HOS_INSTANCE_PORT_BASED_HASH;

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    switch(ctrl_type) {
    case bcmiHosControlOffset:
        {
            bcmi_ltsw_hos_instance_control_t ictrl_type[3] = {
                bcmiHosInstaceControlConcat,
                bcmiHosInstaceControlSubSelect,
                bcmiHosInstaceControlOffset
            };
            int val[3];
            int max_offset;

            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_multi_get(unit, type, inst, port, 3,
                                        ictrl_type, val));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_encode(unit, type, val[0], val[1], val[2],
                                            value));
            if (val[0]) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (hos_instance_offset_max_get(unit, type, 0, &max_offset));
                *value += max_offset;
            }
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_control_flow_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_control_t ctrl_type,
    int value)
{
    int inst = HOS_INSTANCE_FLOW_BASED_HASH;
    int concat;
    int max_offset;

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_get(unit, type, inst, 0,
                          bcmiHosInstaceControlConcat, &concat));
    switch(ctrl_type) {
    case bcmiHosControlConcatEnable:
        if (concat != value) {
            concat = value;
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_set(unit, type, inst, -1,
                                  bcmiHosInstaceControlConcat, concat));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_max_get(unit, type, concat, &max_offset));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_stride_set(unit, type, inst, concat,
                                                0, max_offset, 1));
        }
        break;
    case bcmiHosControlSeed:
        SHR_IF_ERR_VERBOSE_EXIT
            (hos_instance_offset_seed_set(unit, type, inst, concat, value));
        break;
    case bcmiHosControlMinOffset:
    case bcmiHosControlMaxOffset:
    case bcmiHosControlStrideOffset:
        {
            int min, max, stride;
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_max_get(unit, type, concat, &max_offset));

            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_stride_get(unit, type, inst, concat,
                                                &min, &max, &stride));

            if (ctrl_type == bcmiHosControlMinOffset) {
                if (value == min) {
                    SHR_EXIT();
                } else if ((max > 0) && (value > max)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
                min = value == -1 ? 0 : value;
                if (min < 0) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            } else if (ctrl_type == bcmiHosControlMaxOffset) {
                if (value == max) {
                    SHR_EXIT();
                } else if ((value < min) && (value != -1)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
                max_offset -= 1;
                max = value == -1 ? max_offset : value;
                if (max > max_offset) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            } else if (ctrl_type == bcmiHosControlStrideOffset) {
                if (value == stride) {
                    SHR_EXIT();
                } else if (value < 0) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
                stride = value;
            }
            if (stride == 0 && min != max) {
                stride = 1;
            }
            if (stride < 0) {
                stride = 1;
            }
            if (ctrl_type == bcmiHosControlStrideOffset) {
                if ((stride == 1) && (min == max)) {
                    max += stride;
                }
            }
            LOG_VERBOSE(BSL_LOG_MODULE,
                        (BSL_META_U(unit,
                                    "HOS(unit %d)"
                                    " min = %"PRId32
                                    " stride = %"PRId32
                                    " max = %"PRId32"\n"),
                         unit, min, stride, max));
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_stride_set(unit, type, inst, concat,
                                                min, max, stride));
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_control_flow_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_control_t ctrl_type,
    int *value)
{
    int inst = HOS_INSTANCE_FLOW_BASED_HASH;
    int concat;

    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_get(unit, type, inst, 0,
                          bcmiHosInstaceControlConcat, &concat));
    switch(ctrl_type) {
    case bcmiHosControlConcatEnable:
        *value = concat;
        break;
    case bcmiHosControlMinOffset:
    case bcmiHosControlMaxOffset:
    case bcmiHosControlStrideOffset:
        {
            int min, max, stride;
            SHR_IF_ERR_VERBOSE_EXIT
                (hos_instance_offset_stride_get(unit, type, inst, concat,
                                                &min, &max, &stride));
            if (ctrl_type == bcmiHosControlMinOffset) {
                *value = min;
            } else if (ctrl_type == bcmiHosControlMaxOffset) {
                *value = max;
            } else if (ctrl_type == bcmiHosControlStrideOffset) {
                *value = stride;
            }
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

void
bcmi_ltsw_hos_sw_dump(int unit)
{
    hos_db_t *hos_db = &bcmi_ltsw_hos_db[unit];
    hos_profile_t *profile = &hos_db->profile;

    if (ltsw_feature(unit, LTSW_FT_HASH_OUTPUT_SELECTION_PROFILE)) {
        (void)hos_profile_dump(unit, profile);
    }
}

int
bcmi_ltsw_hos_profile_create(
    int unit,
    uint32_t option,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_feature_profile(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_create(unit, option, profile_id));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_profile_destroy(
    int unit,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_validate_feature_profile(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_destory(unit, profile_id));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_profile_set(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    int array_size,
    bcmi_ltsw_hos_profile_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_multi_set(unit, profile_id, type, array_size, ctrl_type, value));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_profile_get(
    int unit,
    int profile_id,
    bcmi_ltsw_hos_type_t type,
    bcmi_ltsw_hos_profile_control_t ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_profile_get(unit, profile_id, type, ctrl_type, value));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_instance_set(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    int array_size,
    bcmi_ltsw_hos_instance_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_set(unit, type, inst_id, flow_id, array_size, ctrl_type, value));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_instance_get(
    int unit,
    bcmi_ltsw_hos_type_t type,
    int inst_id,
    int flow_id,
    int array_size,
    bcmi_ltsw_hos_instance_control_t *ctrl_type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    hos_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_instance_multi_get(unit, type, inst_id, flow_id, array_size, ctrl_type, value));

exit:
    hos_unlock(unit);
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (hos_db_is_initialized(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_hos_deinit(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_lock_create(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_init(unit));
exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_hos_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_deinit(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (hos_lock_destroy(unit));
exit:
    SHR_FUNC_EXIT();
}

