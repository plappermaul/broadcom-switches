/*~~~~~~~~~~~~~~~~~~~~~~~~~~OTN/TDM Applications~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File: cint_tdm_example.c
 * Purpose: Example shows setup configuration of TDM standard and optimize modes, with and without inner FTMH header.
 *
 * These modes are for devices that are dedicated to OTN/TDM traffic only.
 *
 * Application Sequence:
 *  1.  Set cell size constraints.
 *  2.  For a TDM port, configure the port editing settings to enable the following actions:
 *      o    At the ingress, the FTMH header is generated by the device itself.
 *      o    At the egress, the FTMH header is removed.
 *
 * The CINT consists of two applications: TDM standard and TDM optimize.
 *  o   TDM standard/optimize with inner FTMH header:
 *      o   Set the cell size range to min_size-max_size.
 *      o   Configure the port editing settings to enable the following actions:
 *          o    At the ingress: appending FTMH with a unicast/multicast destination
 *               (user settings) and user defined fields.
 *          o    At the egress: removing FTMH.
 *      o   To run application:
 *          cint_tdm_example (unit,incoming_port_id, is_multicast, is_optimize_mode ,min_size, max_size)
 *      o   Run traffic from the incoming port. Note that the packet is considered to be payload only,
 *          since the forwarding decision is performed via the appended FTMH.
 *      o   You can configure different settings for the port editing, including a different
 *          destination port, multicast group settings, FTMH actions, and user defined fields.
 *      Note: Before running the following TDM standard application, be sure the device is configured for
 *      TDM Standard/optimize. in add config-sand:
 *          o   fap_tdm_bypass.BCM88650_A0=TDM_OPTIMIZED/fap_tdm_bypass.BCM88650=TDM_STANDARD
 *          o   tm_port_header_type_<incoming_port_id>.BCM88650=TDM (for example tm_port_header_type_13.BCM88650=TDM)
 *  o   TDM standard/optimize with no inner FTMH header:
 *      o   Set the cell size range to min_size-max_size.
 *      o   Configure the port editing settings to disable the adding and removing FTMH headers at the ingress and egress.
 *      o   To run application:
 *          cint_tdm_outter_header_example (unit,incoming_port_id, is_multicast, in_size, max_size)
 *      o   Run traffic from the incoming port. Note that the packet is not considered to be payload only,
 *          since the forwarding decision is disabled via the appended FTMH.
 *      o   the packet header should contain the appropriate data:
 *              Uniticast Standard FTMH: DESTINATION_FAP_ID[3:13] OUT_FAP_PORT[33:40] Type(UC/MC)[48:48]
 *              Multicast Standard FTMH: DESTINATION_FAP_ID[3:13] OUT_FAP_PORT[49:56] Type(UC/MC)[48:48] Internaluse[41:49] must be define to 11111111
 *              Uniticast Optimize FTMH  DESTINATION_FAP_ID[13:23] OUT_FAP_PORT [24:31] Type(UC/MC)[8:8]
 *              Multicast Optimize FTMH  MC-ID[13:31] Type(UC/MC)[8:8]
 *      o   You can configure different settings for the port editing, including a different
 *          destination port, multicast group settings, FTMH actions, and user defined fields.
 *      Note: Before running the following TDM standard application, be sure the device is configured for
 *      TDM Standard/optimize. in add config-sand:
 *          o   fap_tdm_bypass.BCM88650_A0=TDM_OPTIMIZED/fap_tdm_bypass.BCM88650=TDM_STANDARD
 *          o   tm_port_header_type_<incoming_port_id>.BCM88650=TDM (for example tm_port_header_type_13.BCM88650=TDM)
 * For Petra the CINT consists of two applications: TDM standard and TDM optimize.
 *  o   TDM standard:
 *      o   Set the cell size range to 70-120.
 *      o   Configure the port editing settings to enable the following actions:
 *          o    At the ingress: appending FTMH with a unicast/multicast destination
 *               (user settings) and user defined fields.
 *          o    At the egress: removing FTMH.
 *      o   To run application:
 *          petra_std_tdm_example (unit, incoming_port_id, is_multicast)
 *      o   Run traffic from the incoming port. Note that the packet is considered to be payload only,
 *          since the forwarding decision is performed via the appended FTMH.
 *      o   You can configure different settings for the port editing, including a different
 *          destination port, multicast group settings, FTMH actions, and user defined fields.
 *      Note: Before running the following TDM standard application, be sure the device is configured for
 *      TDM Standard in dune.soc: Uncomment tdm=1
 *
 *  o   TDM optimize:
 *      Note: Before running the following TDM optimize application, be sure the device is configured for
 *      TDM Optimize in dune.soc: Uncomment tdm=1 and add fap_device_mode=TDM_OPTIMIZED.
 *      o   Set the fixed cell size to 78.
 *      o   Configure the port editing settings to enable the following actions:
 *          o    At the ingress: appending FTMH with a unicast/multicast destination (user settings).
 *          o    At the egress: removing FTMH.
 *      o   To run application:
 *          petra_opt_tdm_example (unit, incoming_port_id, is_mc_settings)
 *      o   Run traffic from the incoming port. Note that the packet is considered payload only,
 *          since the forwarding decision is performed via the appended FTMH.
 *      o   You can configure different settings for the port editing, including a different incoming port,
 *          destination port, multicast group settings, and FTMH actions.
 *
 *  Required CINTs:
 *    src/examples/sand/utility/cint_sand_utils_multicast.c
 *    src/examples/sand/utility/cint_sand_utils_global.c
 */
/*
 * If set to a non-zero value then extra printouts are ejected to help visibility
 * for debugging.
 */
int detailed_dnx_print = 0;
/*
 * Setup the TDM configuration (Both Ingress and Egress)
 */
int setup_tdm(
    int unit,
    int local_port_id,
    int dest_id,
    int is_mc,
    int add_crc,
    bcm_fabric_tdm_editing_type_t ingress_edit_type,
    bcm_fabric_tdm_editing_type_t egress_edit_type,
    int user_field_count,
    int *user_field)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_gport_t gport_local;
    bcm_fabric_tdm_editing_t ing_editing, eg_editing;
    int i;

    /* Set up the GPort to configure */
    BCM_GPORT_LOCAL_SET(gport_local,local_port_id);

    /* Set the destination and editing flags (for the Ingress) */
    if(is_mc)
    {
        ing_editing.multicast_id = dest_id; /* Destination is a MC group ID */
        ing_editing.flags = BCM_FABRIC_TDM_EDITING_INGRESS | BCM_FABRIC_TDM_EDITING_MULTICAST;
    }
    else
    {
        ing_editing.destination_port = dest_id; /* Destination is a GPort */
        ing_editing.flags = BCM_FABRIC_TDM_EDITING_INGRESS | BCM_FABRIC_TDM_EDITING_UNICAST;
    }

    /* Set the User Field */
    if (user_field_count > 48)
    {
        printf("Cant set a user field of over 48 bits");
        ing_editing.user_field_count = 0;
    }
    else
    {
        int index = 0;
        ing_editing.user_field_count = user_field_count;
        for (i = 0; i < user_field_count; i += 8) {
            ing_editing.user_field[index] = user_field[index];
            index++;
        }
    }
    /* Set the editing type according to bcm_fabric_tdm_editing_type_t */
    ing_editing.type = ingress_edit_type;
    ing_editing.add_packet_crc = add_crc;

    /* Set the Ingress configuration */
    rv = bcm_fabric_tdm_editing_set(unit,gport_local,ing_editing);
    if (rv != BCM_E_NONE)
    {
        return rv;
    }
    /* Set the Egress configuration (only editing) */
    eg_editing.flags = BCM_FABRIC_TDM_EDITING_EGRESS;
    eg_editing.type = egress_edit_type;
    eg_editing.add_packet_crc = add_crc;

    rv = bcm_fabric_tdm_editing_set(unit,gport_local,eg_editing);
    return rv;
}

/*
 * In MESH MC TDM mode,
 * When custom_feature_use_ext_tdm_mesh_mc soc_property is off
 * (It means to use IRE table).
 * We can configure mc replications:
 *                  0: local to EGQ-0
 *                  1: local to EGQ-1
 *            gport=2: replication to dest 0
 *            gport=3: replication to dest 1
 *            gport=4: replication to dest 2
 */
int cint_tdm_ext_mesh_mc_example(
    int unit,
    int local_port_id,
    int dest_port_id,
    int is_mc,
    int is_opt,
    int min_size,
    int max_size,
    int mc_port1,
    int mc_port2)
{
    bcm_gport_t dest_gport_local;
    int destid_count;
    int flags =0;
    int rv;
    int core, tm_port;
    bcm_module_t destid_array[3];

    BCM_GPORT_LOCAL_SET(dest_gport_local,dest_port_id);
    rv = cint_tdm_example_multi_device (unit, unit,
                                        local_port_id,
                                        dest_gport_local,
                                        is_mc,
                                        is_opt,
                                        min_size,
                                        max_size, mc_port1, mc_port2);

    if (rv != BCM_E_NONE)
    {
        return rv;
    }

    /* Set replication */
    destid_count = 3;

    /* We asume that all the ports on the local device */
    if (get_core_and_tm_port_from_port(unit, dest_port_id, &core, &tm_port) != BCM_E_NONE)
    {
        return rv;
    }
    destid_array[0] = core;

    if (get_core_and_tm_port_from_port(unit, mc_port1, &core, &tm_port) != BCM_E_NONE)
    {
        return rv;
    }
    destid_array[1] = core;

    if (get_core_and_tm_port_from_port(unit, mc_port2, &core, &tm_port) != BCM_E_NONE)
    {
        return rv;
    }
    destid_array[2] = core;

    rv = bcm_fabric_static_replication_set(unit, local_port_id, flags, destid_count, &destid_array);

    return rv;
}

/*
 * CINT procedures for TDM on DNX family
 * {
 */
/*
 * See dnx_tdm_ire_configure()
 *
 * 'dst_port' is the destination gport (modport, local port or logical port).
 */
int setup_dnx_tdm_ire_configure(
    int unit,
    bcm_port_t src_port,
    unsigned long channel_id,
    int is_mc,
    bcm_gport_t dst_port,
    bcm_tdm_ingress_editing_type_t type,
    int stamp_mcid_with_sid,
    int mc_id,
    bcm_tdm_interface_config_t * set_interface_config_p,
    int *ingress_context_id_p)
{
    int rv;
    int i_stream, set_stream_context;
    bcm_tdm_ingress_context_t ingress_context;
    bcm_gport_t gport;
    int stream_id;
    unsigned long flags;
    int type_as_int;
    char *proc_name;

    proc_name = "setup_dnx_tdm_ire_configure";
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): ENTER. src_port 0x%X (%d) is_mc %d dst_port 0x%08X (%d)\r\n", proc_name, src_port, src_port, is_mc, dst_port, dst_port);
    }
    rv = BCM_E_NONE;
    /*
     * Configure interface - how to generate streams?
     */
    BCM_GPORT_LOCAL_SET(gport, src_port);
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): Call %s(). gport 0x%X\r\n", proc_name, "bcm_tdm_interface_config_set", gport);
    }
    rv = bcm_tdm_interface_config_set(unit, 0, gport, set_interface_config_p);
    if (rv != BCM_E_NONE)
    {
        printf("\r\n %s(): 'bcm_tdm_interface_config_set' has failed with code %d. Quit.\r\n", proc_name, rv);
        return rv;
    }
    /*
     * Create Ingress Context
     */
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): Call %s()\r\n", proc_name, "bcm_tdm_ingress_editing_context_t_init");
    }
    bcm_tdm_ingress_editing_context_t_init(&ingress_context);
    if (is_mc == FALSE)
    {
        ingress_context.destination_port = dst_port;
        ingress_context.is_mc = FALSE;
    }
    else
    {
        ingress_context.is_mc = TRUE;
        /*
         * Should be: _BCM_MULTICAST_GROUP_SET(ingress_context.multicast_id, 0, mc_id);
         */
        ingress_context.multicast_id = mc_id;
    }
    ingress_context.type = type;
    ingress_context.stamp_mcid_with_sid = stamp_mcid_with_sid;
    /*
     * Indicate all available fabric links should be assigned to TDM (as well as
     * other sources).
     */
    flags = 0;
    type_as_int = type;
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): Call %s(). mc_id 0x%X, type %d\r\n", proc_name, "bcm_tdm_ingress_context_create",ingress_context.multicast_id, type_as_int);
    }
    rv = bcm_tdm_ingress_context_create(unit, flags, &set_stream_context, &ingress_context);
    if (rv != BCM_E_NONE)
    {
        printf("\r\n %s(): 'bcm_tdm_ingress_context_create' has failed with code %d. Quit.\r\n", proc_name, rv);
        return rv;
    }
    *ingress_context_id_p = set_stream_context;
    
    if (set_interface_config_p->stream_id_enable == TRUE)
    {
        for (i_stream = 0; i_stream < SAL_BIT(set_interface_config_p->stream_id_key_size); i_stream++)
        {
            stream_id = set_interface_config_p->stream_id_base + i_stream;
            BCM_GPORT_TDM_STREAM_SET(gport, stream_id);
            if (detailed_dnx_print)
            {
                printf("\r\n %s(): 1. Call %s()\r\n", proc_name, "bcm_tdm_stream_ingress_context_set");
            }
            rv = bcm_tdm_stream_ingress_context_set(unit, 0, gport, set_stream_context);
            if (rv != BCM_E_NONE)
            {
                printf("\r\n %s(): 1. 'bcm_tdm_stream_ingress_context_set' has failed with code %d. Quit.\r\n", proc_name, rv);
                return rv;
            }
        }
    }
    else
    {
        stream_id = set_interface_config_p->stream_id_base + channel_id;
        BCM_GPORT_TDM_STREAM_SET(gport, stream_id);
        if (detailed_dnx_print)
        {
            printf("\r\n %s(): 2. Call %s() stream_context %d stream_id %d gport 0x%X\r\n", proc_name, "bcm_tdm_stream_ingress_context_set", set_stream_context, stream_id, gport);
        }
        rv = bcm_tdm_stream_ingress_context_set(unit, 0, gport, set_stream_context);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 2. 'bcm_tdm_stream_ingress_context_set' has failed with code %d. Quit.\r\n", proc_name, rv);
            return rv;
        }
    }
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): EXIT\r\n", proc_name);
    }
    return (rv);
}

/*
 * Setup the TDM configuration (Both Ingress and Egress)
 *
 * Note that,
 *   For non-zero mc_id, 'dest_id' is the identifier of the corresponding multicast group.
 *   For zero mc_id, 'dest_id' is the destination gport. It is either modport or local port or,
 *     otherwise, logical port.
 */
int setup_dnx_tdm(
    int unit,
    bcm_port_t local_port_id,
    bcm_gport_t dest_id,
    int is_mc,
    bcm_tdm_egress_editing_type_t egress_edit_type,
    int user_bit_count,
    int *user_field)
{
    int rv;
    bcm_gport_t loc_gport;
    bcm_tdm_egress_editing_t eg_editing;
    unsigned long user_data;
    unsigned long channel_id;
    bcm_tdm_ingress_editing_type_t ingress_editing_type;
    int stamp_mcid_with_sid;
    int mc_id;
    bcm_tdm_interface_config_t tdm_interface_config;
    int context_id;
    unsigned long flags;
    char *proc_name;
    int is_dnx = 0; 

    rv = bcm_device_member_get(unit, 0, bcmDeviceMemberDNX, &is_dnx);
    if (BCM_FAILURE(rv))
    {
        printf("Error, in bcm_device_member_get, unit %d.\n", unit);
        return rv;
    }

    if (!is_dnx)
    {
        return  setup_tdm(unit, local_port_id, dest_id, is_mc, 1, bcmFabricTdmEditingAppend, bcmFabricTdmEditingRemove, user_bit_count, user_field);
    }

    proc_name = "setup_dnx_tdm";
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): ENTER. local_port_id %d dest_id %08X\r\n", proc_name,local_port_id,dest_id);
    }
    rv = BCM_E_NONE;

    /*
     * Set the destination and editing flags (for the Ingress)
     */
    channel_id = 0;
    ingress_editing_type = bcmTdmIngressEditingPrepend;
    stamp_mcid_with_sid = FALSE;
    mc_id = dest_id;
    sal_memset(&tdm_interface_config,0,sizeof(tdm_interface_config));
    tdm_interface_config.stream_id_base = 1000;
    tdm_interface_config.stream_id_enable = FALSE;
    tdm_interface_config.stream_id_key_size = 1;
    rv = setup_dnx_tdm_ire_configure(unit,local_port_id,channel_id,is_mc,dest_id,ingress_editing_type, stamp_mcid_with_sid, mc_id, &tdm_interface_config, &context_id);
    if (rv != BCM_E_NONE)
    {
        printf("\r\n %s(): 'setup_dnx_tdm_ire_configure' has failed with code %d. Quit.\r\n", proc_name, rv);
        return rv;
    }
    /*
     * Set the Egress configuration (only editing)
     * {
     */
    /*
     * Set up the GPort to configure
     */
    BCM_GPORT_LOCAL_SET(loc_gport,local_port_id);
    /*
     * Set the User Field
     */
    user_data = 0;
    if (user_bit_count > 32)
    {
        printf("\r\n %s(): Can't set a user field of over 32 bits. user_bit_count %d\r\n",proc_name, user_bit_count);
    }
    else
    {
        int bit_counter;
        int byte_counter;
        unsigned long loc_user_field;
        unsigned long loc_user_mask;

        loc_user_mask = 0x000000FF;
        for (byte_counter = 0, bit_counter = 0; bit_counter < user_bit_count; bit_counter += 8, byte_counter++, loc_user_mask <<= 8)
        {
            loc_user_field = user_field[byte_counter];
            user_data |= ((loc_user_field << bit_counter) & loc_user_mask);
        }
    }
    eg_editing.type = egress_edit_type;
    eg_editing.user_data = user_data;
    flags = 0;
    rv = bcm_tdm_egress_editing_set(unit,flags,loc_gport,&eg_editing);
    if (rv != BCM_E_NONE)
    {
        printf("\r\n %s(): 'bcm_tdm_egress_editing_set' has failed with code %d. Quit.\r\n", proc_name, rv);
        return rv;
    }
    /*
     * }
     */
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): EXIT\r\n", proc_name);
    }
    return rv;
}
/*
 * Standard/Optimized TDM Example:
 * This example can configure a MC to ports mc_port1,mc_port2 and incoming port id ,or UC to incoming incoming port id.
 * The FTMH will be appended in the ingress, and removed in the egress.
 * It also sets the Cells Size Range: min_size to max_size
 * local_port_id = Incoming BCM local port id.
 * dest_gport = Outgoing BCM local port id or mod port id or logical port id.
 * is_mc = is it multicast configuration or unicast configuration
 * min_size = min Cells Size Range: from 64
 * max_size = max Cells Size Range: up to 512/511
 */
int cint_dnx_tdm_example_multi_device(
    int src_unit,
    int dst_unit,
    bcm_port_t local_port_id,
    bcm_gport_t dest_gport,
    int is_mc,
    int mc_group_id,
    int num_in_mcast_group,
    int is_opt,
    int min_size,
    int max_size,
    int mc_port1,
    int mc_port2)
{
    int ii;
    int rv = BCM_E_NONE;
    char *proc_name;
    int mc_ports[5];
    int mc_cuds[5];
    bcm_port_t dest_gport_logical;

    proc_name = "cint_dnx_tdm_example_multi_device";
    if (detailed_dnx_print)
    {
        printf("\r\n %s(): ENTER. src_port %d dst_port %d (0x%08X) is_mc %d mc_group_id %d num_in_mcast_group %d\r\n",
                                        proc_name, local_port_id, dest_gport, dest_gport, is_mc, mc_group_id, num_in_mcast_group);
    }
    if (BCM_GPORT_IS_MODPORT(dest_gport))
    {
        dest_gport_logical = BCM_GPORT_MODPORT_PORT_GET(dest_gport);
    }
    else if (BCM_GPORT_IS_LOCAL(dest_gport))
    {
        dest_gport_logical = BCM_GPORT_LOCAL_GET(dest_gport);
    }
    else
    {
        dest_gport_logical = dest_gport;
    }
    /*
     * From this point on, 'dest_gport_logical' is assumed to be the logical port representation of 'dest_gport'
     */
    /*
     * Set the MC Parameters. Note that we create a multicast group of local ports.
     */
    mc_ports[0] = dest_gport_logical;
    mc_ports[1] = mc_port1;
    mc_ports[2] = mc_port2;
    mc_cuds[0] = 101;
    mc_cuds[1] = 101;
    mc_cuds[2] = 101;
    /*
     * Set the UC Parameters
     */
    /*
     * Set the user field parameter
     */
    int user_field_size;
    int user_field_data[2];
    bcm_tdm_egress_editing_type_t egress_edit_type;
    if (is_opt)
    {
        /*
         * Size in bits (max is 32 bits)
         */
        user_field_size = 0;

        egress_edit_type = bcmTdmEgressEditingNoHeader;
    }
    else
    {
        /*
         * Size in bits (max is 32 bits)
         */
        user_field_size = 16;
        /*
         * First 8 bits in user define will be 11
         * Second 8 bits in user define will be 22
         */
        user_field_data[0] = 0x11;
        user_field_data[1] = 0x22;

        egress_edit_type = bcmTdmEgressEditingStampMulticastUserDefined;
    }
    /*
     * Setup the MC or UC configuration
     */
    if (is_mc)
    {
        if (detailed_dnx_print)
        {
            printf("\r\n %s(): Build multicast group %d out of %d ports:\r\n", proc_name, mc_group_id, num_in_mcast_group);
            for (ii = 0; ii < num_in_mcast_group; ii++)
            {
                printf("%s(): ii %d mc_ports[ii] %d mc_cuds[ii] %d:\r\n", proc_name, ii, mc_ports[ii], mc_cuds[ii]);
            }
        }
        rv = multicast__open_egress_mc_group_with_local_ports(dst_unit, mc_group_id, mc_ports, mc_cuds, num_in_mcast_group, 0);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 'multicast__open_egress_mc_group_with_local_ports' has failed with code %d. Quit.\r\n", proc_name, rv);
            return rv;
        }
        rv = setup_dnx_tdm(src_unit, local_port_id, mc_group_id, is_mc, egress_edit_type, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 1. 'setup_dnx_tdm' has failed with code %d. Quit.\r\n", proc_name, rv);
            return rv;
        }
    }
    else
    {
        rv = setup_dnx_tdm(src_unit, local_port_id, dest_gport, is_mc, egress_edit_type, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 2. 'setup_dnx_tdm' has failed with code %d. Quit.\r\n", proc_name, rv);
            return rv;
        }
    }

    int is_dnx = 0; 

    rv = bcm_device_member_get(src_unit, 0, bcmDeviceMemberDNX, &is_dnx);

    if (is_dnx)
    {
        bcm_tdm_control_t type;
        int arg;

        type = bcmTdmBypassMinPacketSize;
        arg = min_size;
        rv = bcm_tdm_control_set(src_unit, type, arg);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 1. 'bcm_tdm_control_set' has failed with type %s. code %d. Quit.\r\n", proc_name, "bcmTdmBypassMinPacketSize", rv);
            return rv;
        }
        type = bcmTdmBypassMaxPacketSize;
        arg = max_size;
        rv = bcm_tdm_control_set(src_unit, type, arg);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 2. 'bcm_tdm_control_set' has failed with type %s. code %d. Quit.\r\n", proc_name, "bcmTdmBypassMaxPacketSize", rv);
            return rv;
        }
        type = bcmTdmOutHeaderType;
        arg = BCM_TDM_CONTROL_OUT_HEADER_FTMH;
        rv = bcm_tdm_control_set(src_unit, type, arg);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 3. 'bcm_tdm_control_set' has failed with type %s. code %d. Quit.\r\n", proc_name, "bcmTdmOutHeaderType", rv);
            return rv;
        }
        type = bcmTdmStreamMulticastPrefix;
        arg = 0;
        rv = bcm_tdm_control_set(src_unit, type, arg);
        if (rv != BCM_E_NONE)
        {
            printf("\r\n %s(): 4. 'bcm_tdm_control_set' has failed with type %s. code %d. Quit.\r\n", proc_name, "bcmTdmStreamMulticastPrefix", rv);
            return rv;
        }
    }
    else
    {
        /* Set the Cell Size Range (Calling once for min, and once for max) */
        rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMin, min_size);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
        rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMax , max_size);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
        

    }

    if (detailed_dnx_print)
    {
        printf("\r\n %s(): EXIT\r\n", proc_name);
    }
    return rv;
}
/*
 * See cint_dnx_tdm_example_multi_device description.
 * dest_port_id is expected to be local port unless 'is_mc' is set. In the latter case, it is mc_id.
 *                                              .
 */
int cint_dnx_tdm_example(
    int unit,
    bcm_port_t local_port_id,
    bcm_port_t dest_port_id,
    int is_mc,
    int is_opt,
    int min_size,
    int max_size,
    int mc_id,
    int num_in_mcast_group,
    int mc_port1,
    int mc_port2)
{
    int dnx_data_min_cell_size;
    int dnx_data_max_cell_size;
    bcm_error_t rv;
    char *proc_name;

    proc_name = "cint_dnx_tdm_example";
    rv = BCM_E_NONE;
    if (min_size > max_size)
    {
        rv = BCM_E_PARAM;
        printf("\r\n 'min_cell_size' (%d) is smaller tha 'max_cell_size' (%d).\r\n==> Illegal combination. Quit.\r\n", min_size, max_size);
        return (rv);
    }
    dnx_data_min_cell_size = *(dnxc_data_get(unit,  "tdm", "params", "pkt_size_lower_limit", NULL)); 
    dnx_data_max_cell_size = *(dnxc_data_get(unit,  "tdm", "params", "pkt_size_upper_limit", NULL)); 
    if (max_size > dnx_data_max_cell_size)
    {
        rv = BCM_E_PARAM;
        printf("\r\n %s(): 'max_cell_size' (%d) is larger than upper limit (%d).\r\n==> Illegal combination. Quit.\r\n", proc_name, max_size, dnx_data_max_cell_size);
        return (rv);
    }
    if (min_size < dnx_data_min_cell_size)
    {
        rv = BCM_E_PARAM;
        printf("\r\n %s(): 'min_cell_size' (%d) is smaller than lower limit (%d).\r\n==> Illegal combination. Quit.\r\n", proc_name, max_size, dnx_data_min_cell_size);
        return (rv);
    }
    rv = cint_dnx_tdm_example_multi_device(unit, unit,
                                         local_port_id,
                                         dest_port_id,
                                         is_mc,
                                         mc_id,
                                         num_in_mcast_group,
                                         is_opt,
                                         min_size,
                                         max_size, mc_port1, mc_port2);
    if (rv != BCM_E_NONE)
    {
        printf("\r\n %s(): 'cint_dnx_tdm_example_multi_device' has failed. Code (%d). Quit.\r\n", proc_name, rv);
        return (rv);
    }
    return (rv);
}

/*
 * }
 */

/*
 * See cint_tdm_example_multi_device description.
 * dest_port_id is expected to be local port    .
 *                                              .
 */
int cint_tdm_example(
    int unit,
    int local_port_id,
    int dest_port_id,
    int is_mc,
    int is_opt,
    int min_size,
    int max_size,
    int mc_port1,
    int mc_port2)
{
    bcm_gport_t dest_gport_local;

    BCM_GPORT_LOCAL_SET(dest_gport_local,dest_port_id);

    return cint_tdm_example_multi_device(unit, unit,
                                         local_port_id,
                                         dest_gport_local,
                                         is_mc,
                                         is_opt,
                                         min_size,
                                         max_size, mc_port1, mc_port2);
}

/*
 * Standard/Optimized TDM Example:
 * This example can configure a MC to ports 14,15 and incoming port id ,or UC to incoming incoming port id.
 * The FTMH will be appended in the ingress, and removed in the egress.
 * It also sets the Cells Size Range: min_size to max_size
 * local_port_id = Incoming BCM local port id.
 * dest_gport = Outgoing BCM local port id or mod port id.
 * is_mc = is it multicast configuration or unicast configuration
 * min_size = min Cells Size Range: from 65
 * max_size = max Cells Size Range: up to 255
 */
int cint_tdm_example_multi_device(
    int src_unit,
    int dst_unit,
    int local_port_id,
    bcm_gport_t dest_gport,
    int is_mc,
    int is_opt,
    int min_size,
    int max_size,
    int mc_port1,
    int mc_port2)
{

    bcm_error_t rv = BCM_E_NONE;
    /* Set the MC Parameters */
    int mc_group_id = 5005;
    int mc_ports[3];
    int mc_cuds[3];
    mc_ports[0] = dest_gport;
    mc_ports[1] = mc_port1;
    mc_ports[2] = mc_port2;
    mc_cuds[0] = 1;
    mc_cuds[1] = 1;
    mc_cuds[2] = 1;
    /* Set the UC Parameters */
    /*in arad you must add crc to TDM packets*/
    int add_crc = 1;
    /* Set the user field parameter */
    int user_field_size;
    int user_field_data[2];
    if (is_opt)
    {
        user_field_size = 0; /* Size in bits (max is 32 bits) */
    }
    else
    {
        user_field_size = 16; /* Size in bits (max is 32 bits) */
        /* First 8 bits in user define will be 11 */
        /* Second 8 bits in user define will be 22 */
        user_field_data[0] = 0;
        user_field_data[1] = 0;
    }
    /* Setup the MC or UC configuration */
    if (is_mc)
    {
        rv = multicast__open_egress_mc_group_with_local_ports(dst_unit, mc_group_id, mc_ports, mc_cuds, 3, 0);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
        rv = setup_tdm(src_unit, local_port_id, mc_group_id, 1, add_crc, bcmFabricTdmEditingAppend ,bcmFabricTdmEditingRemove, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    }
    else
    {
        rv = setup_tdm(src_unit, local_port_id, dest_gport, 0, add_crc, bcmFabricTdmEditingAppend ,bcmFabricTdmEditingRemove, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    }
    /* Set the Cell Size Range (Calling once for min, and once for max) */
    rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMin, min_size);
    if (rv != BCM_E_NONE)
    {
        return rv;
    }
    rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMax , max_size);

    return rv;
}

int cint_multi_device_tdm_example(
    int src_unit,
    int dst_unit,
    int local_port_id,
    bcm_gport_t dest_gport,
    int is_mc,
    int min_size,
    int max_size,
    int mc_group_id)
{
    bcm_error_t rv = BCM_E_NONE;
    int nof_mc_ports = 1;
    /* Set the MC Parameters */
    int mc_ports[nof_mc_ports];
    int mc_cuds[nof_mc_ports];
    mc_ports[0] = dest_gport;
    mc_cuds[0] = 1;
    /* Set the UC Parameters */
    /*in arad you must add crc to TDM packets*/
    int add_crc = 1;
    /* Set the user field parameter */
    int user_field_size;
    int user_field_data[2];
    user_field_size = 16; /* Size in bits (max is 32 bits) */
    /* First 8 bits in user define will be 11 */
    /* Second 8 bits in user define will be 22 */
    user_field_data[0] = 0;
    user_field_data[1] = 0;

    /* Setup the MC or UC configuration */
    if (is_mc)
    {
        rv = multicast__open_egress_mc_group_with_local_ports(dst_unit, mc_group_id, mc_ports, mc_cuds, 1, 0);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
        rv = setup_tdm(src_unit, local_port_id, mc_group_id, 1, add_crc,
                       bcmFabricTdmEditingAppend ,bcmFabricTdmEditingRemove,
                       user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    }
    else
    {
        rv = setup_tdm(src_unit, local_port_id, dest_gport,  0, add_crc,
                       bcmFabricTdmEditingAppend ,bcmFabricTdmEditingRemove,
                       user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    }

    /* Set the Cell Size Range (Calling once for min, and once for max) */
    rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMin, min_size);
    if (rv != BCM_E_NONE)
    {
        return rv;
    }
    rv = bcm_fabric_control_set(src_unit, bcmFabricCellSizeMax , max_size);

    return rv;
}

/*
 * Standard/Optimized TDM Example:
 * This example can configure a MC to ports 14,15 and incoming port id ,or UC to incoming incoming port id.
 * The FTMH will not be appended in the ingress, and will nor be removed in the egress.
 * Set the Cells Size Range: min_size to max_size
 * local_port_id = Incoming BCM local port id.
 * dest_port_id = Outgoing BCM local port id.
 * is_mc = is it multicast configuration or unicast configuration
 * min_size = min Cells Size Range: from 65
 * max_size = max Cells Size Range: up to 255
 */
int cint_tdm_outter_header_example (
    int unit,
    int local_port_id,
    int dest_port_id,
    int is_mc,
    int min_size,
    int max_size,
    int mc_port1,
    int mc_port2)
{
    bcm_error_t rv = BCM_E_NONE;

    /* Set the MC Parameters */
    int mc_group_id = 5005;
    int mc_ports[3];
    int mc_cuds[3];
    mc_ports[0] = dest_port_id;
    mc_ports[1] = mc_port1;
    mc_ports[2] = mc_port2;
    mc_cuds[0] = 0x123;
    mc_cuds[1] = 0x789;
    mc_cuds[2] = 0x975;

    /* Set the UC Parameters */
    /*in arad you must add crc to TDM packets*/
    int add_crc = 1;
    /* Set the user field parameter:
       there is no inner header so there is no use for user fields */
    int user_field_size = 0;
    int user_field_data[2];
    /*
     * Setup the MC or UC configuration
     */
    if (is_mc)
    {
        int enable_outer_ftmh_cud_stamping = (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "tdm_eg_editing_is_cud_stamping", 0) == 1) || 
                                             (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "tdm_eg_editing_is_cud_stamping_type1", 0) == 1);
        bcm_fabric_tdm_editing_type_t egress_edit_type = (enable_outer_ftmh_cud_stamping ? bcmFabricTdmEditingCustomExternal : bcmFabricTdmEditingNoChange);
        rv = multicast__open_egress_mc_group_with_local_ports(unit, mc_group_id, mc_ports, mc_cuds, 3, 0);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
        rv = setup_tdm(unit, local_port_id, 0, 1, add_crc, bcmFabricTdmEditingNoChange, egress_edit_type, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    } else {
        rv = setup_tdm(unit, local_port_id, 0, 0, add_crc, bcmFabricTdmEditingNoChange,bcmFabricTdmEditingNoChange, user_field_size, user_field_data);
        if (rv != BCM_E_NONE)
        {
            return rv;
        }
    }

    /* Set the Cell Size Range (Calling once for min, and once for max) */

    rv = bcm_fabric_control_set(unit, bcmFabricCellSizeMin, min_size);
    if (rv != BCM_E_NONE)
    {
        return rv;
    }
    rv = bcm_fabric_control_set(unit, bcmFabricCellSizeMax , max_size);

    return rv;
}

