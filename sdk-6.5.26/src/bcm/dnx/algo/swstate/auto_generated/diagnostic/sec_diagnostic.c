/** \file algo/swstate/auto_generated/diagnostic/sec_diagnostic.c
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

#include <bcm_int/dnx/algo/swstate/auto_generated/diagnostic/sec_diagnostic.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/layout/sec_layout.h>
#if defined(DNX_SW_STATE_DIAGNOSTIC)
/*
 * Global Variables
 */

extern dnx_sec_t * dnx_sec_db_data[SOC_MAX_NUM_DEVICES];
/*
 * FUNCTIONs
 */

/*
 *
 * dump function for the variable dnx_sec_db
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_stat_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_dump(unit, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable ingress_sec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_flow_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_policy_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_tcam_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_default_policy_id_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_index_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable flow_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_flow_res_mngr_dump(int  unit,  int  flow_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = flow_res_mngr_idx_0, I0 = flow_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec flow_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec flow_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/flow_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.flow_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__FLOW_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__FLOW_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.flow_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__FLOW_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.flow_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable policy_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_policy_res_mngr_dump(int  unit,  int  policy_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = policy_res_mngr_idx_0, I0 = policy_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec policy_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec policy_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/policy_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.policy_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__POLICY_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__POLICY_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.policy_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__POLICY_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.policy_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sc_res_mngr_dump(int  unit,  int  sc_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_res_mngr_idx_0, I0 = sc_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_tcam_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sc_tcam_res_mngr_dump(int  unit,  int  sc_tcam_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_tcam_res_mngr_idx_0, I0 = sc_tcam_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_tcam_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_tcam_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_tcam_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_tcam_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_TCAM_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_TCAM_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_TCAM_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_tcam_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sa_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sa_res_mngr_dump(int  unit,  int  sa_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_res_mngr_idx_0, I0 = sa_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sa_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sa_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sa_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable default_policy_id
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_default_policy_id_dump(int  unit,  int  default_policy_id_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = default_policy_id_idx_0, I0 = default_policy_id_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec default_policy_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec default_policy_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/default_policy_id.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.default_policy_id[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__DEFAULT_POLICY_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__DEFAULT_POLICY_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.default_policy_id[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__DEFAULT_POLICY_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.default_policy_id[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_index_map
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sc_index_map_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_sc_tcam_index_dump(unit, sc_index_map_idx_0,sc_index_map_idx_1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_is_ipsec_dump(unit, sc_index_map_idx_0,sc_index_map_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_tcam_index
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sc_index_map_sc_tcam_index_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  int  sc_tcam_index_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_map_idx_0, I0 = sc_index_map_idx_0 + 1;
    int i1 = sc_index_map_idx_1, I1 = sc_index_map_idx_1 + 1, org_i1 = sc_index_map_idx_1;
    int i2 = sc_tcam_index_idx_0, I2 = sc_tcam_index_idx_0 + 1, org_i2 = sc_tcam_index_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_index_map sc_tcam_index") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_index_map sc_tcam_index\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_index_map/sc_tcam_index.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[][].sc_tcam_index[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__SC_TCAM_INDEX, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = 2;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index
                        , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= 2)
                {
                    LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(2 == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[%s%d][%s%d].sc_tcam_index[%s%d]: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_int(
                        unit,
                        &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index[i2]);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sc_index_map_is_ipsec_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_map_idx_0, I0 = sc_index_map_idx_0 + 1;
    int i1 = sc_index_map_idx_1, I1 = sc_index_map_idx_1 + 1, org_i1 = sc_index_map_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_index_map is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_index_map is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_index_map/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SC_INDEX_MAP__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sa_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sa_index_info_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_index_info_is_ipsec_dump(unit, sa_index_info_idx_0,sa_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_ingress_sec_sa_index_info_is_ipsec_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_index_info_idx_0, I0 = sa_index_info_idx_0 + 1;
    int i1 = sa_index_info_idx_1, I1 = sa_index_info_idx_1 + 1, org_i1 = sa_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sa_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sa_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sa_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__INGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable egress_sec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_index_info_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_index_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sc_res_mngr_dump(int  unit,  int  sc_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_res_mngr_idx_0, I0 = sc_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sc_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sc_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sc_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sa_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sa_res_mngr_dump(int  unit,  int  sa_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_res_mngr_idx_0, I0 = sa_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sa_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sa_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sa_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sa_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sa_index_info_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_index_info_is_ipsec_dump(unit, sa_index_info_idx_0,sa_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sa_index_info_is_ipsec_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_index_info_idx_0, I0 = sa_index_info_idx_0 + 1;
    int i1 = sa_index_info_idx_1, I1 = sa_index_info_idx_1 + 1, org_i1 = sa_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sa_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sa_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sa_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SA_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sc_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sc_index_info_dump(int  unit,  int  sc_index_info_idx_0,  int  sc_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_index_info_is_ipsec_dump(unit, sc_index_info_idx_0,sc_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_egress_sec_sc_index_info_is_ipsec_dump(int  unit,  int  sc_index_info_idx_0,  int  sc_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_info_idx_0, I0 = sc_index_info_idx_0 + 1;
    int i1 = sc_index_info_idx_1, I1 = sc_index_info_idx_1 + 1, org_i1 = sc_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sc_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sc_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sc_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__EGRESS_SEC__SC_INDEX_INFO__IS_IPSEC, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable control_sec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_trunk_info_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_power_down_info_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_port_state_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable trunk_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_trunk_info_dump(int  unit,  int  trunk_info_idx_0,  int  trunk_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_trunk_info_is_macsec_enabled_dump(unit, trunk_info_idx_0,trunk_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_macsec_enabled
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_trunk_info_is_macsec_enabled_dump(int  unit,  int  trunk_info_idx_0,  int  trunk_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = trunk_info_idx_0, I0 = trunk_info_idx_0 + 1;
    int i1 = trunk_info_idx_1, I1 = trunk_info_idx_1 + 1, org_i1 = trunk_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec control_sec trunk_info is_macsec_enabled") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec control_sec trunk_info is_macsec_enabled\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/control_sec/trunk_info/is_macsec_enabled.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.trunk_info[][].is_macsec_enabled: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.trunk_info[][].is_macsec_enabled: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.trunk_info[][].is_macsec_enabled: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__TRUNK_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.trunk_info[%s%d][%s%d].is_macsec_enabled: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0][i1].is_macsec_enabled);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable power_down_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_power_down_info_dump(int  unit,  int  power_down_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_power_down_info_is_powered_down_dump(unit, power_down_info_idx_0, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_power_down_info_is_forced_power_up_state_dump(unit, power_down_info_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_powered_down
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_power_down_info_is_powered_down_dump(int  unit,  int  power_down_info_idx_0,  int  is_powered_down_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = power_down_info_idx_0, I0 = power_down_info_idx_0 + 1;
    int i1 = is_powered_down_idx_0, I1 = is_powered_down_idx_0 + 1, org_i1 = is_powered_down_idx_0;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec control_sec power_down_info is_powered_down") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec control_sec power_down_info is_powered_down\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/control_sec/power_down_info/is_powered_down.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.power_down_info[].is_powered_down[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.power_down_info[].is_powered_down[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.power_down_info[].is_powered_down[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_POWERED_DOWN, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.power_down_info[%s%d].is_powered_down[%s%d]: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_powered_down[i1]);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_forced_power_up_state
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_power_down_info_is_forced_power_up_state_dump(int  unit,  int  power_down_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = power_down_info_idx_0, I0 = power_down_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec control_sec power_down_info is_forced_power_up_state") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec control_sec power_down_info is_forced_power_up_state\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/control_sec/power_down_info/is_forced_power_up_state.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.power_down_info[].is_forced_power_up_state: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_FORCED_POWER_UP_STATE,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_FORCED_POWER_UP_STATE, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.power_down_info[].is_forced_power_up_state: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__POWER_DOWN_INFO__IS_FORCED_POWER_UP_STATE, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.power_down_info[%s%d].is_forced_power_up_state: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.power_down_info[i0].is_forced_power_up_state);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable port_state_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_port_state_info_dump(int  unit,  int  port_state_info_idx_0,  int  port_state_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_port_state_info_is_macsec_enabled_dump(unit, port_state_info_idx_0,port_state_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_macsec_enabled
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_control_sec_port_state_info_is_macsec_enabled_dump(int  unit,  int  port_state_info_idx_0,  int  port_state_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = port_state_info_idx_0, I0 = port_state_info_idx_0 + 1;
    int i1 = port_state_info_idx_1, I1 = port_state_info_idx_1 + 1, org_i1 = port_state_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec control_sec port_state_info is_macsec_enabled") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec control_sec port_state_info is_macsec_enabled\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/control_sec/port_state_info/is_macsec_enabled.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.port_state_info[][].is_macsec_enabled: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.port_state_info[][].is_macsec_enabled: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.port_state_info[][].is_macsec_enabled: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__CONTROL_SEC__PORT_STATE_INFO__IS_MACSEC_ENABLED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.port_state_info[%s%d][%s%d].is_macsec_enabled: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.port_state_info[i0][i1].is_macsec_enabled);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable stat_sec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_stat_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_stat_sec_stat_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable stat_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_stat_sec_stat_info_dump(int  unit,  int  stat_info_idx_0,  int  stat_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_stat_sec_stat_info_value_info_dump(unit, stat_info_idx_0,stat_info_idx_1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable value_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_stat_sec_stat_info_value_info_dump(int  unit,  int  stat_info_idx_0,  int  stat_info_idx_1,  int  value_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = stat_info_idx_0, I0 = stat_info_idx_0 + 1;
    int i1 = stat_info_idx_1, I1 = stat_info_idx_1 + 1, org_i1 = stat_info_idx_1;
    int i2 = value_info_idx_0, I2 = value_info_idx_0 + 1, org_i2 = value_info_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint64") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec stat_sec stat_info value_info") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec stat_sec stat_info value_info\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/stat_sec/stat_info/value_info.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","stat_sec.stat_info[][].value_info[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->stat_sec.stat_info[][].value_info[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->stat_sec.stat_info[][].value_info[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO,
                        ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info
                        , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info))
                {
                    LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->stat_sec.stat_info[][].value_info[]: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__STAT_SEC__STAT_INFO__VALUE_INFO, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","stat_sec.stat_info[%s%d][%s%d].value_info[%s%d]: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint64(
                        unit,
                        &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->stat_sec.stat_info[i0][i1].value_info[i2]);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable wrapper_sec
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_wrapper_info_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_nif_port_info_dump(unit, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable wrapper_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_wrapper_info_dump(int  unit,  int  wrapper_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_wrapper_info_subscribed_speed_dump(unit, wrapper_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_wrapper_info_active_calendar_dump(unit, wrapper_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_wrapper_info_sec_port_res_mngr_dump(unit, wrapper_info_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable subscribed_speed
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_wrapper_info_subscribed_speed_dump(int  unit,  int  wrapper_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = wrapper_info_idx_0, I0 = wrapper_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec wrapper_info subscribed_speed") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec wrapper_info subscribed_speed\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/wrapper_info/subscribed_speed.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[].subscribed_speed: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SUBSCRIBED_SPEED,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SUBSCRIBED_SPEED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.wrapper_info[].subscribed_speed: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SUBSCRIBED_SPEED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[%s%d].subscribed_speed: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info[i0].subscribed_speed);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable active_calendar
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_wrapper_info_active_calendar_dump(int  unit,  int  wrapper_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = wrapper_info_idx_0, I0 = wrapper_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec wrapper_info active_calendar") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec wrapper_info active_calendar\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/wrapper_info/active_calendar.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[].active_calendar: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__ACTIVE_CALENDAR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__ACTIVE_CALENDAR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.wrapper_info[].active_calendar: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__ACTIVE_CALENDAR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[%s%d].active_calendar: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info[i0].active_calendar);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sec_port_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_wrapper_info_sec_port_res_mngr_dump(int  unit,  int  wrapper_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = wrapper_info_idx_0, I0 = wrapper_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec wrapper_info sec_port_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec wrapper_info sec_port_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/wrapper_info/sec_port_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[].sec_port_res_mngr: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SEC_PORT_RES_MNGR,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SEC_PORT_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.wrapper_info[].sec_port_res_mngr: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__WRAPPER_INFO__SEC_PORT_RES_MNGR, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.wrapper_info[%s%d].sec_port_res_mngr: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.wrapper_info[i0].sec_port_res_mngr);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable nif_port_info
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_nif_port_info_dump(int  unit,  int  nif_port_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_nif_port_info_sec_port_dump(unit, nif_port_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_nif_port_info_wrapper_id_dump(unit, nif_port_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_nif_port_info_is_bypass_dump(unit, nif_port_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_wrapper_sec_nif_port_info_is_macsec_requested_dump(unit, nif_port_info_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable sec_port
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_nif_port_info_sec_port_dump(int  unit,  int  nif_port_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = nif_port_info_idx_0, I0 = nif_port_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec nif_port_info sec_port") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec nif_port_info sec_port\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/nif_port_info/sec_port.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[].sec_port: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__SEC_PORT,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__SEC_PORT, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.nif_port_info[].sec_port: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__SEC_PORT, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[%s%d].sec_port: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info[i0].sec_port);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable wrapper_id
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_nif_port_info_wrapper_id_dump(int  unit,  int  nif_port_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = nif_port_info_idx_0, I0 = nif_port_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec nif_port_info wrapper_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec nif_port_info wrapper_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/nif_port_info/wrapper_id.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[].wrapper_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__WRAPPER_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__WRAPPER_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.nif_port_info[].wrapper_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__WRAPPER_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[%s%d].wrapper_id: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info[i0].wrapper_id);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_bypass
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_nif_port_info_is_bypass_dump(int  unit,  int  nif_port_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = nif_port_info_idx_0, I0 = nif_port_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec nif_port_info is_bypass") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec nif_port_info is_bypass\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/nif_port_info/is_bypass.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[].is_bypass: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_BYPASS,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_BYPASS, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.nif_port_info[].is_bypass: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_BYPASS, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[%s%d].is_bypass: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info[i0].is_bypass);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 *
 * dump function for the variable is_macsec_requested
 * AUTO-GENERATED - DO NOT MODIFY
 *
 */
int
dnx_sec_db_wrapper_sec_nif_port_info_is_macsec_requested_dump(int  unit,  int  nif_port_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = nif_port_info_idx_0, I0 = nif_port_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec wrapper_sec nif_port_info is_macsec_requested") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec wrapper_sec nif_port_info is_macsec_requested\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/wrapper_sec/nif_port_info/is_macsec_requested.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[].is_macsec_requested: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_MACSEC_REQUESTED,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_MACSEC_REQUESTED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->wrapper_sec.nif_port_info[].is_macsec_requested: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SW_STATE_DNX_SEC_DB__WRAPPER_SEC__NIF_PORT_INFO__IS_MACSEC_REQUESTED, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","wrapper_sec.nif_port_info[%s%d].is_macsec_requested: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->wrapper_sec.nif_port_info[i0].is_macsec_requested);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}


/*
 * Global Variables
 */

dnx_sw_state_diagnostic_info_t dnx_sec_db_info[SOC_MAX_NUM_DEVICES][DNX_SEC_DB_INFO_NOF_ENTRIES];
const char* dnx_sec_db_layout_str[DNX_SEC_DB_INFO_NOF_ENTRIES] = {
    "DNX_SEC_DB~",
    "DNX_SEC_DB~INGRESS_SEC~",
    "DNX_SEC_DB~INGRESS_SEC~FLOW_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~POLICY_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SC_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SC_TCAM_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SA_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~DEFAULT_POLICY_ID~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~SC_TCAM_INDEX~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~IS_IPSEC~",
    "DNX_SEC_DB~INGRESS_SEC~SA_INDEX_INFO~",
    "DNX_SEC_DB~INGRESS_SEC~SA_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~EGRESS_SEC~",
    "DNX_SEC_DB~EGRESS_SEC~SC_RES_MNGR~",
    "DNX_SEC_DB~EGRESS_SEC~SA_RES_MNGR~",
    "DNX_SEC_DB~EGRESS_SEC~SA_INDEX_INFO~",
    "DNX_SEC_DB~EGRESS_SEC~SA_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~EGRESS_SEC~SC_INDEX_INFO~",
    "DNX_SEC_DB~EGRESS_SEC~SC_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~CONTROL_SEC~",
    "DNX_SEC_DB~CONTROL_SEC~TRUNK_INFO~",
    "DNX_SEC_DB~CONTROL_SEC~TRUNK_INFO~IS_MACSEC_ENABLED~",
    "DNX_SEC_DB~CONTROL_SEC~POWER_DOWN_INFO~",
    "DNX_SEC_DB~CONTROL_SEC~POWER_DOWN_INFO~IS_POWERED_DOWN~",
    "DNX_SEC_DB~CONTROL_SEC~POWER_DOWN_INFO~IS_FORCED_POWER_UP_STATE~",
    "DNX_SEC_DB~CONTROL_SEC~PORT_STATE_INFO~",
    "DNX_SEC_DB~CONTROL_SEC~PORT_STATE_INFO~IS_MACSEC_ENABLED~",
    "DNX_SEC_DB~STAT_SEC~",
    "DNX_SEC_DB~STAT_SEC~STAT_INFO~",
    "DNX_SEC_DB~STAT_SEC~STAT_INFO~VALUE_INFO~",
    "DNX_SEC_DB~WRAPPER_SEC~",
    "DNX_SEC_DB~WRAPPER_SEC~WRAPPER_INFO~",
    "DNX_SEC_DB~WRAPPER_SEC~WRAPPER_INFO~SUBSCRIBED_SPEED~",
    "DNX_SEC_DB~WRAPPER_SEC~WRAPPER_INFO~ACTIVE_CALENDAR~",
    "DNX_SEC_DB~WRAPPER_SEC~WRAPPER_INFO~SEC_PORT_RES_MNGR~",
    "DNX_SEC_DB~WRAPPER_SEC~NIF_PORT_INFO~",
    "DNX_SEC_DB~WRAPPER_SEC~NIF_PORT_INFO~SEC_PORT~",
    "DNX_SEC_DB~WRAPPER_SEC~NIF_PORT_INFO~WRAPPER_ID~",
    "DNX_SEC_DB~WRAPPER_SEC~NIF_PORT_INFO~IS_BYPASS~",
    "DNX_SEC_DB~WRAPPER_SEC~NIF_PORT_INFO~IS_MACSEC_REQUESTED~",
};
#endif /* DNX_SW_STATE_DIAGNOSTIC */
#undef BSL_LOG_MODULE
