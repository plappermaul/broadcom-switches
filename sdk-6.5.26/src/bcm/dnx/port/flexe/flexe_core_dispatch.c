
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif /* BCM_DNX_SUPPORT */

#include <bcm_int/dnx/algo/swstate/auto_generated/access/dnx_algo_flexe_core_access.h>
#include <flexe_drv.h>
#include <bcm_int/dnx/port/flexe/flexe_core.h>
#include <bcm_int/dnx/port/flexe/flexe_core_dispatch.h>

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT

const __flexe_core__dispatch__t__ flexe_core_None_driver = { NULL };
extern __flexe_core__dispatch__t__ flexe_core_flexe_std_driver;
#ifdef INCLUDE_FLEXE_DBG
extern __flexe_core__dispatch__t__ flexe_core_flexe_dbg_driver;
#endif
extern __flexe_core__dispatch__t__ flexe_core_flexe_std_gen2_driver;

const __flexe_core__dispatch__t__ *__flexe_core__dispatch__[flexe_coreDispatchTypeCount] = {
    &flexe_core_None_driver,
    &flexe_core_flexe_std_driver,
#ifdef INCLUDE_FLEXE_DBG
    &flexe_core_flexe_dbg_driver,
#endif
    &flexe_core_flexe_std_gen2_driver,

};

int
flexe_core_dispatch_type_t_validate(
    int unit,
    flexe_core_dispatch_type_t flexe_core_dispatch_type)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_dispatch_type >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_init(
    int unit)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_init)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_init(unit);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_init isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_deinit(
    int unit)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_deinit)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_deinit(unit);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_deinit isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sync(
    int unit)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sync)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sync(unit);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sync isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_speed_mode_t_validate(
    int unit,
    flexe_core_port_speed_mode_t flexe_core_port_speed_mode)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_port_speed_mode >= flexe_core_port_speed_mode_Count)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_serdes_rate_mode_t_validate(
    int unit,
    flexe_core_serdes_rate_mode_t flexe_core_serdes_rate_mode)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_serdes_rate_mode >= flexe_core_serdes_rate_mode_Count)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_info_t_validate(
    int unit,
    const flexe_core_port_info_t * flexe_core_port_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_port_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

    if (_SHR_E_NONE != flexe_core_serdes_rate_mode_t_validate(unit, flexe_core_port_info->serdes_rate_mode))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "serdes_rate_mode validation failed");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_info_t_init(
    int unit,
    flexe_core_port_info_t * flexe_core_port_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_port_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_port_info NULL parameter");
    }
    sal_memset(flexe_core_port_info, 0, sizeof(flexe_core_port_info_t));
    flexe_core_port_info->is_bypass = 0;
    flexe_core_port_info->speed = 0;
    flexe_core_port_info->serdes_rate_mode = flexe_core_serdes_rate_mode_25G;

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_rate_adpt_info_t_validate(
    int unit,
    const flexe_core_rate_adpt_info_t * flexe_core_rate_adpt_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_rate_adpt_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_rate_adpt_info_t_init(
    int unit,
    flexe_core_rate_adpt_info_t * flexe_core_rate_adpt_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_rate_adpt_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_rate_adpt_info NULL parameter");
    }
    sal_memset(flexe_core_rate_adpt_info, 0, sizeof(flexe_core_rate_adpt_info_t));
    flexe_core_rate_adpt_info->speed = 0;
    flexe_core_rate_adpt_info->bus_type = 0;
    flexe_core_rate_adpt_info->module_id = 0;

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_sar_jitter_fifo_level_t_validate(
    int unit,
    const flexe_core_sar_jitter_fifo_level_t * flexe_core_sar_jitter_fifo_level)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_sar_jitter_fifo_level == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_sar_jitter_fifo_level_t_init(
    int unit,
    flexe_core_sar_jitter_fifo_level_t * flexe_core_sar_jitter_fifo_level)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_sar_jitter_fifo_level == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_sar_jitter_fifo_level NULL parameter");
    }
    sal_memset(flexe_core_sar_jitter_fifo_level, 0, sizeof(flexe_core_sar_jitter_fifo_level_t));
    flexe_core_sar_jitter_fifo_level->high_level = 0;
    flexe_core_sar_jitter_fifo_level->tolerance_level = 0;
    flexe_core_sar_jitter_fifo_level->low_level = 0;

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_group_phy_add(
    int unit,
    uint32 flags,
    int group_index,
    soc_pbmp_t flexe_core_port_bmp,
    const int *logical_phy_id,
    const flexe_core_port_info_t * port_info)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_port_info_t_validate(unit, port_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "port_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_add)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_add(unit, flags, group_index,
                                                                           flexe_core_port_bmp, logical_phy_id,
                                                                           port_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_group_phy_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_group_phy_remove(
    int unit,
    uint32 flags,
    int group_index,
    soc_pbmp_t flexe_core_port_bmp)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_remove)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_remove(unit, flags, group_index,
                                                                              flexe_core_port_bmp);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_group_phy_remove isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_add(
    int unit,
    int client_channel,
    uint32 flags,
    int cal_id,
    const int *flexe_core_port_array,
    bcm_port_flexe_time_slot_t ts_mask,
    int nof_flexe_core_ports)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_add)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_add(unit, client_channel, flags, cal_id,
                                                                        flexe_core_port_array, ts_mask,
                                                                        nof_flexe_core_ports);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_delete(
    int unit,
    int client_channel,
    uint32 flags,
    int cal_id,
    const int *flexe_core_port_array,
    bcm_port_flexe_time_slot_t ts_mask,
    int nof_flexe_core_ports)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_delete)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_delete(unit, client_channel, flags, cal_id,
                                                                           flexe_core_port_array, ts_mask,
                                                                           nof_flexe_core_ports);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_mac_client_add(
    int unit,
    int client_channel,
    int speed)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_add(unit, client_channel, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_mac_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_mac_client_delete(
    int unit,
    int client_channel,
    int speed)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_delete)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_delete(unit, client_channel, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_mac_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_add(
    int unit,
    int client_channel,
    uint32 flags,
    int speed)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_add(unit, client_channel, flags, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_delete(
    int unit,
    int client_channel,
    uint32 flags,
    int speed)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_delete)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_delete(unit, client_channel, flags, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_rateadpt_add(
    int unit,
    int client_channel,
    const flexe_core_rate_adpt_info_t * rate_adpt_info)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_rate_adpt_info_t_validate(unit, rate_adpt_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "rate_adpt_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_add(unit, client_channel, rate_adpt_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_rateadpt_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_rateadpt_delete(
    int unit,
    int client_channel,
    const flexe_core_rate_adpt_info_t * rate_adpt_info)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_rate_adpt_info_t_validate(unit, rate_adpt_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "rate_adpt_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_delete)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_delete(unit, client_channel, rate_adpt_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_rateadpt_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_sar_channel_map_info_t_validate(
    int unit,
    const flexe_core_sar_channel_map_info_t * flexe_core_sar_channel_map_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_sar_channel_map_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_sar_channel_map_info_t_init(
    int unit,
    flexe_core_sar_channel_map_info_t * flexe_core_sar_channel_map_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_sar_channel_map_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_sar_channel_map_info NULL parameter");
    }
    sal_memset(flexe_core_sar_channel_map_info, 0, sizeof(flexe_core_sar_channel_map_info_t));
    flexe_core_sar_channel_map_info->sar_channel = 0;
    flexe_core_sar_channel_map_info->peer_channel = 0;

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_channel_map_set(
    int unit,
    uint32 flags,
    const flexe_core_sar_channel_map_info_t * map_info,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_sar_channel_map_info_t_validate(unit, map_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "map_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_channel_map_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_channel_map_set(unit, flags, map_info, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_channel_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_66bswitch_channel_info_t_validate(
    int unit,
    const flexe_core_66bswitch_channel_info_t * flexe_core_66bswitch_channel_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_66bswitch_channel_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_66bswitch_channel_info_t_init(
    int unit,
    flexe_core_66bswitch_channel_info_t * flexe_core_66bswitch_channel_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_66bswitch_channel_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_66bswitch_channel_info NULL parameter");
    }
    sal_memset(flexe_core_66bswitch_channel_info, 0, sizeof(flexe_core_66bswitch_channel_info_t));
    flexe_core_66bswitch_channel_info->block_id = 0;
    flexe_core_66bswitch_channel_info->channel = 0;

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_66b_switch_set(
    int unit,
    const flexe_core_66bswitch_channel_info_t * src_info,
    const flexe_core_66bswitch_channel_info_t * dest_info,
    int index,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_validate(unit, src_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "src_info validation failed");
    }

    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_validate(unit, dest_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "dest_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_set(unit, src_info, dest_info, index, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_66b_switch_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_66b_switch_get(
    int unit,
    const flexe_core_66bswitch_channel_info_t * src_info,
    flexe_core_66bswitch_channel_info_t * dest_info,
    int *nof_dest)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_validate(unit, src_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "src_info validation failed");
    }

    if (dest_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "dest_info NULL parameter");
    }
    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_init(unit, dest_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "dest_info initialization failed");
    }

    if (nof_dest == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "nof_dest NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_get(unit, src_info, dest_info, nof_dest);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_66b_switch_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_66b_switch_reverse_get(
    int unit,
    const flexe_core_66bswitch_channel_info_t * dest_info,
    flexe_core_66bswitch_channel_info_t * src_info,
    int *nof_src)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_validate(unit, dest_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "dest_info validation failed");
    }

    if (src_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "src_info NULL parameter");
    }
    if (_SHR_E_NONE != flexe_core_66bswitch_channel_info_t_init(unit, src_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "src_info initialization failed");
    }

    if (nof_src == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "nof_src NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_reverse_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_reverse_get(unit, dest_info, src_info, nof_src);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_66b_switch_reverse_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_logical_phy_id_set(
    int unit,
    int flexe_core_port,
    int speed,
    int logical_phy_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_set(unit, flexe_core_port, speed,
                                                                                   logical_phy_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_logical_phy_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_logical_phy_id_get(
    int unit,
    int flexe_core_port,
    int speed,
    uint32 flags,
    int *logical_phy_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (logical_phy_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "logical_phy_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_get(unit, flexe_core_port, speed, flags,
                                                                                   logical_phy_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_logical_phy_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_group_id_set(
    int unit,
    int flexe_core_port,
    int group_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_set(unit, flexe_core_port, group_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_group_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_group_id_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *group_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (group_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "group_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_get(unit, flexe_core_port, flags, group_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_group_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_client_id_set(
    int unit,
    int cal_id,
    int nof_ports,
    const int *flexe_core_port_array,
    int nof_slots,
    const int *calendar_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_set(unit, cal_id, nof_ports,
                                                                              flexe_core_port_array, nof_slots,
                                                                              calendar_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_client_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_client_id_get(
    int unit,
    int cal_id,
    uint32 flags,
    int nof_ports,
    const int *flexe_core_port_array,
    int nof_slots,
    int *calendar_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (calendar_slots == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "calendar_slots NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_get(unit, cal_id, flags, nof_ports,
                                                                              flexe_core_port_array, nof_slots,
                                                                              calendar_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_client_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cr_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cr_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cr_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cr_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_ca_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_ca_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_ca_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_ca_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_c_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_c_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_c_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_c_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_sc_bit_set(
    int unit,
    int flexe_core_port,
    int sync_config)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_set(unit, flexe_core_port, sync_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_sc_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_sc_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *sync_config)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (sync_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "sync_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_get(unit, flexe_core_port, flags, sync_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_sc_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_active_calendar_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_active_calendar_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_active_calendar_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_active_calendar_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_alarm_status_get(
    int unit,
    int flexe_core_port,
    uint16 *alarm_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (alarm_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "alarm_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_alarm_status_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_alarm_status_get(unit, flexe_core_port, alarm_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_alarm_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cal_mismatch_ts_get(
    int unit,
    int flexe_core_port,
    bcm_port_flexe_time_slot_t * time_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (time_slots == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "time_slots NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cal_mismatch_ts_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cal_mismatch_ts_get(unit, flexe_core_port, time_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cal_mismatch_ts_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_status_get(
    int unit,
    int flexe_core_port,
    uint16 *alarms_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (alarms_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "alarms_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_status_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_status_get(unit, flexe_core_port, alarms_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_alarm_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_period_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 base_period)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_set(unit, client_channel, flags,
                                                                                 base_period);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_period_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_period_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *base_period)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (base_period == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "base_period NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_get(unit, client_channel, flags,
                                                                                 base_period);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_period_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_insert_enable_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_insert_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_insert_enable_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_insert_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bypass_enable_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_set(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bypass_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bypass_enable_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_get(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bypass_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_oam_bypass_enable_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_set(unit, client_channel, flags,
                                                                                       enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_oam_bypass_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_oam_bypass_enable_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_get(unit, client_channel, flags,
                                                                                       enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_oam_bypass_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_local_fault_insert_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_local_fault_insert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_local_fault_insert_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_local_fault_insert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_remote_fault_insert_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_remote_fault_insert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_remote_fault_insert_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_remote_fault_insert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_rdi_insert_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_rdi_insert_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_rdi_insert_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_rdi_insert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_rdi_insert_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_rdi_insert_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_rdi_insert_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_rdi_insert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_set(unit, client_channel, block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_get(unit, client_channel, block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_set(unit, client_channel,
                                                                                        threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_get(unit, client_channel,
                                                                                        threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_set(unit, client_channel, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_get(unit, client_channel, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_set(unit, client_channel,
                                                                                           block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_get(unit, client_channel,
                                                                                           block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_set(unit, client_channel,
                                                                                             threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_get(unit, client_channel,
                                                                                             threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_set(unit, client_channel,
                                                                                           threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_get(unit, client_channel,
                                                                                           threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_set(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_get(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_set(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_get(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_set(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_get(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_set(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_get(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_set(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_get(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_set(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_get(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bip8_counter_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bip8_counter_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bip8_counter_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bip8_counter_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bei_counter_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bei_counter_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bei_counter_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bei_counter_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_pkt_count_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_pkt_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_pkt_count_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_pkt_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_pkt_count_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_pkt_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_pkt_count_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_pkt_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_phy_default_config_set(
    int unit,
    int flexe_core_port,
    int local_port,
    int speed,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_phy_default_config_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_phy_default_config_set(unit, flexe_core_port, local_port,
                                                                                    speed, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_phy_default_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_timer_step_set(
    int unit,
    int step)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_set(unit, step);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_timer_step_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_timer_step_get(
    int unit,
    int *step)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (step == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "step NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_get(unit, step);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_timer_step_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_step_count_set(
    int unit,
    int step_count)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_set(unit, step_count);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_step_count_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_step_count_get(
    int unit,
    int *step_count)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (step_count == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "step_count NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_get(unit, step_count);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_step_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_cell_mode_set(
    int unit,
    int cell_mode)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_set(unit, cell_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_cell_mode_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_cell_mode_get(
    int unit,
    int *cell_mode)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cell_mode == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cell_mode NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_get(unit, cell_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_cell_mode_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_cell_mode_per_channel_set(
    int unit,
    int client_channel,
    int is_rx,
    int cell_mode)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_per_channel_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_per_channel_set(unit, client_channel, is_rx,
                                                                                           cell_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_cell_mode_per_channel_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_busa_channel_map_info_t_validate(
    int unit,
    const flexe_core_busa_channel_map_info_t * flexe_core_busa_channel_map_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_busa_channel_map_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_busa_channel_map_info_t_init(
    int unit,
    flexe_core_busa_channel_map_info_t * flexe_core_busa_channel_map_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_busa_channel_map_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_busa_channel_map_info NULL parameter");
    }
    sal_memset(flexe_core_busa_channel_map_info, 0, sizeof(flexe_core_busa_channel_map_info_t));
    flexe_core_busa_channel_map_info->flexe_core_port = 0;
    flexe_core_busa_channel_map_info->is_eth = 0;
    flexe_core_busa_channel_map_info->is_flexe_phy = 0;
    flexe_core_busa_channel_map_info->is_mgmt_intf = 0;
    flexe_core_busa_channel_map_info->local_port = 0;

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_busa_channel_map_set(
    int unit,
    uint32 flags,
    const flexe_core_busa_channel_map_info_t * channel_map_info,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_busa_channel_map_info_t_validate(unit, channel_map_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "channel_map_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_busa_channel_map_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_busa_channel_map_set(unit, flags, channel_map_info,
                                                                                  enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_busa_channel_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_local_fault_get(
    int unit,
    int client_channel,
    int *local_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (local_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "local_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_local_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_local_fault_get(unit, client_channel,
                                                                                    local_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_local_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_remote_fault_get(
    int unit,
    int client_channel,
    int *remote_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (remote_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "remote_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_remote_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_remote_fault_get(unit, client_channel,
                                                                                     remote_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_remote_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_local_fault_get(
    int unit,
    int client_channel,
    int *local_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (local_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "local_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_local_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_local_fault_get(unit, client_channel,
                                                                                        local_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_local_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_remote_fault_get(
    int unit,
    int client_channel,
    int *remote_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (remote_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "remote_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_remote_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_remote_fault_get(unit, client_channel,
                                                                                         remote_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_remote_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_1588_pkt_header_set(
    int unit,
    uint32 flags,
    uint32 val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_1588_pkt_header_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_1588_pkt_header_set(unit, flags, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_1588_pkt_header_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_1588_pkt_header_get(
    int unit,
    uint32 flags,
    uint32 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_1588_pkt_header_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_1588_pkt_header_get(unit, flags, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_1588_pkt_header_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_oam_pkt_mac_set(
    int unit,
    uint32 flags,
    uint32 val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_oam_pkt_mac_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_oam_pkt_mac_set(unit, flags, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_oam_pkt_mac_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_oam_pkt_mac_get(
    int unit,
    uint32 flags,
    uint32 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_oam_pkt_mac_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_oam_pkt_mac_get(unit, flags, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_oam_pkt_mac_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_bas_oam_to_ext_processor_set(
    int unit,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_bas_oam_to_ext_processor_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_bas_oam_to_ext_processor_set(unit, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_bas_oam_to_ext_processor_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_bas_oam_to_ext_processor_get(
    int unit,
    int *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_bas_oam_to_ext_processor_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_bas_oam_to_ext_processor_get(unit, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_bas_oam_to_ext_processor_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_ptp_2step_tx_info_get(
    int unit,
    int flexe_core_port,
    uint32 *valid,
    uint64 *timestamp)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (valid == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "valid NULL parameter");
    }
    if (timestamp == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "timestamp NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_ptp_2step_tx_info_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_ptp_2step_tx_info_get(unit, flexe_core_port, valid,
                                                                                   timestamp);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_ptp_2step_tx_info_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_jitter_fifo_level_set(
    int unit,
    int client_channel,
    const flexe_core_sar_jitter_fifo_level_t * fifo_level)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_sar_jitter_fifo_level_t_validate(unit, fifo_level))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "fifo_level validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_jitter_fifo_level_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_jitter_fifo_level_set(unit, client_channel,
                                                                                       fifo_level);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_jitter_fifo_level_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_jitter_fifo_level_get(
    int unit,
    int client_channel,
    flexe_core_sar_jitter_fifo_level_t * fifo_level)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (fifo_level == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "fifo_level NULL parameter");
    }
    if (_SHR_E_NONE != flexe_core_sar_jitter_fifo_level_t_init(unit, fifo_level))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "fifo_level initialization failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_jitter_fifo_level_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_jitter_fifo_level_get(unit, client_channel,
                                                                                       fifo_level);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_jitter_fifo_level_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bas_bip_recal_enable_set(
    int unit,
    int val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_bip_recal_enable_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_bip_recal_enable_set(unit, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bas_bip_recal_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bas_bip_recal_enable_get(
    int unit,
    int *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_bip_recal_enable_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_bip_recal_enable_get(unit, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bas_bip_recal_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bas_period_mismatch_trigger_los_alarm_set(
    int unit,
    int val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_period_mismatch_trigger_los_alarm_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_period_mismatch_trigger_los_alarm_set(unit, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_bas_period_mismatch_trigger_los_alarm_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bas_period_mismatch_trigger_los_alarm_get(
    int unit,
    int *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_period_mismatch_trigger_los_alarm_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bas_period_mismatch_trigger_los_alarm_get(unit, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_bas_period_mismatch_trigger_los_alarm_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_deskew_alarm_trigger_lf_set(
    int unit,
    int group_index,
    int val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_deskew_alarm_trigger_lf_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_deskew_alarm_trigger_lf_set(unit, group_index, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_deskew_alarm_trigger_lf_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_deskew_alarm_trigger_lf_get(
    int unit,
    int group_index,
    int *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_deskew_alarm_trigger_lf_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_deskew_alarm_trigger_lf_get(unit, group_index, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_deskew_alarm_trigger_lf_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_enable_set(
    int unit,
    int client_channel,
    uint32 flags,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_enable_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_enable_set(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_enable_get(
    int unit,
    int client_channel,
    uint32 flags,
    int *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_enable_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_enable_get(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_flr_rate_generator_divider_set(
    int unit,
    bcm_port_t logical_port)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_flr_rate_generator_divider_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_flr_rate_generator_divider_set(unit, logical_port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_flr_rate_generator_divider_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_flr_logical_to_serdes_lane_set(
    int unit,
    bcm_port_t logical_port)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_flr_logical_to_serdes_lane_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_flr_logical_to_serdes_lane_set(unit, logical_port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_flr_logical_to_serdes_lane_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

#undef BSL_LOG_MODULE
