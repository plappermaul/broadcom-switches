# $Id: Make.config,v 1.429.8.1.4.2 2013/07/22 01:39:00 xueming Exp $
# $Copyright: (c) 2005 Broadcom Corp.
# All Rights Reserved.$
#
# Make command configuration for SOC driver and diags.
ifeq (${BCM_HIDE_DISPATCHABLE},1)
# {
CFGFLAGS += -DBCM_HIDE_DISPATCHABLE
# }
endif

ifeq (${WAN_PORT_SUPPORT},1)
# {
CFGFLAGS += -DWAN_PORT_SUPPORT
# }
endif

ifeq (${IPROC_NO_ATL},1)
# {
CFGFLAGS += -DIPROC_NO_ATL
# }
endif

#
# Set a default target if one is not set. If override-target is set,
# then the target will become override-target and a warning is printed
# if the assigned TARGET was different.
#
ifneq ($(strip $(override-target)),)
# {
override TARGET=$(override-target)
# }
endif

#
# If TARGET is not set, default to a Unix target based on host type
#
ifndef TARGET
# {
 uname := $(shell uname -s)
 ifeq ($(filter-out Linux Darwin,$(uname)),)
  ifeq ($(shell uname -m),x86_64)
   TARGET=unix-linux-64
  else
   TARGET=unix-linux
  endif
 endif
 ifeq ($(uname),NetBSD)
  TARGET=unix-netbsd
 endif
 ifndef	TARGET
  $(error Cannot determine TARGET in Make.config, uname = $(uname))
 endif
# }
endif

export TARGET


#
# Set up the target name, and the target base variables.
#
# target = The full name of the target such as unix-user
# targetbase = 1st part of target (e.g. unix)
# targetplat = 2nd part of target (e.g. user) if any; otherwise same as 1st
#
target     = ${TARGET}
targetsplt = $(subst -, , ${target})	# change hyphens to spaces
targetbase = $(word 1,${targetsplt})
targetplat = $(subst ${targetbase}-,,${TARGET})
#targetplat = $(lastword ,${targetsplt})

#
# Common configuration for all platforms
# (Additional platform-dependent configurations are in Makefile.xxx)
#

#
# THIS FILE SHOULD NOT BE MODIFIED LOCALLY, to override, add a file
# $SDK/make/Make.local that sets your local settings, and/or provide
# a path to your settings using the MAKE_LOCAL variable.  If 
# either of these files exists, their values will override those in this makefile.
#
ifdef MAKE_LOCAL
# {
include        ${MAKE_LOCAL}
# }
else
# {
-include	${SDK}/make/Make.local
# }
endif

ifndef	VENDOR_LIST
# {
VENDOR_LIST =	CALHOUN GAMMA BROADCOM
# }
endif
CFGFLAGS += $(foreach vendor,$(VENDOR_LIST), -DVENDOR_$(vendor))
ifeq (BROADCOM,$(findstring BROADCOM,$(VENDOR_LIST)))
    VENDOR_BROADCOM = 1
endif

# Make sure some chip is supported

# Here list EA chipsets
TOMAHAWK3_CHIP_NAMES = BCM_56980_A0 BCM_56980_B0

ESW_CHIP_NAMES = BCM_5675_A0 BCM_56504_A0 BCM_56504_B0 BCM_56314_A0 BCM_56112_A0 \
  BCM_56304_B0 BCM_56102_A0 BCM_56580_A0 BCM_56700_A0 BCM_56800_A0 BCM_56218_A0 \
  BCM_56514_A0 BCM_56624_A0 BCM_56680_A0 BCM_56680_B0 BCM_56224_A0 BCM_56224_B0 BCM_56820_A0 \
  BCM_53314_A0 BCM_56725_A0 BCM_56624_B0 BCM_56634_A0 BCM_56634_B0 \
  BCM_56524_A0 BCM_56524_B0 BCM_56685_A0 BCM_56685_B0 BCM_56334_A0 BCM_56334_B0 \
  BCM_56840_A0 BCM_56840_B0 BCM_56142_A0 BCM_53324_A0 BCM_56440_A0 \
  BCM_56440_B0 BCM_56640_A0 BCM_56850_A0 BCM_56450_A0 BCM_56450_B0 BCM_56450_B1 BCM_56340_A0 \
  BCM_56150_A0 BCM_53400_A0 BCM_56960_A0 BCM_56860_A0 BCM_56560_A0 BCM_56260_A0 BCM_56260_B0 \
  BCM_56160_A0 BCM_56560_B0 BCM_56270_A0 BCM_56965_A0 BCM_56970_A0 BCM_56980_A0 BCM_56980_B0 \
  BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 \
  BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0


# In order to keep backward compatability for J2 gen compilation we map ALL_DNX_CHIPS to ALL_DNX2_CHIPS
ifdef ALL_DNX_CHIPS
# {
ALL_DNX2_CHIPS = 1
# }
endif

# In order to keep backward compatability for J2 gen compilation we map ALL_DNXF_CHIPS to ALL_DNXF1_CHIPS
ifdef ALL_DNXF_CHIPS
# {
ALL_DNXF1_CHIPS = 1
# }
endif

DPP_CHIP_NAMES = BCM_88660_A0 BCM_88675_A0 BCM_88675_B0 BCM_88375_A0 BCM_88375_B0 BCM_88680_A0 BCM_88470_A0 BCM_88470_B0 BCM_88270_A0
DFE_CHIP_NAMES = BCM_88950_A0 BCM_88950_A1 BCM_88770_A1
DNX2_CHIP_NAMES = BCM_88690_A0 BCM_88690_B0 BCM_88800_A0 BCM_88850_A0 BCM_88830_A0 BCM_88480_A0 BCM_88480_B0
DNXF1_CHIP_NAMES = BCM_88790_A0

#
# UNIONOF_DNXF_CHIPS_NAMES is the union of all chips that use the DNXF dispatcher.
#
UNIONOF_DNXF_CHIPS_NAMES = $(DNXF1_CHIP_NAMES)
#
#
# UNIONOF_DNX_CHIPS_NAMES is the union of all chips that use the DNX dispatcher.
#
UNIONOF_DNX_CHIPS_NAMES = $(DNX2_CHIP_NAMES)
#

LTSW_SPEC_XGS_CHIP_NAMES = BCM_56990_A0 BCM_56990_B0 BCM_56996_A0 BCM_56996_B0 BCM_56998_A0 BCM_56999_A0
LTSW_SPEC_XFS_CHIP_NAMES = BCM_56880_A0 BCM_56780_A0
CTSW_SPEC_XFS_CHIP_NAMES = BCM_56780_A0
LTSW_SPEC_TM_CHIP_NAMES = BCM_56880_A0 BCM_56780_A0 BCM_56990_A0 BCM_56990_B0 BCM_56996_A0 BCM_56996_B0 BCM_56998_A0 BCM_56999_A0
LTSW_SPEC_CHIP_NAMES = $(LTSW_SPEC_XGS_CHIP_NAMES) $(LTSW_SPEC_XFS_CHIP_NAMES)
CTSW_SPEC_CHIP_NAMES = $(CTSW_SPEC_XFS_CHIP_NAMES)
LTSW_CHIP_NAME_LIST = $(LTSW_SPEC_CHIP_NAMES) $(CTSW_SPEC_CHIP_NAMES)
LTSW_CHIP_NAMES = $(sort $(LTSW_CHIP_NAME_LIST))
LTSW_SDKLT_CHIP_NAMES := $(LTSW_CHIP_NAMES)

whereischip = $(origin $(chipname))
seekesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(whereischip))
seekdpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(whereischip))
seekdfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(whereischip))
seekdnx2 = $(foreach chipname,$(DNX2_CHIP_NAMES),$(whereischip))
seekdnxf1 = $(foreach chipname,$(DNXF1_CHIP_NAMES),$(whereischip))
seekltsw = $(foreach chipname,$(LTSW_SPEC_CHIP_NAMES),$(whereischip))
seekctsw = $(foreach chipname,$(CTSW_SPEC_CHIP_NAMES),$(whereischip))
seekth3 = $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES),$(whereischip))

setallesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnx2 = $(foreach chipname,$(DNX2_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnxf1 = $(foreach chipname,$(DNXF1_CHIP_NAMES),$(eval export $(chipname) = 1))
setallth3 = $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES),$(eval export $(chipname) = 1))
setallltsw = $(foreach chipname,$(LTSW_SPEC_CHIP_NAMES),$(eval export $(chipname) = 1))
setallctsw = $(foreach chipname,$(CTSW_SPEC_CHIP_NAMES),$(eval export $(chipname) = 1))
ifeq (1,$(PORTMOD_STAND_ALONE))
# {
export PORTMOD_STAND_ALONE
BCM_PTL_SPT=1
PHYMOD_SUPPORT=1
PORTMOD_SUPPORT=1
CFLAGS += -DPORTMOD_STAND_ALONE
# }
endif

ifdef ALL_DNX_CHIPS
ifeq ($(BCM_DNX_INTERNAL_INIT),1)
export BCM_DNX_INTERNAL_INIT
CFGFLAGS += -DBCM_DNX_INTERNAL_INIT
endif
endif

ifdef BCM_PTL_SPT
# {
  ifdef ALL_TOMAHAWK3_CHIPS
    $(setallth3)
    export BCM_ESW_SUPPORT = 1
    export BCM_TOMAHAWK3_SUPPORT = 1
    export BCM_ALL_CHIPS = 1
    CFGFLAGS+=-DBCM_ALL_CHIPS
  endif

  ifdef ALL_ESW_CHIPS
    $(setallesw)
    export BCM_ESW_SUPPORT = 1
    export BCM_ALL_CHIPS = 1
    CFGFLAGS+=-DBCM_ALL_CHIPS
  endif

  ifdef ALL_DPP_CHIPS
    $(setalldpp)
  endif

  ifdef ALL_DFE_CHIPS
    $(setalldfe)
  endif

  ifdef ALL_DNX2_CHIPS
    $(setalldnx2)
  endif


  ifdef ALL_DNXF1_CHIPS
    $(setalldnxf1)
  endif


  ifdef ALL_LTSW_CHIPS
    $(setallltsw)
  endif

  ifdef ALL_CTSW_CHIPS
    $(setallctsw)
  endif

  ifneq "$(findstring file,$(seekesw))" ""
    ESW_CHIPS = 1
    export ESW_CHIPS
  endif

  ifneq "$(findstring file,$(seekdpp))" ""
    DPP_CHIPS = 1
    export DPP_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdfe))" ""
    DFE_CHIPS = 1
    export DFE_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdnx2))" ""
    DNX2_CHIPS = 1
# DNX_CHIPS stands for code which is common to chip groups that use DNX dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
    DNX_CHIPS = 1
    export DNX2_CHIPS
  endif


  ifneq "$(findstring file,$(seekdnxf1))" ""
    DNXF1_CHIPS = 1
# DNXF_CHIPS stands for code which is common to chip groups that use DNXF dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
    DNXF_CHIPS = 1
    export DNXF1_CHIPS
  endif


  ifneq "$(findstring file,$(seekth3))" ""
    TOMAHAWK3_CHIPS = 1
  endif

  ifneq "$(findstring file,$(seekltsw))" ""
    LTSW_SPEC_CHIPS = 1
    export LTSW_SPEC_CHIPS
  endif

  ifneq "$(findstring file,$(seekctsw))" ""
    CTSW_SPEC_CHIPS = 1
    export CTSW_SPEC_CHIPS
  endif

  ifdef LTSW_SPEC_CHIPS
    LTSW_CHIPS=1
    export LTSW_CHIPS
  else
    ifdef CTSW_SPEC_CHIPS
      LTSW_CHIPS=1
      export LTSW_CHIPS
    endif
  endif

ifndef ESW_CHIPS
# {
ifndef DPP_CHIPS
# {
ifndef DFE_CHIPS
# {
ifndef DNX2_CHIPS
# {
ifndef DNXF1_CHIPS
# {
ifndef TOMAHAWK3_CHIPS
# {
ifndef LTSW_SPEC_CHIPS
# {
ifndef CTSW_SPEC_CHIPS
# {
ifndef PORTMOD_STAND_ALONE #Compile without chips is allowed in case of portmod stand alone
# {
ifneq (C_COMPILER,$(MAKECMDGOALS))
# {
  $(error "BCM_PTL_SPT defined, and no valid chip names were defined")
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif

# }
else # BCM_PTL_SPT
# {

ifdef ALL_CHIPS
# {
  ESW_CHIPS = 1
  DPP_CHIPS = 1
  DFE_CHIPS = 1
  DNX2_CHIPS = 1
# DNX_CHIPS stands for code which is common to chip groups that use DNX dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
  DNX_CHIPS = 1
  DNXF1_CHIPS = 1
# DNXF_CHIPS stands for code which is common to chip groups that use DNXF dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
  DNXF_CHIPS = 1
  TOMAHAWK3_CHIPS = 1
  LTSW_SPEC_CHIPS = 1
  CTSW_SPEC_CHIPS = 1
  LTSW_CHIPS = 1
# }
else
# {
  ifndef ESW_CHIPS
	# Check if ESW support exist
	ifeq ($(shell test -d $(SDK)/src/bcm/esw; echo $$?),0)
            ESW_CHIPS = 1
            export ESW_CHIPS
      	endif
  endif
  ifndef TOMAHAWK3_CHIPS
	# Check if Tomahawk3 support exist
        ifeq ($(shell test -d $(SDK)/src/bcm/tomahawk3; echo $$?),0)
            TOMAHAWK3_CHIPS = 1
            export TOMAHAWK3_CHIPS
        endif
  endif

  ifdef ALL_DPP_CHIPS
    DPP_CHIPS=1
    export DPP_CHIPS
  endif

  ifdef ALL_DFE_CHIPS
    DFE_CHIPS=1
    export DFE_CHIPS
  endif

  ifdef ALL_DNX2_CHIPS
    DNX2_CHIPS=1
# DNX_CHIPS stands for code which is common to chip groups that use DNX dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
    DNX_CHIPS = 1
    export DNX2_CHIPS
  endif


  ifdef ALL_DNXF1_CHIPS
    DNXF1_CHIPS=1
# DNXF_CHIPS stands for code which is common to chip groups that use DNXF dispatcher. This way, current
# code may remain unchanged after introducing more such user.
# It may also be used as indication that any of these users is present
    DNXF_CHIPS = 1
    export DNXF1_CHIPS
  endif


  ifdef ALL_LTSW_CHIPS
    LTSW_SPEC_CHIPS=1
    export LTSW_SPEC_CHIPS
  endif

  ifdef ALL_CTSW_CHIPS
    CTSW_SPEC_CHIPS=1
    export CTSW_SPEC_CHIPS
  endif

  ifdef LTSW_SPEC_CHIPS
    LTSW_CHIPS=1
    export LTSW_CHIPS
  else
    ifdef CTSW_SPEC_CHIPS
      LTSW_CHIPS=1
      export LTSW_CHIPS
    endif
  endif
# }
endif # ALL_CHIPS

# }
endif # BCM_PTL_SPT

#
# Check for incompatible reload options
#

ifneq (,$(findstring -DBCM_WARM_BOOT_SUPPORT,$(CFGFLAGS)))
# {
ifneq (,$(findstring -DBCM_EASY_RELOAD_SUPPORT,$(CFGFLAGS)))
# {
 $(error "BCM_WARM_BOOT_SUPPORT and BCM_EASY_RELOAD_SUPPORT should not be enabled at the same time")
# }
endif
# }
endif

#
# SDKLT-based devices may specify SDKLT source tree using the $$SDKLT variable
# instead of the default $(SDK)/libs/sdklt
#
ifdef LTSW_CHIPS
  ifeq (,$(SDKLT))
    ifeq ($(shell test -d $(SDK)/libs/sdklt; echo $$?),0)
      SDKLT = $(SDK)/libs/sdklt
      ifndef SDKLT_IS_INTERNAL_LIB
        SDKLT_IS_INTERNAL_LIB = 0
      endif
    else
      $(error '$(SDK)/libs/sdklt not exist or $$SDKLT not set.')
    endif
  endif

  BUILD_SDKLT=1

  ifeq (,$(BCM_SKIP_ISSU_BUILD))
  # {
  ifneq (,$(findstring -DBCM_WARM_BOOT_SUPPORT,$(CFGFLAGS)))
    ifdef DISPATCH_LIST
      ifeq (LTSW,$(findstring LTSW,$(DISPATCH_LIST)))
        BUILD_ISSU=1
      endif
    else
      BUILD_ISSU=1
    endif
  endif
  # }
  endif

endif # LTSW_CHIPS

ifeq (1,$(BUILD_SDKLT))

  # SDKLT needs to link libdl library.
  ifndef LINK_STATIC
    LINK_STATIC = 0
  endif
  ifndef LINK_DL
    LINK_DL = 1
  endif

endif # BUILD_SDKLT == 1

#
# By default, turn off the "changing directory" message.
#

MAKEFLAGS += --no-print-directory

#
# Use gmake by default
#

include ${SDK}/make/Make.tools
include	${SDK}/make/Makefile.${target}

# For make v3.80, eval function cannot be placed inside any ifxxx-endif section
# The issue is fixed in v3.81
eval_fixed_ver := 3.81
eval_fixed := $(filter $(eval_fixed_ver),$(firstword $(sort $(MAKE_VERSION) $(eval_fixed_ver))))

# See Make.local (Make.local.template) to configure chip support

ifndef BCM_PTL_SPT
# {

# Support all chips by default
CFGFLAGS += -DBCM_ALL_CHIPS

ifdef ESW_CHIPS
# {
ifeq ($(eval_fixed),$(eval_fixed_ver))
# {
$(setallesw)
# }
else
# {
BCM_5675_A0 = 1
BCM_56504_A0 = 1
BCM_56504_B0 = 1
BCM_56314_A0 = 1
BCM_56112_A0 = 1
BCM_56304_B0 = 1
BCM_56102_A0 = 1
BCM_56580_A0 = 1
BCM_56700_A0 = 1
BCM_56800_A0 = 1
BCM_56218_A0 = 1
BCM_56514_A0 = 1
BCM_56624_A0 = 1
BCM_56224_A0 = 1
BCM_56224_B0 = 1
BCM_56820_A0 = 1
BCM_53314_A0 = 1
BCM_56725_A0 = 1
BCM_56624_B0 = 1
BCM_56634_A0 = 1
BCM_56634_B0 = 1
BCM_56524_A0 = 1
BCM_56524_B0 = 1
BCM_56685_A0 = 1
BCM_56685_B0 = 1
BCM_56334_A0 = 1
BCM_56334_B0 = 1
BCM_56840_A0 = 1
BCM_56840_B0 = 1
BCM_56142_A0 = 1
BCM_53324_A0 = 1
BCM_56440_A0 = 1
BCM_56440_B0 = 1
BCM_56450_A0 = 1
BCM_56450_B0 = 1
BCM_56450_B1 = 1
BCM_56640_A0 = 1
BCM_56850_A0 = 1
BCM_56340_A0 = 1
BCM_56150_A0 = 1
BCM_53400_A0 = 1
BCM_56960_A0 = 1
BCM_56980_A0 = 1
BCM_56980_B0 = 1
BCM_56160_A0 = 1
BCM_56860_A0 = 1
BCM_56560_A0 = 1
BCM_56260_A0 = 1
BCM_56260_B0 = 1
BCM_56870_A0 = 1
BCM_56275_A0 = 1
BCM_56370_A0 = 1
BCM_56470_A0 = 1
BCM_56770_A0 = 1
BCM_56270_A0 = 1
BCM_56560_B0 = 1
BCM_56670_A0 = 1
BCM_56670_B0 = 1
BCM_56670_C0 = 1
BCM_56965_A0 = 1
BCM_56970_A0 = 1
BCM_53570_A0 = 1
BCM_53570_B0 = 1
BCM_53540_A0 = 1
BCM_56070_A0 = 1
# }
endif
# }
endif

#
# If any of the chip groups, which use the DNXF dispatcher, (currently DNXF1, ...), is
# active then the unused chips on ALL these groups need to be marked with 'NO_chip_name'.
# This is required by MCM (See enum_max.h).
#
ifdef DNXF_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(UNIONOF_DNXF_CHIPS_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNXF_CHIPS

ifdef TOMAHAWK3_CHIPS
# {
ifeq ($(eval_fixed),$(eval_fixed_ver))
# {
$(setallth3)
# }
else
# {
BCM_56980_A0 = 1
BCM_56980_B0 = 1
# }
endif
# }
endif

ifdef DPP_CHIPS
# {
$(setalldpp)
# }
endif

ifdef DFE_CHIPS
# {
$(setalldfe)
# }
endif

ifdef DNX2_CHIPS
# {
$(setalldnx2)
# }
endif

ifdef DNXF1_CHIPS
# {
$(setalldnxf1)
# }
endif



ifdef LTSW_SPEC_CHIPS
# {
$(setallltsw)
# }
endif

ifdef CTSW_SPEC_CHIPS
# {
$(setallctsw)
# }
endif
# }
else # BCM_PTL_SPT
# {

# Some chip or chips excluded

ifdef TOMAHAWK3_CHIPS
CFGFLAGS += $(strip $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
ifdef BCM_56980_A0
BCM_56980_A0 = 1
endif
ifdef BCM_56980_B0
BCM_56980_B0 = 1
endif
endif

ifdef ESW_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(ESW_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
CFGFLAGS += -DUSE_SCACHE_DIRTY_BIT
ifdef BCM_56340_A0
# {
BCM_56640_A0 = 1
# }
endif
ifdef BCM_56440_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56440_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B1
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_A0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_B0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56270_A0
# {
BCM_56260_A0 = 1
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56560_B0
# {
BCM_56560_A0 = 1
# }
endif
ifdef BCM_56670_A0
#{
BCM_56670_A0 = 1
# }
endif
ifdef BCM_56670_B0
#{
BCM_56670_B0 = 1
# }
endif
ifdef BCM_56670_C0
#{
BCM_56670_C0 = 1
# }
endif
# }
endif # ESW_CHIPS

ifdef DPP_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DPP_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DPP_CHIPS

ifdef DFE_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DFE_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DFE_CHIPS

#
# If any of the chip groups, which use the DNX dispatcher, (currently DNX2, ...), is
# active then the unused chips on ALL these groups need to be marked with 'NO_chip_name'.
# This is required by MCM (See enum_max.h).
#
ifdef DNX_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(UNIONOF_DNX_CHIPS_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNX_CHIPS

#
# If any of the chip groups, which use the DNXF dispatcher, (currently DNXF1, ...), is
# active then the unused chips on ALL these groups need to be marked with 'NO_chip_name'.
# This is required by MCM (See enum_max.h).
#
ifdef DNXF_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(UNIONOF_DNXF_CHIPS_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNXF_CHIPS

# }
endif # BCM_PTL_SPT

ifdef LTSW_CHIPS
LTSW_CHIP_CFGFLAGS = -DBCMDRD_INCLUDE_CUSTOM_CONFIG

ifdef LTSW_SPEC_CHIPS
LTSW_SPEC_INCLUDE_XGS_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_SPEC_XGS_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))
LTSW_SPEC_INCLUDE_XFS_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_SPEC_XFS_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))
LTSW_SPEC_INCLUDE_TM_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_SPEC_TM_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))
ifneq (,$(LTSW_SPEC_INCLUDE_XGS_CHIP_NAMES))
LTSW_SPEC_INCLUDE_XGS=1
endif
ifneq (,$(LTSW_SPEC_INCLUDE_XFS_CHIP_NAMES))
LTSW_SPEC_INCLUDE_XFS=1
endif
ifneq (,$(LTSW_SPEC_INCLUDE_TM_CHIP_NAMES))
LTSW_SPEC_INCLUDE_TM=1
endif
LTSW_SPEC_INCLUDE_CHIP_NAMES = $(LTSW_SPEC_INCLUDE_XGS_CHIP_NAMES) \
                               $(LTSW_SPEC_INCLUDE_XFS_CHIP_NAMES)
LTSW_SPEC_INCLUDE_CHIPS = $(strip $(subst BCM_,BCM,$(LTSW_SPEC_INCLUDE_CHIP_NAMES)))
LTSW_INCLUDE_CHIP_DEVS = $(strip $(foreach chipname,$(LTSW_SPEC_INCLUDE_CHIPS),\
                                   $(word 1,$(subst _, ,$(chipname)))))
endif # LTSW_SPEC_CHIPS

ifdef CTSW_SPEC_CHIPS
CTSW_SPEC_INCLUDE_XFS_CHIP_NAMES = $(strip $(foreach chipname,$(CTSW_SPEC_XFS_CHIP_NAMES),\
                                           $(if $(value $(chipname)),$(chipname),)))
ifneq (,$(CTSW_SPEC_INCLUDE_XFS_CHIP_NAMES))
CTSW_SPEC_INCLUDE_XFS=1
endif

CTSW_SPEC_INCLUDE_CHIP_NAMES = $(CTSW_SPEC_INCLUDE_XFS_CHIP_NAMES)
CTSW_SPEC_INCLUDE_CHIPS = $(strip $(subst BCM_,BCM,$(CTSW_SPEC_INCLUDE_CHIP_NAMES)))
CTSW_SPEC_INCLUDE_CHIP_DEVS = $(strip $(foreach chipname,$(CTSW_SPEC_INCLUDE_CHIPS),\
                                       $(word 1,$(subst _, ,$(chipname)))))
endif # CTSW_SPEC_CHIPS

LTSW_INCLUDE_CHIP_NAME_LIST = $(LTSW_SPEC_INCLUDE_CHIP_NAMES) $(CTSW_SPEC_INCLUDE_CHIP_NAMES)
LTSW_INCLUDE_CHIP_NAMES = $(sort $(LTSW_INCLUDE_CHIP_NAME_LIST))
LTSW_INCLUDE_CHIPS = $(strip $(subst BCM_,BCM,$(LTSW_INCLUDE_CHIP_NAMES)))

LTSW_CHIP_STD_NAMES = $(strip $(subst BCM_,BCM,$(LTSW_CHIP_NAMES)))
LTSW_CHIP_DEVS = $(strip $(foreach chipname,$(LTSW_CHIP_STD_NAMES),\
                                   $(word 1,$(subst _, ,$(chipname)))))
LTSW_CHIP_REVS = A0 B0 C0
devid = $(strip $(word 1,$(subst _, ,$(1))))
devid_cnt = $(words $(filter $(1),$(2)))
revid = $(strip $(word 2,$(subst _, ,$(1))))
revid_converter = $(if $(findstring $(1),$(strip $(2))),$(shell echo $(1) | tr 0 x),$(1))
revid_suffix = $(call revid_converter,$(call revid,$(1)),$(2))
revid_no_need = $(findstring x0x,x$(shell expr $(call devid_cnt,$(1),$(2)) - 1)x)
chip_def = $(call devid,$(1))$(if $(call revid_no_need,$(call devid,$(1)),$(2)),,_$(call revid_suffix,$(1),$(3)))
chip_def_construct = $(call chip_def,$(1),$(LTSW_CHIP_DEVS),$(LTSW_CHIP_REVS))

LTSW_INCLUDE_CHIP_DEFS = $(foreach devname,$(LTSW_INCLUDE_CHIPS),\
                                   $(call chip_def_construct,$(devname)))
LTSW_CHIP_CFGFLAGS += $(foreach chipname,$(LTSW_INCLUDE_CHIP_DEFS),\
                        -DBCMDRD_CONFIG_INCLUDE_$(chipname)=1)
LTSW_CHIP_CFGFLAGS += -DBCMDRD_CONFIG_INCLUDE_CHIP_DEFAULT=0
LTSW_LKM_ADD_CPPFLAGS = $(LTSW_CHIP_CFGFLAGS)
LTSW_LKM_ADD_CFLAGS = $(LTSW_CHIP_CFGFLAGS)
CFGFLAGS += $(LTSW_CHIP_CFGFLAGS)
SDK_CHIPS = $(shell echo $(LTSW_INCLUDE_CHIPS) | tr A-Z a-z)
export SDK_CHIPS
ifeq ($(SDK_VARIANTS),)
ifneq ($(BCM_VARIANT_LIST),)
SDK_VARIANTS += $(BCM_VARIANT_LIST),
endif
ifneq ($(BCM_VARIANTS_APPEND),)
SDK_VARIANTS += $(BCM_VARIANTS_APPEND)
endif
ifneq ($(SDK_VARIANTS),)
export SDK_VARIANTS
endif
endif

ifndef ISSU_CHIPS
ISSU_CHIPS = $(LTSW_INCLUDE_CHIPS)
endif
endif # LTSW_CHIPS

ifndef	FEATURE_LIST
# {

ifdef ESW_CHIPS
# {
_ESW_FEATURE_LIST = L3 I2C MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
    TEST CHASSIS CINT PTP BFD TCB PSTATS
#
# CES is only supported on Katana devices.
#
ifdef BCM_56440_A0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
ifdef BCM_56440_B0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
# }
endif

ifdef TOMAHAWK3_CHIPS
_TOMAHAWK3_FEATURE_LIST = L3 I2C MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
    TEST CHASSIS CINT PTP BFD
endif

ifdef DPP_CHIPS
# {
_DPP_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif

ifdef DFE_CHIPS
# {
_DFE_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif

ifdef DNX2_CHIPS
# {
  _DNX2_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif # DNX2_CHIPS


ifdef DNXF1_CHIPS
# {
_DNXF1_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif


ifdef LTSW_CHIPS
# {
_LTSW_FEATURE_LIST = L3 EDITLINE CUSTOMER CINT PTP BFD TCB PSTATS
# }
endif

_ALL_FEATURE_LIST = ${_ESW_FEATURE_LIST} \
    ${_DPP_FEATURE_LIST} \
    ${_DFE_FEATURE_LIST} ${_DNX2_FEATURE_LIST} ${_DNXF1_FEATURE_LIST} \
    ${_TOMAHAWK3_FEATURE_LIST} ${_LTSW_FEATURE_LIST}

FEATURE_LIST = $(sort ${_ALL_FEATURE_LIST})

# end ifndef FEATURE_LIST
# }
endif

ifeq ($(EXTERNAL_FEATURES),ALL)
# {
  FEATURE_LIST += XFLOW_MACSEC 
  FEATURE_LIST += FLEXE_DBG
# }
endif
ifeq ($(EXTERNAL_FEATURES),FLEXE_DBG)
# {
  FEATURE_LIST += FLEXE_DBG
# }
endif
ifeq ($(EXTERNAL_FEATURES),XFLOW_MACSEC)
# {
  FEATURE_LIST += XFLOW_MACSEC
# }
endif
ifeq ($(EXTERNAL_FEATURES),MACSEC)
# {
  FEATURE_LIST += MACSEC
# }
endif


# Include board make rules if present
-include ${SDK}/make/Make.boards

# Enable TCL interface
ifdef DNX_TCL
# {
FEATURE_LIST += TCL
# }
endif

# If TCL is enabled then add EDITLINE and ASE_TEST
ifeq (TCL,$(findstring TCL,$(FEATURE_LIST)))


# {
ifneq (EDITLINE,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
FEATURE_LIST += EDITLINE
# }
endif

ifneq (ASE_TEST,$(findstring ASE_TEST,$(FEATURE_LIST)))
# {
FEATURE_LIST += ASE_TEST
# }
endif
# }
endif

# DPP only compiles with BFD
ifdef DPP_CHIPS
# {
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DPP chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif

ifdef DNX2_CHIPS
# {
# DNX2 only compiles with BFD
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DNX chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif


# If BFD is enabled then add L3
ifeq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST += L3
# }
endif
# }
endif

# If CINT is not enabled, filter out APIMODE
ifeq (,$(findstring CINT,$(FEATURE_LIST)))
# {
FEATURE_EXCLUDE_LIST += APIMODE
# }
endif

# If CCM_SLM is enabled then filter out CCM
ifeq (CCM_SLM,$(findstring CCM_SLM,$(FEATURE_LIST)))
# {
  FEATURE_EXCLUDE_LIST += CCM
# }
endif

ifdef NO_SAL_APPL
# {
FEATURE_EXCLUDE_LIST += TCL EDITLINE I2C TELNET DRIVERS CINT APIMODE
CFGFLAGS += -DNO_SAL_APPL -DNO_CTRL_C -DNO_FILEIO -DNO_MEMTUNE
# }
endif

ifdef MINIMAL_DNX_FEATURES
# {
#
# For DNX chips: Remove features which are not required for the most basic
# compilation.
# The minimum required is:
# CPU_I2C MEM_SCAN CINT TEST L3
#
FEATURE_EXCLUDE_LIST += CUSTOMER CHASSIS MSTP ATPTRANS_SOCKET INTR APIMODE CTEST
FEATURE_EXCLUDE_LIST += I2C AUTOCOMPLETE TELNET DRIVERS BSAFE
FEATURE_EXCLUDE_LIST += BCM_SAL_PROFILE
#
# Note that if TCL is NOT removed then EDITLINE must remain as well.
#
FEATURE_EXCLUDE_LIST += TCL EDITLINE
#CFGFLAGS += -DNO_CTRL_C -DNO_MEMTUNE
# }
endif
#
# Remove DUNE_UI unless DPP/DFE chips are supported.
#
ifndef DPP_CHIPS
# {
ifndef DFE_CHIPS
# {
FEATURE_EXCLUDE_LIST += DUNE_UI
# }
endif
# }
endif

ifdef FEATURE_EXCLUDE_LIST
# {
FEATURE_LIST := $(filter-out $(FEATURE_EXCLUDE_LIST), $(FEATURE_LIST))
# }
endif

# If L3 is not defined, remove MPLS_LM_DM if present.
ifeq (MPLS_LM_DM,$(findstring MPLS_LM_DM,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST := $(filter-out MPLS_LM_DM, $(FEATURE_LIST))
# }
endif
# }
endif

CFGFLAGS += $(foreach feature,$(FEATURE_LIST), -DINCLUDE_$(feature))

ifeq (IPSEC,$(findstring IPSEC,$(FEATURE_LIST)))
DIAG_IPSEC=1
endif

ifndef	DISPATCH_LIST
# {
    ifdef ESW_CHIPS
# {
        DISPATCH_LIST += RPC ESW
# }
    endif
    ifdef TOMAHAWK3_CHIPS
        DISPATCH_LIST += RPC TOMAHAWK3
        ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))
            DISPATCH_LIST += TOMAHAWK3X
        endif
    endif
    ifdef LTSW_CHIPS
# {
        DISPATCH_LIST += RPC LTSW
# }
    endif
else # if DISPATCH_LIST defined
#   Since TH3 is a new dispatch table and still comes under ESW,
#   we add TH3 to the dispatch_list
    ifeq (ESW,$(findstring ESW,$(DISPATCH_LIST)))
        ESW_CHIPS = 1
        export ESW_CHIPS
        ifdef TOMAHAWK3_CHIPS
            DISPATCH_LIST += TOMAHAWK3
            ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))
                DISPATCH_LIST += TOMAHAWK3X
            endif
            export TOMAHAWK3_CHIPS
        endif
    endif
# }
endif #end of dispatch_list

#
# SAND_CHIPS means that at least one of Dune chip family is defined
# aka DPP_CHIPS || DFE_CHIPS || DNX2_CHIPS || DNXF1_CHIPS
#
# DCMN_CHIPS means that at least one of legacy Dune chip family is defined
# aka DPP_CHIPS || DFE_CHIPS
#
# DNXC_CHIPS means that at least one of recent Dune chip family is defined
# aka DNX2_CHIPS || DNXF1_CHIPS
#
#
# If ANY 'dune chip' is supported (SAND_CHIPS = 1) then define
# BCM_SAND_SUPPORT (for C-preprocessor usage) to indicate that.
#

ifdef DPP_CHIPS
# {
DISPATCH_LIST += PETRA
SAND_CHIPS = 1
DCMN_CHIPS = 1
# }
endif

ifdef DFE_CHIPS
# {
DISPATCH_LIST += DFE
SAND_CHIPS = 1
DCMN_CHIPS = 1
# }
endif

#
# Specify the users of DNX dispatcher: 'dnx2', ...
#
ifdef DNX_CHIPS
# {
DISPATCH_LIST += DNX
SAND_CHIPS = 1
DNXC_CHIPS = 1
# }
endif

ifdef DNXF_CHIPS
# {
DISPATCH_LIST += DNXF
SAND_CHIPS = 1
DNXC_CHIPS = 1
# }
endif

ifdef ALL_DNX2_CHIPS
# {
CFGFLAGS += -DBCM_DNX2_SUPPORT
# }
endif


ifdef ALL_DNXF1_CHIPS
# {
CFGFLAGS += -DBCM_DNXF1_SUPPORT
# }
endif

#
# If ANY 'dune chip' is supported then define BCM_SAND_SUPPORT to
# indicate that.
#
ifdef SAND_CHIPS
# {
CFGFLAGS += -DBCM_SAND_SUPPORT
export SAND_CHIPS
# }
endif
#
# If ANY 'recent dune chip' is supported then define DBCM_DNXC_SUPPORT to
# indicate that.
#
ifdef DNXC_CHIPS
# {
CFGFLAGS += -DBCM_DNXC_SUPPORT
export DNXC_CHIPS
# }
endif
#
# If ANY 'legacy dune chip' is supported then define BCM_DCMN_SUPPORT to
# indicate that.
#
ifdef DCMN_CHIPS
# {
CFGFLAGS += -DBCM_DCMN_SUPPORT
export DCMN_CHIPS
# }
endif

ifdef DNXC_CHIPS
# {
#
# For DUNE chips, we do not support NO_SAL_APPL or NO_FILEIO
# (Allow NO_FILEIO on kernel modules)
#
ifdef NO_SAL_APPL
# {
$(error 'NO_SAL_APPL can not be applied for any DNX application')
# }
endif
ifneq (,$(findstring -DNO_FILEIO,$(CFGFLAGS)))
# {
ifeq (,$(findstring kernel,$(CFGFLAGS)))
# {
$(error 'NO_FILEIO can not be applied for any DNX application')
# }
endif
# }
endif
#
# For DUNE chips, if DNX_SW_STATE_DIAGNOSTIC is defined as '1' at the 'make' level
# or it is not defined at all
# then define it at the C level.
#
ifdef DNX_SW_STATE_DIAGNOSTIC
# {
ifeq (1,$(DNX_SW_STATE_DIAGNOSTIC))
# {
CFGFLAGS += -DDNX_SW_STATE_DIAGNOSTIC
# }
endif
# }
else
# {
CFGFLAGS += -DDNX_SW_STATE_DIAGNOSTIC
# }
endif

# }
endif
#
# SAND_LIST is the list of all disaptchers related to DNX.
# It is used to filter them out of the full DISPATCH_LIST.
# If there are only SAND dispatchers, then we may manipulate PHY chips to
# use only the ones required for DNX.
#
SAND_LIST = DNX DNXF PETRA DFE
NON_SAND_DISPATCH_LIST := $(filter-out $(SAND_LIST), $(DISPATCH_LIST))
ifeq (,$(NON_SAND_DISPATCH_LIST))
# {
SAND_ONLY=1
# }
else
# {
SAND_ONLY=0
# }
endif


CFGFLAGS += $(foreach dispatch,$(DISPATCH_LIST), -DBCM_$(dispatch)_SUPPORT)
ifneq (,$(findstring -DBCM_RPC_SUPPORT,$(CFGFLAGS)))
# {
CFGFLAGS += -DINCLUDE_LIB_CPUDB
CFGFLAGS += -DINCLUDE_LIB_CPUTRANS
CFGFLAGS += -DINCLUDE_LIB_DISCOVER
CFGFLAGS += -DINCLUDE_LIB_STKTASK
CFGFLAGS += -DDISCOVER_APP_DATA_BOARDID
# }
endif

ifdef DPP_CHIPS
# {
CFLAGS += -DDUNE_BCM -DLINK_PETRA_LIBRARIES -DLINK_PPD_LIBRARIES
ifdef BCM_88675_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88375_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88680_A0
# {
CFLAGS += -DBCM_JERICHO_PLUS_SUPPORT
# }
endif
ifdef BCM_88470_A0
# {
CFLAGS += -DBCM_QAX_SUPPORT
# }
endif
ifdef BCM_88270_A0
# {
CFLAGS += -DBCM_QUX_SUPPORT
# }
endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif

ifdef DNX2_CHIPS
# {
ifdef BCM_88690_A0
# {
CFLAGS += -DBCM_JERICHO_2_SUPPORT
# }
else
# {
ifdef BCM_88690_B0
# {
CFLAGS += -DBCM_JERICHO_2_SUPPORT
# }
endif

ifdef BCM_88480_A0
CFLAGS += -DBCM_Q2A_SUPPORT
else
ifdef BCM_88480_B0
CFLAGS += -DBCM_Q2A_SUPPORT
endif
endif

endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif



ifdef DFE_CHIPS
# {
CFLAGS += -DDUNE_BCM
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
# }
endif

ifdef DNXF1_CHIPS
# {
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
# }
endif


ifneq (,$(findstring I2C,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_I2C
# }
endif

ifneq (,$(findstring AEDEV,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_AEDEV
# }
endif

ifneq (,$(findstring CINT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_CINT
CFGFLAGS += -DCINT_CONFIG_INCLUDE_SDK_SAL=1 -DCINT_CONFIG_INCLUDE_PARSER=1 -DCINT_CONFIG_INCLUDE_CINT_LOAD=0

_DNX_CHIPS = $(DPP_CHIPS) $(DFE_CHIPS) $(DNX2_CHIPS) $(DNXF1_CHIPS)



#
# API logger built in by default for all DNX chips, unless requested to exclude
# it with BCM_API_VERBOSE_LOGGING=0
#
ifneq (,$(findstring 1, $(_DNX_CHIPS) ))
# {
ifneq (0,$(BCM_API_VERBOSE_LOGGING))
# {
BCM_API_VERBOSE_LOGGING = 1
# }
endif
# }
endif
ifeq (1,$(BCM_API_VERBOSE_LOGGING))
# {
CFGFLAGS += -DCINT_CONFIG_INCLUDE_CINT_LOGGER=1 -DBCM_API_VERBOSE_LOGGING=1
# }
else
# {
CFGFLAGS += -DBCM_API_VERBOSE_LOGGING=0
# }
endif
ifeq (,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
CFGFLAGS += -DCINT_CONFIG_INCLUDE_PARSER_READLINE=0 -DCINT_CONFIG_INCLUDE_PARSER_ADD_HISTORY=0
# }
endif
# }
else
# {
CFGFLAGS += -DBCM_API_VERBOSE_LOGGING=0
# }
endif

ifneq (,$(findstring C_UNIT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_C_UNIT
CFGFLAGS += -DC_UNIT_CONFIG_INCLUDE_SDK_SAL=1
# }
endif

ifndef	BCM_PHY_LIST
# {
#
# SAND chips (separated to DNX and DPP) only use a subset of the phy chips in the phymod library.
# 
ifeq (1,$(SAND_ONLY))
# {
BCM_PHY_LIST=SERDES SIMUL 
ifdef DNXC_CHIPS
# {
BCM_PHY_LIST +=
# }
endif
ifdef DCMN_CHIPS
# {
BCM_PHY_LIST += 82381 82764 522X 54XX 5464 5421S 54616 54680 54680E 52681E 54880E 54682 54684 54640 54640E 54880 5482 8703 8705 8706 8072 8040 8750
BCM_PHY_LIST += 8729 84740 84756 54380 542XX 84334 84728 84749 84793 82328 EGPHY28
# }
endif
# }
else
# {
BCM_PHY_LIST=522X 54XX 5464 5421S 5482 54616 54680 54680E 52681E 54880E 54682 54684 54640 54640E 54880 SERDES SIMUL 8703 8705 8706 8072 8040 8481 8750 8729 84740 84756 54380 542XX 84334 84728 84749 84328 84793 82328 82381 82780
BCM_PHY_LIST += 82764 EGPHY28 82864 82109 EGPHY16
# }
endif

ifdef ESW_CHIPS
# {
ifndef EXCLUDE_PHY_8806X
BCM_PHY_LIST += 8806X
endif
# }
endif
# }
endif

ifndef EXCLUDE_PHY_8806X
INCDIR += -I${SDK}/src/soc/phy/phy8806x/include
endif

CFGFLAGS += $(foreach phy,$(BCM_PHY_LIST), -DINCLUDE_PHY_$(phy))

ifneq (,(findstring 54880,$(BCM_PHY_LIST)))
# {
CFGFLAGS += -DINCLUDE_LONGREACH
# }
endif

# use QUIET=1 to control printing of compilation lines
ifdef	QUIET
# {
Q:=@
# }
else
# {
Q:=
# }
endif

#
# Suffix to add to the "target" files to allow local builds with different
# flags. Set "target_suffix" to XXX to cause the build to put built objects
# in ${target}${target_suffix}. This allows things like building a debug
# version with different flags.  This may also be set in another Makefile.
#

#target_suffix :=

#
# Optional suffix to add to the build directory and output binary files
# to allow multiple builds to co-exist for various reasons.
#
#chip_suffix := -$(shell echo $(CHIP) | tr A-Z a-z)

#
# Combined suffixes
#
all_suffix = ${chip_suffix}${target_suffix}

#
# Default location to place binaries and make depend files for building
# purposes.
#
ifndef SDKBUILD
# {
SDKBUILD :=build
# }
endif

BLDROOT = ${SDK}/${SDKBUILD}/$(if ${BLDCONFIG},${BLDCONFIG}/)${target}${all_suffix}${bldroot_suffix}

ifndef DEST_DIR_SUFFIX
# {
export DEST_DIR_SUFFIX :=$(subst $(realpath $(SDK))/systems,,$(realpath $(CURDIR)/$(dir ($(firstword $(MAKEFILE_LIST))))))
ifeq ($(MAKELEVEL),0)
# {
# }
endif
# }
endif

ifeq ($(DEST_DIR),)
# {
export DEST_DIR :=${SDK}/${SDKBUILD}$(if ${BLDCONFIG},/${BLDCONFIG})$(DEST_DIR_SUFFIX)
# }
endif

ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}/${LOCALDIR}
# }
else # ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}
# }
endif # ifdef LOCALDIR

LIBDIR = ${BLDROOT}

#
# Export directory, where build objects used by the outside world are
# placed (exported header files, libs, bins)
#
EXPDIR = ${SDK}/export/${target}${all_suffix}

#
# Standard include paths
#
ifeq (iproc,$(findstring iproc,$(platform)))
CPU_PLATFORM = iproc
endif
ifeq (wrx-opennsa, $(platform))
CPU_PLATFORM = wrx
endif
ifeq (wrx,$(findstring wrx,$(platform)))
CPU_PLATFORM = wrx
endif
ifeq (slk,$(findstring slk,$(platform)))
CPU_PLATFORM = slk
CPU_ENDIAN_MODE = $(ENDIAN_MODE)
endif
ifeq (gts,$(findstring gts,$(platform)))
CPU_PLATFORM = gts
endif
ifeq (gto,$(findstring gto,$(platform)))
CPU_PLATFORM = gto
endif
ifeq (xlr-3_14,$(findstring xlr-3_14,$(platform)))
CPU_PLATFORM = xlr-3_14
endif
ifeq (xlr-4_4,$(findstring xlr-4_4,$(platform)))
CPU_PLATFORM = xlr-4_4
endif

ifeq (x86-64-fc28,$(findstring x86-64-fc28,$(platform)))
CPU_PLATFORM = x86_64
ifeq (LE_HOST=1,$(findstring LE_HOST=1,$(ENDIAN)))
CPU_ENDIAN_MODE = LE
endif
endif

export CPU_PLATFORM

INCDIR	= ${SDK}/include
INCDIR	= ${SDK}/src/appl/cint
ifneq (,$(findstring -DBCM_PTP_EXT_SERVO_SUPPORT,$(CFGFLAGS)))

export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export CPU_ENDIAN_MODE

INCDIR += -I${EXT_SERVO_ROOT}/idtSystem/osAdaptation/linux.${CPU_PLATFORM}/include \
          -I${EXT_SERVO_ROOT}/idtSystem/deviceAdaptors/timeStamp/api/include/ \
          -I${EXT_SERVO_ROOT}/idtCommon/include \
		  -I${EXT_SERVO_ROOT}/idtCore/management/include \
		  -I${EXT_SERVO_ROOT}/idtCore/servo/include
endif

# XFLOW_MACSEC include paths
ifneq (,$(findstring XFLOW_MACSEC,$(FEATURE_LIST)))
# {
BUILD_XFLOW_MACSEC = 1
export BUILD_XFLOW_MACSEC
FEATURE_XFLOW_MACSEC = 1
XFLOW_MACSEC_BUILD_FLAG=-DBROADCOM_SAL -I${SDK} -I${SDK}/include -g -Wall -Werror -fno-strict-aliasing
ifdef LTSW_CHIPS
XFLOW_MACSEC_BUILD_FLAG += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
endif

XFLOW_MACSEC_BUILD_FLAG += ${STD_CFLAGS}

ifndef XFLOW_MACSEC_HOME
# {
export XFLOW_MACSEC_HOME := ${SDK}/libs/xflow_macsec
ifneq ($(shell test -d $(XFLOW_MACSEC_HOME); echo $$?),0)
$(error "The $$XFLOW_MACSEC_HOME environment variable is not set")
endif
# }
endif
INCDIR += -I${SDK} -I${XFLOW_MACSEC_HOME}/include
CFGFLAGS += -DBROADCOM_SAL
# }
endif

# MACSEC include paths
# Since MACSEC string is also present in XFLOW_MACSEC using filter instead of findstring
ifneq (,$(filter MACSEC,$(FEATURE_LIST)))
# {
BUILD_MACSEC = 1
FEATURE_MACSEC = 1
MACSEC_BUILD_FLAG=-DBROADCOM_SAL -I${SDK} -I${SDK}/include -g -Wall -Werror -fno-strict-aliasing

MACSEC_BUILD_FLAG += ${STD_CFLAGS}

ifndef MACSEC_HOME
# {
toast:; $(error 'The $$MACSEC_HOME environment variable is not set')
# }
endif
INCDIR += -I${SDK} -I${MACSEC_HOME}/include -I${MACSEC_HOME}/cli -I${MACSEC_HOME}/phy/bcm54380  -I${MACSEC_HOME}/phy/bcm8729 -I${MACSEC_HOME}/phy/bcm84756 -I${MACSEC_HOME}/phy/bcm84334  -I${MACSEC_HOME}/phy/bcm84749  -I${MACSEC_HOME}/phy/dummyphy
CFGFLAGS += -DBROADCOM_SAL
# }
endif

ifneq (,$(findstring -DBCM_PTP_EXT_SERVO_SUPPORT,$(CFGFLAGS)))
BUILD_EXT_SERVO = 1
FEATURE_EXT_SERVO = 1
EXT_SERVO_BUILD_FLAG = CPU_TARGET=${CPU_PLATFORM} USER_ARFLAGS=rcvs CLOCK_TYPE=BC NUMBER_OF_STACK_INSTANCES=10 DCO_DEVICE=softwareDco TIMESTAMP_DEVICE=softwareTimestamping
endif

# FCMAP include paths
ifneq (,$(findstring FCMAP,$(FEATURE_LIST)))
# {
FEATURE_FCMAP = 1
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/fcmap/include
CFGFLAGS += -DBROADCOM_SAL
# }
endif
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/koi/merlin_koi_src -I${SDK}/libs/phymod/chip
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/orca/eagle_orca_src

ifdef IMACSEC_HOME
INCDIR += -I${SDK}/src/soc/phy -I${SDK}/src/soc/phy/imacsec/include -I${IMACSEC_HOME}/bcm_plp_base_t_sec
CFGFLAGS += -DINCLUDE_PLP_IMACSEC
CFGFLAGS += -DINCLUDE_PLP_UNIMAC
endif

# EAV APPL in diag is intended to be built
#ifneq (,$(findstring EAV_APPL,$(FEATURE_LIST)))
#BUILD_EAV_APPL = 1
#endif

ifneq (,$(findstring KNET,$(FEATURE_LIST)))
# {
BUILD_KNET = 1

ifneq (,$(findstring KNETSYNC,$(FEATURE_LIST)))
# {
BUILD_KNETSYNC = 1
# }
endif

# }
endif

ifeq ($(NO_PRECOMPILED_MODULE),1)
# {
ifneq (,$(findstring KNET_CB,$(FEATURE_LIST)))
# {
BUILD_KNET_CB = 1

ifneq (,$(findstring KNETSYNC,$(FEATURE_LIST)))
# {
BUILD_KNETSYNC = 1
# }
endif

# }
endif
# }
endif

# Start Checking for KBP feature
#
ifeq (KBP,$(findstring KBP,$(FEATURE_LIST)))
# {
ifndef KBP_DEVICE
# {
$(error "KBP Feature is Enabled, and no valid Device was defined. Define KBP_DEVICE=KBP_11K or KBP_DEVICE=KBP_ALG")
# }
else
# {
ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
$(error "KBP_12K device not supported. Only KBP_11K and KBP_ALG devices are supported for KBP feature")
# }
endif
# }
endif

ifeq (KBP_11K,$(findstring KBP_11K,$(KBP_DEVICE)))
# {
DEVICE=nlm2
INCDIR += -I${SDK}/include/soc/kbp/nlm2/diagnostic
INCDIR += -I${SDK}/include/soc/kbp/nlm2/nlmxpt
INCDIR += -I${SDK}/include/soc/kbp/nlm2/simxpt
# }
endif

ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
DEVICE=nlm3
INCDIR += -I${SDK}/include/soc/kbp/nlm3/model
INCDIR += -I${SDK}/include/soc/kbp/nlm3/blackholexpt
INCDIR += -I${SDK}/include/soc/kbp/nlm3/xpt
# }
endif

ifneq (KBP_ALG,$(findstring KBP_ALG,$(KBP_DEVICE)))
# {
KBP_LIBDIR=${SDK}/src/soc/kbp/${DEVICE}/lib/${targetbase}-${targetplat}/${platform}/

CFLAGS += -DNLMPLATFORM_BCM
INCDIR += -I${SDK}/include
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmdevmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/arch
INCDIR += -I${SDK}/include/soc/kbp/common
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmrangemgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmgenerictblmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/api
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/common
# }
else
# {
CFLAGS += -DNLMPLATFORM_UNIX -DNLMPLATFORM_LINUX
# }
endif


ifeq ($(shell uname -m),x86_64)
# {
ifeq (DLONGS_ARE_64BITS,$(findstring DLONGS_ARE_64BITS,$(CFLAGS)))
# {
ifeq (DPTRS_ARE_64BITS,$(findstring DPTRS_ARE_64BITS,$(CFLAGS)))
# {
CFLAGS += -DNLM_BUILD64
# }
endif
# }
endif
# }
endif
# }
endif

# End Checking for KBP feature

#
# PHYMOD library support
#
# PHYMOD_CHIP_NAMES defines which internal PHYs require PHYMOD support.
# PHYMOD_PHY_LIST defines which external PHYs require PHYMOD support.
#
PHYMOD_CHIP_NAMES = BCM_53400_A0 BCM_88950_A0 BCM_88790_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0 BCM_88680_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88470_A0   BCM_88270_A0 BCM_56960_A0 BCM_56560_A0 BCM_56560_B0 BCM_56260_A0 BCM_56160_A0 BCM_56260_B0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56980_A0 BCM_56980_B0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0


ifdef LTSW_CHIPS
ifneq (1,$(PHYMOD_EXCLUDE_LTSW_CHIP))
PHYMOD_CHIP_NAMES += $(LTSW_CHIP_NAMES)
endif
endif

PHYMOD_PHY_LIST = 82381 82764 82864 82109
ifdef INCLUDE_PHY_8806X
PHYMOD_PHY_LIST += 8806X
endif

# Define default PHYMOD support based on included PHYs
ifeq (,$(PHYMOD_SUPPORT))
# {
seekphymodchips = $(foreach chipname,$(PHYMOD_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekphymodchips))" ""
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif
ifeq (,$(PHYMOD_SUPPORT))
# {
ifneq (,$(filter $(PHYMOD_PHY_LIST),$(BCM_PHY_LIST)))
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (wrx-opennsa, $(platform))
PHYMOD_SUPPORT = 1
endif

# Include PHYMOD diagnotics by default
ifeq (,$(PHYMOD_DIAG))
# {
PHYMOD_DIAG = $(PHYMOD_SUPPORT)
# }
endif

# Configure PHYMOD build
ifeq (1,$(PHYMOD_SUPPORT))
# {
BUILD_PHYMOD = 1
PHYMOD_LOCALDIR = libs/phymod
ifdef PHYMOD_PRE_BUILD_PATH
PHYMOD_DIR := $(PHYMOD_PRE_BUILD_PATH)/libs/phymod
else
PHYMOD_DIR := $(SDK)/libs/phymod
endif
INCDIR += -I${PHYMOD_DIR}/include
PHYMOD_ADD_CFLAGS += -DPHYMOD_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TIER1_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_INCLUDE_CUSTOM_CONFIG
ifeq (1,$(PHYMOD_DIAG))
# {
PHYMOD_ADD_CFLAGS += -DPHYMOD_DIAG
# }
endif
#
# For SAND chips, select a subset of the phy chips/architectures to support.
# See above: In parallel, numeric idntifiers of the contained chips are specified.
#
ifeq (1,$(SAND_ONLY))
# {
PHYMOD_ADD_CFLAGS += -DUSER_DEFINED_PHYMOD_CHIPS
export PHYMOD_CHIPS =
ifdef DNXC_CHIPS
# {
export PHYMOD_CHIPS += BLACKHAWK BLACKHAWK7_V1L8P1 BLACKHAWK7_L8P2 BLACKHAWK7_L2P2 FALCON16 TSCBH TSCBH_GEN2 TSCBH_FLEXE TSCBH_FE_GEN2 TSCBH_GEN3 TSCF16 TSCF16_GEN3 FALCON16_V1L4P1 PEREGRINE5_TC

PHYMOD_ADD_CFLAGS += -DPHYMOD_BLACKHAWK_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_BLACKHAWK7_V1L8P1_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_BLACKHAWK7_L8P2_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_BLACKHAWK7_L2P2_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_FALCON16_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCBH_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCBH_GEN2_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCBH_FE_GEN2_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCBH_FLEXE_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCBH_GEN3_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCF16_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCF16_GEN3_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_FALCON16_V1L4P1_SUPPORT
# }
endif
ifdef DCMN_CHIPS
# {
export PHYMOD_CHIPS += EAGLE FALCON FURIA QSGMIIE TSCE TSCF VIPER SESTO

PHYMOD_ADD_CFLAGS += -DPHYMOD_EAGLE_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_FALCON_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_FURIA_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_QSGMIIE_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCE_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TSCF_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_VIPER_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_SESTO_SUPPORT
# }
endif

ifneq (,$(findstring 82381,$(BCM_PHY_LIST)))
# {
#
# Just making sure that, if '82381' is incorporated then 'FURIA' is included as well.
# See src/soc/phy/phy82381.c
# Probably, this clause will never be executed.
#
ifeq (,$(findstring FURIA,$(PHYMOD_CHIPS)))
# {
export PHYMOD_CHIPS += FURIA

PHYMOD_ADD_CFLAGS += -DPHYMOD_FURIA_SUPPORT
# }
endif
# }
endif
ifneq (,$(findstring 82764,$(BCM_PHY_LIST)))
# {
#
# Just making sure that, if '82764' is incorporated then 'SESTO' is included as well.
# See src/soc/phy/phy82764.c
# Probably, this clause will never be executed.
#
ifeq (,$(findstring SESTO,$(PHYMOD_CHIPS)))
# {
export PHYMOD_CHIPS += SESTO

PHYMOD_ADD_CFLAGS += -DPHYMOD_SESTO_SUPPORT
# }
endif
# }
endif

# }
endif

CFLAGS += ${PHYMOD_ADD_CFLAGS}
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += ${PHYMOD_ADD_CFLAGS}
LTSW_ADD_CPPFLAGS += -I${PHYMOD_DIR}/include
endif
# }
endif

#
# Required for building SDKLT phymod library.
#
ifdef LTSW_CHIPS
ifeq (,$(BUILD_PHYMOD))
LTSW_ADD_CPPFLAGS += -DPHYMOD_DIAG
LTSW_ADD_CPPFLAGS += -I$(SDKLT)/phymod/../phymod/include
endif
endif

#Add the devices that has CPRI module.
CPRIMOD_CHIP_NAMES = BCM_56670_A0 BCM_56670_B0 BCM_56670_C0

seekportmod =  $(foreach chipname,$(CPRIMOD_CHIP_NAMES),$(whereischip))
#portmod support)
ifeq (,$(CPRIMOD_SUPPORT))
# {
ifneq "$(findstring file,$(seekportmod))" ""
# {
CPRIMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(CPRIMOD_SUPPORT))
# {
BUILD_PORTMOD = 1
CFLAGS += -DCPRIMOD_DIAG
CFLAGS += -DCPRIMOD_SUPPORT
CFLAGS += -DCPRI_DIAG_SUPPORT
CFLAGS += -DCPRIMOD_CPRI_FALCON_SUPPORT
export CPRIMOD_SUPPORT
# }
endif


PORTMOD_CHIP_NAMES = BCM_53400_A0 BCM_88950_A0 BCM_88790_A0 BCM_88670_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0 BCM_88680_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88470_A0  BCM_88270_A0 BCM_56960_A0 BCM_56560_A0 BCM_56560_B0 BCM_56160_A0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56980_A0 BCM_56980_B0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0



seekportmod =  $(foreach chipname,$(PORTMOD_CHIP_NAMES),$(whereischip))
#portmod support)
ifeq (,$(PORTMOD_SUPPORT))
# {
ifneq "$(findstring file,$(seekportmod))" ""
# {
PORTMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(PORTMOD_SUPPORT))
# {
BUILD_PORTMOD = 1
CFLAGS += -DPORTMOD_DIAG
CFLAGS += -DPORTMOD_SUPPORT
export PORTMOD_SUPPORT
# }
endif


#
# CANCUN support
#
# CANCUN_CHIP_NAMES defines which chips require CANCUN support
#
CANCUN_CHIP_NAMES = BCM_56870_A0 BCM_56870_B0 BCM_56370_A0 BCM_56770_A0 BCM_56275_A0 BCM_56470_A0






ifeq (,$(CANCUN_SUPPORT))
seekcancunchips = $(foreach chipname,$(CANCUN_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekcancunchips))" ""
CANCUN_SUPPORT = 1
endif
endif

ifeq (1,$(CANCUN_SUPPORT))

CFLAGS += -DCANCUN_SUPPORT
export CANCUN_SUPPORT
endif

#
# CMICFW support
#
# CMICFW_CHIP_NAMES defines which chips require CMICFW support
#
CMICFW_CHIP_NAMES = BCM_56870_A0 BCM_56980_A0 BCM_56980_B0


ifeq (,$(CMICFW_SUPPORT))
seekcmicfwchips = $(foreach chipname,$(CMICFW_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekcmicfwchips))" ""
CMICFW_SUPPORT = 1
endif
endif

ifeq (1,$(CMICFW_SUPPORT))

endif

#Add the devices that supports SW Autoneg to the lst below 
SW_AN_CHIP_NAMES = BCM_56965_A0 BCM_56560_B0 BCM_56565_B0 BCM_56969_A0 BCM_56966_A0 BCM_56967_A0 BCM_56970_A0

ifeq (,$(SW_AUTONEG_SUPPORT))
# {
seekswanchips = $(foreach chipname,$(SW_AN_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekswanchips))" ""
# {
SW_AUTONEG_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(SW_AUTONEG_SUPPORT))
# {
CFLAGS += -DSW_AUTONEG_SUPPORT
#}
endif

#
# PCIE PHY library support
#
# PCIEPHY_CHIP_NAMES defines which chips require PCIE PHY library support.
#
PCIEPHY_CHIP_NAMES = BCM_56870_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88790_A0 BCM_56980_A0 BCM_56980_B0 BCM_56770_A0 BCM_56370_A0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0




# Define default PCIEPHY support based on included PHYs
ifeq (,$(PCIEPHY_SUPPORT))
seekpciephychips = $(foreach chipname,$(PCIEPHY_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekpciephychips))" ""
PCIEPHY_SUPPORT = 1
endif
endif

# Include PCIEPHY PHY diagnotics by default
ifeq (,$(PCIEPHY_DIAG))
# {
PCIEPHY_DIAG = $(PCIEPHY_SUPPORT)
# }
endif

ifdef LTSW_CHIPS
ifeq (,$(PCIEPHY_SUPPORT))
PCIEPHY_SUPPORT = 1
endif
endif

# Configure PCIEPHY build
ifeq (1,$(PCIEPHY_SUPPORT))
# {
BUILD_PCIEPHY = 1
PCIEPHY_LOCALDIR = libs/pciephy
PCIEPHY_DIR = ${SDK}/${PCIEPHY_LOCALDIR}
INCDIR += -I${PCIEPHY_DIR}/include
PCIEPHY_ADD_CFLAGS += -DPCIEPHY_SUPPORT -DPCIEPHY_INCLUDE_CUSTOM_CONFIG=1
ifeq (1,$(PCIEPHY_DIAG))
# {
PCIEPHY_ADD_CFLAGS += -DPCIEPHY_DIAG_SUPPORT
# }
endif
CFLAGS += ${PCIEPHY_ADD_CFLAGS}
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += -I${PCIEPHY_DIR}/include
endif
# }
endif

ifeq (1,$(BUILD_SDKLT))
SDKLT_EXPORT_COMPONENT = bcma bcmpkt bcmlt bcmltm bcmltd bcmmgmt bcmha bcmissu bcmlrd bcmdrd bcmcfg bcmbd bcmdi shr bsl sal bcmpc
ifneq (,$(findstring XFLOW_MACSEC,$(FEATURE_LIST)))
# {
  SDKLT_EXPORT_COMPONENT += bcmsec
# }
endif
INCDIR += $(foreach component,$(SDKLT_EXPORT_COMPONENT),-I$(SDKLT)/$(component)/include)
endif

#
# BUILD KAPS if at least one of Dune chip family defined
# aka DPP_CHIPS || DFE_CHIPS || DNX2_CHIPS || DNXF1_CHIPS
#

ifdef DPP_CHIPS
# {
BUILD_KAPS = 1
# }
endif
ifdef DFE_CHIPS
# {
BUILD_KAPS = 1
# }
endif
ifdef DNX2_CHIPS
# {
BUILD_KAPS = 1
BUILD_FLEXE = 1
# }
endif
ifdef DNXF1_CHIPS
# {
BUILD_KAPS = 1
# }
endif


# Configure FLEXE build
ifeq (${BUILD_FLEXE},1)
# {
export BUILD_FLEXE
INCDIR += -I${SDK}/libs/flexe_core/std
# }
endif


ifneq (,$(findstring FLEXE_ONLY,$(FEATURE_LIST)))
# {
BUILD_FRAMER = 1
FRAMER_LIB_NAME = libframer_flexe
# }
endif

ifneq (,$(findstring FLEXE_OTN,$(FEATURE_LIST)))
# {
BUILD_FRAMER = 1
FRAMER_LIB_NAME = libframer
# }
endif

# Configure FRAMER build
ifeq (${BUILD_FRAMER},1)
# {
export BUILD_FRAMER
export FRAMER_LIB_NAME
INCDIR += -I${SDK}/libs/framer/include
INCDIR += -I${SDK}/libs/framer/define
INCDIR += -I${SDK}/libs/framer/lib
INCDIR += -I${SDK}/libs/framer/chip
INCDIR += -I${SDK}/libs/framer/debug
INCDIR += -I${SDK}/libs/framer/platform
INCDIR += -I${SDK}/libs/framer/thd_code/usr
INCDIR += -I${SDK}/libs/framer/sdk/framer/uas
INCDIR += -I${SDK}/libs/framer/sdk/framer/sal
INCDIR += -I${SDK}/libs/framer/sdk/framer/var
INCDIR += -I${SDK}/libs/framer/sdk/framer/api
INCDIR += -I${SDK}/libs/framer/component/mnvalue
INCDIR += -I${SDK}/libs/framer/component/average
INCDIR += -I${SDK}/libs/framer/component/cross
INCDIR += -I${SDK}/libs/framer/component/issu
INCDIR += -I${SDK}/libs/framer/component/ghao
INCDIR += -I${SDK}/libs/framer/component/ramblk
INCDIR += -I${SDK}/libs/framer/component/opu2demux
INCDIR += -I${SDK}/libs/framer/component/opuk_cm
CFGFLAGS += -DFRAMER_SUPPORT
# }
else
# {
CFGFLAGS += -DNO_FRAMER_LIB_BUILD
# }
endif

# Configure FLEXE_DBG build
ifeq (FLEXE_DBG,$(findstring FLEXE_DBG,$(FEATURE_LIST)))
# {
BUILD_FLEXE_DBG = 1
export BUILD_FLEXE_DBG
INCDIR += -I${SDK}/libs/flexe_core/dbg/adapt/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/bsp/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/66bswitch
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/cpb
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/demux
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/mux
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/sar
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/flexe_oh
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/module1588
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/oam
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/init
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/mcmac
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/rateadpt
INCDIR += -I${SDK}/libs/flexe_core/dbg/lib/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/protocal/demux/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/protocal/mux/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/top
INCDIR += -I${SDK}/libs/flexe_core/dbg
# }
endif

ifeq (AAPL,$(findstring AAPL,$(FEATURE_LIST)))
# {
BUILD_AAPL = 1
export BUILD_AAPL
# }
endif

# Paths of where we install files for make install
#
# install_headers - where to install header files.
# install_lib     - where to install libs
# install_bin	  - where to install completely linked binaries
#
install_headers	= ${SDK}/export/include
install_lib	= ${SDK}/export/lib/${target}
install_bin	= ${SDK}/export/bin/${target}

#
# Compilation Flags
#
# Flags may be added to (see below)
#

INCDIR += -I${SDK}/src/soc/phy/phy8806x/include

INCFLAGS = -I${INCDIR} -I${SDK}/systems

CFLAGS += ${INCFLAGS}
CXXFLAGS += ${INCFLAGS}
CPPFLAGS += ${INCFLAGS}

#
# Debug #ifdef control
#
# Compiling out #ifdef DEBUG code saves about 1.3% on executable size.
# It is recommended to leave debug enabled when developing applications.
#
ifndef DEBUG_IFDEFS
# {
DEBUG_IFDEFS=TRUE
# }
endif

ifeq ($(DEBUG_IFDEFS),TRUE)
# {
CFLAGS += -DBROADCOM_DEBUG
CXXFLAGS += -DBROADCOM_DEBUG
CPPFLAGS += -DBROADCOM_DEBUG
# }
endif

#
# Debug symbol information control
#
ifneq ($(targetbase),ghs)
# {
ifndef DEBUG_SYMBOLS
# {
DEBUG_SYMBOLS=TRUE
# }
endif
# }
endif

ifeq ($(DEBUG_SYMBOLS),TRUE)
# {
CFLAGS += -g
CXXFLAGS += -g
CPPFLAGS += -g
ifdef LTSW_CHIPS
# {
LTSW_ADD_CFLAGS += -g
# }
endif
# }
else
# {
CFLAGS += -g0
CXXFLAGS += -g0
CPPFLAGS += -g0
ifdef LTSW_CHIPS
# {
LTSW_ADD_CFLAGS += -g0
# }
endif
# }
endif

#
# If DEBUG_CFLAGS is set, add its contents to CFLAGS.
# May be useful for setting on the command line or adding to Make.local.
# Example: gmake DEBUG_CFLAGS=-save-temps system.c
#

ifneq ($(DEBUG_CFLAGS),)
# {
CFLAGS += $(DEBUG_CFLAGS)
CXXFLAGS += $(DEBUG_CFLAGS)
CPPFLAGS += $(DEBUG_CFLAGS)
ifdef LTSW_CHIPS
LTSW_ADD_CFLAGS += $(DEBUG_CFLAGS)
endif
# }
endif

#
# Optimization level
#
# Set DEBUG_OPTIMIZE to TRUE (default) to use a normal optimization
#		determined by OPTFLAGS_DEFAULT in the platform Makefile.
# Set DEBUG_OPTIMIZE to FALSE to use no optimization,
#		strongly recommended when using any debugger.
# Set DEBUG_OPTIMIZE to any other option string to request specific
#		optimization flags (for example -O2).
#
ifndef DEBUG_OPTIMIZE
# {
DEBUG_OPTIMIZE=TRUE
# }
endif

ifeq ($(DEBUG_OPTIMIZE),TRUE)
# {
OPTFLAGS += $(OPTFLAGS_DEFAULT)
# }
else
# {
ifneq ($(DEBUG_OPTIMIZE),FALSE)
# {
OPTFLAGS += $(DEBUG_OPTIMIZE)
# }
endif
# }
endif

ifdef LTSW_CHIPS
LTSW_ADD_CFLAGS += $(BCM_CFLAGS)
LTSW_ADD_CFLAGS += $(OPTFLAGS)
ifneq (,$(findstring -fPIC,$(STD_CFLAGS)))
LTSW_ADD_CFLAGS += -fPIC
endif
LTSW_ADD_CPPFLAGS += $(BCM_CPPFLAGS)
ifneq (,$(findstring -DCINT_CONFIG_INCLUDE_SDK_SAL=1,$(STD_CPPFLAGS)))
LTSW_ADD_CPPFLAGS += $(filter-out -DCINT_CONFIG_INCLUDE_SDK_SAL=1,$(STD_CPPFLAGS))
else
LTSW_ADD_CPPFLAGS += $(STD_CPPFLAGS)
endif
endif # LTSW_CHIPS

#
# Required for building SDKLT SAL library
#
ifdef LTSW_CHIPS
CFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
CXXFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
CPPFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
LTSW_ADD_CPPFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
endif

#
# Required for building customize BSL library
#
ifdef LTSW_CHIPS
CFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
LTSW_ADD_CPPFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
endif

#
# Required for SDKLT custom configuration header files
#
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += -I$(SDK)/include/sdklt -I$(SDK)/include
LTSW_LKM_ADD_CFLAGS += -I$(SDK)/include
endif

#
# PKTIO: streamlined packet I/O using imported drivers for legacy chips
#
ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))

# Default list of chips that support PKTIO
ifndef PKTIO_CHIPS
PKTIO_CHIPIDS = 56980_A0 56980_B0
endif # PKTIO_CHIPS

# Public header files required by PKTIO API
ifndef LTSW_CHIPS
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmpkt/include
endif # !LTSW_CHIPS

# For PKTIO implementation files
ifdef PKTIO_IMPL

CFLAGS += -DPKTIO_IMPL=1
INCDIR += -I${SDK}/src/bcm/esw/pktio
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmcnet/include

ifdef LTSW_CHIPS

SDKLT = ${SDK}/src/bcm/esw/pktio

else # !LTSW_CHIPS

INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmdrd/include
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmlrd/include
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmltd/include

endif # LTSW_CHIPS

# Build chip-specific drivers for PKTIO enabled chips
CFLAGS += -DBCMDRD_CONFIG_INCLUDE_CHIP_DEFAULT=0
$(foreach v,${PKTIO_CHIPIDS},$(if $(BCM_$v),$(eval CFLAGS+=-DBCMDRD_CONFIG_INCLUDE_BCM$v=1),))

# Rename public imported functions on the fly
$(foreach v,${PKTIO_FUNCS},$(eval CFLAGS+=-D$v=pktio_$v))

endif # PKTIO_IMPL


# Enable full BSL enums for imported modules
CFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID

endif # PKTIO

#
# Debug assertion control.
#
# Compiling out assert() saves about 1.1% on executable size,
# however doing so is VERY MUCH discouraged.
#
ifndef DEBUG_ASSERTS
# {
DEBUG_ASSERTS=TRUE
# }
endif

ifeq ($(DEBUG_ASSERTS),FALSE)
# {
CFLAGS += -DNDEBUG
CXXFLAGS += -DNDEBUG
CPPFLAGS += -DNDEBUG
# }
endif

#
# GCC pedantic mode.
#
ifeq ($(DEBUG_PEDANTIC),TRUE)
# {
CFGFLAGS += -D__PEDANTIC__
CFLAGS += --pedantic
CXXFLAGS += --pedantic
# }
endif

#
# Dynamic Load Enabled
#
ifeq ($(DL_ENABLE),TRUE)
# {
CFLAGS += -DDL_ENABLE
ifneq ($(USE_CLANG),1)
# {
LDFLAGS += -ldl -export-dynamic
# }
endif
# }
endif

#
# In each directory, build a list of local sources, objects, and headers
#
LSRCS	=	$(wildcard *.c *.cpp *.s *.cc *.C)
LOBJS	=	$(addsuffix .o, $(basename ${LSRCS}))
BOBJS	= 	$(addprefix ${BLDDIR}/,${LOBJS})
LHDRS	=	$(wildcard *.h *.H)
LDOTIS	=	$(wildcard *.i)


#
# Rule to create object file (build) directory
#

.PHONY: all install clean distclean

.PRECIOUS: ${BLDDIR}/.tree

%/.tree:
	@$(ECHO) Creating build directory $(dir $@)
	$Q($(MKDIR) $(dir $@); $(TOUCH) $@)

# Rule allowing build through CPP only, creates .E file from .c file.

%.E: %.c
	$Q$(CC) -E ${CFLAGS} $< | $(SED) -e '/^ *$$/d' -e p -e d > $@

# Rule allowing build through source only, creates .s file from .c file.

%.s: %.c
	$Q$(CC) -S ${CFLAGS} $<

# allow disabling of dependency file generation
# enable partial recompilation through use of included
# dependency make files
#
ifndef NO_SDK_DEPS
# {
# take the compiler generated .d file and reparse it 
# to generate a dependency graph rule for this object
# file
# the two steps generate:
#  file.o: file.c \
#	file.h ...
#
#  file.h: 
#  header.h: 
# some compilers will generate errors without the latter
# part of the list

.PHONY: .phony

DEPS_SED = \
	$(CP) $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp;\
	$(ECHO) >> $(BLDDIR)/$*.tmp;\
	$(SED) -e 's/\#.*//' -e 's/^[^:]*: *//' \
	-e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' \
	-e '/^ .$$/d' \
	< $(BLDDIR)/$*.d >> $(BLDDIR)/$*.tmp; \
	$(SED) -e 's|^\([^\/ ].*\.o\):|'$(BLDDIR)/'\1:|g'  \
	-e 's|.*?/\(.*\.o\):|'$(BLDDIR)/'\1:|g'  \
	< $(BLDDIR)/$*.tmp > $(BLDDIR)/$*.P; \
	$(RM) -f $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp
DEPS_CMD = $(DEPS_SED)

ifeq ($(targetbase),ghs)
# {
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring gnu,$(TOOL)),)
# {
# Gnu compilers always support -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring i686,$(CROSS_COMPILE)),)
# {
# Gcc 2.95 does not support -MD -MF with -o and -c
# }
else
# {
# newer gnu-based compilers allow -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
endif
# }
endif
# }
endif

# From gmsl

# Standard definitions for true and false.  true is any non-empty
# string, false is an empty string. These are intended for use with
# $(if).

true  := T
false :=

# ----------------------------------------------------------------------------
# Function:  not
# Arguments: 1: A boolean value
# Returns:   Returns the opposite of the arg. (true -> false, false -> true)
# ----------------------------------------------------------------------------
not = $(if $1,$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  map
# Arguments: 1: Name of function to $(call) for each element of list
#            2: List to iterate over calling the function in 1
# Returns:   The list after calling the function on each element
# ----------------------------------------------------------------------------
map = $(strip $(foreach a,$2,$(call $1,$a)))

# ----------------------------------------------------------------------------
# Function:  seq
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are identical
# ----------------------------------------------------------------------------
seq = $(if $(filter-out xx,x$(subst $1,,$2)$(subst $2,,$1)x),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  sne
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are not the same
# ----------------------------------------------------------------------------
sne = $(call not,$(call seq,$1,$2))

# End from gmsl

# Define comma symbol so we can repace it with a variable
comma :=,

# Signature
last_target :=

dump_var = $$(eval $1 := $($1))

define new_rule
@echo '$(call map,dump_var,@ < *)' > $S
@$(if $(wildcard $F),,touch $F)
@echo $@: $F >> $S
endef

define do
$(eval S := $(BLDDIR)/$*.sig)$(eval F := $(BLDDIR)/$*.force)$(eval C := $1)
$(if $(call sne,$@,$(last_target)),$(call new_rule),$(eval last_target := $@))
@echo '$$(if $$(call sne,$$(sort $1),$(sort $(subst $(comma),$$(comma),$C))),$$(shell touch $F))' >> $S
$Q$C
endef

# end of Signature


# }
else # ifndef NO_SDK_DEPS
# {
# No dependency files, faster compile times
# no partial compile support
DEPS_SED =
DEPS_OPT =
DEPS_CPY =
DEPS_CMD = /bin/true

define do
$(eval C := $1)
$Q$C
endef

# }
endif

#
# Default Build rules for .c --> .o, leaving the binary in BLDDIR/X.o,
# even if file not built from directory of source.
#
ifeq ($(FAST),1)
# {
${BLDDIR}/%.o: %.c
# }
else
# {
ifdef GENERATE_C_FILES
# {
${BLDDIR}/%.o: %.c
# }
else
# {

${BLDDIR}/%.o: %.c
# }
endif
# }
endif
# echo Compiling needed to properly process errors 
	@$Q$(ECHO) Compiling ${LOCALDIR}/$< 
	$Q$(MKDIR) $(@D)
	$Q$(RM) -f $@
	$(call do,$$(CC) $$(DEPS_OPT) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@ -c $$(realpath $$<))  && ($(DEPS_CMD))


${BLDDIR}/%.o: %.s
ifdef QUIET
# {
	@$(ECHO) Assembling ${LOCALDIR}/$<
# }
endif
	$Q$(CC) ${CFLAGS} ${EXTRA_CFLAGS} -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cpp
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS}  -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cc ${BLDDIR}/.tree
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS} -o $@ -c $(realpath $<)

#
# Cause "make foo.o" in any subdirectory to put the object in the build
# directory instead of the local directory.
#
%.o: ${BLDDIR}/%.o
	@

#
# Java Support
#
JAVAC	= /bin/javac
JAVACFLAGS= -nowarn

${BLDDIR}/%.class: %.java
	$(JAVAC) ${JAVACFLAGS} -d ${BLDDIR} $<

%.Z: %
	@$(ECHO) Compressing $< .....
	@$(COMPRESS) -c $< > $@

%.gz: %
	@$(ECHO) Compressing $< .....
	@$(GZIP) -c $< > $@


#
# Some Basic tools
#
INSTALL = /usr/ucb/install
INSTALLFLAGS =
CTAGS   = ctags
ETAGS	= etags

#
# List of directories where built objects live.
# (we are not making the export directories for now)
#
#DIRS =	${BLDDIR} ${EXPDIR}/lib ${EXPDIR}/bin ${EXPDIR}/include
DIRS =	${BLDDIR}

#
# Targets for build
#
include ${SDK}/make/Make.targets

ifeq (C_COMPILER,$(MAKECMDGOALS))
# {
C_COMPILER:
	@echo $(CC)
# }
endif

ifeq (CXX_COMPILER,$(MAKECMDGOALS))
# {
CXX_COMPILER:
	@echo $(CXX)
# }
endif

#
# Required for building PHYMOD library
#
ifeq (1,$(BUILD_PHYMOD))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export PHYMOD_LOCALDIR
export PHYMOD_BLDDIR = $(LIBDIR)
export PHYMOD_OBJDIR = $(BLDDIR)
export PHYMOD_EPIL_BLDDIR = $(LIBDIR)
export PHYMOD_EPIL_OBJDIR = $(BLDDIR)
export PHYMOD_CPPFLAGS = $(CFLAGS)
ifdef PHYMOD_PRE_BUILD_LIB
export PHYMOD_MAKE_RULES = $(SDK)/make/Make.phymod_prebuild
else
export PHYMOD_MAKE_RULES = $(SDK)/make/Make.phymod
endif
# }
endif

#
# Required for building PCIEPHY library
#
ifeq (1,$(BUILD_PCIEPHY))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export PCIEPHY_LOCALDIR
export PCIEPHY_BLDDIR = $(LIBDIR)
export PCIEPHY_OBJDIR = $(BLDDIR)
export PCIEPHY_CPPFLAGS = $(CFLAGS)
export PCIEPHY_MAKE_RULES = $(SDK)/make/Make.pciephy
# }
endif

#
# Required for building SDKLT library
#
ifeq (1,$(BUILD_SDKLT))
# {
# Export toolchain.
export CC
export AR
export ARFLAGS
export LD
export TOOLSDIR
export CROSS_COMPILE
export KDIR=$(KERNDIR)

# Configure SDKLT libraries.
export Q
export SDK_BLDDIR = $(LIBDIR)/sdklt
export SDK_DSTDIR = $(LIBDIR)
export SDK_CPPFLAGS = $(LTSW_ADD_CPPFLAGS)
export SDK_CFLAGS = $(LTSW_ADD_CFLAGS)
export BCMA_SYS_SUBDIRS=conf probe
export BCMA_EXCLUDE_TARGETS=sal bsl
export BCMA_CINT_EXCLUDE_TARGETS=core cli
export SHR_EXCLUDE_TARGETS = aidxres avl bitop crc pb thread timeout util
SDK_EXCLUDE_TARGETS += bsl sal
ifeq (1,$(BUILD_PHYMOD))
SDK_EXCLUDE_TARGETS += phymod
endif
ifeq (1,$(BUILD_PCIEPHY))
SDK_EXCLUDE_TARGETS += pciephy
endif
ifneq (,(SDK_EXCLUDE_TARGETS))
export SDK_EXCLUDE_TARGETS
endif
# Exclude the shareable pli library (see $SDKLT/sim/pli/posix directory)
export SIM_EXCLUDE_TARGETS = pli

# Configure SDKLT ISSU.
ifdef ISSU_CHIPS
export INCLUDE_DEVICES = $(addprefix -c ,$(ISSU_CHIPS))
endif
export ISSU_SDK_BLDDIR = $(SDK_BLDDIR)
export ISSU_SDK_DSTDIR = $(SDK_DSTDIR)
# }
endif

#
# Required for building FRAMER library
#
ifeq (1,$(BUILD_FRAMER))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export FRAMER_BLDDIR = $(LIBDIR)
export FRAMER_OBJDIR = $(BLDDIR)
export FRAMER_CPPFLAGS = $(CFLAGS)
export FRAMER_MAKE_RULES = $(SDK)/make/Make.framer
# }
endif

#
# Required for building FLEXE library
#
ifeq (1,$(BUILD_FLEXE))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export FLEXE_BLDDIR = $(LIBDIR)
export FLEXE_OBJDIR = $(BLDDIR)
export FLEXE_CPPFLAGS = $(CFLAGS)
export FLEXE_MAKE_RULES = $(SDK)/make/Make.flexe
# }
endif

#
# Required for building AAPL library
#
ifeq (1,$(BUILD_AAPL))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export AAPL_BLDDIR = $(LIBDIR)
export AAPL_OBJDIR = $(BLDDIR)
export AAPL_CPPFLAGS = $(CFLAGS)
export AAPL_MAKE_RULES = $(SDK)/make/Make.aapl
# }
endif

#
# Required for building XFLOW_MACSEC library
#
ifeq (1,$(BUILD_XFLOW_MACSEC))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export XFLOW_MACSEC_BLDDIR = $(LIBDIR)
export XFLOW_MACSEC_OBJDIR = $(BLDDIR)
export XFLOW_MACSEC_CFLAGS = $(CFLAGS)
# }
endif

#
# Required for building KAPS library
#
ifeq (1,$(BUILD_KAPS))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export KAPS_BLDDIR = $(LIBDIR)
export KAPS_OBJDIR = $(BLDDIR)
export KAPS_CPPFLAGS = $(CFLAGS)
export KAPS_MAKE_RULES = $(SDK)/make/Make.kaps
# }
endif

# Go test framework
ifeq (GO,$(findstring GO,$(FEATURE_LIST)))
# {
BUILD_GO = 1
# Not sure what the limitations of Go will be.
# When this is determined, should set GO_SUPPORT based on the limitations.
GO_SUPPORT = 1
# }
endif

# EDK-Host Build
ifeq (EDK,$(findstring EDK,$(FEATURE_LIST)))
# {
BUILD_EDK = 1
# }
endif

# External DPLL driver build
ifneq (,$(findstring -DBCM_EXT_DPLL_DRV_SUPPORT,$(CFGFLAGS)))
# {
CFGFLAGS += -DBCM_EXT_DPLL_DRV_SUPPORT
CFGFLAGS += -I$(EXT_DPLL_DRV_ROOT)/include/
# }
endif

ifneq ($(APPEND_TO_CFLAGS),)
#Adding " " between the different flags
CFGFLAGS += $(subst -, -, $(APPEND_TO_CFLAGS))
endif

ifeq (1,$(BUILD_SDKLT))
# {
SDK_VHDR_PATH = $(SDK)/include/soc/ltsw/generated
SDK_VHDR = $(SDK_VHDR_PATH)/issu_sw_ver.h

ifeq (,$(BUILD_ISSU))
  DERIVE_VER=1
endif
ifneq (,$(SDK_CLEAN))
  DERIVE_VER=1
endif
ifneq (,$(findstring clean,$(MAKECMDGOALS)))
  DERIVE_VER=1
endif

ifdef DERIVE_VER
# {
ISSU_SCRIPTS = $(SDKLT)/bcmha/scripts
LAST_VER_SCRIPT = $(ISSU_SCRIPTS)/issu_next_ver.py
ISSU_DB = $(SDK)/src/bcm/ltsw/dll/db

ifeq (,$(SDK_VER))
  export SDK_VER
  ifneq ("$(wildcard $(BLDROOT)/VERSION)","")
    # Use the version from the VERSION file if exist
    SDK_VER := $(shell echo `cat $(BLDROOT)/VERSION`)
  else
    # Otherwise, derive version from the RELEASE file and ISSU DB
    REL_VERSION := $(subst sdk-,,$(shell cat $(SDK)/RELEASE))
    SCRIPT_PARAMS = 3 $(ISSU_DB) $(REL_VERSION)
    SDK_VER := $(shell python $(LAST_VER_SCRIPT) $(SCRIPT_PARAMS))
  endif
endif

ifeq (,$(SDKLT_VER))
  export SDKLT_VER
  ifneq ("$(wildcard $(SDK_BLDDIR)/VERSION)","")
    # Use the version from the VERSION file if exist
    SDKLT_VER := $(shell echo `cat $(SDK_BLDDIR)/VERSION`)
  else
    # Otherwise, derive version from the RELEASE file and ISSU DB
    LT_REL_VERSION := $(shell echo `cat $(SDKLT)/RELEASE`)
    LT_SCRIPT_PARAMS = 3 $(SDKLT)/bcmissu/dll/db $(LT_REL_VERSION)
    SDKLT_VER := $(shell python $(LAST_VER_SCRIPT) $(LT_SCRIPT_PARAMS))
  endif
endif
# }
endif
# }
endif
