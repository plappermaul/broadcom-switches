/*
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_XFLOW_MACSEC_H__
#define __BCM_XFLOW_MACSEC_H__

#if defined(INCLUDE_XFLOW_MACSEC)

#include <bcm/types.h>
#include <xflow_macsec_defs.h>

#define BCM_XFLOW_MACSEC_SECURE_CHAN_ID_CREATE(flag, chan_id)                  \
                XFLOW_MACSEC_SECURE_CHAN_ID_CREATE(flag, chan_id) 
#define BCM_XFLOW_MACSEC_ENCRYPT_DECRYPT_NONE XFLOW_MACSEC_ENCRYPT_DECRYPT_NONE /* Indicates the
                                                          parameters are not
                                                          specific to encrypt or
                                                          decrypt flow or
                                                          applies to both. */
#define BCM_XFLOW_MACSEC_ENCRYPT            XFLOW_MACSEC_ENCRYPT /* Indicates the
                                                          parameters are for
                                                          encryption. */
#define BCM_XFLOW_MACSEC_DECRYPT            XFLOW_MACSEC_DECRYPT /* Indicates the
                                                          parameters are for
                                                          decryption. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_WITH_ID XFLOW_MACSEC_SECURE_CHAN_WITH_ID /* To be used when secure
                                                          channel needs to be
                                                          created with a
                                                          particular id. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_INCLUDE_SCI XFLOW_MACSEC_SECURE_CHAN_INFO_INCLUDE_SCI /* Indicates the 64-bit
                                                          SCI should be included
                                                          in the SecTAG during
                                                          encryption. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_CONTROLLED_PORT XFLOW_MACSEC_SECURE_CHAN_INFO_CONTROLLED_PORT /* Allow all data packets
                                                          and management
                                                          packets. The default
                                                          is uncontrolled port
                                                          which is to discard
                                                          all data packets and
                                                          allow only management
                                                          packets. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_ENCRYPT_DISABLE XFLOW_MACSEC_SECURE_CHAN_INFO_ENCRYPT_DISABLE /* Do not encrypt the
                                                          packet using the
                                                          Cipher suite. The
                                                          default behavior is to
                                                          encrypt. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_REPLAY_PROTECT_ENABLE XFLOW_MACSEC_SECURE_CHAN_INFO_REPLAY_PROTECT_ENABLE /* Enable replay protect. */

typedef enum bcm_xflow_macsec_crypto_e {
    bcmXflowMacsecCryptoAes128GcmIntegrityOnly = xflowMacsecCryptoAes128GcmIntegrityOnly, 
    bcmXflowMacsecCryptoAes128Gcm = xflowMacsecCryptoAes128Gcm, 
    bcmXflowMacsecCryptoAes128GcmXpnIntegrityOnly = xflowMacsecCryptoAes128GcmXpnIntegrityOnly, 
    bcmXflowMacsecCryptoAes128GcmXpn = xflowMacsecCryptoAes128GcmXpn, 
    bcmXflowMacsecCryptoAes256GcmIntegrityOnly = xflowMacsecCryptoAes256GcmIntegrityOnly, 
    bcmXflowMacsecCryptoAes256Gcm = xflowMacsecCryptoAes256Gcm, 
    bcmXflowMacsecCryptoAes256GcmXpnIntegrityOnly = xflowMacsecCryptoAes256GcmXpnIntegrityOnly, 
    bcmXflowMacsecCryptoAes256GcmXpn = xflowMacsecCryptoAes256GcmXpn, 
    bcmXflowMacsecCryptoCount = xflowMacsecCryptoCount 
} bcm_xflow_macsec_crypto_t;

typedef enum bcm_xflow_macsec_mtu_e {
    bcmXflowMacsecMtu0 = xflowMacsecMtu0, 
    bcmXflowMacsecMtu1 = xflowMacsecMtu1, 
    bcmXflowMacsecMtu2 = xflowMacsecMtu2, 
    bcmXflowMacsecMtu3 = xflowMacsecMtu3, 
    bcmXflowMacsecMtuCount = xflowMacsecMtuCount 
} bcm_xflow_macsec_mtu_t;

typedef enum bcm_xflow_macsec_sectag_ethertype_e {
    bcmXflowMacsecSecTagEtype0 = xflowMacsecSecTagEtype0, 
    bcmXflowMacsecSecTagEtype1 = xflowMacsecSecTagEtype1, 
    bcmXflowMacsecSecTagEtype2 = xflowMacsecSecTagEtype2, 
    bcmXflowMacsecSecTagEtype3 = xflowMacsecSecTagEtype3, 
    bcmXflowMacsecSecTagEtypeCount = xflowMacsecSecTagEtypeCount 
} bcm_xflow_macsec_sectag_ethertype_t;

typedef xflow_macsec_instance_id_t bcm_xflow_macsec_instance_id_t;

typedef xflow_macsec_secure_chan_info_t bcm_xflow_macsec_secure_chan_info_t;

typedef xflow_macsec_secure_chan_id_t bcm_xflow_macsec_secure_chan_id_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Installs a new security channel entry. Returns the channel Id. */
extern int bcm_xflow_macsec_secure_chan_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id);

/* 
 * Sets/Resets the value of one of the parameters of a given security
 * channel.
 */
extern int bcm_xflow_macsec_secure_chan_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority);

/* Get the security channel configuration for a given SC index. */
extern int bcm_xflow_macsec_secure_chan_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int *priority);

/* 
 * Delete the given security channel. The corresponding SA must be
 * destroyed first.
 */
extern int bcm_xflow_macsec_secure_chan_destroy(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_secure_chan_info_t_init(
    bcm_xflow_macsec_secure_chan_info_t *chan_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable the Security Channel. */
extern int bcm_xflow_macsec_secure_chan_enable_set(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int enable);

/* Check if the Security Channel is enabled. */
extern int bcm_xflow_macsec_secure_chan_enable_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int *enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_xflow_macsec_chan_traverse_cb */
typedef int (*bcm_xflow_macsec_chan_traverse_cb)(
    int unit, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse secure channels */
extern int bcm_xflow_macsec_secure_chan_info_traverse(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_chan_traverse_cb callback, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_SECURE_ASSOC_ID_CREATE(flag, assoc_id)                  \
                XFLOW_MACSEC_SECURE_ASSOC_ID_CREATE(flag, assoc_id) 
#define BCM_XFLOW_MACSEC_SECURE_ASSOC_INFO_SET_NEXT_PKT_NUM XFLOW_MACSEC_SECURE_ASSOC_INFO_SET_NEXT_PKT_NUM /* Set the next PN of the
                                                          security association
                                                          to the value given. */

typedef xflow_macsec_secure_assoc_info_t bcm_xflow_macsec_secure_assoc_info_t;

typedef xflow_macsec_crypto_aes128_gcm_t bcm_xflow_macsec_crypto_aes128_gcm_t;

typedef xflow_macsec_crypto_aes256_gcm_t bcm_xflow_macsec_crypto_aes256_gcm_t;

typedef uint32 bcm_xflow_macsec_secure_assoc_id_t;

typedef enum bcm_xflow_macsec_secure_assoc_an_control_e {
    bcmXflowMacsecSecureAssocAnNormal = xflowMacsecSecureAssocAnNormal, 
    bcmXflowMacsecSecureAssocAnRollover = xflowMacsecSecureAssocAnRollover, 
    bcmXflowMacsecSecureAssocAnAuto = xflowMacsecSecureAssocAnAuto, 
    bcmXflowMacsecSecureAssocAnCount = xflowMacsecSecureAssocAnCount 
} bcm_xflow_macsec_secure_assoc_an_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Create the Security Association for the given Security Channel. */
extern int bcm_xflow_macsec_secure_assoc_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_assoc_id_t *assoc_id);

/* 
 * Sets/Resets the value of any of the parameters of a given security
 * association.
 */
extern int bcm_xflow_macsec_secure_assoc_set(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info);

/* 
 * Retrieve the Security Association configuration and the SC index from
 * the SA index.
 */
extern int bcm_xflow_macsec_secure_assoc_get(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id);

/* Deletes the SA entry corresponding to the Security Association. */
extern int bcm_xflow_macsec_secure_assoc_destroy(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the Security Association data structure. */
extern void bcm_xflow_macsec_secure_assoc_info_t_init(
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info);

/* bcm_xflow_macsec_secure_assoc_traverse_cb */
typedef int (*bcm_xflow_macsec_secure_assoc_traverse_cb)(
    int unit, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse Secure Associations */
extern int bcm_xflow_macsec_secure_assoc_traverse(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_traverse_cb callback, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_ID_CREATE(id)                  \
                XFLOW_MACSEC_POLICY_ID_CREATE(BCM_XFLOW_MACSEC_DECRYPT, id) 
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_WITH_ID XFLOW_MACSEC_POLICY_WITH_ID /* Provide the policy_id
                                                          as input to the API. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_FRAME_DENY XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_FRAME_DENY /* Deny and account all
                                                          data packet which
                                                          doesn't have a sectag. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_CHECK_ICV XFLOW_MACSEC_DECRYPT_POLICY_CHECK_ICV /* Allow all data and
                                                          control packets to be
                                                          permitted and
                                                          accounted regardless
                                                          of policy violation,
                                                          but do check and
                                                          account (but not drop)
                                                          for ICV violations. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_CHECK_NONE XFLOW_MACSEC_DECRYPT_POLICY_CHECK_NONE /* Allow all data and
                                                          control packets to be
                                                          permitted and
                                                          accounted regardless
                                                          of policy violation
                                                          and do not perform an
                                                          ICV check. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_CONTROL_PORT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_CONTROL_PORT_ENABLE /* Allow data packets
                                                          which are untagged
                                                          (i.e., they don't have
                                                          a SecTAG) to be
                                                          processed by the
                                                          MACsec logic. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_TAGGED_CONTROL_PORT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_TAGGED_CONTROL_PORT_ENABLE /* Allow data
                                                          (non-management)
                                                          packets which are
                                                          tagged (i.e., they
                                                          have a SecTAG) to be
                                                          processed by the
                                                          MACsec logic. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_POINT_TO_POINT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_POINT_TO_POINT_ENABLE /* Enable the point to
                                                          point mode in the
                                                          Policy table. This
                                                          mode is disabled by
                                                          default. The SCI value
                                                          is only programmed
                                                          when point to point
                                                          mode is enabled. */

typedef xflow_macsec_policy_id_t bcm_xflow_macsec_policy_id_t;

typedef xflow_macsec_policy_info_t bcm_xflow_macsec_decrypt_policy_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Create a Macsec decrypt policy. Returns the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info, 
    bcm_xflow_macsec_policy_id_t *policy_id);

/* 
 * Set/Replace one of the parameters of an existing decrypt policy
 * configuration.
 */
extern int bcm_xflow_macsec_decrypt_policy_set(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

/* Get the decrypt policy configuration given the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_get(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

/* Get the decrypt policy configuration given the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_destroy(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_decrypt_policy_info_t_init(
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

#define BCM_XFLOW_MACSEC_DECRYPT_FLOW_ID_CREATE(id)                  \
                XFLOW_MACSEC_FLOW_ID_CREATE(XFLOW_MACSEC_DECRYPT, assoc_id) 
#define BCM_XFLOW_MACSEC_FLOW_WITH_ID       XFLOW_MACSEC_FLOW_WITH_ID /* To be used when flows
                                                          need to be created
                                                          with a particular id */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_0    XFLOW_MACSEC_FLOW_TPID_SEL_0 /* Select the first TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_1    XFLOW_MACSEC_FLOW_TPID_SEL_1 /* Select the second TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_2    XFLOW_MACSEC_FLOW_TPID_SEL_2 /* Select the third TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_3    XFLOW_MACSEC_FLOW_TPID_SEL_3 /* Select the fourth TPID
                                                          to be matched. */

typedef xflow_macsec_flow_id_t bcm_xflow_macsec_flow_id_t;

typedef xflow_macsec_flow_info_mpls_t bcm_xflow_macsec_flow_info_mpls_t;

typedef xflow_macsec_flow_udf_param_t bcm_xflow_macsec_flow_udf_param_t;

typedef xflow_macsec_flow_info_t bcm_xflow_macsec_decrypt_flow_info_t;

typedef enum bcm_xflow_macsec_decrypt_flow_pkt_type_e {
    bcmXflowMacsecDecyptFlowAny = xflowMacsecDecyptFlowAny, 
    bcmXflowMacsecDecyptFlowNonMacsec = xflowMacsecDecyptFlowNonMacsec, 
    bcmXflowMacsecDecyptFlowMacSec = xflowMacsecDecyptFlowMacSec, 
    bcmXflowMacsecDecyptFlowManagement = xflowMacsecDecyptFlowManagement, 
    bcmXflowMacsecDecyptFlowKay = xflowMacsecDecyptFlowKay, 
    bcmXflowMacsecDecyptFlowCount = xflowMacsecDecyptFlowCount 
} bcm_xflow_macsec_decrypt_flow_pkt_type_t;

typedef enum bcm_xflow_macsec_decrypt_flow_etype_e {
    bcmXflowMacsecFlowEtypeAny = xflowMacsecFlowEtypeAny, 
    bcmXflowMacsecFlowEtypeEII = xflowMacsecFlowEtypeEII, 
    bcmXflowMacsecFlowEtypeSnap = xflowMacsecFlowEtypeSnap, 
    bcmXflowMacsecFlowEtypeLlc = xflowMacsecFlowEtypeLlc, 
    bcmXflowMacsecFlowEtypeMpls = xflowMacsecFlowEtypeMpls, 
    bcmXflowMacsecFlowEtypeCount = xflowMacsecFlowEtypeCount 
} bcm_xflow_macsec_decrypt_flow_etype_t;

typedef enum bcm_xflow_macsec_vlan_mpls_tag_status_e {
    bcmXflowMacsecTagAny = xflowMacsecTagAny, 
    bcmXflowMacsecTagUntaggedVlan = xflowMacsecTagUntaggedVlan, 
    bcmXflowMacsecTagSingleVlan = xflowMacsecTagSingleVlan, 
    bcmXflowMacsecTagDoubleVlan = xflowMacsecTagDoubleVlan, 
    bcmXflowMacsecTagOneMplsLabel = xflowMacsecTagOneMplsLabel, 
    bcmXflowMacsecTagTwoMplsLabel = xflowMacsecTagTwoMplsLabel, 
    bcmXflowMacsecTagThreeMplsLabel = xflowMacsecTagThreeMplsLabel, 
    bcmXflowMacsecTagCount = xflowMacsecTagCount 
} bcm_xflow_macsec_vlan_mpls_tag_status_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Creates a flow entry in the decrypt TCAM which is used to match
 * packets that need decryption. Matched entry results in an index to the
 * policy table.
 */
extern int bcm_xflow_macsec_decrypt_flow_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority, 
    bcm_xflow_macsec_flow_id_t *flow_id);

/* Set/Replace one of the parameters in the flow criteria. */
extern int bcm_xflow_macsec_decrypt_flow_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority);

/* Get the flow configuration given a flow index. */
extern int bcm_xflow_macsec_decrypt_flow_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int *priority);

/* 
 * Delete a flow configuration given a flow index. This does not delete
 * the policy configuration.
 */
extern int bcm_xflow_macsec_decrypt_flow_destroy(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_decrypt_flow_info_t_init(
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable a flow given the flow index. */
extern int bcm_xflow_macsec_decrypt_flow_enable_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int enable);

/* Disable a flow given the flow index. */
extern int bcm_xflow_macsec_decrypt_flow_enable_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int *enable);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef xflow_macsec_id_t bcm_xflow_macsec_id_t;

typedef xflow_macsec_subport_id_t bcm_xflow_macsec_subport_id_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Gives the subport ID corresponding to an encrypt or decrypt channel. */
extern int bcm_xflow_macsec_subport_id_get(
    int unit, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_subport_id_t *macsec_subport_id);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_xflow_macsec_control_e {
    bcmXflowMacsecControlPNThreshold = xflowMacsecControlPNThreshold, 
    bcmXflowMacsecControlXPNThreshold = xflowMacsecControlXPNThreshold, 
    bcmXflowMacsecControlCount = xflowMacsecControlCount 
} bcm_xflow_macsec_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Sets the value in HW for the macsec control type provided. */
extern int bcm_xflow_macsec_control_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_control_t type, 
    uint64 value);

/* Gets the value from HW for the macsec control type provided. */
extern int bcm_xflow_macsec_control_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_control_t type, 
    uint64 *value);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_xflow_macsec_stat_type_e {
    bcmXflowMacsecStatTypeInvalid = xflowMacsecStatTypeInvalid , 
    bcmXflowMacsecUnctrlPortInOctets = xflowMacsecUnctrlPortInOctets, 
    bcmXflowMacsecUnctrlPortInUcastPkts = xflowMacsecUnctrlPortInUcastPkts, 
    bcmXflowMacsecUnctrlPortInMulticastPkts = xflowMacsecUnctrlPortInMulticastPkts, 
    bcmXflowMacsecUnctrlPortInBroadcastPkts = xflowMacsecUnctrlPortInBroadcastPkts, 
    bcmXflowMacsecUnctrlPortInDiscards = xflowMacsecUnctrlPortInDiscards, 
    bcmXflowMacsecUnctrlPortOutOctets = xflowMacsecUnctrlPortOutOctets, 
    bcmXflowMacsecUnctrlPortOutUcastPkts = xflowMacsecUnctrlPortOutUcastPkts, 
    bcmXflowMacsecUnctrlPortOutMulticastPkts = xflowMacsecUnctrlPortOutMulticastPkts, 
    bcmXflowMacsecUnctrlPortOutBroadcastPkts = xflowMacsecUnctrlPortOutBroadcastPkts, 
    bcmXflowMacsecUnctrlPortOutErrors = xflowMacsecUnctrlPortOutErrors, 
    bcmXflowMacsecCtrlPortInOctets = xflowMacsecCtrlPortInOctets, 
    bcmXflowMacsecCtrlPortInUcastPkts = xflowMacsecCtrlPortInUcastPkts, 
    bcmXflowMacsecCtrlPortInMulticastPkts = xflowMacsecCtrlPortInMulticastPkts, 
    bcmXflowMacsecCtrlPortInBroadcastPkts = xflowMacsecCtrlPortInBroadcastPkts, 
    bcmXflowMacsecCtrlPortInDiscards = xflowMacsecCtrlPortInDiscards, 
    bcmXflowMacsecCtrlPortInErrors = xflowMacsecCtrlPortInErrors, 
    bcmXflowMacsecCtrlPortOutOctets = xflowMacsecCtrlPortOutOctets, 
    bcmXflowMacsecCtrlPortOutUcastPkts = xflowMacsecCtrlPortOutUcastPkts, 
    bcmXflowMacsecCtrlPortOutMulticastPkts = xflowMacsecCtrlPortOutMulticastPkts, 
    bcmXflowMacsecCtrlPortOutBroadcastPkts = xflowMacsecCtrlPortOutBroadcastPkts, 
    bcmXflowMacsecCtrlPortOutErrors = xflowMacsecCtrlPortOutErrors, 
    bcmXflowMacsecSecyStatsTxUntaggedPkts = xflowMacsecSecyStatsTxUntaggedPkts, 
    bcmXflowMacsecSecyStatsTxTooLongPkts = xflowMacsecSecyStatsTxTooLongPkts, 
    bcmXflowMacsecSecyStatsRxUntaggedPkts = xflowMacsecSecyStatsRxUntaggedPkts, 
    bcmXflowMacsecSecyStatsRxNoTagPkts = xflowMacsecSecyStatsRxNoTagPkts, 
    bcmXflowMacsecSecyStatsRxBadTagPkts = xflowMacsecSecyStatsRxBadTagPkts, 
    bcmXflowMacsecSecyStatsRxUnknownSCIPkts = xflowMacsecSecyStatsRxUnknownSCIPkts, 
    bcmXflowMacsecSecyStatsRxNoSCIPkts = xflowMacsecSecyStatsRxNoSCIPkts, 
    bcmXflowMacsecSecyStatsRxOverrunPkts = xflowMacsecSecyStatsRxOverrunPkts, 
    bcmXflowMacsecSecyTxSCStatsProtectedPkts = xflowMacsecSecyTxSCStatsProtectedPkts, 
    bcmXflowMacsecSecyTxSCStatsEncryptedPkts = xflowMacsecSecyTxSCStatsEncryptedPkts, 
    bcmXflowMacsecSecyTxSCStatsOctetsProtected = xflowMacsecSecyTxSCStatsOctetsProtected, 
    bcmXflowMacsecSecyTxSCStatsOctetsEncrypted = xflowMacsecSecyTxSCStatsOctetsEncrypted, 
    bcmXflowMacsecSecyRxSCStatsUnusedSAPkts = xflowMacsecSecyRxSCStatsUnusedSAPkts, 
    bcmXflowMacsecSecyRxSCStatsNotUsingSAPkts = xflowMacsecSecyRxSCStatsNotUsingSAPkts, 
    bcmXflowMacsecSecyRxSCStatsLatePkts = xflowMacsecSecyRxSCStatsLatePkts, 
    bcmXflowMacsecSecyRxSCStatsNotValidPkts = xflowMacsecSecyRxSCStatsNotValidPkts, 
    bcmXflowMacsecSecyRxSCStatsInvalidPkts = xflowMacsecSecyRxSCStatsInvalidPkts, 
    bcmXflowMacsecSecyRxSCStatsDelayedPkts = xflowMacsecSecyRxSCStatsDelayedPkts, 
    bcmXflowMacsecSecyRxSCStatsUncheckedPkts = xflowMacsecSecyRxSCStatsUncheckedPkts, 
    bcmXflowMacsecSecyRxSCStatsOKPkts = xflowMacsecSecyRxSCStatsOKPkts, 
    bcmXflowMacsecSecyRxSCStatsOctetsValidated = xflowMacsecSecyRxSCStatsOctetsValidated, 
    bcmXflowMacsecSecyRxSCStatsOctetsDecrypted = xflowMacsecSecyRxSCStatsOctetsDecrypted, 
    bcmXflowMacsecSecyTxSAStatsProtectedPkts = xflowMacsecSecyTxSAStatsProtectedPkts, 
    bcmXflowMacsecSecyTxSAStatsEncryptedPkts = xflowMacsecSecyTxSAStatsEncryptedPkts, 
    bcmXflowMacsecSecyRxSAStatsUnusedSAPkts = xflowMacsecSecyRxSAStatsUnusedSAPkts, 
    bcmXflowMacsecSecyRxSAStatsNotUsingSAPkts = xflowMacsecSecyRxSAStatsNotUsingSAPkts, 
    bcmXflowMacsecSecyRxSAStatsNotValidPkts = xflowMacsecSecyRxSAStatsNotValidPkts, 
    bcmXflowMacsecSecyRxSAStatsInvalidPkts = xflowMacsecSecyRxSAStatsInvalidPkts, 
    bcmXflowMacsecSecyRxSAStatsOKPkts = xflowMacsecSecyRxSAStatsOKPkts, 
    bcmXflowMacsecInMgmtPkts = xflowMacsecInMgmtPkts, 
    bcmXflowMacsecFlowTcamHitCntr = xflowMacsecFlowTcamHitCntr, 
    bcmXflowMacsecFlowTcamMissCntr = xflowMacsecFlowTcamMissCntr, 
    bcmXflowMacsecScTcamHitCntr = xflowMacsecScTcamHitCntr, 
    bcmXflowMacsecScTcamMissCntr = xflowMacsecScTcamMissCntr, 
    bcmXflowMacsecOutMgmtPkts = xflowMacsecOutMgmtPkts, 
    bcmXflowMacsecInPacketDropCntr = xflowMacsecInPacketDropCntr, 
    bcmXflowMacsecOutPacketDropCntr = xflowMacsecOutPacketDropCntr, 
    bcmXflowMacsecBadOlpHdrCntr = xflowMacsecBadOlpHdrCntr, 
    bcmXflowMacsecStatTypeCount = xflowMacsecStatTypeCount 
} bcm_xflow_macsec_stat_type_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Gets the counter value corresponding to the macsec_id and stat_type
 * provided.
 */
extern int bcm_xflow_macsec_stat_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 *value);

/* 
 * Sets the counter value corresponding to the macsec_id and stat_type
 * provided.
 */
extern int bcm_xflow_macsec_stat_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 value);

/* 
 * Gets an array of counter values corresponding to macsec_id and the
 * array of stat_type provided. The output ?stats_array? should be
 * allocated to hold ?array_count? number of values.
 */
extern int bcm_xflow_macsec_stat_multi_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array);

/* 
 * Sets an array of counter values corresponding to macsec_id and the
 * array of stat_type provided. The output ?stats_array? should be
 * allocated to hold ?array_count? number of values.
 */
extern int bcm_xflow_macsec_stat_multi_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_0   XFLOW_MACSEC_MATCH_TPID_SEL_0 /* Select the first TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_1   XFLOW_MACSEC_MATCH_TPID_SEL_1 /* Select the second TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_2   XFLOW_MACSEC_MATCH_TPID_SEL_2 /* Select the third TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_3   XFLOW_MACSEC_MATCH_TPID_SEL_3 /* Select the fourth TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_VLAN_TPID_MAX      XFLOW_MACSEC_VLAN_TPID_MAX /* Total TPIDs
                                                          configurable */

typedef xflow_macsec_vlan_tpid_t bcm_xflow_macsec_vlan_tpid_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the four VLAN TPID for decrypt flow. */
extern int bcm_xflow_macsec_vlan_tpid_array_set(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid);

/* Retrieve the four vlan tpid configured. */
extern int bcm_xflow_macsec_vlan_tpid_array_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid);

/* 
 * Get the index corresponding to a TPID value. This is to be used in the
 * decrypt policy.
 */
extern int bcm_xflow_macsec_vlan_tpid_array_index_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 vlan_tpid, 
    uint8 *tpid_index_sel);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_MTU_WITH_ID    XFLOW_MACSEC_MTU_WITH_ID /* The mtu_index is provided
                                                      as an input. */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set the MTU for encrypt or decrypt flow and get the corresponding MTU
 * sel. The sel can be used with SC config. To clear the value, set mtu
 * as 0 for the corresponding mtu_sel (IN).
 */
extern int bcm_xflow_macsec_mtu_set(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 mtu, 
    bcm_xflow_macsec_mtu_t *mtu_sel);

/* Get the value corresponding to a MTU sel. */
extern int bcm_xflow_macsec_mtu_get(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mtu_t mtu_sel, 
    uint32 *mtu);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_ETHERTYPE_WITH_ID  XFLOW_MACSEC_ETHERTYPE_WITH_ID /* The sectag_etype_index
                                                          is provided as input. */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set the sectag Ethertype and get the corresponding ethertype sel. To
 * clear this value, set the sectag_etype to 0 for the given
 * sectag_etype_sel(IN) along with the appropriate flag. This API is
 * applicable to both encrypt and decrypt.
 */
extern int bcm_xflow_macsec_sectag_etype_set(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 sectag_etype, 
    bcm_xflow_macsec_sectag_ethertype_t *sectag_etype_sel);

/* Get the value corresponding to a Sectag Ethertype select. */
extern int bcm_xflow_macsec_sectag_etype_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_sectag_ethertype_t sectag_etype_sel, 
    uint32 *sectag_etype);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_xflow_macsec_event_e {
    bcmXflowMacsecEventSASoftExpire = xflowMacsecEventSASoftExpire, /* SA Soft Expire event. This indicates
                                           that the PN for a given SA has hit
                                           the threshold value configured. The
                                           index id has to be typecasted to
                                           bcm_xflow_macsec_secure_assoc_id_t. */
    bcmXflowMacsecEventSAExpire = xflowMacsecEventSAExpire, /* SA Expire event. This indicates that
                                           the PN for a given SA has hit the
                                           maximum value possible. For AES
                                           algorithm, this is 2^32. For AES XPN
                                           algorithm, this is 2^64. The index id
                                           has to be typecasted to
                                           bcm_xflow_macsec_secure_assoc_id_t. */
    bcmXflowMacsecEventCount = xflowMacsecEventCount 
} bcm_xflow_macsec_event_t;

/* 
 * Callback function to notify Xflow Macsec events. The flags specify
 * whether the callback is for encrypt or decrypt. The index id should be
 * typecasted based on the event.
 */
typedef int (*bcm_xflow_macsec_event_cb)(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_event_t event, 
    bcm_xflow_macsec_id_t id, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Xflow Macsec callback registration API. The callback function will be
 * invoked when an event occurs.
 */
extern int bcm_xflow_macsec_event_register(
    int unit, 
    bcm_xflow_macsec_event_cb cb, 
    void *user_data);

/* Xflow Macsec callback deregistration API. */
extern int bcm_xflow_macsec_event_deregister(
    int unit, 
    bcm_xflow_macsec_event_cb cb);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef xflow_macsec_mac_addr_info_t bcm_xflow_macsec_mac_addr_info_t;

typedef enum bcm_xflow_macsec_mac_addr_control_e {
    bcmXflowMacsecStationDstMac = xflowMacsecStationDstMac, /* Station mac addressed to be used when
                                           a dropped packet is to be copied to
                                           cpu.
                                           Argument mac_addr_info.mac_addr
                                           specifies the station MACDA.
                                           Not applicable to Inline Xflow
                                           Macsec. */
    bcmXflowMacsecMacAddrControlCount = xflowMacsecMacAddrControlCount /* Max value. */
} bcm_xflow_macsec_mac_addr_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Sets the value in HW for the macsec control type provided. */
extern int bcm_xflow_macsec_mac_addr_control_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mac_addr_control_t control_type, 
    bcm_xflow_macsec_mac_addr_info_t *control_info);

/* Sets the value in HW for the macsec control type provided. */
extern int bcm_xflow_macsec_mac_addr_control_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mac_addr_control_t control_type, 
    bcm_xflow_macsec_mac_addr_info_t *control_info);

#endif /* defined(INCLUDE_XFLOW_MACSEC) */

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_XFLOW_MACSEC_H__ */
