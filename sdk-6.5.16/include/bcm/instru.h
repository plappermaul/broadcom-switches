/*
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_INSTRU_H__
#define __BCM_INSTRU_H__

#include <bcm/types.h>

/* Visibility Modes */
typedef enum bcm_vis_mode_e {
    bcmVisModeNone = 0,     /* Visibility is not enabled */
    bcmVisModeAlways = 1,   /* Visibility is enabled for all packets from all
                               ports */
    bcmVisModeSelective = 2 /* Visibility should be configured per specific
                               parameter */
} bcm_vis_mode_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set Visibility mode */
extern int bcm_instru_vis_mode_set(
    int unit, 
    bcm_vis_mode_t mode);

/* Get Visibility mode */
extern int bcm_instru_vis_mode_get(
    int unit, 
    bcm_vis_mode_t *mode);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Node type of IPT profile */
typedef enum bcm_instru_ipt_node_type_e {
    bcmInstruIptNodeTypeTail = 0,       /* Tail */
    bcmInstruIptNodeTypeIntOverVxlanFirst = 1, /* Vxlan first node */
    bcmInstruIptNodeTypeIntOverVxlanIntermediate = 2, /* Vxlan intermediate node */
    bcmInstruIptNodeTypeIntOverVxlanLast = 3 /* Vxlan last node */
} bcm_instru_ipt_node_type_t;

/* Control of various Instrumentation features */
typedef enum bcm_instru_control_e {
    bcmInstruControlIptSwitchId = 0,    /* IPT switch ID */
    bcmInstruControlVisMode = 1,        /* Visibility Mode */
    bcmInstruControlVisSampling = 2,    /* Visibility sampling parameters in
                                           Selective mode */
    bcmInstruControlSFlowSamplingRate = 3, /* Global sampling rate for sFlow
                                           datagrams */
    bcmInstruControlSFlowAgentIPAddress = 4, /* Global agent IP address for sFlow
                                           datagrams */
    bcmInstruControlSFlowUpTime = 5     /* Time stamp that will be stamped on
                                           sFlow packets. Should be updated
                                           periodically. */
} bcm_instru_control_t;

/* 
 * Supported visibility modes, used in arg when type is 
 * bcmInstruControlVisMode
 */
typedef enum bcm_instru_vis_mode_control_e {
    bcmInstruVisModeNone = 0,       /* No visibility enabled */
    bcmInstruVisModeAlways = 1,     /* Visibility is enabled for any packet from
                                       any port */
    bcmInstruVisModeSelective = 2   /* Selective visibility enabled, user port
                                       control to enable specific resources */
} bcm_instru_vis_mode_control_t;

/* Control of various per-port Instrumentation features */
typedef enum bcm_instru_gport_control_e {
    bcmInstruGportControlTraceProbability = 0, /* Probability in one tenth percentage */
    bcmInstruGportControlVisEnable = 1, /* Enable visibility on per port basis */
    bcmInstruGportControlVisForce = 2,  /* Force visibility on per port basis */
    bcmInstruGportControlIptTrapToRcyEnable = 3 /* Trap IPT packet to Recycle interface */
} bcm_instru_gport_control_t;

/* IPT first node header values */
typedef struct bcm_instru_ipt_first_node_header_s {
    uint32 options; /* Options field */
    uint32 type;    /* Type field */
    uint32 length;  /* IPT header length length in bytes */
} bcm_instru_ipt_first_node_header_t;

/* IPT info */
typedef struct bcm_instru_ipt_s {
    bcm_instru_ipt_node_type_t node_type; /* Node type */
    uint32 metadata_flags;              /* Metadata flags */
    bcm_instru_ipt_first_node_header_t first_node_header; /* First header info */
} bcm_instru_ipt_t;

/* Control of various Instrumentation features */
#define BCM_INSTRU_CONTROL_FLAG_DIRECTION_INGRESS 0x1        /* Apply control to
                                                          INGRESS direction */
#define BCM_INSTRU_CONTROL_FLAG_DIRECTION_EGRESS 0x2        /* Apply control to
                                                          EGRESS direction */

#ifndef BCM_HIDE_DISPATCHABLE

/* Set various instrumentation features. */
extern int bcm_instru_control_set(
    int unit, 
    uint32 flags, 
    bcm_instru_control_t type, 
    int arg);

/* Get various instrumentation features. */
extern int bcm_instru_control_get(
    int unit, 
    uint32 flags, 
    bcm_instru_control_t type, 
    int *arg);

/* Set various instrumentation features at the port level. */
extern int bcm_instru_gport_control_set(
    int unit, 
    bcm_gport_t gport, 
    uint32 flags, 
    bcm_instru_gport_control_t type, 
    int arg);

/* Get various instrumentation features at the port level. */
extern int bcm_instru_gport_control_get(
    int unit, 
    bcm_gport_t gport, 
    uint32 flags, 
    bcm_instru_gport_control_t type, 
    int *arg);

/* Get various instrumentation features at the port level. */
extern int bcm_instru_ipt_profile_set(
    int unit, 
    uint32 flags, 
    int ipt_profile, 
    bcm_instru_ipt_t *config);

/* Get various instrumentation features at the port level. */
extern int bcm_instru_ipt_profile_get(
    int unit, 
    uint32 flags, 
    int ipt_profile, 
    bcm_instru_ipt_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize bcm_instru_ipt_t struct. */
extern void bcm_instru_ipt_t_init(
    bcm_instru_ipt_t *config);

/* IPT metadata options */
#define BCM_INSTRU_IPT_METADATA_FLAG_INGRESS_TOD 0x1        /* INGRESS TOD */
#define BCM_INSTRU_IPT_METADATA_FLAG_INGRESS_SYS_PORT 0x2        /* INGRESS PORT */
#define BCM_INSTRU_IPT_METADATA_FLAG_INGRESS_DEV_ID 0x4        /* INGRESS DEVICE ID */
#define BCM_INSTRU_IPT_METADATA_FLAG_INGRESS_RESERVED 0x8        /* INGRESS RESERVED */
#define BCM_INSTRU_IPT_METADATA_FLAG_EGRESS_TOD 0x10       /* EGRESS TOD */
#define BCM_INSTRU_IPT_METADATA_FLAG_EGRESS_SYS_PORT 0x20       /* EGRESS PORT */
#define BCM_INSTRU_IPT_METADATA_FLAG_EGRESS_DEV_ID 0x40       /* EGRESS DEVICE ID */
#define BCM_INSTRU_IPT_METADATA_FLAG_SWITCH_ID 0x80       /* SWITCH ID */
#define BCM_INSTRU_IPT_METADATA_FLAG_EGRESS_RESERVED 0x100      /* EGRESS RESERVED */
#define BCM_INSTRU_IPT_METADATA_FLAG_QUEUE_INFO 0x200      /* QUEUE INFO */

/* sFlow encap flags. */
#define BCM_INSTRU_SFLOW_ENCAP_WITH_ID      (1 << 0)   /* Allocate with sflow
                                                          encap id. */
#define BCM_INSTRU_SFLOW_ENCAP_REPLACE      (1 << 1)   /* Replace existing
                                                          entry, update
                                                          EEDB_SFLOW,
                                                          EGRESS_OAM_LIF_DB
                                                          tables. */
#define BCM_INSTRU_SFLOW_ENCAP_AGGREGATED   (2 << 1)   /* Sflow samples will be
                                                          aggregated. */

/* SFlow EEDB instrumentation info */
typedef struct bcm_instru_sflow_encap_info_s {
    uint32 flags;           /* See BCM_INSTRU_SFLOW_ENCAP_XXX flags definitions. */
    int sflow_encap_id;     /* Global lif */
    bcm_gport_t tunnel_id;  /* next eedb pointer - udp tunnel id */
    int stat_cmd;           /* Statistic command - request sequence number */
    int counter_command_id; /* Command id (interface id) */
    int sub_agent_id;       /* sub_agent_id for this sFlow encap */
    uint16 eventor_id;      /* Eventor RX context to use for this flow */
} bcm_instru_sflow_encap_info_t;

/* Vswitch callback function prototype */
typedef int (*bcm_instru_sflow_encap_traverse_cb)(
    int unit, 
    bcm_instru_sflow_encap_info_t *sflow_encap_info, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Fills the sFlow ETPS types. */
extern int bcm_instru_sflow_encap_create(
    int unit, 
    bcm_instru_sflow_encap_info_t *sflow_encap_info);

/* Get sFlow ETPS entry. */
extern int bcm_instru_sflow_encap_get(
    int unit, 
    bcm_instru_sflow_encap_info_t *sflow_encap_info);

/* Delete sFlow ETPS entry. */
extern int bcm_instru_sflow_encap_delete(
    int unit, 
    bcm_instru_sflow_encap_info_t *sflow_encap_info);

/* Traverse sFlow ETPS entries. */
extern int bcm_instru_sflow_encap_traverse(
    int unit, 
    bcm_instru_sflow_encap_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Eventor context ID. */
typedef uint16 bcm_eventor_context_id_t;

/* Eventor engine ID. */
typedef uint16 bcm_eventor_builder_id_t;

/* Number of Eventor srum bank. */
typedef uint16 bcm_eventor_sram_bank_t;

/* Eventor context type */
typedef enum bcm_eventor_context_type_e {
    bcmEventorContextTypeRx = 0,        /* RX Eventor context type */
    bcmEventorContextTypeTx = 1,        /* TX Eventor context type */
    bcmEventorContextTypeTxFifo = 2,    /* FIFO (TX) Eventor context type */
    bcmEventorContextTypeAny = 255      /* A value used to get any Eventor
                                           context type in a get operation. Not
                                           a real type */
} bcm_eventor_context_type_t;

/* Constant value to be used in Eventor output. */
typedef struct bcm_instru_eventor_operation_s {
    uint32 flags;       /* control flags: TX/additional buffer */
    uint32 buf_offset;  /* offset inside the buffer in 4 byte words */
    uint32 access_info; /* Use APs to generate this information containing
                           block+address+type (reg/mem/DMA) */
} bcm_instru_eventor_operation_t;

/* Constant value to be used in Eventor output. */
typedef struct bcm_instru_eventor_const_value_s {
    uint32 value;   /* 4 byte words constant value to be used in Eventor output */
    uint32 offset;  /* output offset for the constant value in 4 byte words */
} bcm_instru_eventor_const_value_t;

#define BCM_INSTRU_EVENTOR_TIMEOUT_NONE     ((uint32)-1) /* No timeout */
#define BCM_INSTRU_EVENTOR_TIMEOUT_MINIMAL  0          /* smallest timeout
                                                          possible */

/* Eventor context configuration */
typedef struct bcm_instru_eventor_context_conf_s {
    uint32 flags;                       /* control flags: Was there enough room
                                           to return the full DMA program and
                                           all constant values , auto select
                                           bank/buffer for RX , event type
                                           (RX/FIFO/TX) */
    bcm_eventor_sram_bank_t bank1;      /* SRAM bank used for first buffer */
    bcm_eventor_sram_bank_t bank2;      /* SRAM bank used for second buffer */
    uint32 buffer_size;                 /* buffer size in 4 byte words used for
                                           both buffers */
    uint32 buffer1_start;               /* offset in 4 byte words in the SRAM
                                           bank of the first buffer */
    uint32 buffer2_start;               /* offset in 4 byte words in the SRAM
                                           bank of the second buffer */
    uint32 program1_start;              /* offset in 4 byte words in the SRAM
                                           bank of the first buffer's DMA
                                           program filling the buffer */
    uint32 program2_start;              /* offset in 4 byte words in the SRAM
                                           bank of the second buffer's DMA
                                           program filling the buffer */
    uint32 nof_operations;              /* number operations in the DMA program
                                           filling the buffers */
    bcm_instru_eventor_operation_t operations; /* The operations in the DMA program
                                           filling the buffers */
    uint32 nof_const_values;            /* number operations in the DMA program
                                           filling the buffers */
    bcm_instru_eventor_const_value_t *const_values; /* The operations in the DMA program
                                           filling the buffers */
} bcm_instru_eventor_context_conf_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the configuration of the given context */
extern int bcm_instru_eventor_context_set(
    int unit, 
    uint32 flags, 
    bcm_eventor_context_id_t context, 
    bcm_eventor_context_type_t context_type, 
    bcm_instru_eventor_context_conf_t *conf);

/* Get the configuration of the given context */
extern int bcm_instru_eventor_context_get(
    int unit, 
    uint32 flags, 
    bcm_eventor_context_id_t context, 
    bcm_eventor_context_type_t context_type, 
    bcm_instru_eventor_context_conf_t *out_conf);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Eventor builder configuration */
typedef struct bcm_instru_eventor_builder_conf_s {
    uint32 flags;           /* control flags */
    uint32 thresh_size;     /* When this amount of 4 byte words is reached,
                               generate a packet */
    uint32 thresh_time;     /* When this amount of ms passes since stated
                               receiving data, generate a packet. May take
                               BCM_INSTRU_EVENTOR_TIMEOUT_* */
    uint32 header_length;   /* The length, in bytes, of the header to use in
                               generated packets */
    uint8 *header_data;     /* The data of the header to use in generated
                               packets */
} bcm_instru_eventor_builder_conf_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the configuration of the given builder. */
extern int bcm_instru_eventor_builder_set(
    int unit, 
    uint32 flags, 
    bcm_eventor_builder_id_t builder, 
    bcm_instru_eventor_builder_conf_t *conf);

/* Get the configuration of the given builder. */
extern int bcm_instru_eventor_builder_get(
    int unit, 
    uint32 flags, 
    bcm_eventor_builder_id_t builder, 
    bcm_instru_eventor_builder_conf_t *out_conf);

/* Start or stop the Eventor. */
extern int bcm_instru_eventor_active_set(
    int unit, 
    uint32 flags, 
    int active);

/* Check id the Eventor is active/started. */
extern int bcm_instru_eventor_active_get(
    int unit, 
    uint32 flags, 
    int *out_active);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_INSTRU_H__ */
